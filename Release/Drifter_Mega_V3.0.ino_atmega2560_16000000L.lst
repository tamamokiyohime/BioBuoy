
C:\Users\tensh\AppData\Local\Temp\VMBuilds\Drifter_Mega_V3.0\mega_atmega2560\Release/Drifter_Mega_V3.0.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
       0:	0c 94 42 03 	jmp	0x684	; 0x684 <__dtors_end>
       4:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
       8:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
       c:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      10:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      14:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      18:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      1c:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      20:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      24:	0c 94 7b 4f 	jmp	0x9ef6	; 0x9ef6 <__vector_10>
      28:	0c 94 7b 4f 	jmp	0x9ef6	; 0x9ef6 <__vector_10>
      2c:	0c 94 7b 4f 	jmp	0x9ef6	; 0x9ef6 <__vector_10>
      30:	0c 94 71 4f 	jmp	0x9ee2	; 0x9ee2 <__vector_12>
      34:	0c 94 38 4d 	jmp	0x9a70	; 0x9a70 <__vector_13>
      38:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      3c:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      40:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      44:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      48:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      4c:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      50:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      54:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      58:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      5c:	0c 94 27 4f 	jmp	0x9e4e	; 0x9e4e <__vector_23>
      60:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      64:	0c 94 fd 4e 	jmp	0x9dfa	; 0x9dfa <__vector_25>
      68:	0c 94 d3 4e 	jmp	0x9da6	; 0x9da6 <__vector_26>
      6c:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      70:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      74:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      78:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      7c:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      80:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      84:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      88:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      8c:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      90:	0c 94 a9 4e 	jmp	0x9d52	; 0x9d52 <__vector_36>
      94:	0c 94 7f 4e 	jmp	0x9cfe	; 0x9cfe <__vector_37>
      98:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      9c:	0c 94 85 4f 	jmp	0x9f0a	; 0x9f0a <__vector_39>
      a0:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      a4:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      a8:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      ac:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      b0:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      b4:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      b8:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      bc:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      c0:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      c4:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      c8:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      cc:	0c 94 55 4e 	jmp	0x9caa	; 0x9caa <__vector_51>
      d0:	0c 94 2b 4e 	jmp	0x9c56	; 0x9c56 <__vector_52>
      d4:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>
      d8:	0c 94 01 4e 	jmp	0x9c02	; 0x9c02 <__vector_54>
      dc:	0c 94 d7 4d 	jmp	0x9bae	; 0x9bae <__vector_55>
      e0:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <__bad_interrupt>

000000e4 <__trampolines_start>:
__trampolines_start():
      e4:	0c 94 7f 28 	jmp	0x50fe	; 0x50fe <RemoveBTNmessage()>
      e8:	0c 94 d1 5a 	jmp	0xb5a2	; 0xb5a2 <main+0xeba>
      ec:	0c 94 99 5a 	jmp	0xb532	; 0xb532 <main+0xe4a>
      f0:	0c 94 0a 0d 	jmp	0x1a14	; 0x1a14 <analogWrite+0x1a4>
      f4:	0c 94 0d 08 	jmp	0x101a	; 0x101a <turnOffPWM+0xbc>
      f8:	0c 94 b5 0c 	jmp	0x196a	; 0x196a <analogWrite+0xfa>
      fc:	0c 94 9c 5a 	jmp	0xb538	; 0xb538 <main+0xe50>
     100:	0c 94 ec 07 	jmp	0xfd8	; 0xfd8 <turnOffPWM+0x7a>
     104:	0c 94 e8 07 	jmp	0xfd0	; 0xfd0 <turnOffPWM+0x72>
     108:	0c 94 54 5d 	jmp	0xbaa8	; 0xbaa8 <main+0x13c0>
     10c:	0c 94 ab 0c 	jmp	0x1956	; 0x1956 <analogWrite+0xe6>
     110:	0c 94 cd 5c 	jmp	0xb99a	; 0xb99a <main+0x12b2>
     114:	0c 94 fa 07 	jmp	0xff4	; 0xff4 <turnOffPWM+0x96>
     118:	0c 94 92 5a 	jmp	0xb524	; 0xb524 <main+0xe3c>
     11c:	0c 94 f6 07 	jmp	0xfec	; 0xfec <turnOffPWM+0x8e>
     120:	0c 94 a7 18 	jmp	0x314e	; 0x314e <SDLib::File::flush()>
     124:	0c 94 42 07 	jmp	0xe84	; 0xe84 <HardwareSerial::write(unsigned char)>
     128:	0c 94 78 0c 	jmp	0x18f0	; 0x18f0 <analogWrite+0x80>
     12c:	0c 94 3c 4c 	jmp	0x9878	; 0x9878 <SerialDecode(String)+0x290>
     130:	0c 94 12 08 	jmp	0x1024	; 0x1024 <turnOffPWM+0xc6>
     134:	0c 94 ac 1b 	jmp	0x3758	; 0x3758 <TwoWire::flush()>
     138:	0c 94 8f 07 	jmp	0xf1e	; 0xf1e <HardwareSerial::flush()>
     13c:	0c 94 70 0c 	jmp	0x18e0	; 0x18e0 <analogWrite+0x70>
     140:	0c 94 fd 18 	jmp	0x31fa	; 0x31fa <SDLib::File::write(unsigned char)>
     144:	0c 94 8b 5a 	jmp	0xb516	; 0xb516 <main+0xe2e>
     148:	0c 94 87 0c 	jmp	0x190e	; 0x190e <analogWrite+0x9e>
     14c:	0c 94 0d 5d 	jmp	0xba1a	; 0xba1a <main+0x1332>
     150:	0c 94 a3 5a 	jmp	0xb546	; 0xb546 <main+0xe5e>
     154:	0c 94 a1 4b 	jmp	0x9742	; 0x9742 <SerialDecode(String)+0x15a>
     158:	0c 94 d0 18 	jmp	0x31a0	; 0x31a0 <SDLib::File::availableForWrite()>
     15c:	0c 94 df 07 	jmp	0xfbe	; 0xfbe <turnOffPWM+0x60>
     160:	0c 94 1a 06 	jmp	0xc34	; 0xc34 <TwoWire::available()>
     164:	0c 94 00 08 	jmp	0x1000	; 0x1000 <turnOffPWM+0xa2>
     168:	0c 94 bc 1b 	jmp	0x3778	; 0x3778 <TwoWire::write(unsigned char const*, unsigned int)>
     16c:	0c 94 bd 5a 	jmp	0xb57a	; 0xb57a <main+0xe92>
     170:	0c 94 5d 1d 	jmp	0x3aba	; 0x3aba <Print::availableForWrite()>
     174:	0c 94 00 0d 	jmp	0x1a00	; 0x1a00 <analogWrite+0x190>
     178:	0c 94 56 62 	jmp	0xc4ac	; 0xc4ac <_GLOBAL__sub_D_debugMode>
     17c:	0c 94 bf 0c 	jmp	0x197e	; 0x197e <analogWrite+0x10e>
     180:	0c 94 d7 4b 	jmp	0x97ae	; 0x97ae <SerialDecode(String)+0x1c6>
     184:	0c 94 35 4d 	jmp	0x9a6a	; 0x9a6a <SerialDecode(String)+0x482>
     188:	0c 94 f8 5c 	jmp	0xb9f0	; 0xb9f0 <main+0x1308>
     18c:	0c 94 56 5a 	jmp	0xb4ac	; 0xb4ac <main+0xdc4>
     190:	0c 94 ca 5a 	jmp	0xb594	; 0xb594 <main+0xeac>
     194:	0c 94 0e 08 	jmp	0x101c	; 0x101c <turnOffPWM+0xbe>
     198:	0c 94 c6 4b 	jmp	0x978c	; 0x978c <SerialDecode(String)+0x1a4>
     19c:	0c 94 ec 06 	jmp	0xdd8	; 0xdd8 <HardwareSerial::available()>
     1a0:	0c 94 5b 4c 	jmp	0x98b6	; 0x98b6 <SerialDecode(String)+0x2ce>
     1a4:	0c 94 e9 1b 	jmp	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
     1a8:	0c 94 f0 22 	jmp	0x45e0	; 0x45e0 <LiquidCrystal_I2C::write(unsigned char)>
     1ac:	0c 94 7e 4c 	jmp	0x98fc	; 0x98fc <SerialDecode(String)+0x314>
     1b0:	0c 94 08 08 	jmp	0x1010	; 0x1010 <turnOffPWM+0xb2>
     1b4:	0c 94 62 4c 	jmp	0x98c4	; 0x98c4 <SerialDecode(String)+0x2dc>
     1b8:	0c 94 75 06 	jmp	0xcea	; 0xcea <Print::write(unsigned char const*, unsigned int)>
     1bc:	0c 94 4f 04 	jmp	0x89e	; 0x89e <TwoWire::onRequestService()>
     1c0:	0c 94 3b 06 	jmp	0xc76	; 0xc76 <Print::flush()>
     1c4:	0c 94 d7 07 	jmp	0xfae	; 0xfae <turnOffPWM+0x50>
     1c8:	0c 94 91 0c 	jmp	0x1922	; 0x1922 <analogWrite+0xb2>
     1cc:	0c 94 0c 51 	jmp	0xa218	; 0xa218 <global constructors keyed to 65535_0_Drifter_Mega_V3.0.cpp.o.6099>
     1d0:	0c 94 d8 0c 	jmp	0x19b0	; 0x19b0 <analogWrite+0x140>
     1d4:	0c 94 50 04 	jmp	0x8a0	; 0x8a0 <TwoWire::onReceiveService(unsigned char*, int)>
     1d8:	0c 94 e2 07 	jmp	0xfc4	; 0xfc4 <turnOffPWM+0x66>
     1dc:	0c 94 9b 0c 	jmp	0x1936	; 0x1936 <analogWrite+0xc6>
     1e0:	0c 94 db 07 	jmp	0xfb6	; 0xfb6 <turnOffPWM+0x58>
     1e4:	0c 94 85 5a 	jmp	0xb50a	; 0xb50a <main+0xe22>
     1e8:	0c 94 ad 1b 	jmp	0x375a	; 0x375a <TwoWire::peek()>
     1ec:	0c 94 eb 5a 	jmp	0xb5d6	; 0xb5d6 <main+0xeee>
     1f0:	0c 94 ba 4c 	jmp	0x9974	; 0x9974 <SerialDecode(String)+0x38c>
     1f4:	0c 94 04 08 	jmp	0x1008	; 0x1008 <turnOffPWM+0xaa>
     1f8:	0c 94 b0 5a 	jmp	0xb560	; 0xb560 <main+0xe78>
     1fc:	0c 94 de 5a 	jmp	0xb5bc	; 0xb5bc <main+0xed4>
     200:	0c 94 a3 0c 	jmp	0x1946	; 0x1946 <analogWrite+0xd6>
     204:	0c 94 46 18 	jmp	0x308c	; 0x308c <SdFile::write(unsigned char)>
     208:	0c 94 ca 06 	jmp	0xd94	; 0xd94 <HardwareSerial::read()>
     20c:	0c 94 e0 18 	jmp	0x31c0	; 0x31c0 <SDLib::File::write(unsigned char const*, unsigned int)>
     210:	0c 94 c9 0c 	jmp	0x1992	; 0x1992 <analogWrite+0x122>
     214:	0c 94 99 6c 	jmp	0xd932	; 0xd932 <__divdi3_moddi3+0x16>
     218:	0c 94 2a 5d 	jmp	0xba54	; 0xba54 <main+0x136c>
     21c:	0c 94 3c 1a 	jmp	0x3478	; 0x3478 <SDLib::File::peek()>
     220:	0c 94 bb 4b 	jmp	0x9776	; 0x9776 <SerialDecode(String)+0x18e>
     224:	0c 94 12 4d 	jmp	0x9a24	; 0x9a24 <SerialDecode(String)+0x43c>
     228:	0c 94 d3 07 	jmp	0xfa6	; 0xfa6 <turnOffPWM+0x48>
     22c:	0c 94 b0 18 	jmp	0x3160	; 0x3160 <SDLib::File::available()>
     230:	0c 94 32 1a 	jmp	0x3464	; 0x3464 <SDLib::File::read()>
     234:	0c 94 4a 5a 	jmp	0xb494	; 0xb494 <main+0xdac>
     238:	0c 94 40 16 	jmp	0x2c80	; 0x2c80 <SdFile::availableForWrite()>
     23c:	0c 94 f6 0c 	jmp	0x19ec	; 0x19ec <analogWrite+0x17c>
     240:	0c 94 bb 06 	jmp	0xd76	; 0xd76 <HardwareSerial::availableForWrite()>
     244:	0c 94 ec 0c 	jmp	0x19d8	; 0x19d8 <analogWrite+0x168>
     248:	0c 94 cd 07 	jmp	0xf9a	; 0xf9a <turnOffPWM+0x3c>
     24c:	0c 94 7d 0c 	jmp	0x18fa	; 0x18fa <analogWrite+0x8a>
     250:	0c 94 3f 5d 	jmp	0xba7e	; 0xba7e <main+0x1396>
     254:	0c 94 e2 0c 	jmp	0x19c4	; 0x19c4 <analogWrite+0x154>
     258:	0c 94 de 5c 	jmp	0xb9bc	; 0xb9bc <main+0x12d4>
     25c:	0c 94 de 06 	jmp	0xdbc	; 0xdbc <HardwareSerial::peek()>
     260:	0c 94 29 04 	jmp	0x852	; 0x852 <TwoWire::read()>
     264:	0c 94 f2 07 	jmp	0xfe4	; 0xfe4 <turnOffPWM+0x86>

00000268 <__trampolines_end>:
__trampolines_end():
     268:	4e 41       	sbci	r20, 0x1E	; 30
     26a:	4e 49       	Address 0x0000026a is out of bounds.
.word	0xffff	; ????

0000026b <pstr_inity>:
     26b:	49 4e 49 54 59                                      INITY

00000270 <pstr_inf>:
     270:	49 4e 46                                            INF

00000273 <pwr_m10>:
     273:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     283:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

0000028b <pwr_p10>:
     28b:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     29b:	ca 1b 0e 5a ae c5 9d 74 00 40 7a 10 f3 5a 00 a0     ...Z...t.@z..Z..
     2ab:	72 4e 18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00     rN..........vH..
     2bb:	00 e4 0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05     ...T.....;......
     2cb:	00 00 80 96 98 00 00 00 40 42 0f 00 00 00 a0 86     ........@B......
     2db:	01 00 00 00 10 27 00 00 00 00 e8 03 00 00 00 00     .....'..........
     2eb:	64 00 00 00 00 00 0a 00 00 00 00 00 01 00 00 00     d...............
     2fb:	00 00 2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59     ..,v...gO.#....Y
     30b:	e1 b1 b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8     .......S.:.Q.v..
     31b:	e6 c2 84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc     ...&....b.@|o...
     32b:	9c 9f 40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93     ..@...o....Z*.\.
     33b:	6b 6c f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6     kl.gm......G.. .
     34b:	b5 00 d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e     .........5w.....
     35b:	08 00 00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f     ... N......3333.
     36b:	98 6e 12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf     .n...A..!..;.U..
     37b:	fe e6 db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb     ......K8..|.....
     38b:	e4 24 20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5     .$ 2.r^"....$...
     39b:	3d 27                                               ='

0000039d <__c.2370>:
     39d:	63 64 69 6e 6f 70 73 75 78 58 5b 00                 cdinopsuxX[.

000003a9 <do_SD()::__c>:
     3a9:	55 6e 61 62 6c 65 20 54 6f 20 41 63 63 65 73 73     Unable To Access
     3b9:	20 53 44 20 43 61 72 64 00                           SD Card.

000003c2 <SdFile::make83Name(char const*, unsigned char*)::__c>:
     3c2:	7c 3c 3e 5e 2b 3d 3f 2f 5b 5d 3b 2c 2a 22 5c 00     |<>^+=?/[];,*"\.

000003d2 <daysInMonth>:
     3d2:	1f 1c 1f 1e 1f 1e 1f 1f 1e 1f 1e                    ...........

000003dd <port_to_mode_PGM>:
     3dd:	00 00 21 00 24 00 27 00 2a 00 2d 00 30 00 33 00     ..!.$.'.*.-.0.3.
     3ed:	01 01 00 00 04 01 07 01 0a 01                       ..........

000003f7 <port_to_input_PGM>:
     3f7:	00 00 20 00 23 00 26 00 29 00 2c 00 2f 00 32 00     .. .#.&.).,./.2.
     407:	00 01 00 00 03 01 06 01 09 01                       ..........

00000411 <digital_pin_to_timer_PGM>:
     411:	00 00 0a 0b 02 09 0c 0d 0e 08 07 03 04 01 00 00     ................
	...
     43d:	12 11 10 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00000457 <RTC_check()::__c>:
     457:	21 21 21 52 54 43 20 54 49 4d 45 20 45 52 52 4f     !!!RTC TIME ERRO
     467:	57 21 21 21 2e 2e 2e 2e 20 43 6f 6e 6e 65 63 74     W!!!.... Connect
     477:	20 74 6f 20 50 43 20 74 6f 20 52 65 73 65 74 00      to PC to Reset.

00000487 <RTC_check()::__c>:
     487:	52 54 43 20 4e 6f 74 20 46 6f 75 6e 64 00           RTC Not Found.

00000495 <_ZZ5setupE3__c__14_>:
     495:	57 61 74 63 68 64 6f 67 20 61 63 74 69 76 61 74     Watchdog activat
     4a5:	65 00                                               e.

000004a7 <_ZZ5setupE3__c__13_>:
     4a7:	4c 43 44 27 73 20 4c 45 44 20 77 69 6c 6c 20 54     LCD's LED will T
     4b7:	55 52 4e 20 4f 46 46 20 61 66 74 65 72 20 62 6f     URN OFF after bo
     4c7:	6f 74 69 6e 67 00                                   oting.

000004cd <_ZZ5setupE3__c__12_>:
     4cd:	50 4f 57 45 52 20 53 41 56 49 4e 47 20 4f 4e 00     POWER SAVING ON.

000004dd <_ZZ5setupE3__c__11_>:
     4dd:	57 61 72 69 6e 67 21 20 50 6f 77 65 72 20 53 61     Waring! Power Sa
     4ed:	76 69 6e 67 20 4f 4e 2c 20 4c 43 44 27 73 20 4c     ving ON, LCD's L
     4fd:	45 44 20 77 69 6c 6c 20 73 68 75 74 64 6f 77 6e     ED will shutdown
     50d:	20 61 66 74 65 72 20 62 6f 6f 74 69 6e 67 21 00      after booting!.

0000051d <_ZZ5setupE3__c__10_>:
     51d:	4f 70 65 6e 20 70 75 6d 70 00                       Open pump.

00000527 <setup::__c>:
     527:	44 65 76 69 63 65 20 49 44 20 3d 20 00              Device ID = .

00000534 <setup::__c>:
     534:	44 61 74 61 20 43 6f 6c 6c 65 63 74 69 6e 67 20     Data Collecting 
     544:	53 79 73 74 00                                      Syst.

00000549 <setup::__c>:
     549:	42 69 6f 63 68 65 6d 69 73 74 72 79 20 20 20 20     Biochemistry    
     559:	42 75 6f 79 00                                      Buoy.

0000055e <setup::__c>:
     55e:	53 44 20 6f 72 20 52 54 43 20 65 72 72 6f 72 00     SD or RTC error.

0000056e <setup::__c>:
     56e:	53 44 20 61 6e 64 20 52 54 43 20 50 61 73 73 00     SD and RTC Pass.

0000057e <setup::__c>:
     57e:	53 44 20 43 68 65 63 6b 69 6e 67 00                 SD Checking.

0000058a <setup::__c>:
     58a:	52 54 43 20 43 68 65 63 6b 69 6e 67 00              RTC Checking.

00000597 <setup::__c>:
     597:	47 65 74 20 45 45 50 52 4f 4d 20 64 61 74 61 00     Get EEPROM data.

000005a7 <setup::__c>:
     5a7:	44 69 73 61 62 6c 65 20 70 61 72 74 69 61 6c 20     Disable partial 
     5b7:	47 50 53 20 44 61 74 61 00                          GPS Data.

000005c0 <setup::__c>:
     5c0:	53 65 6e 73 6f 72 20 41 63 74 69 76 61 74 65 00     Sensor Activate.

000005d0 <setup::__c>:
     5d0:	4c 45 44 20 54 65 73 74 00                          LED Test.

000005d9 <digital_pin_to_bit_mask_PGM>:
     5d9:	01 02 10 20 20 08 08 10 20 40 10 20 40 80 02 01     ...  ... @. @...
     5e9:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 80 40     ........... @..@
     5f9:	20 10 08 04 02 01 80 04 02 01 80 40 20 10 08 04      ..........@ ...
     609:	02 01 08 04 02 01 01 02 04 08 10 20 40 80 01 02     ........... @...
     619:	04 08 10 20 40 80                                   ... @.

0000061f <port_to_output_PGM>:
     61f:	00 00 22 00 25 00 28 00 2b 00 2e 00 31 00 34 00     ..".%.(.+...1.4.
     62f:	02 01 00 00 05 01 08 01 0b 01                       ..........

00000639 <digital_pin_to_port_PGM>:
     639:	05 05 05 05 07 05 08 08 08 08 02 02 02 02 0a 0a     ................
     649:	08 08 04 04 04 04 01 01 01 01 01 01 01 01 03 03     ................
     659:	03 03 03 03 03 03 04 07 07 07 0c 0c 0c 0c 0c 0c     ................
     669:	0c 0c 02 02 02 02 06 06 06 06 06 06 06 06 0b 0b     ................
     679:	0b 0b 0b 0b 0b 0b                                   ......

0000067f <tone_pin_to_timer_PGM>:
     67f:	02                                                  .

00000680 <__ctors_start>:
__ctors_start():
     680:	0c 51       	subi	r16, 0x1C	; 28

00000682 <__ctors_end>:
__dtors_start():
     682:	56 62       	ori	r21, 0x26	; 38

00000684 <__dtors_end>:
__dtors_end():
     684:	11 24       	eor	r1, r1
     686:	1f be       	out	0x3f, r1	; 63
     688:	cf ef       	ldi	r28, 0xFF	; 255
     68a:	d1 e2       	ldi	r29, 0x21	; 33
     68c:	de bf       	out	0x3e, r29	; 62
     68e:	cd bf       	out	0x3d, r28	; 61
     690:	00 e0       	ldi	r16, 0x00	; 0
     692:	0c bf       	out	0x3c, r16	; 60

00000694 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2373
     694:	19 e0       	ldi	r17, 0x09	; 9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2374
     696:	a0 e0       	ldi	r26, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2375
     698:	b2 e0       	ldi	r27, 0x02	; 2
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2376
     69a:	e4 e1       	ldi	r30, 0x14	; 20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2377
     69c:	fa ee       	ldi	r31, 0xEA	; 234
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2378
     69e:	00 e0       	ldi	r16, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2379
     6a0:	0b bf       	out	0x3b, r16	; 59
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2380
     6a2:	02 c0       	rjmp	.+4      	; 0x6a8 <__do_copy_data+0x14>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2382
     6a4:	07 90       	elpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2383
     6a6:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2385
     6a8:	a8 31       	cpi	r26, 0x18	; 24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2386
     6aa:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2387
     6ac:	d9 f7       	brne	.-10     	; 0x6a4 <__do_copy_data+0x10>

000006ae <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     6ae:	23 e1       	ldi	r18, 0x13	; 19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     6b0:	a8 e1       	ldi	r26, 0x18	; 24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     6b2:	b9 e0       	ldi	r27, 0x09	; 9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     6b4:	01 c0       	rjmp	.+2      	; 0x6b8 <.do_clear_bss_start>

000006b6 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     6b6:	1d 92       	st	X+, r1

000006b8 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     6b8:	a0 37       	cpi	r26, 0x70	; 112
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     6ba:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     6bc:	e1 f7       	brne	.-8      	; 0x6b6 <.do_clear_bss_loop>

000006be <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     6be:	13 e0       	ldi	r17, 0x03	; 3
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     6c0:	c1 e4       	ldi	r28, 0x41	; 65
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     6c2:	d3 e0       	ldi	r29, 0x03	; 3
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2470
     6c4:	00 e0       	ldi	r16, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     6c6:	06 c0       	rjmp	.+12     	; 0x6d4 <__do_global_ctors+0x16>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     6c8:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2476
     6ca:	01 09       	sbc	r16, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2477
     6cc:	80 2f       	mov	r24, r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     6ce:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     6d0:	0e 94 2b 6c 	call	0xd856	; 0xd856 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     6d4:	c0 34       	cpi	r28, 0x40	; 64
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     6d6:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2486
     6d8:	80 e0       	ldi	r24, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2487
     6da:	08 07       	cpc	r16, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     6dc:	a9 f7       	brne	.-22     	; 0x6c8 <__do_global_ctors+0xa>
     6de:	0e 94 74 53 	call	0xa6e8	; 0xa6e8 <main>
     6e2:	0c 94 f8 74 	jmp	0xe9f0	; 0xe9f0 <__do_global_dtors>

000006e6 <__bad_interrupt>:
__vector_38():
     6e6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>:
beginTransmission():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:191
}

void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
     6ea:	91 e0       	ldi	r25, 0x01	; 1
     6ec:	90 93 7a 0c 	sts	0x0C7A, r25	; 0x800c7a <TwoWire::transmitting>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:193
  // set address of targeted slave
  txAddress = address;
     6f0:	80 93 79 0c 	sts	0x0C79, r24	; 0x800c79 <TwoWire::txAddress>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:195
  // reset tx buffer iterator vars
  txBufferIndex = 0;
     6f4:	10 92 78 0c 	sts	0x0C78, r1	; 0x800c78 <TwoWire::txBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:196
  txBufferLength = 0;
     6f8:	10 92 77 0c 	sts	0x0C77, r1	; 0x800c77 <TwoWire::txBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:197
}
     6fc:	08 95       	ret

000006fe <HardwareSerial::begin(unsigned long, unsigned char) [clone .constprop.170]>:
begin():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:117
  }
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
     6fe:	cf 93       	push	r28
     700:	df 93       	push	r29
     702:	ec 01       	movw	r28, r24
     704:	9a 01       	movw	r18, r20
     706:	ab 01       	movw	r20, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:121
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
     708:	e8 89       	ldd	r30, Y+16	; 0x10
     70a:	f9 89       	ldd	r31, Y+17	; 0x11
     70c:	82 e0       	ldi	r24, 0x02	; 2
     70e:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:128
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     710:	21 15       	cp	r18, r1
     712:	81 ee       	ldi	r24, 0xE1	; 225
     714:	38 07       	cpc	r19, r24
     716:	41 05       	cpc	r20, r1
     718:	51 05       	cpc	r21, r1
     71a:	81 f1       	breq	.+96     	; 0x77c <HardwareSerial::begin(unsigned long, unsigned char) [clone .constprop.170]+0x7e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:120
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
     71c:	60 e0       	ldi	r22, 0x00	; 0
     71e:	79 e0       	ldi	r23, 0x09	; 9
     720:	8d e3       	ldi	r24, 0x3D	; 61
     722:	90 e0       	ldi	r25, 0x00	; 0
     724:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
     728:	21 50       	subi	r18, 0x01	; 1
     72a:	31 09       	sbc	r19, r1
     72c:	41 09       	sbc	r20, r1
     72e:	51 09       	sbc	r21, r1
     730:	56 95       	lsr	r21
     732:	47 95       	ror	r20
     734:	37 95       	ror	r19
     736:	27 95       	ror	r18
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:135
    *_ucsra = 0;
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
     738:	ec 85       	ldd	r30, Y+12	; 0x0c
     73a:	fd 85       	ldd	r31, Y+13	; 0x0d
     73c:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:136
  *_ubrrl = baud_setting;
     73e:	ee 85       	ldd	r30, Y+14	; 0x0e
     740:	ff 85       	ldd	r31, Y+15	; 0x0f
     742:	20 83       	st	Z, r18
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:138

  _written = false;
     744:	18 8e       	std	Y+24, r1	; 0x18
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:144

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
     746:	ec 89       	ldd	r30, Y+20	; 0x14
     748:	fd 89       	ldd	r31, Y+21	; 0x15
     74a:	86 e0       	ldi	r24, 0x06	; 6
     74c:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:146
  
  sbi(*_ucsrb, RXEN0);
     74e:	ea 89       	ldd	r30, Y+18	; 0x12
     750:	fb 89       	ldd	r31, Y+19	; 0x13
     752:	80 81       	ld	r24, Z
     754:	80 61       	ori	r24, 0x10	; 16
     756:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:147
  sbi(*_ucsrb, TXEN0);
     758:	ea 89       	ldd	r30, Y+18	; 0x12
     75a:	fb 89       	ldd	r31, Y+19	; 0x13
     75c:	80 81       	ld	r24, Z
     75e:	88 60       	ori	r24, 0x08	; 8
     760:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:148
  sbi(*_ucsrb, RXCIE0);
     762:	ea 89       	ldd	r30, Y+18	; 0x12
     764:	fb 89       	ldd	r31, Y+19	; 0x13
     766:	80 81       	ld	r24, Z
     768:	80 68       	ori	r24, 0x80	; 128
     76a:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:149
  cbi(*_ucsrb, UDRIE0);
     76c:	ea 89       	ldd	r30, Y+18	; 0x12
     76e:	fb 89       	ldd	r31, Y+19	; 0x13
     770:	80 81       	ld	r24, Z
     772:	8f 7d       	andi	r24, 0xDF	; 223
     774:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:150
}
     776:	df 91       	pop	r29
     778:	cf 91       	pop	r28
     77a:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:130
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
  {
    *_ucsra = 0;
     77c:	e8 89       	ldd	r30, Y+16	; 0x10
     77e:	f9 89       	ldd	r31, Y+17	; 0x11
     780:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:131
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
     782:	20 e1       	ldi	r18, 0x10	; 16
     784:	d9 cf       	rjmp	.-78     	; 0x738 <HardwareSerial::begin(unsigned long, unsigned char) [clone .constprop.170]+0x3a>

00000786 <SDLib::File::operator=(SDLib::File&&) [clone .constprop.162]>:
operator=():
D:\USER\Documents\Arduino\libraries\SD\src/SD.h:28
#define FILE_READ O_READ
#define FILE_WRITE (O_READ | O_WRITE | O_CREAT | O_APPEND)

namespace SDLib {

  class File : public Stream {
     786:	cf 93       	push	r28
     788:	df 93       	push	r29
     78a:	fc 01       	movw	r30, r24
     78c:	82 81       	ldd	r24, Z+2	; 0x02
     78e:	93 81       	ldd	r25, Z+3	; 0x03
_ZN5PrintaSEOS_():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:37
#ifdef BIN // Prevent warnings if BIN is previously defined in "iotnx4.h" or similar
#undef BIN
#endif
#define BIN 2

class Print
     790:	90 93 0f 11 	sts	0x110F, r25	; 0x80110f <myFile+0x3>
     794:	80 93 0e 11 	sts	0x110E, r24	; 0x80110e <myFile+0x2>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Stream.h:49
    SKIP_WHITESPACE // Only tabs, spaces, line feeds & carriage returns are skipped.
};

#define NO_IGNORE_CHAR  '\x01' // a char not found in a valid ASCII numeric field

class Stream : public Print
     798:	84 81       	ldd	r24, Z+4	; 0x04
     79a:	95 81       	ldd	r25, Z+5	; 0x05
     79c:	a6 81       	ldd	r26, Z+6	; 0x06
     79e:	b7 81       	ldd	r27, Z+7	; 0x07
     7a0:	80 93 10 11 	sts	0x1110, r24	; 0x801110 <myFile+0x4>
     7a4:	90 93 11 11 	sts	0x1111, r25	; 0x801111 <myFile+0x5>
     7a8:	a0 93 12 11 	sts	0x1112, r26	; 0x801112 <myFile+0x6>
     7ac:	b0 93 13 11 	sts	0x1113, r27	; 0x801113 <myFile+0x7>
     7b0:	80 85       	ldd	r24, Z+8	; 0x08
     7b2:	91 85       	ldd	r25, Z+9	; 0x09
     7b4:	a2 85       	ldd	r26, Z+10	; 0x0a
     7b6:	b3 85       	ldd	r27, Z+11	; 0x0b
     7b8:	80 93 14 11 	sts	0x1114, r24	; 0x801114 <myFile+0x8>
     7bc:	90 93 15 11 	sts	0x1115, r25	; 0x801115 <myFile+0x9>
     7c0:	a0 93 16 11 	sts	0x1116, r26	; 0x801116 <myFile+0xa>
     7c4:	b0 93 17 11 	sts	0x1117, r27	; 0x801117 <myFile+0xb>
D:\USER\Documents\Arduino\libraries\SD\src/SD.h:28
     7c8:	df 01       	movw	r26, r30
     7ca:	1c 96       	adiw	r26, 0x0c	; 12
     7cc:	cf 01       	movw	r24, r30
     7ce:	49 96       	adiw	r24, 0x19	; 25
     7d0:	c8 e1       	ldi	r28, 0x18	; 24
     7d2:	d1 e1       	ldi	r29, 0x11	; 17
     7d4:	2d 91       	ld	r18, X+
     7d6:	29 93       	st	Y+, r18
     7d8:	a8 17       	cp	r26, r24
     7da:	b9 07       	cpc	r27, r25
     7dc:	d9 f7       	brne	.-10     	; 0x7d4 <SDLib::File::operator=(SDLib::File&&) [clone .constprop.162]+0x4e>
     7de:	81 8d       	ldd	r24, Z+25	; 0x19
     7e0:	92 8d       	ldd	r25, Z+26	; 0x1a
     7e2:	90 93 26 11 	sts	0x1126, r25	; 0x801126 <myFile+0x1a>
     7e6:	80 93 25 11 	sts	0x1125, r24	; 0x801125 <myFile+0x19>
     7ea:	8c e0       	ldi	r24, 0x0C	; 12
     7ec:	91 e1       	ldi	r25, 0x11	; 17
     7ee:	df 91       	pop	r29
     7f0:	cf 91       	pop	r28
     7f2:	08 95       	ret

000007f4 <Countimer::stop() [clone .constprop.145]>:
stop():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:104
	_isStopped = true;
}

void Countimer::stop()
{
	_isStopped = true;
     7f4:	81 e0       	ldi	r24, 0x01	; 1
     7f6:	80 93 4b 12 	sts	0x124B, r24	; 0x80124b <resetRow1+0x19>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:105
	_isCounterCompleted = true;
     7fa:	80 93 4a 12 	sts	0x124A, r24	; 0x80124a <resetRow1+0x18>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:106
	_currentCountTime = _countTime;
     7fe:	80 91 42 12 	lds	r24, 0x1242	; 0x801242 <resetRow1+0x10>
     802:	90 91 43 12 	lds	r25, 0x1243	; 0x801243 <resetRow1+0x11>
     806:	a0 91 44 12 	lds	r26, 0x1244	; 0x801244 <resetRow1+0x12>
     80a:	b0 91 45 12 	lds	r27, 0x1245	; 0x801245 <resetRow1+0x13>
     80e:	80 93 3a 12 	sts	0x123A, r24	; 0x80123a <resetRow1+0x8>
     812:	90 93 3b 12 	sts	0x123B, r25	; 0x80123b <resetRow1+0x9>
     816:	a0 93 3c 12 	sts	0x123C, r26	; 0x80123c <resetRow1+0xa>
     81a:	b0 93 3d 12 	sts	0x123D, r27	; 0x80123d <resetRow1+0xb>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:108

	if(_countType == COUNT_UP)
     81e:	80 91 56 12 	lds	r24, 0x1256	; 0x801256 <resetRow1+0x24>
     822:	90 91 57 12 	lds	r25, 0x1257	; 0x801257 <resetRow1+0x25>
     826:	01 97       	sbiw	r24, 0x01	; 1
     828:	41 f4       	brne	.+16     	; 0x83a <Countimer::stop() [clone .constprop.145]+0x46>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:110
	{
		_currentCountTime = 0;		
     82a:	10 92 3a 12 	sts	0x123A, r1	; 0x80123a <resetRow1+0x8>
     82e:	10 92 3b 12 	sts	0x123B, r1	; 0x80123b <resetRow1+0x9>
     832:	10 92 3c 12 	sts	0x123C, r1	; 0x80123c <resetRow1+0xa>
     836:	10 92 3d 12 	sts	0x123D, r1	; 0x80123d <resetRow1+0xb>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:112
	}
}
     83a:	08 95       	ret

0000083c <delayMicroseconds>:
delayMicroseconds():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:170
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
     83c:	82 30       	cpi	r24, 0x02	; 2
     83e:	91 05       	cpc	r25, r1
     840:	38 f0       	brcs	.+14     	; 0x850 <delayMicroseconds+0x14>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:175

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
     842:	88 0f       	add	r24, r24
     844:	99 1f       	adc	r25, r25
     846:	88 0f       	add	r24, r24
     848:	99 1f       	adc	r25, r25
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:180

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
     84a:	05 97       	sbiw	r24, 0x05	; 5
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:234
	

#endif

	// busy wait
	__asm__ __volatile__ (
     84c:	01 97       	sbiw	r24, 0x01	; 1
     84e:	f1 f7       	brne	.-4      	; 0x84c <delayMicroseconds+0x10>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:239
		"1: sbiw %0,1" "\n\t" // 2 cycles
		"brne 1b" : "=w" (us) : "0" (us) // 2 cycles
	);
	// return = 4 cycles
}
     850:	08 95       	ret

00000852 <TwoWire::read()>:
read():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:296
int TwoWire::read(void)
{
  int value = -1;
  
  // get each successive byte on each call
  if(rxBufferIndex < rxBufferLength){
     852:	90 91 76 0c 	lds	r25, 0x0C76	; 0x800c76 <TwoWire::rxBufferIndex>
     856:	80 91 75 0c 	lds	r24, 0x0C75	; 0x800c75 <TwoWire::rxBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:293
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  int value = -1;
     85a:	2f ef       	ldi	r18, 0xFF	; 255
     85c:	3f ef       	ldi	r19, 0xFF	; 255
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:296
  
  // get each successive byte on each call
  if(rxBufferIndex < rxBufferLength){
     85e:	98 17       	cp	r25, r24
     860:	48 f4       	brcc	.+18     	; 0x874 <TwoWire::read()+0x22>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:297
    value = rxBuffer[rxBufferIndex];
     862:	e9 2f       	mov	r30, r25
     864:	f0 e0       	ldi	r31, 0x00	; 0
     866:	eb 5a       	subi	r30, 0xAB	; 171
     868:	f3 4f       	sbci	r31, 0xF3	; 243
     86a:	20 81       	ld	r18, Z
     86c:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:298
    ++rxBufferIndex;
     86e:	9f 5f       	subi	r25, 0xFF	; 255
     870:	90 93 76 0c 	sts	0x0C76, r25	; 0x800c76 <TwoWire::rxBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:302
  }

  return value;
}
     874:	c9 01       	movw	r24, r18
     876:	08 95       	ret

00000878 <TwoWire::read() [clone .constprop.142]>:
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:296
int TwoWire::read(void)
{
  int value = -1;
  
  // get each successive byte on each call
  if(rxBufferIndex < rxBufferLength){
     878:	90 91 76 0c 	lds	r25, 0x0C76	; 0x800c76 <TwoWire::rxBufferIndex>
     87c:	80 91 75 0c 	lds	r24, 0x0C75	; 0x800c75 <TwoWire::rxBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:293
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  int value = -1;
     880:	2f ef       	ldi	r18, 0xFF	; 255
     882:	3f ef       	ldi	r19, 0xFF	; 255
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:296
  
  // get each successive byte on each call
  if(rxBufferIndex < rxBufferLength){
     884:	98 17       	cp	r25, r24
     886:	48 f4       	brcc	.+18     	; 0x89a <TwoWire::read() [clone .constprop.142]+0x22>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:297
    value = rxBuffer[rxBufferIndex];
     888:	e9 2f       	mov	r30, r25
     88a:	f0 e0       	ldi	r31, 0x00	; 0
     88c:	eb 5a       	subi	r30, 0xAB	; 171
     88e:	f3 4f       	sbci	r31, 0xF3	; 243
     890:	20 81       	ld	r18, Z
     892:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:298
    ++rxBufferIndex;
     894:	9f 5f       	subi	r25, 0xFF	; 255
     896:	90 93 76 0c 	sts	0x0C76, r25	; 0x800c76 <TwoWire::rxBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:302
  }

  return value;
}
     89a:	c9 01       	movw	r24, r18
     89c:	08 95       	ret

0000089e <TwoWire::onRequestService()>:
onRequestService():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:361
  // !!! this will kill any pending pre-master sendTo() activity
  txBufferIndex = 0;
  txBufferLength = 0;
  // alert user program
  user_onRequest();
}
     89e:	08 95       	ret

000008a0 <TwoWire::onReceiveService(unsigned char*, int)>:
onReceiveService():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:346
  // set rx iterator vars
  rxBufferIndex = 0;
  rxBufferLength = numBytes;
  // alert user program
  user_onReceive(numBytes);
}
     8a0:	08 95       	ret

000008a2 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]>:
transfer():
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:259
/*!
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
     8a2:	cf 92       	push	r12
     8a4:	df 92       	push	r13
     8a6:	ef 92       	push	r14
     8a8:	ff 92       	push	r15
     8aa:	0f 93       	push	r16
     8ac:	1f 93       	push	r17
     8ae:	cf 93       	push	r28
     8b0:	df 93       	push	r29
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:123
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  buffer The buffer to send and receive at the same time
 *    @param  len    The number of bytes to transfer
 */
void Adafruit_SPIDevice::transfer(uint8_t *buffer, size_t len) {
  if (_spi) {
     8b2:	20 91 54 11 	lds	r18, 0x1154	; 0x801154 <max>
     8b6:	30 91 55 11 	lds	r19, 0x1155	; 0x801155 <max+0x1>
     8ba:	23 2b       	or	r18, r19
     8bc:	79 f0       	breq	.+30     	; 0x8dc <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x3a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:247
    return out.val;
  }
  inline static void transfer(void *buf, size_t count) {
    if (count == 0) return;
    uint8_t *p = (uint8_t *)buf;
    SPDR = *p;
     8be:	8e bd       	out	0x2e, r24	; 46
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:255
      while (!(SPSR & _BV(SPIF))) ;
      uint8_t in = SPDR;
      SPDR = out;
      *p++ = in;
    }
    while (!(SPSR & _BV(SPIF))) ;
     8c0:	0d b4       	in	r0, 0x2d	; 45
     8c2:	07 fe       	sbrs	r0, 7
     8c4:	fd cf       	rjmp	.-6      	; 0x8c0 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x1e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:256
    *p = SPDR;
     8c6:	de b4       	in	r13, 0x2e	; 46
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:263
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
  transfer(&data, 1);
  return data;
}
     8c8:	8d 2d       	mov	r24, r13
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	1f 91       	pop	r17
     8d0:	0f 91       	pop	r16
     8d2:	ff 90       	pop	r15
     8d4:	ef 90       	pop	r14
     8d6:	df 90       	pop	r13
     8d8:	cf 90       	pop	r12
     8da:	08 95       	ret
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:139
#endif
    return;
  }

  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
     8dc:	20 91 5c 11 	lds	r18, 0x115C	; 0x80115c <max+0x8>
     8e0:	30 91 5d 11 	lds	r19, 0x115D	; 0x80115d <max+0x9>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:140
    startbit = 0x1;
     8e4:	c1 e0       	ldi	r28, 0x01	; 1
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:139
#endif
    return;
  }

  uint8_t startbit;
  if (_dataOrder == SPI_BITORDER_LSBFIRST) {
     8e6:	23 2b       	or	r18, r19
     8e8:	09 f0       	breq	.+2      	; 0x8ec <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x4a>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:142
    startbit = 0x1;
  } else {
    startbit = 0x80;
     8ea:	c0 e8       	ldi	r28, 0x80	; 128
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:145
  }

  bool towrite, lastmosi = !(buffer[0] & startbit);
     8ec:	cc 24       	eor	r12, r12
     8ee:	c3 94       	inc	r12
     8f0:	98 2f       	mov	r25, r24
     8f2:	9c 23       	and	r25, r28
     8f4:	09 f0       	breq	.+2      	; 0x8f8 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x56>
     8f6:	c1 2c       	mov	r12, r1
     8f8:	d8 2f       	mov	r29, r24
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:146
  uint8_t bitdelay_us = (1000000 / _freq) / 2;
     8fa:	20 91 58 11 	lds	r18, 0x1158	; 0x801158 <max+0x4>
     8fe:	30 91 59 11 	lds	r19, 0x1159	; 0x801159 <max+0x5>
     902:	40 91 5a 11 	lds	r20, 0x115A	; 0x80115a <max+0x6>
     906:	50 91 5b 11 	lds	r21, 0x115B	; 0x80115b <max+0x7>
     90a:	60 e2       	ldi	r22, 0x20	; 32
     90c:	71 ea       	ldi	r23, 0xA1	; 161
     90e:	87 e0       	ldi	r24, 0x07	; 7
     910:	90 e0       	ldi	r25, 0x00	; 0
     912:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
     916:	12 2f       	mov	r17, r18
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:260
 *    @brief  Transfer (send/receive) one byte over hard/soft SPI
 *    @param  send The byte to send
 *    @return The byte received while transmitting
 */
uint8_t Adafruit_SPIDevice::transfer(uint8_t send) {
  uint8_t data = send;
     918:	dd 2e       	mov	r13, r29
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:151
  uint8_t bitdelay_us = (1000000 / _freq) / 2;

  // for softSPI we'll do it by hand
  for (size_t i = 0; i < len; i++) {
    // software SPI
    uint8_t reply = 0;
     91a:	00 e0       	ldi	r16, 0x00	; 0
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:165
    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
     91c:	e2 2e       	mov	r14, r18
     91e:	f1 2c       	mov	r15, r1
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:164

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
         b = (_dataOrder == SPI_BITORDER_LSBFIRST) ? b << 1 : b >> 1) {

      if (bitdelay_us) {
     920:	11 23       	and	r17, r17
     922:	19 f0       	breq	.+6      	; 0x92a <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x88>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:165
        delayMicroseconds(bitdelay_us);
     924:	c7 01       	movw	r24, r14
     926:	0e 94 1e 04 	call	0x83c	; 0x83c <delayMicroseconds>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:168
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
     92a:	80 91 5e 11 	lds	r24, 0x115E	; 0x80115e <max+0xa>
     92e:	87 7f       	andi	r24, 0xF7	; 247
     930:	09 f0       	breq	.+2      	; 0x934 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x92>
     932:	54 c0       	rjmp	.+168    	; 0x9dc <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x13a>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:170
        towrite = send & b;
        if ((_mosi != -1) && (lastmosi != towrite)) {
     934:	80 91 61 11 	lds	r24, 0x1161	; 0x801161 <max+0xd>
     938:	8f 3f       	cpi	r24, 0xFF	; 255
     93a:	a1 f0       	breq	.+40     	; 0x964 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0xc2>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:169
      if (bitdelay_us) {
        delayMicroseconds(bitdelay_us);
      }

      if (_dataMode == SPI_MODE0 || _dataMode == SPI_MODE2) {
        towrite = send & b;
     93c:	9d 2f       	mov	r25, r29
     93e:	9c 23       	and	r25, r28
     940:	81 e0       	ldi	r24, 0x01	; 1
     942:	09 f4       	brne	.+2      	; 0x946 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0xa4>
     944:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:170
        if ((_mosi != -1) && (lastmosi != towrite)) {
     946:	8c 15       	cp	r24, r12
     948:	69 f0       	breq	.+26     	; 0x964 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0xc2>
     94a:	e0 91 63 11 	lds	r30, 0x1163	; 0x801163 <max+0xf>
     94e:	f0 91 64 11 	lds	r31, 0x1164	; 0x801164 <max+0x10>
     952:	80 91 6b 11 	lds	r24, 0x116B	; 0x80116b <max+0x17>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:172
#ifdef BUSIO_USE_FAST_PINIO
          if (towrite)
     956:	99 23       	and	r25, r25
     958:	d9 f1       	breq	.+118    	; 0x9d0 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x12e>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:173
            *mosiPort |= mosiPinMask;
     95a:	90 81       	ld	r25, Z
     95c:	89 2b       	or	r24, r25
     95e:	80 83       	st	Z, r24
     960:	cc 24       	eor	r12, r12
     962:	c3 94       	inc	r12
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:183
#endif
          lastmosi = towrite;
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
     964:	e0 91 65 11 	lds	r30, 0x1165	; 0x801165 <max+0x11>
     968:	f0 91 66 11 	lds	r31, 0x1166	; 0x801166 <max+0x12>
     96c:	80 81       	ld	r24, Z
     96e:	90 91 6d 11 	lds	r25, 0x116D	; 0x80116d <max+0x19>
     972:	89 2b       	or	r24, r25
     974:	80 83       	st	Z, r24
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:188
#else
        digitalWrite(_sck, HIGH);
#endif

        if (bitdelay_us) {
     976:	11 23       	and	r17, r17
     978:	19 f0       	breq	.+6      	; 0x980 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0xde>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:189
          delayMicroseconds(bitdelay_us);
     97a:	c7 01       	movw	r24, r14
     97c:	0e 94 1e 04 	call	0x83c	; 0x83c <delayMicroseconds>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:192
        }

        if (_miso != -1) {
     980:	80 91 62 11 	lds	r24, 0x1162	; 0x801162 <max+0xe>
     984:	8f 3f       	cpi	r24, 0xFF	; 255
     986:	51 f0       	breq	.+20     	; 0x99c <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0xfa>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:194
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
     988:	e0 91 67 11 	lds	r30, 0x1167	; 0x801167 <max+0x13>
     98c:	f0 91 68 11 	lds	r31, 0x1168	; 0x801168 <max+0x14>
     990:	80 81       	ld	r24, Z
     992:	90 91 6c 11 	lds	r25, 0x116C	; 0x80116c <max+0x18>
     996:	89 23       	and	r24, r25
     998:	09 f0       	breq	.+2      	; 0x99c <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0xfa>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:198
#else
          if (digitalRead(_miso)) {
#endif
            reply |= b;
     99a:	0c 2b       	or	r16, r28
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:203
          }
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
     99c:	e0 91 65 11 	lds	r30, 0x1165	; 0x801165 <max+0x11>
     9a0:	f0 91 66 11 	lds	r31, 0x1166	; 0x801166 <max+0x12>
     9a4:	90 81       	ld	r25, Z
     9a6:	80 91 6d 11 	lds	r24, 0x116D	; 0x80116d <max+0x19>
     9aa:	80 95       	com	r24
     9ac:	89 23       	and	r24, r25
     9ae:	80 83       	st	Z, r24
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:246
#endif
            reply |= b;
          }
        }
      }
      if (_miso != -1) {
     9b0:	80 91 62 11 	lds	r24, 0x1162	; 0x801162 <max+0xe>
     9b4:	8f 3f       	cpi	r24, 0xFF	; 255
     9b6:	09 f0       	breq	.+2      	; 0x9ba <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x118>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:247
        buffer[i] = reply;
     9b8:	d0 2e       	mov	r13, r16
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:161
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
     9ba:	80 91 5c 11 	lds	r24, 0x115C	; 0x80115c <max+0x8>
     9be:	90 91 5d 11 	lds	r25, 0x115D	; 0x80115d <max+0x9>
     9c2:	89 2b       	or	r24, r25
     9c4:	09 f0       	breq	.+2      	; 0x9c8 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x126>
     9c6:	47 c0       	rjmp	.+142    	; 0xa56 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x1b4>
     9c8:	cc 0f       	add	r28, r28
     9ca:	c1 11       	cpse	r28, r1
     9cc:	a9 cf       	rjmp	.-174    	; 0x920 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x7e>
     9ce:	7c cf       	rjmp	.-264    	; 0x8c8 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x26>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:175
        if ((_mosi != -1) && (lastmosi != towrite)) {
#ifdef BUSIO_USE_FAST_PINIO
          if (towrite)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
     9d0:	90 81       	ld	r25, Z
     9d2:	80 95       	com	r24
     9d4:	89 23       	and	r24, r25
     9d6:	80 83       	st	Z, r24
     9d8:	c1 2c       	mov	r12, r1
     9da:	c4 cf       	rjmp	.-120    	; 0x964 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0xc2>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:210
        digitalWrite(_sck, LOW);
#endif
      } else { // if (_dataMode == SPI_MODE1 || _dataMode == SPI_MODE3)

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort |= clkPinMask; // Clock high
     9dc:	e0 91 65 11 	lds	r30, 0x1165	; 0x801165 <max+0x11>
     9e0:	f0 91 66 11 	lds	r31, 0x1166	; 0x801166 <max+0x12>
     9e4:	80 81       	ld	r24, Z
     9e6:	90 91 6d 11 	lds	r25, 0x116D	; 0x80116d <max+0x19>
     9ea:	89 2b       	or	r24, r25
     9ec:	80 83       	st	Z, r24
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:215
#else
        digitalWrite(_sck, HIGH);
#endif

        if (bitdelay_us) {
     9ee:	11 23       	and	r17, r17
     9f0:	19 f0       	breq	.+6      	; 0x9f8 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x156>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:216
          delayMicroseconds(bitdelay_us);
     9f2:	c7 01       	movw	r24, r14
     9f4:	0e 94 1e 04 	call	0x83c	; 0x83c <delayMicroseconds>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:219
        }

        if (_mosi != -1) {
     9f8:	80 91 61 11 	lds	r24, 0x1161	; 0x801161 <max+0xd>
     9fc:	8f 3f       	cpi	r24, 0xFF	; 255
     9fe:	61 f0       	breq	.+24     	; 0xa18 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x176>
     a00:	e0 91 63 11 	lds	r30, 0x1163	; 0x801163 <max+0xf>
     a04:	f0 91 64 11 	lds	r31, 0x1164	; 0x801164 <max+0x10>
     a08:	80 91 6b 11 	lds	r24, 0x116B	; 0x80116b <max+0x17>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:221
#ifdef BUSIO_USE_FAST_PINIO
          if (send & b)
     a0c:	9d 2f       	mov	r25, r29
     a0e:	9c 23       	and	r25, r28
     a10:	f1 f0       	breq	.+60     	; 0xa4e <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x1ac>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:222
            *mosiPort |= mosiPinMask;
     a12:	90 81       	ld	r25, Z
     a14:	89 2b       	or	r24, r25
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:224
          else
            *mosiPort &= ~mosiPinMask;
     a16:	80 83       	st	Z, r24
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:231
          digitalWrite(_mosi, send & b);
#endif
        }

#ifdef BUSIO_USE_FAST_PINIO
        *clkPort &= ~clkPinMask; // Clock low
     a18:	e0 91 65 11 	lds	r30, 0x1165	; 0x801165 <max+0x11>
     a1c:	f0 91 66 11 	lds	r31, 0x1166	; 0x801166 <max+0x12>
     a20:	90 81       	ld	r25, Z
     a22:	80 91 6d 11 	lds	r24, 0x116D	; 0x80116d <max+0x19>
     a26:	80 95       	com	r24
     a28:	89 23       	and	r24, r25
     a2a:	80 83       	st	Z, r24
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:236
#else
        digitalWrite(_sck, LOW);
#endif

        if (_miso != -1) {
     a2c:	80 91 62 11 	lds	r24, 0x1162	; 0x801162 <max+0xe>
     a30:	8f 3f       	cpi	r24, 0xFF	; 255
     a32:	09 f4       	brne	.+2      	; 0xa36 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x194>
     a34:	bd cf       	rjmp	.-134    	; 0x9b0 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x10e>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:238
#ifdef BUSIO_USE_FAST_PINIO
          if (*misoPort & misoPinMask) {
     a36:	e0 91 67 11 	lds	r30, 0x1167	; 0x801167 <max+0x13>
     a3a:	f0 91 68 11 	lds	r31, 0x1168	; 0x801168 <max+0x14>
     a3e:	80 81       	ld	r24, Z
     a40:	90 91 6c 11 	lds	r25, 0x116C	; 0x80116c <max+0x18>
     a44:	89 23       	and	r24, r25
     a46:	09 f4       	brne	.+2      	; 0xa4a <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x1a8>
     a48:	b3 cf       	rjmp	.-154    	; 0x9b0 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x10e>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:242
#else
          if (digitalRead(_miso)) {
#endif
            reply |= b;
     a4a:	0c 2b       	or	r16, r28
     a4c:	b1 cf       	rjmp	.-158    	; 0x9b0 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x10e>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:224
        if (_mosi != -1) {
#ifdef BUSIO_USE_FAST_PINIO
          if (send & b)
            *mosiPort |= mosiPinMask;
          else
            *mosiPort &= ~mosiPinMask;
     a4e:	90 81       	ld	r25, Z
     a50:	80 95       	com	r24
     a52:	89 23       	and	r24, r25
     a54:	e0 cf       	rjmp	.-64     	; 0xa16 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x174>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:161
    Serial.print(send, HEX);
    Serial.print(" -> 0x");
    */

    // Serial.print(send, HEX);
    for (uint8_t b = startbit; b != 0;
     a56:	c6 95       	lsr	r28
     a58:	b8 cf       	rjmp	.-144    	; 0x9ca <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]+0x128>

00000a5a <Adafruit_Keypad::read() [clone .constprop.58]>:
read_char():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:84
  _iHead = 0;
  _iTail = 0;
}

template <int N> int Adafruit_Keypad_RingbufferN<N>::read_char() {
  if (_iTail == _iHead)
     a5a:	20 91 62 13 	lds	r18, 0x1362	; 0x801362 <customKeypad+0x10a>
     a5e:	30 91 63 13 	lds	r19, 0x1363	; 0x801363 <customKeypad+0x10b>
     a62:	80 91 60 13 	lds	r24, 0x1360	; 0x801360 <customKeypad+0x108>
     a66:	90 91 61 13 	lds	r25, 0x1361	; 0x801361 <customKeypad+0x109>
     a6a:	28 17       	cp	r18, r24
     a6c:	39 07       	cpc	r19, r25
     a6e:	99 f1       	breq	.+102    	; 0xad6 <Adafruit_Keypad::read() [clone .constprop.58]+0x7c>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:87
    return -1;

  uint8_t value = _aucBuffer[_iTail];
     a70:	e0 91 62 13 	lds	r30, 0x1362	; 0x801362 <customKeypad+0x10a>
     a74:	f0 91 63 13 	lds	r31, 0x1363	; 0x801363 <customKeypad+0x10b>
     a78:	e8 5a       	subi	r30, 0xA8	; 168
     a7a:	fd 4e       	sbci	r31, 0xED	; 237
     a7c:	80 85       	ldd	r24, Z+8	; 0x08
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:88
  _iTail = nextIndex(_iTail);
     a7e:	20 91 62 13 	lds	r18, 0x1362	; 0x801362 <customKeypad+0x10a>
     a82:	30 91 63 13 	lds	r19, 0x1363	; 0x801363 <customKeypad+0x10b>
_ZN27Adafruit_Keypad_RingbufferNILi256EE9nextIndexEi():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:117

  return _aucBuffer[_iTail];
}

template <int N> int Adafruit_Keypad_RingbufferN<N>::nextIndex(int index) {
  return (uint32_t)(index + 1) % N;
     a86:	2f 5f       	subi	r18, 0xFF	; 255
     a88:	3f 4f       	sbci	r19, 0xFF	; 255
     a8a:	33 27       	eor	r19, r19
read_char():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:88
template <int N> int Adafruit_Keypad_RingbufferN<N>::read_char() {
  if (_iTail == _iHead)
    return -1;

  uint8_t value = _aucBuffer[_iTail];
  _iTail = nextIndex(_iTail);
     a8c:	30 93 63 13 	sts	0x1363, r19	; 0x801363 <customKeypad+0x10b>
     a90:	20 93 62 13 	sts	0x1362, r18	; 0x801362 <customKeypad+0x10a>
read():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:194
    @returns    the next event in the FIFO
*/
/**************************************************************************/
keypadEvent Adafruit_Keypad::read() {
  keypadEvent k;
  k.bit.EVENT = _eventbuf.read_char();
     a94:	98 2f       	mov	r25, r24
read_char():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:84
  _iHead = 0;
  _iTail = 0;
}

template <int N> int Adafruit_Keypad_RingbufferN<N>::read_char() {
  if (_iTail == _iHead)
     a96:	40 91 62 13 	lds	r20, 0x1362	; 0x801362 <customKeypad+0x10a>
     a9a:	50 91 63 13 	lds	r21, 0x1363	; 0x801363 <customKeypad+0x10b>
     a9e:	20 91 60 13 	lds	r18, 0x1360	; 0x801360 <customKeypad+0x108>
     aa2:	30 91 61 13 	lds	r19, 0x1361	; 0x801361 <customKeypad+0x109>
     aa6:	42 17       	cp	r20, r18
     aa8:	53 07       	cpc	r21, r19
     aaa:	c1 f0       	breq	.+48     	; 0xadc <Adafruit_Keypad::read() [clone .constprop.58]+0x82>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:87
    return -1;

  uint8_t value = _aucBuffer[_iTail];
     aac:	e0 91 62 13 	lds	r30, 0x1362	; 0x801362 <customKeypad+0x10a>
     ab0:	f0 91 63 13 	lds	r31, 0x1363	; 0x801363 <customKeypad+0x10b>
     ab4:	e8 5a       	subi	r30, 0xA8	; 168
     ab6:	fd 4e       	sbci	r31, 0xED	; 237
     ab8:	80 85       	ldd	r24, Z+8	; 0x08
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:88
  _iTail = nextIndex(_iTail);
     aba:	20 91 62 13 	lds	r18, 0x1362	; 0x801362 <customKeypad+0x10a>
     abe:	30 91 63 13 	lds	r19, 0x1363	; 0x801363 <customKeypad+0x10b>
_ZN27Adafruit_Keypad_RingbufferNILi256EE9nextIndexEi():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:117

  return _aucBuffer[_iTail];
}

template <int N> int Adafruit_Keypad_RingbufferN<N>::nextIndex(int index) {
  return (uint32_t)(index + 1) % N;
     ac2:	2f 5f       	subi	r18, 0xFF	; 255
     ac4:	3f 4f       	sbci	r19, 0xFF	; 255
     ac6:	33 27       	eor	r19, r19
read_char():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:88
template <int N> int Adafruit_Keypad_RingbufferN<N>::read_char() {
  if (_iTail == _iHead)
    return -1;

  uint8_t value = _aucBuffer[_iTail];
  _iTail = nextIndex(_iTail);
     ac8:	30 93 63 13 	sts	0x1363, r19	; 0x801363 <customKeypad+0x10b>
     acc:	20 93 62 13 	sts	0x1362, r18	; 0x801362 <customKeypad+0x10a>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:90

  return value;
     ad0:	28 2f       	mov	r18, r24
read():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:198
  k.bit.KEY = _eventbuf.read_char();

  return k;
}
     ad2:	82 2f       	mov	r24, r18
     ad4:	08 95       	ret
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:85
  _iTail = 0;
}

template <int N> int Adafruit_Keypad_RingbufferN<N>::read_char() {
  if (_iTail == _iHead)
    return -1;
     ad6:	8f ef       	ldi	r24, 0xFF	; 255
     ad8:	9f ef       	ldi	r25, 0xFF	; 255
     ada:	dc cf       	rjmp	.-72     	; 0xa94 <Adafruit_Keypad::read() [clone .constprop.58]+0x3a>
     adc:	2f ef       	ldi	r18, 0xFF	; 255
     ade:	3f ef       	ldi	r19, 0xFF	; 255
     ae0:	f8 cf       	rjmp	.-16     	; 0xad2 <Adafruit_Keypad::read() [clone .constprop.58]+0x78>

00000ae2 <Adafruit_Keypad_RingbufferN<256>::store_char(unsigned char) [clone .constprop.55]>:
store_char():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:66
  memset(_aucBuffer, 0, N);
  clear();
}

template <int N> void Adafruit_Keypad_RingbufferN<N>::store_char(uint8_t c) {
  int i = nextIndex(_iHead);
     ae2:	20 91 60 13 	lds	r18, 0x1360	; 0x801360 <customKeypad+0x108>
     ae6:	30 91 61 13 	lds	r19, 0x1361	; 0x801361 <customKeypad+0x109>
_ZN27Adafruit_Keypad_RingbufferNILi256EE9nextIndexEi():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:117

  return _aucBuffer[_iTail];
}

template <int N> int Adafruit_Keypad_RingbufferN<N>::nextIndex(int index) {
  return (uint32_t)(index + 1) % N;
     aea:	2f 5f       	subi	r18, 0xFF	; 255
     aec:	3f 4f       	sbci	r19, 0xFF	; 255
     aee:	33 27       	eor	r19, r19
store_char():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:72

  // if we should be storing the received character into the location
  // just before the tail (meaning that the head would advance to the
  // current location of the tail), we're about to overflow the buffer
  // and so we don't write the character or advance the head.
  if (i != _iTail) {
     af0:	40 91 62 13 	lds	r20, 0x1362	; 0x801362 <customKeypad+0x10a>
     af4:	50 91 63 13 	lds	r21, 0x1363	; 0x801363 <customKeypad+0x10b>
     af8:	24 17       	cp	r18, r20
     afa:	35 07       	cpc	r19, r21
     afc:	59 f0       	breq	.+22     	; 0xb14 <Adafruit_Keypad_RingbufferN<256>::store_char(unsigned char) [clone .constprop.55]+0x32>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:73
    _aucBuffer[_iHead] = c;
     afe:	e0 91 60 13 	lds	r30, 0x1360	; 0x801360 <customKeypad+0x108>
     b02:	f0 91 61 13 	lds	r31, 0x1361	; 0x801361 <customKeypad+0x109>
     b06:	e8 5a       	subi	r30, 0xA8	; 168
     b08:	fd 4e       	sbci	r31, 0xED	; 237
     b0a:	80 87       	std	Z+8, r24	; 0x08
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:74
    _iHead = i;
     b0c:	30 93 61 13 	sts	0x1361, r19	; 0x801361 <customKeypad+0x109>
     b10:	20 93 60 13 	sts	0x1360, r18	; 0x801360 <customKeypad+0x108>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:76
  }
}
     b14:	08 95       	ret

00000b16 <WatchdogAVR::enable(int) [clone .constprop.48]>:
_setPeriod():
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:94

void WatchdogAVR::_setPeriod(int maxMS, int &wdto, int &actualMS) {
  // Note the order of these if statements from highest to lowest  is
  // important so that control flow cascades down to the right value based
  // on its position in the range of discrete timeouts.
  if ((maxMS >= 8000) || (maxMS == 0)) {
     b16:	80 34       	cpi	r24, 0x40	; 64
     b18:	2f e1       	ldi	r18, 0x1F	; 31
     b1a:	92 07       	cpc	r25, r18
     b1c:	14 f4       	brge	.+4      	; 0xb22 <WatchdogAVR::enable(int) [clone .constprop.48]+0xc>
     b1e:	00 97       	sbiw	r24, 0x00	; 0
     b20:	f9 f4       	brne	.+62     	; 0xb60 <WatchdogAVR::enable(int) [clone .constprop.48]+0x4a>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:95
    wdto = WDTO_8S;
     b22:	89 e0       	ldi	r24, 0x09	; 9
     b24:	90 e0       	ldi	r25, 0x00	; 0
     b26:	90 93 f0 0e 	sts	0x0EF0, r25	; 0x800ef0 <Watchdog+0x1>
     b2a:	80 93 ef 0e 	sts	0x0EEF, r24	; 0x800eef <Watchdog>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:96
    actualMS = 8000;
     b2e:	80 e4       	ldi	r24, 0x40	; 64
     b30:	9f e1       	ldi	r25, 0x1F	; 31
enable():
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:24
int WatchdogAVR::enable(int maxPeriodMS) {
  // Pick the closest appropriate watchdog timer value.
  int actualMS;
  _setPeriod(maxPeriodMS, _wdto, actualMS);
  // Enable the watchdog and return the actual countdown value.
  wdt_enable(_wdto);
     b32:	20 91 ef 0e 	lds	r18, 0x0EEF	; 0x800eef <Watchdog>
     b36:	30 91 f0 0e 	lds	r19, 0x0EF0	; 0x800ef0 <Watchdog+0x1>
wdt_enable():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\avr/wdt.h:483
				"out __SREG__,__tmp_reg__" "\n\t"
				"sts %0, %2" "\n \t"
				: /* no outputs */
				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
     b3a:	a9 01       	movw	r20, r18
     b3c:	44 0f       	add	r20, r20
     b3e:	55 1f       	adc	r21, r21
     b40:	44 0f       	add	r20, r20
     b42:	55 1f       	adc	r21, r21
     b44:	40 72       	andi	r20, 0x20	; 32
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\avr/wdt.h:484
						_BV(WDE) | (value & 0x07)) )
     b46:	27 70       	andi	r18, 0x07	; 7
     b48:	28 60       	ori	r18, 0x08	; 8
     b4a:	24 2b       	or	r18, r20
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\avr/wdt.h:486
				: "r0"
		);
     b4c:	38 e1       	ldi	r19, 0x18	; 24
     b4e:	0f b6       	in	r0, 0x3f	; 63
     b50:	f8 94       	cli
     b52:	a8 95       	wdr
     b54:	30 93 60 00 	sts	0x0060, r19	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
     b58:	0f be       	out	0x3f, r0	; 63
     b5a:	20 93 60 00 	sts	0x0060, r18	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
enable():
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:26
  return actualMS;
}
     b5e:	08 95       	ret
_setPeriod():
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:97
  // important so that control flow cascades down to the right value based
  // on its position in the range of discrete timeouts.
  if ((maxMS >= 8000) || (maxMS == 0)) {
    wdto = WDTO_8S;
    actualMS = 8000;
  } else if (maxMS >= 4000) {
     b60:	80 3a       	cpi	r24, 0xA0	; 160
     b62:	2f e0       	ldi	r18, 0x0F	; 15
     b64:	92 07       	cpc	r25, r18
     b66:	4c f0       	brlt	.+18     	; 0xb7a <WatchdogAVR::enable(int) [clone .constprop.48]+0x64>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:98
    wdto = WDTO_4S;
     b68:	88 e0       	ldi	r24, 0x08	; 8
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	90 93 f0 0e 	sts	0x0EF0, r25	; 0x800ef0 <Watchdog+0x1>
     b70:	80 93 ef 0e 	sts	0x0EEF, r24	; 0x800eef <Watchdog>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:99
    actualMS = 4000;
     b74:	80 ea       	ldi	r24, 0xA0	; 160
     b76:	9f e0       	ldi	r25, 0x0F	; 15
     b78:	dc cf       	rjmp	.-72     	; 0xb32 <WatchdogAVR::enable(int) [clone .constprop.48]+0x1c>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:100
  } else if (maxMS >= 2000) {
     b7a:	80 3d       	cpi	r24, 0xD0	; 208
     b7c:	27 e0       	ldi	r18, 0x07	; 7
     b7e:	92 07       	cpc	r25, r18
     b80:	4c f0       	brlt	.+18     	; 0xb94 <WatchdogAVR::enable(int) [clone .constprop.48]+0x7e>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:101
    wdto = WDTO_2S;
     b82:	87 e0       	ldi	r24, 0x07	; 7
     b84:	90 e0       	ldi	r25, 0x00	; 0
     b86:	90 93 f0 0e 	sts	0x0EF0, r25	; 0x800ef0 <Watchdog+0x1>
     b8a:	80 93 ef 0e 	sts	0x0EEF, r24	; 0x800eef <Watchdog>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:102
    actualMS = 2000;
     b8e:	80 ed       	ldi	r24, 0xD0	; 208
     b90:	97 e0       	ldi	r25, 0x07	; 7
     b92:	cf cf       	rjmp	.-98     	; 0xb32 <WatchdogAVR::enable(int) [clone .constprop.48]+0x1c>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:103
  } else if (maxMS >= 1000) {
     b94:	88 3e       	cpi	r24, 0xE8	; 232
     b96:	23 e0       	ldi	r18, 0x03	; 3
     b98:	92 07       	cpc	r25, r18
     b9a:	4c f0       	brlt	.+18     	; 0xbae <WatchdogAVR::enable(int) [clone .constprop.48]+0x98>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:104
    wdto = WDTO_1S;
     b9c:	86 e0       	ldi	r24, 0x06	; 6
     b9e:	90 e0       	ldi	r25, 0x00	; 0
     ba0:	90 93 f0 0e 	sts	0x0EF0, r25	; 0x800ef0 <Watchdog+0x1>
     ba4:	80 93 ef 0e 	sts	0x0EEF, r24	; 0x800eef <Watchdog>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:105
    actualMS = 1000;
     ba8:	88 ee       	ldi	r24, 0xE8	; 232
     baa:	93 e0       	ldi	r25, 0x03	; 3
     bac:	c2 cf       	rjmp	.-124    	; 0xb32 <WatchdogAVR::enable(int) [clone .constprop.48]+0x1c>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:106
  } else if (maxMS >= 500) {
     bae:	84 3f       	cpi	r24, 0xF4	; 244
     bb0:	21 e0       	ldi	r18, 0x01	; 1
     bb2:	92 07       	cpc	r25, r18
     bb4:	4c f0       	brlt	.+18     	; 0xbc8 <WatchdogAVR::enable(int) [clone .constprop.48]+0xb2>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:107
    wdto = WDTO_500MS;
     bb6:	85 e0       	ldi	r24, 0x05	; 5
     bb8:	90 e0       	ldi	r25, 0x00	; 0
     bba:	90 93 f0 0e 	sts	0x0EF0, r25	; 0x800ef0 <Watchdog+0x1>
     bbe:	80 93 ef 0e 	sts	0x0EEF, r24	; 0x800eef <Watchdog>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:108
    actualMS = 500;
     bc2:	84 ef       	ldi	r24, 0xF4	; 244
     bc4:	91 e0       	ldi	r25, 0x01	; 1
     bc6:	b5 cf       	rjmp	.-150    	; 0xb32 <WatchdogAVR::enable(int) [clone .constprop.48]+0x1c>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:109
  } else if (maxMS >= 250) {
     bc8:	8a 3f       	cpi	r24, 0xFA	; 250
     bca:	91 05       	cpc	r25, r1
     bcc:	4c f0       	brlt	.+18     	; 0xbe0 <WatchdogAVR::enable(int) [clone .constprop.48]+0xca>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:110
    wdto = WDTO_250MS;
     bce:	84 e0       	ldi	r24, 0x04	; 4
     bd0:	90 e0       	ldi	r25, 0x00	; 0
     bd2:	90 93 f0 0e 	sts	0x0EF0, r25	; 0x800ef0 <Watchdog+0x1>
     bd6:	80 93 ef 0e 	sts	0x0EEF, r24	; 0x800eef <Watchdog>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:111
    actualMS = 250;
     bda:	8a ef       	ldi	r24, 0xFA	; 250
     bdc:	90 e0       	ldi	r25, 0x00	; 0
     bde:	a9 cf       	rjmp	.-174    	; 0xb32 <WatchdogAVR::enable(int) [clone .constprop.48]+0x1c>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:112
  } else if (maxMS >= 120) {
     be0:	88 37       	cpi	r24, 0x78	; 120
     be2:	91 05       	cpc	r25, r1
     be4:	4c f0       	brlt	.+18     	; 0xbf8 <WatchdogAVR::enable(int) [clone .constprop.48]+0xe2>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:113
    wdto = WDTO_120MS;
     be6:	83 e0       	ldi	r24, 0x03	; 3
     be8:	90 e0       	ldi	r25, 0x00	; 0
     bea:	90 93 f0 0e 	sts	0x0EF0, r25	; 0x800ef0 <Watchdog+0x1>
     bee:	80 93 ef 0e 	sts	0x0EEF, r24	; 0x800eef <Watchdog>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:114
    actualMS = 120;
     bf2:	88 e7       	ldi	r24, 0x78	; 120
     bf4:	90 e0       	ldi	r25, 0x00	; 0
     bf6:	9d cf       	rjmp	.-198    	; 0xb32 <WatchdogAVR::enable(int) [clone .constprop.48]+0x1c>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:115
  } else if (maxMS >= 60) {
     bf8:	8c 33       	cpi	r24, 0x3C	; 60
     bfa:	91 05       	cpc	r25, r1
     bfc:	4c f0       	brlt	.+18     	; 0xc10 <WatchdogAVR::enable(int) [clone .constprop.48]+0xfa>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:116
    wdto = WDTO_60MS;
     bfe:	82 e0       	ldi	r24, 0x02	; 2
     c00:	90 e0       	ldi	r25, 0x00	; 0
     c02:	90 93 f0 0e 	sts	0x0EF0, r25	; 0x800ef0 <Watchdog+0x1>
     c06:	80 93 ef 0e 	sts	0x0EEF, r24	; 0x800eef <Watchdog>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:117
    actualMS = 60;
     c0a:	8c e3       	ldi	r24, 0x3C	; 60
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	91 cf       	rjmp	.-222    	; 0xb32 <WatchdogAVR::enable(int) [clone .constprop.48]+0x1c>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:118
  } else if (maxMS >= 30) {
     c10:	4e 97       	sbiw	r24, 0x1e	; 30
     c12:	4c f0       	brlt	.+18     	; 0xc26 <WatchdogAVR::enable(int) [clone .constprop.48]+0x110>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:119
    wdto = WDTO_30MS;
     c14:	81 e0       	ldi	r24, 0x01	; 1
     c16:	90 e0       	ldi	r25, 0x00	; 0
     c18:	90 93 f0 0e 	sts	0x0EF0, r25	; 0x800ef0 <Watchdog+0x1>
     c1c:	80 93 ef 0e 	sts	0x0EEF, r24	; 0x800eef <Watchdog>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:120
    actualMS = 30;
     c20:	8e e1       	ldi	r24, 0x1E	; 30
     c22:	90 e0       	ldi	r25, 0x00	; 0
     c24:	86 cf       	rjmp	.-244    	; 0xb32 <WatchdogAVR::enable(int) [clone .constprop.48]+0x1c>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:122
  } else {
    wdto = WDTO_15MS;
     c26:	10 92 f0 0e 	sts	0x0EF0, r1	; 0x800ef0 <Watchdog+0x1>
     c2a:	10 92 ef 0e 	sts	0x0EEF, r1	; 0x800eef <Watchdog>
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:123
    actualMS = 15;
     c2e:	8f e0       	ldi	r24, 0x0F	; 15
     c30:	90 e0       	ldi	r25, 0x00	; 0
     c32:	7f cf       	rjmp	.-258    	; 0xb32 <WatchdogAVR::enable(int) [clone .constprop.48]+0x1c>

00000c34 <TwoWire::available()>:
available():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:285
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return rxBufferLength - rxBufferIndex;
     c34:	80 91 75 0c 	lds	r24, 0x0C75	; 0x800c75 <TwoWire::rxBufferLength>
     c38:	90 91 76 0c 	lds	r25, 0x0C76	; 0x800c76 <TwoWire::rxBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:286
}
     c3c:	89 1b       	sub	r24, r25
     c3e:	99 0b       	sbc	r25, r25
     c40:	08 95       	ret

00000c42 <Countimer::callback() [clone .constprop.13]>:
callback():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:177
	}
}

void Countimer::callback()
{
	if(_callback != NULL)
     c42:	e0 91 46 12 	lds	r30, 0x1246	; 0x801246 <resetRow1+0x14>
     c46:	f0 91 47 12 	lds	r31, 0x1247	; 0x801247 <resetRow1+0x15>
     c4a:	30 97       	sbiw	r30, 0x00	; 0
     c4c:	09 f0       	breq	.+2      	; 0xc50 <Countimer::callback() [clone .constprop.13]+0xe>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:178
		_callback();
     c4e:	19 94       	eijmp
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:179
}
     c50:	08 95       	ret

00000c52 <String::operator[](unsigned int)>:
operator[]():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:524
}

char & String::operator[](unsigned int index)
{
	static char dummy_writable_char;
	if (index >= len || !buffer) {
     c52:	fc 01       	movw	r30, r24
     c54:	24 81       	ldd	r18, Z+4	; 0x04
     c56:	35 81       	ldd	r19, Z+5	; 0x05
     c58:	62 17       	cp	r22, r18
     c5a:	73 07       	cpc	r23, r19
     c5c:	20 f4       	brcc	.+8      	; 0xc66 <String::operator[](unsigned int)+0x14>
     c5e:	80 81       	ld	r24, Z
     c60:	91 81       	ldd	r25, Z+1	; 0x01
     c62:	00 97       	sbiw	r24, 0x00	; 0
     c64:	29 f4       	brne	.+10     	; 0xc70 <String::operator[](unsigned int)+0x1e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:525
		dummy_writable_char = 0;
     c66:	10 92 f9 09 	sts	0x09F9, r1	; 0x8009f9 <String::operator[](unsigned int)::dummy_writable_char>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:526
		return dummy_writable_char;
     c6a:	89 ef       	ldi	r24, 0xF9	; 249
     c6c:	99 e0       	ldi	r25, 0x09	; 9
     c6e:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:528
	}
	return buffer[index];
     c70:	86 0f       	add	r24, r22
     c72:	97 1f       	adc	r25, r23
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:529
}
     c74:	08 95       	ret

00000c76 <Print::flush()>:
flush():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:90
    size_t println(unsigned long, int = DEC);
    size_t println(double, int = 2);
    size_t println(const Printable&);
    size_t println(void);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
     c76:	08 95       	ret

00000c78 <Print::print(char)>:
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:69
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
     c78:	dc 01       	movw	r26, r24
     c7a:	ed 91       	ld	r30, X+
     c7c:	fc 91       	ld	r31, X
     c7e:	01 90       	ld	r0, Z+
     c80:	f0 81       	ld	r31, Z
     c82:	e0 2d       	mov	r30, r0
     c84:	19 94       	eijmp

00000c86 <Print::print(String const&)>:
write():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:58
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
    }
    virtual size_t write(const uint8_t *buffer, size_t size);
    size_t write(const char *buffer, size_t size) {
      return write((const uint8_t *)buffer, size);
     c86:	db 01       	movw	r26, r22
     c88:	14 96       	adiw	r26, 0x04	; 4
     c8a:	4d 91       	ld	r20, X+
     c8c:	5c 91       	ld	r21, X
     c8e:	15 97       	sbiw	r26, 0x05	; 5
     c90:	6d 91       	ld	r22, X+
     c92:	7c 91       	ld	r23, X
     c94:	dc 01       	movw	r26, r24
     c96:	ed 91       	ld	r30, X+
     c98:	fc 91       	ld	r31, X
     c9a:	02 80       	ldd	r0, Z+2	; 0x02
     c9c:	f3 81       	ldd	r31, Z+3	; 0x03
     c9e:	e0 2d       	mov	r30, r0
     ca0:	19 94       	eijmp

00000ca2 <Print::print(__FlashStringHelper const*)>:
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:45
  }
  return n;
}

size_t Print::print(const __FlashStringHelper *ifsh)
{
     ca2:	ef 92       	push	r14
     ca4:	ff 92       	push	r15
     ca6:	0f 93       	push	r16
     ca8:	1f 93       	push	r17
     caa:	cf 93       	push	r28
     cac:	df 93       	push	r29
     cae:	8c 01       	movw	r16, r24
     cb0:	7b 01       	movw	r14, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:47
  PGM_P p = reinterpret_cast<PGM_P>(ifsh);
  size_t n = 0;
     cb2:	d0 e0       	ldi	r29, 0x00	; 0
     cb4:	c0 e0       	ldi	r28, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:49
  while (1) {
    unsigned char c = pgm_read_byte(p++);
     cb6:	f7 01       	movw	r30, r14
     cb8:	ec 0f       	add	r30, r28
     cba:	fd 1f       	adc	r31, r29
     cbc:	64 91       	lpm	r22, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:50
    if (c == 0) break;
     cbe:	66 23       	and	r22, r22
     cc0:	61 f0       	breq	.+24     	; 0xcda <Print::print(__FlashStringHelper const*)+0x38>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:51
    if (write(c)) n++;
     cc2:	d8 01       	movw	r26, r16
     cc4:	ed 91       	ld	r30, X+
     cc6:	fc 91       	ld	r31, X
     cc8:	01 90       	ld	r0, Z+
     cca:	f0 81       	ld	r31, Z
     ccc:	e0 2d       	mov	r30, r0
     cce:	c8 01       	movw	r24, r16
     cd0:	19 95       	eicall
     cd2:	89 2b       	or	r24, r25
     cd4:	11 f0       	breq	.+4      	; 0xcda <Print::print(__FlashStringHelper const*)+0x38>
     cd6:	21 96       	adiw	r28, 0x01	; 1
     cd8:	ee cf       	rjmp	.-36     	; 0xcb6 <Print::print(__FlashStringHelper const*)+0x14>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:55
    else break;
  }
  return n;
}
     cda:	ce 01       	movw	r24, r28
     cdc:	df 91       	pop	r29
     cde:	cf 91       	pop	r28
     ce0:	1f 91       	pop	r17
     ce2:	0f 91       	pop	r16
     ce4:	ff 90       	pop	r15
     ce6:	ef 90       	pop	r14
     ce8:	08 95       	ret

00000cea <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:35

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     cea:	af 92       	push	r10
     cec:	bf 92       	push	r11
     cee:	cf 92       	push	r12
     cf0:	df 92       	push	r13
     cf2:	ef 92       	push	r14
     cf4:	ff 92       	push	r15
     cf6:	0f 93       	push	r16
     cf8:	1f 93       	push	r17
     cfa:	cf 93       	push	r28
     cfc:	df 93       	push	r29
     cfe:	6c 01       	movw	r12, r24
     d00:	7b 01       	movw	r14, r22
     d02:	8b 01       	movw	r16, r22
     d04:	04 0f       	add	r16, r20
     d06:	15 1f       	adc	r17, r21
     d08:	eb 01       	movw	r28, r22
     d0a:	5e 01       	movw	r10, r28
     d0c:	ae 18       	sub	r10, r14
     d0e:	bf 08       	sbc	r11, r15
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:37
  size_t n = 0;
  while (size--) {
     d10:	c0 17       	cp	r28, r16
     d12:	d1 07       	cpc	r29, r17
     d14:	59 f0       	breq	.+22     	; 0xd2c <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:38
    if (write(*buffer++)) n++;
     d16:	69 91       	ld	r22, Y+
     d18:	d6 01       	movw	r26, r12
     d1a:	ed 91       	ld	r30, X+
     d1c:	fc 91       	ld	r31, X
     d1e:	01 90       	ld	r0, Z+
     d20:	f0 81       	ld	r31, Z
     d22:	e0 2d       	mov	r30, r0
     d24:	c6 01       	movw	r24, r12
     d26:	19 95       	eicall
     d28:	89 2b       	or	r24, r25
     d2a:	79 f7       	brne	.-34     	; 0xd0a <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:42
    else break;
  }
  return n;
}
     d2c:	c5 01       	movw	r24, r10
     d2e:	df 91       	pop	r29
     d30:	cf 91       	pop	r28
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	ff 90       	pop	r15
     d38:	ef 90       	pop	r14
     d3a:	df 90       	pop	r13
     d3c:	cf 90       	pop	r12
     d3e:	bf 90       	pop	r11
     d40:	af 90       	pop	r10
     d42:	08 95       	ret

00000d44 <HardwareSerial::_rx_complete_irq()>:
_rx_complete_irq():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial_private.h:102
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
     d44:	fc 01       	movw	r30, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial_private.h:103
  if (bit_is_clear(*_ucsra, UPE0)) {
     d46:	a0 89       	ldd	r26, Z+16	; 0x10
     d48:	b1 89       	ldd	r27, Z+17	; 0x11
     d4a:	8c 91       	ld	r24, X
     d4c:	a6 89       	ldd	r26, Z+22	; 0x16
     d4e:	b7 89       	ldd	r27, Z+23	; 0x17
     d50:	82 fd       	sbrc	r24, 2
     d52:	0f c0       	rjmp	.+30     	; 0xd72 <HardwareSerial::_rx_complete_irq()+0x2e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial_private.h:106
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
     d54:	9c 91       	ld	r25, X
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial_private.h:107
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     d56:	81 8d       	ldd	r24, Z+25	; 0x19
     d58:	8f 5f       	subi	r24, 0xFF	; 255
     d5a:	8f 73       	andi	r24, 0x3F	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial_private.h:113

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     d5c:	22 8d       	ldd	r18, Z+26	; 0x1a
     d5e:	82 17       	cp	r24, r18
     d60:	49 f0       	breq	.+18     	; 0xd74 <HardwareSerial::_rx_complete_irq()+0x30>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial_private.h:114
      _rx_buffer[_rx_buffer_head] = c;
     d62:	a1 8d       	ldd	r26, Z+25	; 0x19
     d64:	ae 0f       	add	r26, r30
     d66:	bf 2f       	mov	r27, r31
     d68:	b1 1d       	adc	r27, r1
     d6a:	5d 96       	adiw	r26, 0x1d	; 29
     d6c:	9c 93       	st	X, r25
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial_private.h:115
      _rx_buffer_head = i;
     d6e:	81 8f       	std	Z+25, r24	; 0x19
     d70:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial_private.h:119
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
     d72:	8c 91       	ld	r24, X
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial_private.h:121
  };
}
     d74:	08 95       	ret

00000d76 <HardwareSerial::availableForWrite()>:
availableForWrite():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:198
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     d76:	fc 01       	movw	r30, r24
     d78:	53 8d       	ldd	r21, Z+27	; 0x1b
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:199
    tail = _tx_buffer_tail;
     d7a:	44 8d       	ldd	r20, Z+28	; 0x1c
     d7c:	25 2f       	mov	r18, r21
     d7e:	30 e0       	ldi	r19, 0x00	; 0
     d80:	84 2f       	mov	r24, r20
     d82:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:201
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     d84:	82 1b       	sub	r24, r18
     d86:	93 0b       	sbc	r25, r19
     d88:	54 17       	cp	r21, r20
     d8a:	10 f0       	brcs	.+4      	; 0xd90 <HardwareSerial::availableForWrite()+0x1a>
     d8c:	cf 96       	adiw	r24, 0x3f	; 63
     d8e:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:202
  return tail - head - 1;
     d90:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:203
}
     d92:	08 95       	ret

00000d94 <HardwareSerial::read()>:
read():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:181
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
     d94:	fc 01       	movw	r30, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:183
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     d96:	91 8d       	ldd	r25, Z+25	; 0x19
     d98:	82 8d       	ldd	r24, Z+26	; 0x1a
     d9a:	98 17       	cp	r25, r24
     d9c:	61 f0       	breq	.+24     	; 0xdb6 <HardwareSerial::read()+0x22>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:186
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     d9e:	a2 8d       	ldd	r26, Z+26	; 0x1a
     da0:	ae 0f       	add	r26, r30
     da2:	bf 2f       	mov	r27, r31
     da4:	b1 1d       	adc	r27, r1
     da6:	5d 96       	adiw	r26, 0x1d	; 29
     da8:	8c 91       	ld	r24, X
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:187
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     daa:	92 8d       	ldd	r25, Z+26	; 0x1a
     dac:	9f 5f       	subi	r25, 0xFF	; 255
     dae:	9f 73       	andi	r25, 0x3F	; 63
     db0:	92 8f       	std	Z+26, r25	; 0x1a
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:188
    return c;
     db2:	90 e0       	ldi	r25, 0x00	; 0
     db4:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:184

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     db6:	8f ef       	ldi	r24, 0xFF	; 255
     db8:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:190
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     dba:	08 95       	ret

00000dbc <HardwareSerial::peek()>:
peek():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:172
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
     dbc:	fc 01       	movw	r30, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:173
  if (_rx_buffer_head == _rx_buffer_tail) {
     dbe:	91 8d       	ldd	r25, Z+25	; 0x19
     dc0:	82 8d       	ldd	r24, Z+26	; 0x1a
     dc2:	98 17       	cp	r25, r24
     dc4:	31 f0       	breq	.+12     	; 0xdd2 <HardwareSerial::peek()+0x16>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:176
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     dc6:	82 8d       	ldd	r24, Z+26	; 0x1a
     dc8:	e8 0f       	add	r30, r24
     dca:	f1 1d       	adc	r31, r1
     dcc:	85 8d       	ldd	r24, Z+29	; 0x1d
     dce:	90 e0       	ldi	r25, 0x00	; 0
     dd0:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:174
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     dd2:	8f ef       	ldi	r24, 0xFF	; 255
     dd4:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:178
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     dd6:	08 95       	ret

00000dd8 <HardwareSerial::available()>:
available():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:167
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     dd8:	fc 01       	movw	r30, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:168
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     dda:	91 8d       	ldd	r25, Z+25	; 0x19
     ddc:	22 8d       	ldd	r18, Z+26	; 0x1a
     dde:	89 2f       	mov	r24, r25
     de0:	90 e0       	ldi	r25, 0x00	; 0
     de2:	80 5c       	subi	r24, 0xC0	; 192
     de4:	9f 4f       	sbci	r25, 0xFF	; 255
     de6:	82 1b       	sub	r24, r18
     de8:	91 09       	sbc	r25, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:169
}
     dea:	8f 73       	andi	r24, 0x3F	; 63
     dec:	99 27       	eor	r25, r25
     dee:	08 95       	ret

00000df0 <Serial3_available()>:
Serial3_available():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial3.cpp:54
HardwareSerial Serial3(&UBRR3H, &UBRR3L, &UCSR3A, &UCSR3B, &UCSR3C, &UDR3);

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial3_available() {
  return Serial3.available();
     df0:	8b e7       	ldi	r24, 0x7B	; 123
     df2:	9c e0       	ldi	r25, 0x0C	; 12
     df4:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <HardwareSerial::available()>
     df8:	21 e0       	ldi	r18, 0x01	; 1
     dfa:	89 2b       	or	r24, r25
     dfc:	09 f4       	brne	.+2      	; 0xe00 <Serial3_available()+0x10>
     dfe:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial3.cpp:55
}
     e00:	82 2f       	mov	r24, r18
     e02:	08 95       	ret

00000e04 <Serial2_available()>:
Serial2_available():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial2.cpp:54
HardwareSerial Serial2(&UBRR2H, &UBRR2L, &UCSR2A, &UCSR2B, &UCSR2C, &UDR2);

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial2_available() {
  return Serial2.available();
     e04:	88 e1       	ldi	r24, 0x18	; 24
     e06:	9d e0       	ldi	r25, 0x0D	; 13
     e08:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <HardwareSerial::available()>
     e0c:	21 e0       	ldi	r18, 0x01	; 1
     e0e:	89 2b       	or	r24, r25
     e10:	09 f4       	brne	.+2      	; 0xe14 <Serial2_available()+0x10>
     e12:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial2.cpp:55
}
     e14:	82 2f       	mov	r24, r18
     e16:	08 95       	ret

00000e18 <Serial1_available()>:
Serial1_available():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial1.cpp:66
HardwareSerial Serial1(&UBRR1H, &UBRR1L, &UCSR1A, &UCSR1B, &UCSR1C, &UDR1);

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial1_available() {
  return Serial1.available();
     e18:	85 eb       	ldi	r24, 0xB5	; 181
     e1a:	9d e0       	ldi	r25, 0x0D	; 13
     e1c:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <HardwareSerial::available()>
     e20:	21 e0       	ldi	r18, 0x01	; 1
     e22:	89 2b       	or	r24, r25
     e24:	09 f4       	brne	.+2      	; 0xe28 <Serial1_available()+0x10>
     e26:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial1.cpp:67
}
     e28:	82 2f       	mov	r24, r18
     e2a:	08 95       	ret

00000e2c <Serial0_available()>:
Serial0_available():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial0.cpp:76
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     e2c:	82 e5       	ldi	r24, 0x52	; 82
     e2e:	9e e0       	ldi	r25, 0x0E	; 14
     e30:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <HardwareSerial::available()>
     e34:	21 e0       	ldi	r18, 0x01	; 1
     e36:	89 2b       	or	r24, r25
     e38:	09 f4       	brne	.+2      	; 0xe3c <Serial0_available()+0x10>
     e3a:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial0.cpp:77
}
     e3c:	82 2f       	mov	r24, r18
     e3e:	08 95       	ret

00000e40 <HardwareSerial::_tx_udr_empty_irq()>:
_tx_udr_empty_irq():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:90
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     e40:	fc 01       	movw	r30, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:93
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     e42:	a4 8d       	ldd	r26, Z+28	; 0x1c
     e44:	a8 0f       	add	r26, r24
     e46:	b9 2f       	mov	r27, r25
     e48:	b1 1d       	adc	r27, r1
     e4a:	a3 5a       	subi	r26, 0xA3	; 163
     e4c:	bf 4f       	sbci	r27, 0xFF	; 255
     e4e:	2c 91       	ld	r18, X
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:94
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     e50:	84 8d       	ldd	r24, Z+28	; 0x1c
     e52:	90 e0       	ldi	r25, 0x00	; 0
     e54:	01 96       	adiw	r24, 0x01	; 1
     e56:	8f 73       	andi	r24, 0x3F	; 63
     e58:	99 27       	eor	r25, r25
     e5a:	84 8f       	std	Z+28, r24	; 0x1c
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:96

  *_udr = c;
     e5c:	a6 89       	ldd	r26, Z+22	; 0x16
     e5e:	b7 89       	ldd	r27, Z+23	; 0x17
     e60:	2c 93       	st	X, r18
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:104
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     e62:	a0 89       	ldd	r26, Z+16	; 0x10
     e64:	b1 89       	ldd	r27, Z+17	; 0x11
     e66:	8c 91       	ld	r24, X
     e68:	83 70       	andi	r24, 0x03	; 3
     e6a:	80 64       	ori	r24, 0x40	; 64
     e6c:	8c 93       	st	X, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:109
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
     e6e:	93 8d       	ldd	r25, Z+27	; 0x1b
     e70:	84 8d       	ldd	r24, Z+28	; 0x1c
     e72:	98 13       	cpse	r25, r24
     e74:	06 c0       	rjmp	.+12     	; 0xe82 <HardwareSerial::_tx_udr_empty_irq()+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:111
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
     e76:	02 88       	ldd	r0, Z+18	; 0x12
     e78:	f3 89       	ldd	r31, Z+19	; 0x13
     e7a:	e0 2d       	mov	r30, r0
     e7c:	80 81       	ld	r24, Z
     e7e:	8f 7d       	andi	r24, 0xDF	; 223
     e80:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:113
  }
}
     e82:	08 95       	ret

00000e84 <HardwareSerial::write(unsigned char)>:
write():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:226
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     e84:	ef 92       	push	r14
     e86:	ff 92       	push	r15
     e88:	0f 93       	push	r16
     e8a:	1f 93       	push	r17
     e8c:	cf 93       	push	r28
     e8e:	df 93       	push	r29
     e90:	ec 01       	movw	r28, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:227
  _written = true;
     e92:	81 e0       	ldi	r24, 0x01	; 1
     e94:	88 8f       	std	Y+24, r24	; 0x18
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:232
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     e96:	9b 8d       	ldd	r25, Y+27	; 0x1b
     e98:	8c 8d       	ldd	r24, Y+28	; 0x1c
     e9a:	98 13       	cpse	r25, r24
     e9c:	1a c0       	rjmp	.+52     	; 0xed2 <HardwareSerial::write(unsigned char)+0x4e>
     e9e:	e8 89       	ldd	r30, Y+16	; 0x10
     ea0:	f9 89       	ldd	r31, Y+17	; 0x11
     ea2:	80 81       	ld	r24, Z
     ea4:	85 ff       	sbrs	r24, 5
     ea6:	15 c0       	rjmp	.+42     	; 0xed2 <HardwareSerial::write(unsigned char)+0x4e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:241
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     ea8:	9f b7       	in	r25, 0x3f	; 63
__iCliRetVal():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:50
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     eaa:	f8 94       	cli
write():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:242
      *_udr = c;
     eac:	ee 89       	ldd	r30, Y+22	; 0x16
     eae:	ff 89       	ldd	r31, Y+23	; 0x17
     eb0:	60 83       	st	Z, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:244
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     eb2:	e8 89       	ldd	r30, Y+16	; 0x10
     eb4:	f9 89       	ldd	r31, Y+17	; 0x11
     eb6:	80 81       	ld	r24, Z
     eb8:	83 70       	andi	r24, 0x03	; 3
     eba:	80 64       	ori	r24, 0x40	; 64
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:275
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
     ebc:	80 83       	st	Z, r24
__iRestore():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:70
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     ebe:	9f bf       	out	0x3f, r25	; 63
write():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:279
  }
  
  return 1;
}
     ec0:	81 e0       	ldi	r24, 0x01	; 1
     ec2:	90 e0       	ldi	r25, 0x00	; 0
     ec4:	df 91       	pop	r29
     ec6:	cf 91       	pop	r28
     ec8:	1f 91       	pop	r17
     eca:	0f 91       	pop	r16
     ecc:	ff 90       	pop	r15
     ece:	ef 90       	pop	r14
     ed0:	08 95       	ret
     ed2:	f6 2e       	mov	r15, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:251
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     ed4:	0b 8d       	ldd	r16, Y+27	; 0x1b
     ed6:	10 e0       	ldi	r17, 0x00	; 0
     ed8:	0f 5f       	subi	r16, 0xFF	; 255
     eda:	1f 4f       	sbci	r17, 0xFF	; 255
     edc:	0f 73       	andi	r16, 0x3F	; 63
     ede:	11 27       	eor	r17, r17
     ee0:	e0 2e       	mov	r14, r16
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:255
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     ee2:	8c 8d       	ldd	r24, Y+28	; 0x1c
     ee4:	8e 11       	cpse	r24, r14
     ee6:	0c c0       	rjmp	.+24     	; 0xf00 <HardwareSerial::write(unsigned char)+0x7c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:256
    if (bit_is_clear(SREG, SREG_I)) {
     ee8:	0f b6       	in	r0, 0x3f	; 63
     eea:	07 fc       	sbrc	r0, 7
     eec:	fa cf       	rjmp	.-12     	; 0xee2 <HardwareSerial::write(unsigned char)+0x5e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:261
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     eee:	e8 89       	ldd	r30, Y+16	; 0x10
     ef0:	f9 89       	ldd	r31, Y+17	; 0x11
     ef2:	80 81       	ld	r24, Z
     ef4:	85 ff       	sbrs	r24, 5
     ef6:	f5 cf       	rjmp	.-22     	; 0xee2 <HardwareSerial::write(unsigned char)+0x5e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:262
	_tx_udr_empty_irq();
     ef8:	ce 01       	movw	r24, r28
     efa:	0e 94 20 07 	call	0xe40	; 0xe40 <HardwareSerial::_tx_udr_empty_irq()>
     efe:	f1 cf       	rjmp	.-30     	; 0xee2 <HardwareSerial::write(unsigned char)+0x5e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:268
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     f00:	eb 8d       	ldd	r30, Y+27	; 0x1b
     f02:	ec 0f       	add	r30, r28
     f04:	fd 2f       	mov	r31, r29
     f06:	f1 1d       	adc	r31, r1
     f08:	e3 5a       	subi	r30, 0xA3	; 163
     f0a:	ff 4f       	sbci	r31, 0xFF	; 255
     f0c:	f0 82       	st	Z, r15
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:273

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     f0e:	9f b7       	in	r25, 0x3f	; 63
__iCliRetVal():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:50
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     f10:	f8 94       	cli
write():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:274
    _tx_buffer_head = i;
     f12:	0b 8f       	std	Y+27, r16	; 0x1b
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:275
    sbi(*_ucsrb, UDRIE0);
     f14:	ea 89       	ldd	r30, Y+18	; 0x12
     f16:	fb 89       	ldd	r31, Y+19	; 0x13
     f18:	80 81       	ld	r24, Z
     f1a:	80 62       	ori	r24, 0x20	; 32
     f1c:	cf cf       	rjmp	.-98     	; 0xebc <HardwareSerial::write(unsigned char)+0x38>

00000f1e <HardwareSerial::flush()>:
flush():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:206
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	ec 01       	movw	r28, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:210
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     f24:	88 8d       	ldd	r24, Y+24	; 0x18
     f26:	88 23       	and	r24, r24
     f28:	b9 f0       	breq	.+46     	; 0xf58 <HardwareSerial::flush()+0x3a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:213
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     f2a:	aa 89       	ldd	r26, Y+18	; 0x12
     f2c:	bb 89       	ldd	r27, Y+19	; 0x13
     f2e:	e8 89       	ldd	r30, Y+16	; 0x10
     f30:	f9 89       	ldd	r31, Y+17	; 0x11
     f32:	8c 91       	ld	r24, X
     f34:	85 fd       	sbrc	r24, 5
     f36:	03 c0       	rjmp	.+6      	; 0xf3e <HardwareSerial::flush()+0x20>
     f38:	80 81       	ld	r24, Z
     f3a:	86 fd       	sbrc	r24, 6
     f3c:	0d c0       	rjmp	.+26     	; 0xf58 <HardwareSerial::flush()+0x3a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:214
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     f3e:	0f b6       	in	r0, 0x3f	; 63
     f40:	07 fc       	sbrc	r0, 7
     f42:	f7 cf       	rjmp	.-18     	; 0xf32 <HardwareSerial::flush()+0x14>
     f44:	8c 91       	ld	r24, X
     f46:	85 ff       	sbrs	r24, 5
     f48:	f2 cf       	rjmp	.-28     	; 0xf2e <HardwareSerial::flush()+0x10>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:218
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
     f4a:	80 81       	ld	r24, Z
     f4c:	85 ff       	sbrs	r24, 5
     f4e:	ed cf       	rjmp	.-38     	; 0xf2a <HardwareSerial::flush()+0xc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:219
	  _tx_udr_empty_irq();
     f50:	ce 01       	movw	r24, r28
     f52:	0e 94 20 07 	call	0xe40	; 0xe40 <HardwareSerial::_tx_udr_empty_irq()>
     f56:	e9 cf       	rjmp	.-46     	; 0xf2a <HardwareSerial::flush()+0xc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:223
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     f58:	df 91       	pop	r29
     f5a:	cf 91       	pop	r28
     f5c:	08 95       	ret

00000f5e <turnOffPWM>:
turnOffPWM():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:77
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     f5e:	81 50       	subi	r24, 0x01	; 1
     f60:	82 31       	cpi	r24, 0x12	; 18
     f62:	08 f0       	brcs	.+2      	; 0xf66 <turnOffPWM+0x8>
     f64:	5a c0       	rjmp	.+180    	; 0x101a <turnOffPWM+0xbc>
     f66:	e8 2f       	mov	r30, r24
     f68:	f0 e0       	ldi	r31, 0x00	; 0
     f6a:	88 27       	eor	r24, r24
     f6c:	e5 54       	subi	r30, 0x45	; 69
     f6e:	f8 4f       	sbci	r31, 0xF8	; 248
     f70:	8f 4f       	sbci	r24, 0xFF	; 255
     f72:	0c 94 2b 6c 	jmp	0xd856	; 0xd856 <__tablejump2__>
     f76:	db 07       	cpc	r29, r27
     f78:	df 07       	cpc	r29, r31
     f7a:	cd 07       	cpc	r28, r29
     f7c:	d3 07       	cpc	r29, r19
     f7e:	d7 07       	cpc	r29, r23
     f80:	0d 08       	sbc	r0, r13
     f82:	e2 07       	cpc	r30, r18
     f84:	e8 07       	cpc	r30, r24
     f86:	ec 07       	cpc	r30, r28
     f88:	f2 07       	cpc	r31, r18
     f8a:	f6 07       	cpc	r31, r22
     f8c:	fa 07       	cpc	r31, r26
     f8e:	00 08       	sbc	r0, r0
     f90:	04 08       	sbc	r0, r4
     f92:	0d 08       	sbc	r0, r13
     f94:	08 08       	sbc	r0, r8
     f96:	0e 08       	sbc	r0, r14
     f98:	12 08       	sbc	r1, r2
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:80
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     f9a:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     f9e:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:83
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     fa0:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     fa4:	08 95       	ret
     fa6:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     faa:	8f 7d       	andi	r24, 0xDF	; 223
     fac:	f9 cf       	rjmp	.-14     	; 0xfa0 <turnOffPWM+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:86
		#endif
		#if defined(TCCR1A) && defined(COM1C1)
		case TIMER1C:   cbi(TCCR1A, COM1C1);    break;
     fae:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     fb2:	87 7f       	andi	r24, 0xF7	; 247
     fb4:	f5 cf       	rjmp	.-22     	; 0xfa0 <turnOffPWM+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:94
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     fb6:	84 b5       	in	r24, 0x24	; 36
     fb8:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:98
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     fba:	84 bd       	out	0x24, r24	; 36
     fbc:	08 95       	ret
     fbe:	84 b5       	in	r24, 0x24	; 36
     fc0:	8f 7d       	andi	r24, 0xDF	; 223
     fc2:	fb cf       	rjmp	.-10     	; 0xfba <turnOffPWM+0x5c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:101
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     fc4:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
     fc8:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:104
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     fca:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
     fce:	08 95       	ret
     fd0:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
     fd4:	8f 7d       	andi	r24, 0xDF	; 223
     fd6:	f9 cf       	rjmp	.-14     	; 0xfca <turnOffPWM+0x6c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:108
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
     fd8:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
     fdc:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:114
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
     fde:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
     fe2:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:111
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
     fe4:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
     fe8:	8f 7d       	andi	r24, 0xDF	; 223
     fea:	f9 cf       	rjmp	.-14     	; 0xfde <turnOffPWM+0x80>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:114
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
     fec:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
     ff0:	87 7f       	andi	r24, 0xF7	; 247
     ff2:	f5 cf       	rjmp	.-22     	; 0xfde <turnOffPWM+0x80>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:118
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
     ff4:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     ff8:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:124
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
     ffa:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     ffe:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:121

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
    1000:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    1004:	8f 7d       	andi	r24, 0xDF	; 223
    1006:	f9 cf       	rjmp	.-14     	; 0xffa <turnOffPWM+0x9c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:124
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
    1008:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    100c:	87 7f       	andi	r24, 0xF7	; 247
    100e:	f5 cf       	rjmp	.-22     	; 0xffa <turnOffPWM+0x9c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:131
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
    1010:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
    1014:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:133
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    1016:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:136
		#endif
	}
}
    101a:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:132
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
		#endif			
			
		#if defined(TCCR5A)
		case  TIMER5A:  cbi(TCCR5A, COM5A1);    break;
		case  TIMER5B:  cbi(TCCR5A, COM5B1);    break;
    101c:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
    1020:	8f 7d       	andi	r24, 0xDF	; 223
    1022:	f9 cf       	rjmp	.-14     	; 0x1016 <turnOffPWM+0xb8>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:133
		case  TIMER5C:  cbi(TCCR5A, COM5C1);    break;
    1024:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
    1028:	87 7f       	andi	r24, 0xF7	; 247
    102a:	f5 cf       	rjmp	.-22     	; 0x1016 <turnOffPWM+0xb8>

0000102c <digitalRead>:
digitalRead():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:166

	SREG = oldSREG;
}

int digitalRead(uint8_t pin)
{
    102c:	cf 93       	push	r28
    102e:	df 93       	push	r29
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:167
	uint8_t timer = digitalPinToTimer(pin);
    1030:	28 2f       	mov	r18, r24
    1032:	30 e0       	ldi	r19, 0x00	; 0
    1034:	f9 01       	movw	r30, r18
    1036:	ef 5e       	subi	r30, 0xEF	; 239
    1038:	fb 4f       	sbci	r31, 0xFB	; 251
    103a:	84 91       	lpm	r24, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:168
	uint8_t bit = digitalPinToBitMask(pin);
    103c:	f9 01       	movw	r30, r18
    103e:	e7 52       	subi	r30, 0x27	; 39
    1040:	fa 4f       	sbci	r31, 0xFA	; 250
    1042:	d4 91       	lpm	r29, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:169
	uint8_t port = digitalPinToPort(pin);
    1044:	f9 01       	movw	r30, r18
    1046:	e7 5c       	subi	r30, 0xC7	; 199
    1048:	f9 4f       	sbci	r31, 0xF9	; 249
    104a:	c4 91       	lpm	r28, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:171

	if (port == NOT_A_PIN) return LOW;
    104c:	cc 23       	and	r28, r28
    104e:	a1 f0       	breq	.+40     	; 0x1078 <digitalRead+0x4c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:175

	// If the pin that support PWM output, we need to turn it off
	// before getting a digital reading.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    1050:	81 11       	cpse	r24, r1
    1052:	0e 94 af 07 	call	0xf5e	; 0xf5e <turnOffPWM>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:177

	if (*portInputRegister(port) & bit) return HIGH;
    1056:	ec 2f       	mov	r30, r28
    1058:	f0 e0       	ldi	r31, 0x00	; 0
    105a:	ee 0f       	add	r30, r30
    105c:	ff 1f       	adc	r31, r31
    105e:	e9 50       	subi	r30, 0x09	; 9
    1060:	fc 4f       	sbci	r31, 0xFC	; 252
    1062:	a5 91       	lpm	r26, Z+
    1064:	b4 91       	lpm	r27, Z
    1066:	ec 91       	ld	r30, X
    1068:	ed 23       	and	r30, r29
    106a:	81 e0       	ldi	r24, 0x01	; 1
    106c:	90 e0       	ldi	r25, 0x00	; 0
    106e:	09 f4       	brne	.+2      	; 0x1072 <digitalRead+0x46>
    1070:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:179
	return LOW;
}
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:171
{
	uint8_t timer = digitalPinToTimer(pin);
	uint8_t bit = digitalPinToBitMask(pin);
	uint8_t port = digitalPinToPort(pin);

	if (port == NOT_A_PIN) return LOW;
    1078:	80 e0       	ldi	r24, 0x00	; 0
    107a:	90 e0       	ldi	r25, 0x00	; 0
    107c:	fa cf       	rjmp	.-12     	; 0x1072 <digitalRead+0x46>

0000107e <digitalWrite>:
digitalWrite():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:139
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    107e:	1f 93       	push	r17
    1080:	cf 93       	push	r28
    1082:	df 93       	push	r29
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:140
	uint8_t timer = digitalPinToTimer(pin);
    1084:	28 2f       	mov	r18, r24
    1086:	30 e0       	ldi	r19, 0x00	; 0
    1088:	f9 01       	movw	r30, r18
    108a:	ef 5e       	subi	r30, 0xEF	; 239
    108c:	fb 4f       	sbci	r31, 0xFB	; 251
    108e:	84 91       	lpm	r24, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:141
	uint8_t bit = digitalPinToBitMask(pin);
    1090:	f9 01       	movw	r30, r18
    1092:	e7 52       	subi	r30, 0x27	; 39
    1094:	fa 4f       	sbci	r31, 0xFA	; 250
    1096:	d4 91       	lpm	r29, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:142
	uint8_t port = digitalPinToPort(pin);
    1098:	f9 01       	movw	r30, r18
    109a:	e7 5c       	subi	r30, 0xC7	; 199
    109c:	f9 4f       	sbci	r31, 0xF9	; 249
    109e:	c4 91       	lpm	r28, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:145
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    10a0:	cc 23       	and	r28, r28
    10a2:	a9 f0       	breq	.+42     	; 0x10ce <digitalWrite+0x50>
    10a4:	16 2f       	mov	r17, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:149

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    10a6:	81 11       	cpse	r24, r1
    10a8:	0e 94 af 07 	call	0xf5e	; 0xf5e <turnOffPWM>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:151

	out = portOutputRegister(port);
    10ac:	ec 2f       	mov	r30, r28
    10ae:	f0 e0       	ldi	r31, 0x00	; 0
    10b0:	ee 0f       	add	r30, r30
    10b2:	ff 1f       	adc	r31, r31
    10b4:	e1 5e       	subi	r30, 0xE1	; 225
    10b6:	f9 4f       	sbci	r31, 0xF9	; 249
    10b8:	a5 91       	lpm	r26, Z+
    10ba:	b4 91       	lpm	r27, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:153

	uint8_t oldSREG = SREG;
    10bc:	8f b7       	in	r24, 0x3f	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:154
	cli();
    10be:	f8 94       	cli
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:157

	if (val == LOW) {
		*out &= ~bit;
    10c0:	ec 91       	ld	r30, X
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:156
	out = portOutputRegister(port);

	uint8_t oldSREG = SREG;
	cli();

	if (val == LOW) {
    10c2:	11 11       	cpse	r17, r1
    10c4:	08 c0       	rjmp	.+16     	; 0x10d6 <digitalWrite+0x58>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:157
		*out &= ~bit;
    10c6:	d0 95       	com	r29
    10c8:	de 23       	and	r29, r30
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:159
	} else {
		*out |= bit;
    10ca:	dc 93       	st	X, r29
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:162
	}

	SREG = oldSREG;
    10cc:	8f bf       	out	0x3f, r24	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:163
}
    10ce:	df 91       	pop	r29
    10d0:	cf 91       	pop	r28
    10d2:	1f 91       	pop	r17
    10d4:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:159
	cli();

	if (val == LOW) {
		*out &= ~bit;
	} else {
		*out |= bit;
    10d6:	de 2b       	or	r29, r30
    10d8:	f8 cf       	rjmp	.-16     	; 0x10ca <digitalWrite+0x4c>

000010da <Adafruit_Keypad::tick() [clone .constprop.54]>:
tick():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:68
/**************************************************************************/
/*!
    @brief  read the array of switches and place any events in the buffer.
*/
/**************************************************************************/
void Adafruit_Keypad::tick() {
    10da:	8f 92       	push	r8
    10dc:	9f 92       	push	r9
    10de:	af 92       	push	r10
    10e0:	bf 92       	push	r11
    10e2:	cf 92       	push	r12
    10e4:	df 92       	push	r13
    10e6:	ef 92       	push	r14
    10e8:	ff 92       	push	r15
    10ea:	0f 93       	push	r16
    10ec:	1f 93       	push	r17
    10ee:	cf 93       	push	r28
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:70
  uint8_t evt;
  for (int i = 0; i < _numCols; i++) {
    10f0:	10 e0       	ldi	r17, 0x00	; 0
    10f2:	00 e0       	ldi	r16, 0x00	; 0
    10f4:	80 91 66 13 	lds	r24, 0x1366	; 0x801366 <customKeypad+0x10e>
    10f8:	90 91 67 13 	lds	r25, 0x1367	; 0x801367 <customKeypad+0x10f>
    10fc:	08 17       	cp	r16, r24
    10fe:	19 07       	cpc	r17, r25
    1100:	6c f4       	brge	.+26     	; 0x111c <Adafruit_Keypad::tick() [clone .constprop.54]+0x42>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:71
    digitalWrite(_col[i], HIGH);
    1102:	e0 91 5c 12 	lds	r30, 0x125C	; 0x80125c <customKeypad+0x4>
    1106:	f0 91 5d 12 	lds	r31, 0x125D	; 0x80125d <customKeypad+0x5>
    110a:	e0 0f       	add	r30, r16
    110c:	f1 1f       	adc	r31, r17
    110e:	61 e0       	ldi	r22, 0x01	; 1
    1110:	80 81       	ld	r24, Z
    1112:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:70
    @brief  read the array of switches and place any events in the buffer.
*/
/**************************************************************************/
void Adafruit_Keypad::tick() {
  uint8_t evt;
  for (int i = 0; i < _numCols; i++) {
    1116:	0f 5f       	subi	r16, 0xFF	; 255
    1118:	1f 4f       	sbci	r17, 0xFF	; 255
    111a:	ec cf       	rjmp	.-40     	; 0x10f4 <Adafruit_Keypad::tick() [clone .constprop.54]+0x1a>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:75
    digitalWrite(_col[i], HIGH);
  }

  int i = 0;
  for (int c = 0; c < _numCols; c++) {
    111c:	10 e0       	ldi	r17, 0x00	; 0
    111e:	00 e0       	ldi	r16, 0x00	; 0
delayMicroseconds():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:234
	

#endif

	// busy wait
	__asm__ __volatile__ (
    1120:	8b e4       	ldi	r24, 0x4B	; 75
    1122:	88 2e       	mov	r8, r24
    1124:	91 2c       	mov	r9, r1
tick():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:75
    1126:	80 91 66 13 	lds	r24, 0x1366	; 0x801366 <customKeypad+0x10e>
    112a:	90 91 67 13 	lds	r25, 0x1367	; 0x801367 <customKeypad+0x10f>
    112e:	08 17       	cp	r16, r24
    1130:	19 07       	cpc	r17, r25
    1132:	0c f0       	brlt	.+2      	; 0x1136 <Adafruit_Keypad::tick() [clone .constprop.54]+0x5c>
    1134:	61 c0       	rjmp	.+194    	; 0x11f8 <Adafruit_Keypad::tick() [clone .constprop.54]+0x11e>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:76
    digitalWrite(_col[c], LOW);
    1136:	e0 91 5c 12 	lds	r30, 0x125C	; 0x80125c <customKeypad+0x4>
    113a:	f0 91 5d 12 	lds	r31, 0x125D	; 0x80125d <customKeypad+0x5>
    113e:	e0 0f       	add	r30, r16
    1140:	f1 1f       	adc	r31, r17
    1142:	60 e0       	ldi	r22, 0x00	; 0
    1144:	80 81       	ld	r24, Z
    1146:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
delayMicroseconds():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:234
    114a:	c4 01       	movw	r24, r8
    114c:	01 97       	sbiw	r24, 0x01	; 1
    114e:	f1 f7       	brne	.-4      	; 0x114c <Adafruit_Keypad::tick() [clone .constprop.54]+0x72>
tick():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:78
    delayMicroseconds(_KEYPAD_SETTLING_DELAY);
    for (int r = 0; r < _numRows; r++) {
    1150:	f1 2c       	mov	r15, r1
    1152:	e1 2c       	mov	r14, r1
    1154:	80 91 64 13 	lds	r24, 0x1364	; 0x801364 <customKeypad+0x10c>
    1158:	90 91 65 13 	lds	r25, 0x1365	; 0x801365 <customKeypad+0x10d>
    115c:	e8 16       	cp	r14, r24
    115e:	f9 06       	cpc	r15, r25
    1160:	f4 f5       	brge	.+124    	; 0x11de <Adafruit_Keypad::tick() [clone .constprop.54]+0x104>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:79
      i = r * _numCols + c;
    1162:	80 91 66 13 	lds	r24, 0x1366	; 0x801366 <customKeypad+0x10e>
    1166:	90 91 67 13 	lds	r25, 0x1367	; 0x801367 <customKeypad+0x10f>
    116a:	e8 9e       	mul	r14, r24
    116c:	60 01       	movw	r12, r0
    116e:	e9 9e       	mul	r14, r25
    1170:	d0 0c       	add	r13, r0
    1172:	f8 9e       	mul	r15, r24
    1174:	d0 0c       	add	r13, r0
    1176:	11 24       	eor	r1, r1
    1178:	c0 0e       	add	r12, r16
    117a:	d1 1e       	adc	r13, r17
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:80
      bool pressed = !digitalRead(_row[r]);
    117c:	e0 91 5a 12 	lds	r30, 0x125A	; 0x80125a <customKeypad+0x2>
    1180:	f0 91 5b 12 	lds	r31, 0x125B	; 0x80125b <customKeypad+0x3>
    1184:	ee 0d       	add	r30, r14
    1186:	ff 1d       	adc	r31, r15
    1188:	80 81       	ld	r24, Z
    118a:	0e 94 16 08 	call	0x102c	; 0x102c <digitalRead>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:82
      // Serial.print((int)pressed);
      volatile byte *state = _keystates + i;
    118e:	a0 90 5e 12 	lds	r10, 0x125E	; 0x80125e <customKeypad+0x6>
    1192:	b0 90 5f 12 	lds	r11, 0x125F	; 0x80125f <customKeypad+0x7>
    1196:	ac 0c       	add	r10, r12
    1198:	bd 1c       	adc	r11, r13
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:83
      byte currentState = *state;
    119a:	f5 01       	movw	r30, r10
    119c:	c0 81       	ld	r28, Z
    119e:	2c 2f       	mov	r18, r28
    11a0:	22 70       	andi	r18, 0x02	; 2
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:84
      if (pressed && !(currentState & _KEY_PRESSED)) {
    11a2:	89 2b       	or	r24, r25
    11a4:	b1 f4       	brne	.+44     	; 0x11d2 <Adafruit_Keypad::tick() [clone .constprop.54]+0xf8>
    11a6:	21 11       	cpse	r18, r1
    11a8:	0e c0       	rjmp	.+28     	; 0x11c6 <Adafruit_Keypad::tick() [clone .constprop.54]+0xec>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:85
        currentState |= (_JUST_PRESSED | _KEY_PRESSED);
    11aa:	c6 60       	ori	r28, 0x06	; 6
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:87
        evt = KEY_JUST_PRESSED;
        _eventbuf.store_char(evt);
    11ac:	81 e0       	ldi	r24, 0x01	; 1
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:93
        _eventbuf.store_char(*(_userKeymap + i));
      } else if (!pressed && (currentState & _KEY_PRESSED)) {
        currentState |= _JUST_RELEASED;
        currentState &= ~(_KEY_PRESSED);
        evt = KEY_JUST_RELEASED;
        _eventbuf.store_char(evt);
    11ae:	0e 94 71 05 	call	0xae2	; 0xae2 <Adafruit_Keypad_RingbufferN<256>::store_char(unsigned char) [clone .constprop.55]>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:94
        _eventbuf.store_char(*(_userKeymap + i));
    11b2:	80 91 58 12 	lds	r24, 0x1258	; 0x801258 <customKeypad>
    11b6:	90 91 59 12 	lds	r25, 0x1259	; 0x801259 <customKeypad+0x1>
    11ba:	c8 0e       	add	r12, r24
    11bc:	d9 1e       	adc	r13, r25
    11be:	f6 01       	movw	r30, r12
    11c0:	80 81       	ld	r24, Z
    11c2:	0e 94 71 05 	call	0xae2	; 0xae2 <Adafruit_Keypad_RingbufferN<256>::store_char(unsigned char) [clone .constprop.55]>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:96
      }
      *state = currentState;
    11c6:	f5 01       	movw	r30, r10
    11c8:	c0 83       	st	Z, r28
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:78

  int i = 0;
  for (int c = 0; c < _numCols; c++) {
    digitalWrite(_col[c], LOW);
    delayMicroseconds(_KEYPAD_SETTLING_DELAY);
    for (int r = 0; r < _numRows; r++) {
    11ca:	ff ef       	ldi	r31, 0xFF	; 255
    11cc:	ef 1a       	sub	r14, r31
    11ce:	ff 0a       	sbc	r15, r31
    11d0:	c1 cf       	rjmp	.-126    	; 0x1154 <Adafruit_Keypad::tick() [clone .constprop.54]+0x7a>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:89
      if (pressed && !(currentState & _KEY_PRESSED)) {
        currentState |= (_JUST_PRESSED | _KEY_PRESSED);
        evt = KEY_JUST_PRESSED;
        _eventbuf.store_char(evt);
        _eventbuf.store_char(*(_userKeymap + i));
      } else if (!pressed && (currentState & _KEY_PRESSED)) {
    11d2:	22 23       	and	r18, r18
    11d4:	c1 f3       	breq	.-16     	; 0x11c6 <Adafruit_Keypad::tick() [clone .constprop.54]+0xec>
    11d6:	cd 7f       	andi	r28, 0xFD	; 253
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:91
        currentState |= _JUST_RELEASED;
        currentState &= ~(_KEY_PRESSED);
    11d8:	c8 60       	ori	r28, 0x08	; 8
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:93
        evt = KEY_JUST_RELEASED;
        _eventbuf.store_char(evt);
    11da:	80 e0       	ldi	r24, 0x00	; 0
    11dc:	e8 cf       	rjmp	.-48     	; 0x11ae <Adafruit_Keypad::tick() [clone .constprop.54]+0xd4>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:99
        _eventbuf.store_char(*(_userKeymap + i));
      }
      *state = currentState;
    }
    // Serial.println("");
    digitalWrite(_col[c], HIGH);
    11de:	e0 91 5c 12 	lds	r30, 0x125C	; 0x80125c <customKeypad+0x4>
    11e2:	f0 91 5d 12 	lds	r31, 0x125D	; 0x80125d <customKeypad+0x5>
    11e6:	e0 0f       	add	r30, r16
    11e8:	f1 1f       	adc	r31, r17
    11ea:	61 e0       	ldi	r22, 0x01	; 1
    11ec:	80 81       	ld	r24, Z
    11ee:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:75
  for (int i = 0; i < _numCols; i++) {
    digitalWrite(_col[i], HIGH);
  }

  int i = 0;
  for (int c = 0; c < _numCols; c++) {
    11f2:	0f 5f       	subi	r16, 0xFF	; 255
    11f4:	1f 4f       	sbci	r17, 0xFF	; 255
    11f6:	97 cf       	rjmp	.-210    	; 0x1126 <Adafruit_Keypad::tick() [clone .constprop.54]+0x4c>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:101
      *state = currentState;
    }
    // Serial.println("");
    digitalWrite(_col[c], HIGH);
  }
}
    11f8:	cf 91       	pop	r28
    11fa:	1f 91       	pop	r17
    11fc:	0f 91       	pop	r16
    11fe:	ff 90       	pop	r15
    1200:	ef 90       	pop	r14
    1202:	df 90       	pop	r13
    1204:	cf 90       	pop	r12
    1206:	bf 90       	pop	r11
    1208:	af 90       	pop	r10
    120a:	9f 90       	pop	r9
    120c:	8f 90       	pop	r8
    120e:	08 95       	ret

00001210 <pinMode>:
pinMode():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:30
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    1210:	cf 93       	push	r28
    1212:	df 93       	push	r29
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:31
	uint8_t bit = digitalPinToBitMask(pin);
    1214:	90 e0       	ldi	r25, 0x00	; 0
    1216:	fc 01       	movw	r30, r24
    1218:	e7 52       	subi	r30, 0x27	; 39
    121a:	fa 4f       	sbci	r31, 0xFA	; 250
    121c:	24 91       	lpm	r18, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:32
	uint8_t port = digitalPinToPort(pin);
    121e:	87 5c       	subi	r24, 0xC7	; 199
    1220:	99 4f       	sbci	r25, 0xF9	; 249
    1222:	fc 01       	movw	r30, r24
    1224:	84 91       	lpm	r24, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:35
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    1226:	88 23       	and	r24, r24
    1228:	c9 f0       	breq	.+50     	; 0x125c <pinMode+0x4c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:38

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    122a:	90 e0       	ldi	r25, 0x00	; 0
    122c:	88 0f       	add	r24, r24
    122e:	99 1f       	adc	r25, r25
    1230:	fc 01       	movw	r30, r24
    1232:	e3 52       	subi	r30, 0x23	; 35
    1234:	fc 4f       	sbci	r31, 0xFC	; 252
    1236:	a5 91       	lpm	r26, Z+
    1238:	b4 91       	lpm	r27, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:39
	out = portOutputRegister(port);
    123a:	fc 01       	movw	r30, r24
    123c:	e1 5e       	subi	r30, 0xE1	; 225
    123e:	f9 4f       	sbci	r31, 0xF9	; 249
    1240:	c5 91       	lpm	r28, Z+
    1242:	d4 91       	lpm	r29, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:41

	if (mode == INPUT) { 
    1244:	61 11       	cpse	r22, r1
    1246:	0d c0       	rjmp	.+26     	; 0x1262 <pinMode+0x52>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:42
		uint8_t oldSREG = SREG;
    1248:	9f b7       	in	r25, 0x3f	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:43
                cli();
    124a:	f8 94       	cli
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:44
		*reg &= ~bit;
    124c:	8c 91       	ld	r24, X
    124e:	20 95       	com	r18
    1250:	82 23       	and	r24, r18
    1252:	8c 93       	st	X, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:45
		*out &= ~bit;
    1254:	88 81       	ld	r24, Y
    1256:	28 23       	and	r18, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:51
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
		uint8_t oldSREG = SREG;
                cli();
		*reg &= ~bit;
		*out |= bit;
    1258:	28 83       	st	Y, r18
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:52
		SREG = oldSREG;
    125a:	9f bf       	out	0x3f, r25	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:59
		uint8_t oldSREG = SREG;
                cli();
		*reg |= bit;
		SREG = oldSREG;
	}
}
    125c:	df 91       	pop	r29
    125e:	cf 91       	pop	r28
    1260:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:47
		uint8_t oldSREG = SREG;
                cli();
		*reg &= ~bit;
		*out &= ~bit;
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    1262:	62 30       	cpi	r22, 0x02	; 2
    1264:	51 f4       	brne	.+20     	; 0x127a <pinMode+0x6a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:48
		uint8_t oldSREG = SREG;
    1266:	9f b7       	in	r25, 0x3f	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:49
                cli();
    1268:	f8 94       	cli
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:50
		*reg &= ~bit;
    126a:	3c 91       	ld	r19, X
    126c:	82 2f       	mov	r24, r18
    126e:	80 95       	com	r24
    1270:	83 23       	and	r24, r19
    1272:	8c 93       	st	X, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:51
		*out |= bit;
    1274:	e8 81       	ld	r30, Y
    1276:	2e 2b       	or	r18, r30
    1278:	ef cf       	rjmp	.-34     	; 0x1258 <pinMode+0x48>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:54
		SREG = oldSREG;
	} else {
		uint8_t oldSREG = SREG;
    127a:	8f b7       	in	r24, 0x3f	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:55
                cli();
    127c:	f8 94       	cli
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:56
		*reg |= bit;
    127e:	ec 91       	ld	r30, X
    1280:	2e 2b       	or	r18, r30
    1282:	2c 93       	st	X, r18
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_digital.c:57
		SREG = oldSREG;
    1284:	8f bf       	out	0x3f, r24	; 63
    1286:	ea cf       	rjmp	.-44     	; 0x125c <pinMode+0x4c>

00001288 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]>:
tone():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:243



// frequency (in hertz) and duration (in milliseconds).

void tone(uint8_t _pin, unsigned int frequency, unsigned long duration)
    1288:	4f 92       	push	r4
    128a:	5f 92       	push	r5
    128c:	6f 92       	push	r6
    128e:	7f 92       	push	r7
    1290:	8f 92       	push	r8
    1292:	9f 92       	push	r9
    1294:	af 92       	push	r10
    1296:	bf 92       	push	r11
    1298:	cf 92       	push	r12
    129a:	df 92       	push	r13
    129c:	ef 92       	push	r14
    129e:	ff 92       	push	r15
    12a0:	0f 93       	push	r16
    12a2:	1f 93       	push	r17
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	00 d0       	rcall	.+0      	; 0x12aa <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x22>
    12aa:	1f 92       	push	r1
    12ac:	1f 92       	push	r1
    12ae:	cd b7       	in	r28, 0x3d	; 61
    12b0:	de b7       	in	r29, 0x3e	; 62
    12b2:	8c 01       	movw	r16, r24
    12b4:	49 83       	std	Y+1, r20	; 0x01
    12b6:	5a 83       	std	Y+2, r21	; 0x02
    12b8:	6b 83       	std	Y+3, r22	; 0x03
    12ba:	7c 83       	std	Y+4, r23	; 0x04
toneBegin():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:134
{
  int8_t _timer = -1;

  // if we're already using the pin, the timer should be configured.  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    if (tone_pins[i] == _pin) {
    12bc:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <tone_pins>
    12c0:	8d 32       	cpi	r24, 0x2D	; 45
    12c2:	c9 f0       	breq	.+50     	; 0x12f6 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x6e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:141
    }
  }
  
  // search for an unused timer.
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    if (tone_pins[i] == 255) {
    12c4:	8f 3f       	cpi	r24, 0xFF	; 255
    12c6:	09 f4       	brne	.+2      	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
    12c8:	80 c0       	rjmp	.+256    	; 0x13ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x142>
tone():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:420
        break;
#endif

    }
  }
}
    12ca:	0f 90       	pop	r0
    12cc:	0f 90       	pop	r0
    12ce:	0f 90       	pop	r0
    12d0:	0f 90       	pop	r0
    12d2:	0f 90       	pop	r0
    12d4:	df 91       	pop	r29
    12d6:	cf 91       	pop	r28
    12d8:	1f 91       	pop	r17
    12da:	0f 91       	pop	r16
    12dc:	ff 90       	pop	r15
    12de:	ef 90       	pop	r14
    12e0:	df 90       	pop	r13
    12e2:	cf 90       	pop	r12
    12e4:	bf 90       	pop	r11
    12e6:	af 90       	pop	r10
    12e8:	9f 90       	pop	r9
    12ea:	8f 90       	pop	r8
    12ec:	7f 90       	pop	r7
    12ee:	6f 90       	pop	r6
    12f0:	5f 90       	pop	r5
    12f2:	4f 90       	pop	r4
    12f4:	08 95       	ret
toneBegin():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:135
  int8_t _timer = -1;

  // if we're already using the pin, the timer should be configured.  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    if (tone_pins[i] == _pin) {
      return pgm_read_byte(tone_pin_to_timer_PGM + i);
    12f6:	ef e7       	ldi	r30, 0x7F	; 127
    12f8:	f6 e0       	ldi	r31, 0x06	; 6
    12fa:	84 91       	lpm	r24, Z
    12fc:	8d 83       	std	Y+5, r24	; 0x05
tone():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:252
  uint32_t ocr = 0;
  int8_t _timer;

  _timer = toneBegin(_pin);

  if (_timer >= 0)
    12fe:	87 fd       	sbrc	r24, 7
    1300:	e4 cf       	rjmp	.-56     	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:255
  {
    // Set the pinMode as OUTPUT
    pinMode(_pin, OUTPUT);
    1302:	61 e0       	ldi	r22, 0x01	; 1
    1304:	8d e2       	ldi	r24, 0x2D	; 45
    1306:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:258
    
    // if we are using an 8 bit timer, scan through prescalars to find the best fit
    if (_timer == 0 || _timer == 2)
    130a:	9d 81       	ldd	r25, Y+5	; 0x05
    130c:	99 23       	and	r25, r25
    130e:	21 f0       	breq	.+8      	; 0x1318 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x90>
    1310:	8d 81       	ldd	r24, Y+5	; 0x05
    1312:	82 30       	cpi	r24, 0x02	; 2
    1314:	09 f0       	breq	.+2      	; 0x1318 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x90>
    1316:	d4 c1       	rjmp	.+936    	; 0x16c0 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x438>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:260
    {
      ocr = F_CPU / frequency / 2 - 1;
    1318:	48 01       	movw	r8, r16
    131a:	b1 2c       	mov	r11, r1
    131c:	a1 2c       	mov	r10, r1
    131e:	60 e0       	ldi	r22, 0x00	; 0
    1320:	72 e1       	ldi	r23, 0x12	; 18
    1322:	8a e7       	ldi	r24, 0x7A	; 122
    1324:	90 e0       	ldi	r25, 0x00	; 0
    1326:	a5 01       	movw	r20, r10
    1328:	98 01       	movw	r18, r16
    132a:	0e 94 11 6a 	call	0xd422	; 0xd422 <__divmodsi4>
    132e:	29 01       	movw	r4, r18
    1330:	3a 01       	movw	r6, r20
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:264
      prescalarbits = 0b001;  // ck/1: same for both timers
      if (ocr > 255)
      {
        ocr = F_CPU / frequency / 2 / 8 - 1;
    1332:	60 e4       	ldi	r22, 0x40	; 64
    1334:	72 e4       	ldi	r23, 0x42	; 66
    1336:	8f e0       	ldi	r24, 0x0F	; 15
    1338:	90 e0       	ldi	r25, 0x00	; 0
    133a:	a5 01       	movw	r20, r10
    133c:	98 01       	movw	r18, r16
    133e:	0e 94 11 6a 	call	0xd422	; 0xd422 <__divmodsi4>
    1342:	69 01       	movw	r12, r18
    1344:	7a 01       	movw	r14, r20
    1346:	91 e0       	ldi	r25, 0x01	; 1
    1348:	c9 1a       	sub	r12, r25
    134a:	d1 08       	sbc	r13, r1
    134c:	e1 08       	sbc	r14, r1
    134e:	f1 08       	sbc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:267
        prescalarbits = 0b010;  // ck/8: same for both timers

        if (_timer == 2 && ocr > 255)
    1350:	8d 81       	ldd	r24, Y+5	; 0x05
    1352:	82 30       	cpi	r24, 0x02	; 2
    1354:	09 f0       	breq	.+2      	; 0x1358 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0xd0>
    1356:	10 c1       	rjmp	.+544    	; 0x1578 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x2f0>
    1358:	9f ef       	ldi	r25, 0xFF	; 255
    135a:	c9 16       	cp	r12, r25
    135c:	d1 04       	cpc	r13, r1
    135e:	e1 04       	cpc	r14, r1
    1360:	f1 04       	cpc	r15, r1
    1362:	09 f0       	breq	.+2      	; 0x1366 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0xde>
    1364:	0c f4       	brge	.+2      	; 0x1368 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0xe0>
    1366:	a4 c1       	rjmp	.+840    	; 0x16b0 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x428>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:269
        {
          ocr = F_CPU / frequency / 2 / 32 - 1;
    1368:	60 e9       	ldi	r22, 0x90	; 144
    136a:	70 ed       	ldi	r23, 0xD0	; 208
    136c:	83 e0       	ldi	r24, 0x03	; 3
    136e:	90 e0       	ldi	r25, 0x00	; 0
    1370:	a5 01       	movw	r20, r10
    1372:	98 01       	movw	r18, r16
    1374:	0e 94 11 6a 	call	0xd422	; 0xd422 <__divmodsi4>
    1378:	69 01       	movw	r12, r18
    137a:	7a 01       	movw	r14, r20
    137c:	81 e0       	ldi	r24, 0x01	; 1
    137e:	c8 1a       	sub	r12, r24
    1380:	d1 08       	sbc	r13, r1
    1382:	e1 08       	sbc	r14, r1
    1384:	f1 08       	sbc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:270
          prescalarbits = 0b011;
    1386:	83 e0       	ldi	r24, 0x03	; 3
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:273
        }

        if (ocr > 255)
    1388:	9f ef       	ldi	r25, 0xFF	; 255
    138a:	c9 16       	cp	r12, r25
    138c:	d1 04       	cpc	r13, r1
    138e:	e1 04       	cpc	r14, r1
    1390:	f1 04       	cpc	r15, r1
    1392:	09 f0       	breq	.+2      	; 0x1396 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x10e>
    1394:	0c f4       	brge	.+2      	; 0x1398 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x110>
    1396:	8d c1       	rjmp	.+794    	; 0x16b2 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:275
        {
          ocr = F_CPU / frequency / 2 / 64 - 1;
    1398:	68 e4       	ldi	r22, 0x48	; 72
    139a:	78 ee       	ldi	r23, 0xE8	; 232
    139c:	81 e0       	ldi	r24, 0x01	; 1
    139e:	90 e0       	ldi	r25, 0x00	; 0
    13a0:	a5 01       	movw	r20, r10
    13a2:	98 01       	movw	r18, r16
    13a4:	0e 94 11 6a 	call	0xd422	; 0xd422 <__divmodsi4>
    13a8:	69 01       	movw	r12, r18
    13aa:	7a 01       	movw	r14, r20
    13ac:	91 e0       	ldi	r25, 0x01	; 1
    13ae:	c9 1a       	sub	r12, r25
    13b0:	d1 08       	sbc	r13, r1
    13b2:	e1 08       	sbc	r14, r1
    13b4:	f1 08       	sbc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:278
          prescalarbits = _timer == 0 ? 0b011 : 0b100;

          if (_timer == 2 && ocr > 255)
    13b6:	8f ef       	ldi	r24, 0xFF	; 255
    13b8:	c8 16       	cp	r12, r24
    13ba:	d1 04       	cpc	r13, r1
    13bc:	e1 04       	cpc	r14, r1
    13be:	f1 04       	cpc	r15, r1
    13c0:	11 f0       	breq	.+4      	; 0x13c6 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x13e>
    13c2:	0c f0       	brlt	.+2      	; 0x13c6 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x13e>
    13c4:	16 c1       	rjmp	.+556    	; 0x15f2 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x36a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:276
        }

        if (ocr > 255)
        {
          ocr = F_CPU / frequency / 2 / 64 - 1;
          prescalarbits = _timer == 0 ? 0b011 : 0b100;
    13c6:	84 e0       	ldi	r24, 0x04	; 4
    13c8:	74 c1       	rjmp	.+744    	; 0x16b2 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42a>
toneBegin():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:142
  }
  
  // search for an unused timer.
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    if (tone_pins[i] == 255) {
      tone_pins[i] = _pin;
    13ca:	8d e2       	ldi	r24, 0x2D	; 45
    13cc:	80 93 8d 02 	sts	0x028D, r24	; 0x80028d <tone_pins>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:143
      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
    13d0:	ef e7       	ldi	r30, 0x7F	; 127
    13d2:	f6 e0       	ldi	r31, 0x06	; 6
    13d4:	94 91       	lpm	r25, Z
    13d6:	9d 83       	std	Y+5, r25	; 0x05
    13d8:	89 2f       	mov	r24, r25
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:148
      break;
    }
  }
  
  if (_timer != -1)
    13da:	9f 3f       	cpi	r25, 0xFF	; 255
    13dc:	09 f4       	brne	.+2      	; 0x13e0 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x158>
    13de:	75 cf       	rjmp	.-278    	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:154
  {
    // Set timer specific stuff
    // All timers in CTC mode
    // 8 bit timers will require changing prescalar values,
    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
    switch (_timer)
    13e0:	92 30       	cpi	r25, 0x02	; 2
    13e2:	09 f4       	brne	.+2      	; 0x13e6 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x15e>
    13e4:	69 c0       	rjmp	.+210    	; 0x14b8 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x230>
    13e6:	60 f4       	brcc	.+24     	; 0x1400 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x178>
    13e8:	99 23       	and	r25, r25
    13ea:	81 f1       	breq	.+96     	; 0x144c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x1c4>
    13ec:	91 30       	cpi	r25, 0x01	; 1
    13ee:	09 f4       	brne	.+2      	; 0x13f2 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x16a>
    13f0:	45 c0       	rjmp	.+138    	; 0x147c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x1f4>
tone():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:252
  uint32_t ocr = 0;
  int8_t _timer;

  _timer = toneBegin(_pin);

  if (_timer >= 0)
    13f2:	87 fd       	sbrc	r24, 7
    13f4:	6a cf       	rjmp	.-300    	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:255
  {
    // Set the pinMode as OUTPUT
    pinMode(_pin, OUTPUT);
    13f6:	61 e0       	ldi	r22, 0x01	; 1
    13f8:	8d e2       	ldi	r24, 0x2D	; 45
    13fa:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
    13fe:	88 cf       	rjmp	.-240    	; 0x1310 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x88>
toneBegin():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:154
  {
    // Set timer specific stuff
    // All timers in CTC mode
    // 8 bit timers will require changing prescalar values,
    // whereas 16 bit timers are set to either ck/1 or ck/64 prescalar
    switch (_timer)
    1400:	9d 81       	ldd	r25, Y+5	; 0x05
    1402:	94 30       	cpi	r25, 0x04	; 4
    1404:	09 f4       	brne	.+2      	; 0x1408 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x180>
    1406:	9a c0       	rjmp	.+308    	; 0x153c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x2b4>
    1408:	08 f4       	brcc	.+2      	; 0x140c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x184>
    140a:	78 c0       	rjmp	.+240    	; 0x14fc <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x274>
    140c:	95 30       	cpi	r25, 0x05	; 5
    140e:	89 f7       	brne	.-30     	; 0x13f2 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x16a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:225
      #endif

      #if defined(TCCR5A) && defined(TCCR5B) &&  defined(TIMSK5)
      case 5:
        // 16 bit timer
        TCCR5A = 0;
    1410:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:226
        TCCR5B = 0;
    1414:	10 92 21 01 	sts	0x0121, r1	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:227
        bitWrite(TCCR5B, WGM52, 1);
    1418:	80 91 21 01 	lds	r24, 0x0121	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
    141c:	88 60       	ori	r24, 0x08	; 8
    141e:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:228
        bitWrite(TCCR5B, CS50, 1);
    1422:	80 91 21 01 	lds	r24, 0x0121	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
    1426:	81 60       	ori	r24, 0x01	; 1
    1428:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:229
        timer5_pin_port = portOutputRegister(digitalPinToPort(_pin));
    142c:	e6 e6       	ldi	r30, 0x66	; 102
    142e:	f6 e0       	ldi	r31, 0x06	; 6
    1430:	e4 91       	lpm	r30, Z
    1432:	f0 e0       	ldi	r31, 0x00	; 0
    1434:	ee 0f       	add	r30, r30
    1436:	ff 1f       	adc	r31, r31
    1438:	e1 5e       	subi	r30, 0xE1	; 225
    143a:	f9 4f       	sbci	r31, 0xF9	; 249
    143c:	85 91       	lpm	r24, Z+
    143e:	94 91       	lpm	r25, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:230
        timer5_pin_mask = digitalPinToBitMask(_pin);
    1440:	e6 e0       	ldi	r30, 0x06	; 6
    1442:	f6 e0       	ldi	r31, 0x06	; 6
    1444:	e4 91       	lpm	r30, Z
    1446:	e0 93 fd 0b 	sts	0x0BFD, r30	; 0x800bfd <timer5_pin_mask>
    144a:	5b cf       	rjmp	.-330    	; 0x1302 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x7a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:159
    switch (_timer)
    {
      #if defined(TCCR0A) && defined(TCCR0B) && defined(WGM01)
      case 0:
        // 8 bit timer
        TCCR0A = 0;
    144c:	14 bc       	out	0x24, r1	; 36
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:160
        TCCR0B = 0;
    144e:	15 bc       	out	0x25, r1	; 37
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:161
        bitWrite(TCCR0A, WGM01, 1);
    1450:	84 b5       	in	r24, 0x24	; 36
    1452:	82 60       	ori	r24, 0x02	; 2
    1454:	84 bd       	out	0x24, r24	; 36
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:162
        bitWrite(TCCR0B, CS00, 1);
    1456:	85 b5       	in	r24, 0x25	; 37
    1458:	81 60       	ori	r24, 0x01	; 1
    145a:	85 bd       	out	0x25, r24	; 37
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:163
        timer0_pin_port = portOutputRegister(digitalPinToPort(_pin));
    145c:	e6 e6       	ldi	r30, 0x66	; 102
    145e:	f6 e0       	ldi	r31, 0x06	; 6
    1460:	e4 91       	lpm	r30, Z
    1462:	f0 e0       	ldi	r31, 0x00	; 0
    1464:	ee 0f       	add	r30, r30
    1466:	ff 1f       	adc	r31, r31
    1468:	e1 5e       	subi	r30, 0xE1	; 225
    146a:	f9 4f       	sbci	r31, 0xF9	; 249
    146c:	85 91       	lpm	r24, Z+
    146e:	94 91       	lpm	r25, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:164
        timer0_pin_mask = digitalPinToBitMask(_pin);
    1470:	e6 e0       	ldi	r30, 0x06	; 6
    1472:	f6 e0       	ldi	r31, 0x06	; 6
    1474:	e4 91       	lpm	r30, Z
    1476:	e0 93 04 0c 	sts	0x0C04, r30	; 0x800c04 <timer0_pin_mask>
    147a:	43 cf       	rjmp	.-378    	; 0x1302 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x7a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:171
      #endif

      #if defined(TCCR1A) && defined(TCCR1B) && defined(WGM12)
      case 1:
        // 16 bit timer
        TCCR1A = 0;
    147c:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:172
        TCCR1B = 0;
    1480:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:173
        bitWrite(TCCR1B, WGM12, 1);
    1484:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
    1488:	88 60       	ori	r24, 0x08	; 8
    148a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:174
        bitWrite(TCCR1B, CS10, 1);
    148e:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
    1492:	81 60       	ori	r24, 0x01	; 1
    1494:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:175
        timer1_pin_port = portOutputRegister(digitalPinToPort(_pin));
    1498:	e6 e6       	ldi	r30, 0x66	; 102
    149a:	f6 e0       	ldi	r31, 0x06	; 6
    149c:	e4 91       	lpm	r30, Z
    149e:	f0 e0       	ldi	r31, 0x00	; 0
    14a0:	ee 0f       	add	r30, r30
    14a2:	ff 1f       	adc	r31, r31
    14a4:	e1 5e       	subi	r30, 0xE1	; 225
    14a6:	f9 4f       	sbci	r31, 0xF9	; 249
    14a8:	85 91       	lpm	r24, Z+
    14aa:	94 91       	lpm	r25, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:176
        timer1_pin_mask = digitalPinToBitMask(_pin);
    14ac:	e6 e0       	ldi	r30, 0x06	; 6
    14ae:	f6 e0       	ldi	r31, 0x06	; 6
    14b0:	e4 91       	lpm	r30, Z
    14b2:	e0 93 03 0c 	sts	0x0C03, r30	; 0x800c03 <timer1_pin_mask>
    14b6:	25 cf       	rjmp	.-438    	; 0x1302 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x7a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:183
      #endif

      #if defined(TCCR2A) && defined(TCCR2B)
      case 2:
        // 8 bit timer
        TCCR2A = 0;
    14b8:	10 92 b0 00 	sts	0x00B0, r1	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:184
        TCCR2B = 0;
    14bc:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:185
        bitWrite(TCCR2A, WGM21, 1);
    14c0:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
    14c4:	82 60       	ori	r24, 0x02	; 2
    14c6:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:186
        bitWrite(TCCR2B, CS20, 1);
    14ca:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    14ce:	81 60       	ori	r24, 0x01	; 1
    14d0:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:187
        timer2_pin_port = portOutputRegister(digitalPinToPort(_pin));
    14d4:	e6 e6       	ldi	r30, 0x66	; 102
    14d6:	f6 e0       	ldi	r31, 0x06	; 6
    14d8:	e4 91       	lpm	r30, Z
    14da:	f0 e0       	ldi	r31, 0x00	; 0
    14dc:	ee 0f       	add	r30, r30
    14de:	ff 1f       	adc	r31, r31
    14e0:	e1 5e       	subi	r30, 0xE1	; 225
    14e2:	f9 4f       	sbci	r31, 0xF9	; 249
    14e4:	85 91       	lpm	r24, Z+
    14e6:	94 91       	lpm	r25, Z
    14e8:	90 93 02 0c 	sts	0x0C02, r25	; 0x800c02 <timer2_pin_port+0x1>
    14ec:	80 93 01 0c 	sts	0x0C01, r24	; 0x800c01 <timer2_pin_port>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:188
        timer2_pin_mask = digitalPinToBitMask(_pin);
    14f0:	e6 e0       	ldi	r30, 0x06	; 6
    14f2:	f6 e0       	ldi	r31, 0x06	; 6
    14f4:	e4 91       	lpm	r30, Z
    14f6:	e0 93 00 0c 	sts	0x0C00, r30	; 0x800c00 <timer2_pin_mask>
    14fa:	03 cf       	rjmp	.-506    	; 0x1302 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x7a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:195
      #endif

      #if defined(TCCR3A) && defined(TCCR3B) &&  defined(TIMSK3)
      case 3:
        // 16 bit timer
        TCCR3A = 0;
    14fc:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:196
        TCCR3B = 0;
    1500:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:197
        bitWrite(TCCR3B, WGM32, 1);
    1504:	80 91 91 00 	lds	r24, 0x0091	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    1508:	88 60       	ori	r24, 0x08	; 8
    150a:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:198
        bitWrite(TCCR3B, CS30, 1);
    150e:	80 91 91 00 	lds	r24, 0x0091	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    1512:	81 60       	ori	r24, 0x01	; 1
    1514:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:199
        timer3_pin_port = portOutputRegister(digitalPinToPort(_pin));
    1518:	e6 e6       	ldi	r30, 0x66	; 102
    151a:	f6 e0       	ldi	r31, 0x06	; 6
    151c:	e4 91       	lpm	r30, Z
    151e:	f0 e0       	ldi	r31, 0x00	; 0
    1520:	ee 0f       	add	r30, r30
    1522:	ff 1f       	adc	r31, r31
    1524:	e1 5e       	subi	r30, 0xE1	; 225
    1526:	f9 4f       	sbci	r31, 0xF9	; 249
    1528:	85 91       	lpm	r24, Z+
    152a:	94 91       	lpm	r25, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:200
        timer3_pin_mask = digitalPinToBitMask(_pin);
    152c:	e6 e0       	ldi	r30, 0x06	; 6
    152e:	f6 e0       	ldi	r31, 0x06	; 6
    1530:	e4 91       	lpm	r30, Z
    1532:	e0 93 ff 0b 	sts	0x0BFF, r30	; 0x800bff <timer3_pin_mask>
    1536:	83 e0       	ldi	r24, 0x03	; 3
    1538:	8d 83       	std	Y+5, r24	; 0x05
    153a:	e3 ce       	rjmp	.-570    	; 0x1302 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x7a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:207
      #endif

      #if defined(TCCR4A) && defined(TCCR4B) &&  defined(TIMSK4)
      case 4:
        // 16 bit timer
        TCCR4A = 0;
    153c:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:208
        TCCR4B = 0;
    1540:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:210
        #if defined(WGM42)
          bitWrite(TCCR4B, WGM42, 1);
    1544:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
    1548:	88 60       	ori	r24, 0x08	; 8
    154a:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:216
        #elif defined(CS43)
          // TODO this may not be correct
          // atmega32u4
          bitWrite(TCCR4B, CS43, 1);
        #endif
        bitWrite(TCCR4B, CS40, 1);
    154e:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
    1552:	81 60       	ori	r24, 0x01	; 1
    1554:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:217
        timer4_pin_port = portOutputRegister(digitalPinToPort(_pin));
    1558:	e6 e6       	ldi	r30, 0x66	; 102
    155a:	f6 e0       	ldi	r31, 0x06	; 6
    155c:	e4 91       	lpm	r30, Z
    155e:	f0 e0       	ldi	r31, 0x00	; 0
    1560:	ee 0f       	add	r30, r30
    1562:	ff 1f       	adc	r31, r31
    1564:	e1 5e       	subi	r30, 0xE1	; 225
    1566:	f9 4f       	sbci	r31, 0xF9	; 249
    1568:	85 91       	lpm	r24, Z+
    156a:	94 91       	lpm	r25, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:218
        timer4_pin_mask = digitalPinToBitMask(_pin);
    156c:	e6 e0       	ldi	r30, 0x06	; 6
    156e:	f6 e0       	ldi	r31, 0x06	; 6
    1570:	e4 91       	lpm	r30, Z
    1572:	e0 93 fe 0b 	sts	0x0BFE, r30	; 0x800bfe <timer4_pin_mask>
    1576:	c5 ce       	rjmp	.-630    	; 0x1302 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x7a>
tone():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:273
        {
          ocr = F_CPU / frequency / 2 / 32 - 1;
          prescalarbits = 0b011;
        }

        if (ocr > 255)
    1578:	8f ef       	ldi	r24, 0xFF	; 255
    157a:	c8 16       	cp	r12, r24
    157c:	d1 04       	cpc	r13, r1
    157e:	e1 04       	cpc	r14, r1
    1580:	f1 04       	cpc	r15, r1
    1582:	09 f0       	breq	.+2      	; 0x1586 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x2fe>
    1584:	0c f4       	brge	.+2      	; 0x1588 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x300>
    1586:	8f c0       	rjmp	.+286    	; 0x16a6 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x41e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:275
        {
          ocr = F_CPU / frequency / 2 / 64 - 1;
    1588:	68 e4       	ldi	r22, 0x48	; 72
    158a:	78 ee       	ldi	r23, 0xE8	; 232
    158c:	81 e0       	ldi	r24, 0x01	; 1
    158e:	90 e0       	ldi	r25, 0x00	; 0
    1590:	a5 01       	movw	r20, r10
    1592:	98 01       	movw	r18, r16
    1594:	0e 94 11 6a 	call	0xd422	; 0xd422 <__divmodsi4>
    1598:	69 01       	movw	r12, r18
    159a:	7a 01       	movw	r14, r20
    159c:	91 e0       	ldi	r25, 0x01	; 1
    159e:	c9 1a       	sub	r12, r25
    15a0:	d1 08       	sbc	r13, r1
    15a2:	e1 08       	sbc	r14, r1
    15a4:	f1 08       	sbc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:276
          prescalarbits = _timer == 0 ? 0b011 : 0b100;
    15a6:	8d 81       	ldd	r24, Y+5	; 0x05
    15a8:	88 23       	and	r24, r24
    15aa:	09 f4       	brne	.+2      	; 0x15ae <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x326>
    15ac:	57 c1       	rjmp	.+686    	; 0x185c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x5d4>
    15ae:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:284
          {
            ocr = F_CPU / frequency / 2 / 128 - 1;
            prescalarbits = 0b101;
          }

          if (ocr > 255)
    15b0:	9f ef       	ldi	r25, 0xFF	; 255
    15b2:	c9 16       	cp	r12, r25
    15b4:	d1 04       	cpc	r13, r1
    15b6:	e1 04       	cpc	r14, r1
    15b8:	f1 04       	cpc	r15, r1
    15ba:	09 f0       	breq	.+2      	; 0x15be <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x336>
    15bc:	08 f4       	brcc	.+2      	; 0x15c0 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x338>
    15be:	79 c0       	rjmp	.+242    	; 0x16b2 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:286
          {
            ocr = F_CPU / frequency / 2 / 256 - 1;
    15c0:	62 e1       	ldi	r22, 0x12	; 18
    15c2:	7a e7       	ldi	r23, 0x7A	; 122
    15c4:	80 e0       	ldi	r24, 0x00	; 0
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	a5 01       	movw	r20, r10
    15ca:	94 01       	movw	r18, r8
    15cc:	0e 94 11 6a 	call	0xd422	; 0xd422 <__divmodsi4>
    15d0:	69 01       	movw	r12, r18
    15d2:	7a 01       	movw	r14, r20
    15d4:	91 e0       	ldi	r25, 0x01	; 1
    15d6:	c9 1a       	sub	r12, r25
    15d8:	d1 08       	sbc	r13, r1
    15da:	e1 08       	sbc	r14, r1
    15dc:	f1 08       	sbc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:288
            prescalarbits = _timer == 0 ? 0b100 : 0b110;
            if (ocr > 255)
    15de:	8f ef       	ldi	r24, 0xFF	; 255
    15e0:	c8 16       	cp	r12, r24
    15e2:	d1 04       	cpc	r13, r1
    15e4:	e1 04       	cpc	r14, r1
    15e6:	f1 04       	cpc	r15, r1
    15e8:	11 f0       	breq	.+4      	; 0x15ee <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x366>
    15ea:	0c f0       	brlt	.+2      	; 0x15ee <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x366>
    15ec:	0d c1       	rjmp	.+538    	; 0x1808 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x580>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:287
          }

          if (ocr > 255)
          {
            ocr = F_CPU / frequency / 2 / 256 - 1;
            prescalarbits = _timer == 0 ? 0b100 : 0b110;
    15ee:	86 e0       	ldi	r24, 0x06	; 6
    15f0:	60 c0       	rjmp	.+192    	; 0x16b2 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:280
          ocr = F_CPU / frequency / 2 / 64 - 1;
          prescalarbits = _timer == 0 ? 0b011 : 0b100;

          if (_timer == 2 && ocr > 255)
          {
            ocr = F_CPU / frequency / 2 / 128 - 1;
    15f2:	64 e2       	ldi	r22, 0x24	; 36
    15f4:	74 ef       	ldi	r23, 0xF4	; 244
    15f6:	80 e0       	ldi	r24, 0x00	; 0
    15f8:	90 e0       	ldi	r25, 0x00	; 0
    15fa:	a5 01       	movw	r20, r10
    15fc:	94 01       	movw	r18, r8
    15fe:	0e 94 11 6a 	call	0xd422	; 0xd422 <__divmodsi4>
    1602:	69 01       	movw	r12, r18
    1604:	7a 01       	movw	r14, r20
    1606:	91 e0       	ldi	r25, 0x01	; 1
    1608:	c9 1a       	sub	r12, r25
    160a:	d1 08       	sbc	r13, r1
    160c:	e1 08       	sbc	r14, r1
    160e:	f1 08       	sbc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:281
            prescalarbits = 0b101;
    1610:	85 e0       	ldi	r24, 0x05	; 5
    1612:	ce cf       	rjmp	.-100    	; 0x15b0 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x328>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:286
          }

          if (ocr > 255)
          {
            ocr = F_CPU / frequency / 2 / 256 - 1;
    1614:	62 e1       	ldi	r22, 0x12	; 18
    1616:	7a e7       	ldi	r23, 0x7A	; 122
    1618:	80 e0       	ldi	r24, 0x00	; 0
    161a:	90 e0       	ldi	r25, 0x00	; 0
    161c:	a5 01       	movw	r20, r10
    161e:	94 01       	movw	r18, r8
    1620:	0e 94 11 6a 	call	0xd422	; 0xd422 <__divmodsi4>
    1624:	69 01       	movw	r12, r18
    1626:	7a 01       	movw	r14, r20
    1628:	81 e0       	ldi	r24, 0x01	; 1
    162a:	c8 1a       	sub	r12, r24
    162c:	d1 08       	sbc	r13, r1
    162e:	e1 08       	sbc	r14, r1
    1630:	f1 08       	sbc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:288
            prescalarbits = _timer == 0 ? 0b100 : 0b110;
            if (ocr > 255)
    1632:	9f ef       	ldi	r25, 0xFF	; 255
    1634:	c9 16       	cp	r12, r25
    1636:	d1 04       	cpc	r13, r1
    1638:	e1 04       	cpc	r14, r1
    163a:	f1 04       	cpc	r15, r1
    163c:	11 f0       	breq	.+4      	; 0x1642 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3ba>
    163e:	0c f0       	brlt	.+2      	; 0x1642 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3ba>
    1640:	d3 c0       	rjmp	.+422    	; 0x17e8 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x560>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:287
          }

          if (ocr > 255)
          {
            ocr = F_CPU / frequency / 2 / 256 - 1;
            prescalarbits = _timer == 0 ? 0b100 : 0b110;
    1642:	94 e0       	ldi	r25, 0x04	; 4
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:301
      }

#if defined(TCCR0B)
      if (_timer == 0)
      {
        TCCR0B = (TCCR0B & 0b11111000) | prescalarbits;
    1644:	85 b5       	in	r24, 0x25	; 37
    1646:	88 7f       	andi	r24, 0xF8	; 248
    1648:	89 2b       	or	r24, r25
    164a:	85 bd       	out	0x25, r24	; 37
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:352
    

    // Calculate the toggle count
    if (duration > 0)
    {
      toggle_count = 2 * frequency * duration / 1000;
    164c:	d8 01       	movw	r26, r16
    164e:	aa 0f       	add	r26, r26
    1650:	bb 1f       	adc	r27, r27
    1652:	29 81       	ldd	r18, Y+1	; 0x01
    1654:	3a 81       	ldd	r19, Y+2	; 0x02
    1656:	4b 81       	ldd	r20, Y+3	; 0x03
    1658:	5c 81       	ldd	r21, Y+4	; 0x04
    165a:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
    165e:	28 ee       	ldi	r18, 0xE8	; 232
    1660:	33 e0       	ldi	r19, 0x03	; 3
    1662:	40 e0       	ldi	r20, 0x00	; 0
    1664:	50 e0       	ldi	r21, 0x00	; 0
    1666:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:362
    }

    // Set the OCR for the given timer,
    // set the toggle count,
    // then turn on the interrupts
    switch (_timer)
    166a:	9d 81       	ldd	r25, Y+5	; 0x05
    166c:	92 30       	cpi	r25, 0x02	; 2
    166e:	09 f4       	brne	.+2      	; 0x1672 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3ea>
    1670:	87 c0       	rjmp	.+270    	; 0x1780 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x4f8>
    1672:	0c f0       	brlt	.+2      	; 0x1676 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3ee>
    1674:	d9 c0       	rjmp	.+434    	; 0x1828 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x5a0>
    1676:	99 23       	and	r25, r25
    1678:	09 f4       	brne	.+2      	; 0x167c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3f4>
    167a:	73 c0       	rjmp	.+230    	; 0x1762 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x4da>
    167c:	91 30       	cpi	r25, 0x01	; 1
    167e:	09 f0       	breq	.+2      	; 0x1682 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3fa>
    1680:	24 ce       	rjmp	.-952    	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:375
        break;
#endif

      case 1:
#if defined(OCR1A) && defined(TIMSK1) && defined(OCIE1A)
        OCR1A = ocr;
    1682:	d0 92 89 00 	sts	0x0089, r13	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1686:	c0 92 88 00 	sts	0x0088, r12	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:376
        timer1_toggle_count = toggle_count;
    168a:	20 93 15 0c 	sts	0x0C15, r18	; 0x800c15 <timer1_toggle_count>
    168e:	30 93 16 0c 	sts	0x0C16, r19	; 0x800c16 <timer1_toggle_count+0x1>
    1692:	40 93 17 0c 	sts	0x0C17, r20	; 0x800c17 <timer1_toggle_count+0x2>
    1696:	50 93 18 0c 	sts	0x0C18, r21	; 0x800c18 <timer1_toggle_count+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:377
        bitWrite(TIMSK1, OCIE1A, 1);
    169a:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <__TEXT_REGION_LENGTH__+0x70006f>
    169e:	82 60       	ori	r24, 0x02	; 2
    16a0:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x70006f>
    16a4:	12 ce       	rjmp	.-988    	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:299
          }
        }
      }

#if defined(TCCR0B)
      if (_timer == 0)
    16a6:	8d 81       	ldd	r24, Y+5	; 0x05
    16a8:	81 11       	cpse	r24, r1
    16aa:	02 c0       	rjmp	.+4      	; 0x16b0 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x428>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:265
      ocr = F_CPU / frequency / 2 - 1;
      prescalarbits = 0b001;  // ck/1: same for both timers
      if (ocr > 255)
      {
        ocr = F_CPU / frequency / 2 / 8 - 1;
        prescalarbits = 0b010;  // ck/8: same for both timers
    16ac:	92 e0       	ldi	r25, 0x02	; 2
    16ae:	ca cf       	rjmp	.-108    	; 0x1644 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3bc>
    16b0:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:307
      }
      else
#endif
#if defined(TCCR2B)
      {
        TCCR2B = (TCCR2B & 0b11111000) | prescalarbits;
    16b2:	90 91 b1 00 	lds	r25, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    16b6:	98 7f       	andi	r25, 0xF8	; 248
    16b8:	89 2b       	or	r24, r25
    16ba:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    16be:	c6 cf       	rjmp	.-116    	; 0x164c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3c4>
    16c0:	b1 2c       	mov	r11, r1
    16c2:	a1 2c       	mov	r10, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:318
#endif
    }
    else
    {
      // two choices for the 16 bit timers: ck/1 or ck/64
      ocr = F_CPU / frequency / 2 - 1;
    16c4:	60 e0       	ldi	r22, 0x00	; 0
    16c6:	72 e1       	ldi	r23, 0x12	; 18
    16c8:	8a e7       	ldi	r24, 0x7A	; 122
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	a5 01       	movw	r20, r10
    16ce:	98 01       	movw	r18, r16
    16d0:	0e 94 11 6a 	call	0xd422	; 0xd422 <__divmodsi4>
    16d4:	69 01       	movw	r12, r18
    16d6:	7a 01       	movw	r14, r20
    16d8:	91 e0       	ldi	r25, 0x01	; 1
    16da:	c9 1a       	sub	r12, r25
    16dc:	d1 08       	sbc	r13, r1
    16de:	e1 08       	sbc	r14, r1
    16e0:	f1 08       	sbc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:320

      prescalarbits = 0b001;
    16e2:	91 e0       	ldi	r25, 0x01	; 1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:321
      if (ocr > 0xffff)
    16e4:	c1 14       	cp	r12, r1
    16e6:	d1 04       	cpc	r13, r1
    16e8:	81 e0       	ldi	r24, 0x01	; 1
    16ea:	e8 06       	cpc	r14, r24
    16ec:	f1 04       	cpc	r15, r1
    16ee:	84 f0       	brlt	.+32     	; 0x1710 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x488>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:323
      {
        ocr = F_CPU / frequency / 2 / 64 - 1;
    16f0:	68 e4       	ldi	r22, 0x48	; 72
    16f2:	78 ee       	ldi	r23, 0xE8	; 232
    16f4:	81 e0       	ldi	r24, 0x01	; 1
    16f6:	90 e0       	ldi	r25, 0x00	; 0
    16f8:	a5 01       	movw	r20, r10
    16fa:	98 01       	movw	r18, r16
    16fc:	0e 94 11 6a 	call	0xd422	; 0xd422 <__divmodsi4>
    1700:	69 01       	movw	r12, r18
    1702:	7a 01       	movw	r14, r20
    1704:	91 e0       	ldi	r25, 0x01	; 1
    1706:	c9 1a       	sub	r12, r25
    1708:	d1 08       	sbc	r13, r1
    170a:	e1 08       	sbc	r14, r1
    170c:	f1 08       	sbc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:324
        prescalarbits = 0b011;
    170e:	93 e0       	ldi	r25, 0x03	; 3
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:327
      }

      if (_timer == 1)
    1710:	8d 81       	ldd	r24, Y+5	; 0x05
    1712:	81 30       	cpi	r24, 0x01	; 1
    1714:	39 f4       	brne	.+14     	; 0x1724 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x49c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:330
      {
#if defined(TCCR1B)
        TCCR1B = (TCCR1B & 0b11111000) | prescalarbits;
    1716:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
    171a:	88 7f       	andi	r24, 0xF8	; 248
    171c:	89 2b       	or	r24, r25
    171e:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
    1722:	94 cf       	rjmp	.-216    	; 0x164c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3c4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:334
#endif
      }
#if defined(TCCR3B)
      else if (_timer == 3)
    1724:	8d 81       	ldd	r24, Y+5	; 0x05
    1726:	83 30       	cpi	r24, 0x03	; 3
    1728:	39 f4       	brne	.+14     	; 0x1738 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x4b0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:335
        TCCR3B = (TCCR3B & 0b11111000) | prescalarbits;
    172a:	80 91 91 00 	lds	r24, 0x0091	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    172e:	88 7f       	andi	r24, 0xF8	; 248
    1730:	89 2b       	or	r24, r25
    1732:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    1736:	8a cf       	rjmp	.-236    	; 0x164c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3c4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:338
#endif
#if defined(TCCR4B)
      else if (_timer == 4)
    1738:	8d 81       	ldd	r24, Y+5	; 0x05
    173a:	84 30       	cpi	r24, 0x04	; 4
    173c:	39 f4       	brne	.+14     	; 0x174c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x4c4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:339
        TCCR4B = (TCCR4B & 0b11111000) | prescalarbits;
    173e:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
    1742:	88 7f       	andi	r24, 0xF8	; 248
    1744:	89 2b       	or	r24, r25
    1746:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
    174a:	80 cf       	rjmp	.-256    	; 0x164c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3c4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:342
#endif
#if defined(TCCR5B)
      else if (_timer == 5)
    174c:	8d 81       	ldd	r24, Y+5	; 0x05
    174e:	85 30       	cpi	r24, 0x05	; 5
    1750:	09 f0       	breq	.+2      	; 0x1754 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x4cc>
    1752:	7c cf       	rjmp	.-264    	; 0x164c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3c4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:343
        TCCR5B = (TCCR5B & 0b11111000) | prescalarbits;
    1754:	80 91 21 01 	lds	r24, 0x0121	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
    1758:	88 7f       	andi	r24, 0xF8	; 248
    175a:	89 2b       	or	r24, r25
    175c:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
    1760:	75 cf       	rjmp	.-278    	; 0x164c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3c4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:367
    switch (_timer)
    {

#if defined(OCR0A) && defined(TIMSK0) && defined(OCIE0A)
      case 0:
        OCR0A = ocr;
    1762:	c7 bc       	out	0x27, r12	; 39
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:368
        timer0_toggle_count = toggle_count;
    1764:	20 93 19 0c 	sts	0x0C19, r18	; 0x800c19 <timer0_toggle_count>
    1768:	30 93 1a 0c 	sts	0x0C1A, r19	; 0x800c1a <timer0_toggle_count+0x1>
    176c:	40 93 1b 0c 	sts	0x0C1B, r20	; 0x800c1b <timer0_toggle_count+0x2>
    1770:	50 93 1c 0c 	sts	0x0C1C, r21	; 0x800c1c <timer0_toggle_count+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:369
        bitWrite(TIMSK0, OCIE0A, 1);
    1774:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    1778:	82 60       	ori	r24, 0x02	; 2
    177a:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    177e:	a5 cd       	rjmp	.-1206   	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:388
#endif
        break;

#if defined(OCR2A) && defined(TIMSK2) && defined(OCIE2A)
      case 2:
        OCR2A = ocr;
    1780:	c0 92 b3 00 	sts	0x00B3, r12	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:389
        timer2_toggle_count = toggle_count;
    1784:	20 93 11 0c 	sts	0x0C11, r18	; 0x800c11 <timer2_toggle_count>
    1788:	30 93 12 0c 	sts	0x0C12, r19	; 0x800c12 <timer2_toggle_count+0x1>
    178c:	40 93 13 0c 	sts	0x0C13, r20	; 0x800c13 <timer2_toggle_count+0x2>
    1790:	50 93 14 0c 	sts	0x0C14, r21	; 0x800c14 <timer2_toggle_count+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:390
        bitWrite(TIMSK2, OCIE2A, 1);
    1794:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
    1798:	82 60       	ori	r24, 0x02	; 2
    179a:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
    179e:	95 cd       	rjmp	.-1238   	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:396
        break;
#endif

#if defined(OCR3A) && defined(TIMSK3) && defined(OCIE3A)
      case 3:
        OCR3A = ocr;
    17a0:	d0 92 99 00 	sts	0x0099, r13	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    17a4:	c0 92 98 00 	sts	0x0098, r12	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:397
        timer3_toggle_count = toggle_count;
    17a8:	20 93 0d 0c 	sts	0x0C0D, r18	; 0x800c0d <timer3_toggle_count>
    17ac:	30 93 0e 0c 	sts	0x0C0E, r19	; 0x800c0e <timer3_toggle_count+0x1>
    17b0:	40 93 0f 0c 	sts	0x0C0F, r20	; 0x800c0f <timer3_toggle_count+0x2>
    17b4:	50 93 10 0c 	sts	0x0C10, r21	; 0x800c10 <timer3_toggle_count+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:398
        bitWrite(TIMSK3, OCIE3A, 1);
    17b8:	80 91 71 00 	lds	r24, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
    17bc:	82 60       	ori	r24, 0x02	; 2
    17be:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
    17c2:	83 cd       	rjmp	.-1274   	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:404
        break;
#endif

#if defined(OCR4A) && defined(TIMSK4) && defined(OCIE4A)
      case 4:
        OCR4A = ocr;
    17c4:	d0 92 a9 00 	sts	0x00A9, r13	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    17c8:	c0 92 a8 00 	sts	0x00A8, r12	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:405
        timer4_toggle_count = toggle_count;
    17cc:	20 93 09 0c 	sts	0x0C09, r18	; 0x800c09 <timer4_toggle_count>
    17d0:	30 93 0a 0c 	sts	0x0C0A, r19	; 0x800c0a <timer4_toggle_count+0x1>
    17d4:	40 93 0b 0c 	sts	0x0C0B, r20	; 0x800c0b <timer4_toggle_count+0x2>
    17d8:	50 93 0c 0c 	sts	0x0C0C, r21	; 0x800c0c <timer4_toggle_count+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:406
        bitWrite(TIMSK4, OCIE4A, 1);
    17dc:	80 91 72 00 	lds	r24, 0x0072	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
    17e0:	82 60       	ori	r24, 0x02	; 2
    17e2:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
    17e6:	71 cd       	rjmp	.-1310   	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:291
            ocr = F_CPU / frequency / 2 / 256 - 1;
            prescalarbits = _timer == 0 ? 0b100 : 0b110;
            if (ocr > 255)
            {
              // can't do any better than /1024
              ocr = F_CPU / frequency / 2 / 1024 - 1;
    17e8:	73 01       	movw	r14, r6
    17ea:	62 01       	movw	r12, r4
    17ec:	2a e0       	ldi	r18, 0x0A	; 10
    17ee:	f5 94       	asr	r15
    17f0:	e7 94       	ror	r14
    17f2:	d7 94       	ror	r13
    17f4:	c7 94       	ror	r12
    17f6:	2a 95       	dec	r18
    17f8:	d1 f7       	brne	.-12     	; 0x17ee <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x566>
    17fa:	91 e0       	ldi	r25, 0x01	; 1
    17fc:	c9 1a       	sub	r12, r25
    17fe:	d1 08       	sbc	r13, r1
    1800:	e1 08       	sbc	r14, r1
    1802:	f1 08       	sbc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:292
              prescalarbits = _timer == 0 ? 0b101 : 0b111;
    1804:	95 e0       	ldi	r25, 0x05	; 5
    1806:	1e cf       	rjmp	.-452    	; 0x1644 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3bc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:291
            ocr = F_CPU / frequency / 2 / 256 - 1;
            prescalarbits = _timer == 0 ? 0b100 : 0b110;
            if (ocr > 255)
            {
              // can't do any better than /1024
              ocr = F_CPU / frequency / 2 / 1024 - 1;
    1808:	73 01       	movw	r14, r6
    180a:	62 01       	movw	r12, r4
    180c:	9a e0       	ldi	r25, 0x0A	; 10
    180e:	f5 94       	asr	r15
    1810:	e7 94       	ror	r14
    1812:	d7 94       	ror	r13
    1814:	c7 94       	ror	r12
    1816:	9a 95       	dec	r25
    1818:	d1 f7       	brne	.-12     	; 0x180e <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x586>
    181a:	81 e0       	ldi	r24, 0x01	; 1
    181c:	c8 1a       	sub	r12, r24
    181e:	d1 08       	sbc	r13, r1
    1820:	e1 08       	sbc	r14, r1
    1822:	f1 08       	sbc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:292
              prescalarbits = _timer == 0 ? 0b101 : 0b111;
    1824:	87 e0       	ldi	r24, 0x07	; 7
    1826:	45 cf       	rjmp	.-374    	; 0x16b2 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:362
    }

    // Set the OCR for the given timer,
    // set the toggle count,
    // then turn on the interrupts
    switch (_timer)
    1828:	8d 81       	ldd	r24, Y+5	; 0x05
    182a:	84 30       	cpi	r24, 0x04	; 4
    182c:	59 f2       	breq	.-106    	; 0x17c4 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x53c>
    182e:	0c f4       	brge	.+2      	; 0x1832 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x5aa>
    1830:	b7 cf       	rjmp	.-146    	; 0x17a0 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x518>
    1832:	85 30       	cpi	r24, 0x05	; 5
    1834:	09 f0       	breq	.+2      	; 0x1838 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x5b0>
    1836:	49 cd       	rjmp	.-1390   	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:412
        break;
#endif

#if defined(OCR5A) && defined(TIMSK5) && defined(OCIE5A)
      case 5:
        OCR5A = ocr;
    1838:	d0 92 29 01 	sts	0x0129, r13	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    183c:	c0 92 28 01 	sts	0x0128, r12	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:413
        timer5_toggle_count = toggle_count;
    1840:	20 93 05 0c 	sts	0x0C05, r18	; 0x800c05 <timer5_toggle_count>
    1844:	30 93 06 0c 	sts	0x0C06, r19	; 0x800c06 <timer5_toggle_count+0x1>
    1848:	40 93 07 0c 	sts	0x0C07, r20	; 0x800c07 <timer5_toggle_count+0x2>
    184c:	50 93 08 0c 	sts	0x0C08, r21	; 0x800c08 <timer5_toggle_count+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:414
        bitWrite(TIMSK5, OCIE5A, 1);
    1850:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
    1854:	82 60       	ori	r24, 0x02	; 2
    1856:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
    185a:	37 cd       	rjmp	.-1426   	; 0x12ca <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:284
          {
            ocr = F_CPU / frequency / 2 / 128 - 1;
            prescalarbits = 0b101;
          }

          if (ocr > 255)
    185c:	9f ef       	ldi	r25, 0xFF	; 255
    185e:	c9 16       	cp	r12, r25
    1860:	d1 04       	cpc	r13, r1
    1862:	e1 04       	cpc	r14, r1
    1864:	f1 04       	cpc	r15, r1
    1866:	11 f0       	breq	.+4      	; 0x186c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x5e4>
    1868:	0c f0       	brlt	.+2      	; 0x186c <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x5e4>
    186a:	d4 ce       	rjmp	.-600    	; 0x1614 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x38c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:276
        }

        if (ocr > 255)
        {
          ocr = F_CPU / frequency / 2 / 64 - 1;
          prescalarbits = _timer == 0 ? 0b011 : 0b100;
    186c:	93 e0       	ldi	r25, 0x03	; 3
    186e:	ea ce       	rjmp	.-556    	; 0x1644 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]+0x3bc>

00001870 <analogWrite>:
analogWrite():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:105
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
    1870:	1f 93       	push	r17
    1872:	cf 93       	push	r28
    1874:	df 93       	push	r29
    1876:	18 2f       	mov	r17, r24
    1878:	eb 01       	movw	r28, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:111
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
    187a:	61 e0       	ldi	r22, 0x01	; 1
    187c:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:112
	if (val == 0)
    1880:	20 97       	sbiw	r28, 0x00	; 0
    1882:	39 f4       	brne	.+14     	; 0x1892 <analogWrite+0x22>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:114
	{
		digitalWrite(pin, LOW);
    1884:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:118
	}
	else if (val == 255)
	{
		digitalWrite(pin, HIGH);
    1886:	81 2f       	mov	r24, r17
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:293
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    1888:	df 91       	pop	r29
    188a:	cf 91       	pop	r28
    188c:	1f 91       	pop	r17
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:118
	{
		digitalWrite(pin, LOW);
	}
	else if (val == 255)
	{
		digitalWrite(pin, HIGH);
    188e:	0c 94 3f 08 	jmp	0x107e	; 0x107e <digitalWrite>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:116
	pinMode(pin, OUTPUT);
	if (val == 0)
	{
		digitalWrite(pin, LOW);
	}
	else if (val == 255)
    1892:	cf 3f       	cpi	r28, 0xFF	; 255
    1894:	d1 05       	cpc	r29, r1
    1896:	11 f4       	brne	.+4      	; 0x189c <analogWrite+0x2c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:118
	{
		digitalWrite(pin, HIGH);
    1898:	61 e0       	ldi	r22, 0x01	; 1
    189a:	f5 cf       	rjmp	.-22     	; 0x1886 <analogWrite+0x16>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:122
	}
	else
	{
		switch(digitalPinToTimer(pin))
    189c:	e1 2f       	mov	r30, r17
    189e:	f0 e0       	ldi	r31, 0x00	; 0
    18a0:	ef 5e       	subi	r30, 0xEF	; 239
    18a2:	fb 4f       	sbci	r31, 0xFB	; 251
    18a4:	e4 91       	lpm	r30, Z
    18a6:	e1 50       	subi	r30, 0x01	; 1
    18a8:	e2 31       	cpi	r30, 0x12	; 18
    18aa:	08 f0       	brcs	.+2      	; 0x18ae <analogWrite+0x3e>
    18ac:	b3 c0       	rjmp	.+358    	; 0x1a14 <analogWrite+0x1a4>
    18ae:	f0 e0       	ldi	r31, 0x00	; 0
    18b0:	88 27       	eor	r24, r24
    18b2:	e2 5a       	subi	r30, 0xA2	; 162
    18b4:	f3 4f       	sbci	r31, 0xF3	; 243
    18b6:	8f 4f       	sbci	r24, 0xFF	; 255
    18b8:	0c 94 2b 6c 	jmp	0xd856	; 0xd856 <__tablejump2__>
    18bc:	70 0c       	add	r7, r0
    18be:	78 0c       	add	r7, r8
    18c0:	7d 0c       	add	r7, r13
    18c2:	87 0c       	add	r8, r7
    18c4:	91 0c       	add	r9, r1
    18c6:	0a 0d       	add	r16, r10
    18c8:	9b 0c       	add	r9, r11
    18ca:	a3 0c       	add	r10, r3
    18cc:	ab 0c       	add	r10, r11
    18ce:	b5 0c       	add	r11, r5
    18d0:	bf 0c       	add	r11, r15
    18d2:	c9 0c       	add	r12, r9
    18d4:	d8 0c       	add	r13, r8
    18d6:	e2 0c       	add	r14, r2
    18d8:	0a 0d       	add	r16, r10
    18da:	ec 0c       	add	r14, r12
    18dc:	f6 0c       	add	r15, r6
    18de:	00 0d       	add	r16, r0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:136
			#endif

			#if defined(TCCR0A) && defined(COM0A1)
			case TIMER0A:
				// connect pwm to pin on timer 0, channel A
				sbi(TCCR0A, COM0A1);
    18e0:	84 b5       	in	r24, 0x24	; 36
    18e2:	80 68       	ori	r24, 0x80	; 128
    18e4:	84 bd       	out	0x24, r24	; 36
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:137
				OCR0A = val; // set pwm duty
    18e6:	c7 bd       	out	0x27, r28	; 39
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:293
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    18e8:	df 91       	pop	r29
    18ea:	cf 91       	pop	r28
    18ec:	1f 91       	pop	r17
    18ee:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:144
			#endif

			#if defined(TCCR0A) && defined(COM0B1)
			case TIMER0B:
				// connect pwm to pin on timer 0, channel B
				sbi(TCCR0A, COM0B1);
    18f0:	84 b5       	in	r24, 0x24	; 36
    18f2:	80 62       	ori	r24, 0x20	; 32
    18f4:	84 bd       	out	0x24, r24	; 36
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:145
				OCR0B = val; // set pwm duty
    18f6:	c8 bd       	out	0x28, r28	; 40
    18f8:	f7 cf       	rjmp	.-18     	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:152
			#endif

			#if defined(TCCR1A) && defined(COM1A1)
			case TIMER1A:
				// connect pwm to pin on timer 1, channel A
				sbi(TCCR1A, COM1A1);
    18fa:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    18fe:	80 68       	ori	r24, 0x80	; 128
    1900:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:153
				OCR1A = val; // set pwm duty
    1904:	d0 93 89 00 	sts	0x0089, r29	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1908:	c0 93 88 00 	sts	0x0088, r28	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
    190c:	ed cf       	rjmp	.-38     	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:160
			#endif

			#if defined(TCCR1A) && defined(COM1B1)
			case TIMER1B:
				// connect pwm to pin on timer 1, channel B
				sbi(TCCR1A, COM1B1);
    190e:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1912:	80 62       	ori	r24, 0x20	; 32
    1914:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:161
				OCR1B = val; // set pwm duty
    1918:	d0 93 8b 00 	sts	0x008B, r29	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    191c:	c0 93 8a 00 	sts	0x008A, r28	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    1920:	e3 cf       	rjmp	.-58     	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:168
			#endif

			#if defined(TCCR1A) && defined(COM1C1)
			case TIMER1C:
				// connect pwm to pin on timer 1, channel C
				sbi(TCCR1A, COM1C1);
    1922:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1926:	88 60       	ori	r24, 0x08	; 8
    1928:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:169
				OCR1C = val; // set pwm duty
    192c:	d0 93 8d 00 	sts	0x008D, r29	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    1930:	c0 93 8c 00 	sts	0x008C, r28	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    1934:	d9 cf       	rjmp	.-78     	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:184
			#endif

			#if defined(TCCR2A) && defined(COM2A1)
			case TIMER2A:
				// connect pwm to pin on timer 2, channel A
				sbi(TCCR2A, COM2A1);
    1936:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
    193a:	80 68       	ori	r24, 0x80	; 128
    193c:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:185
				OCR2A = val; // set pwm duty
    1940:	c0 93 b3 00 	sts	0x00B3, r28	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    1944:	d1 cf       	rjmp	.-94     	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:192
			#endif

			#if defined(TCCR2A) && defined(COM2B1)
			case TIMER2B:
				// connect pwm to pin on timer 2, channel B
				sbi(TCCR2A, COM2B1);
    1946:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
    194a:	80 62       	ori	r24, 0x20	; 32
    194c:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:193
				OCR2B = val; // set pwm duty
    1950:	c0 93 b4 00 	sts	0x00B4, r28	; 0x8000b4 <__TEXT_REGION_LENGTH__+0x7000b4>
    1954:	c9 cf       	rjmp	.-110    	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:200
			#endif

			#if defined(TCCR3A) && defined(COM3A1)
			case TIMER3A:
				// connect pwm to pin on timer 3, channel A
				sbi(TCCR3A, COM3A1);
    1956:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
    195a:	80 68       	ori	r24, 0x80	; 128
    195c:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:201
				OCR3A = val; // set pwm duty
    1960:	d0 93 99 00 	sts	0x0099, r29	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    1964:	c0 93 98 00 	sts	0x0098, r28	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
    1968:	bf cf       	rjmp	.-130    	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:208
			#endif

			#if defined(TCCR3A) && defined(COM3B1)
			case TIMER3B:
				// connect pwm to pin on timer 3, channel B
				sbi(TCCR3A, COM3B1);
    196a:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
    196e:	80 62       	ori	r24, 0x20	; 32
    1970:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:209
				OCR3B = val; // set pwm duty
    1974:	d0 93 9b 00 	sts	0x009B, r29	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
    1978:	c0 93 9a 00 	sts	0x009A, r28	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
    197c:	b5 cf       	rjmp	.-150    	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:216
			#endif

			#if defined(TCCR3A) && defined(COM3C1)
			case TIMER3C:
				// connect pwm to pin on timer 3, channel C
				sbi(TCCR3A, COM3C1);
    197e:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
    1982:	88 60       	ori	r24, 0x08	; 8
    1984:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:217
				OCR3C = val; // set pwm duty
    1988:	d0 93 9d 00 	sts	0x009D, r29	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
    198c:	c0 93 9c 00 	sts	0x009C, r28	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
    1990:	ab cf       	rjmp	.-170    	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:224
			#endif

			#if defined(TCCR4A)
			case TIMER4A:
				//connect pwm to pin on timer 4, channel A
				sbi(TCCR4A, COM4A1);
    1992:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    1996:	80 68       	ori	r24, 0x80	; 128
    1998:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:226
				#if defined(COM4A0)		// only used on 32U4
				cbi(TCCR4A, COM4A0);
    199c:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    19a0:	8f 7b       	andi	r24, 0xBF	; 191
    19a2:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:228
				#endif
				OCR4A = val;	// set pwm duty
    19a6:	d0 93 a9 00 	sts	0x00A9, r29	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7000a9>
    19aa:	c0 93 a8 00 	sts	0x00A8, r28	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7000a8>
    19ae:	9c cf       	rjmp	.-200    	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:235
			#endif
			
			#if defined(TCCR4A) && defined(COM4B1)
			case TIMER4B:
				// connect pwm to pin on timer 4, channel B
				sbi(TCCR4A, COM4B1);
    19b0:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    19b4:	80 62       	ori	r24, 0x20	; 32
    19b6:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:236
				OCR4B = val; // set pwm duty
    19ba:	d0 93 ab 00 	sts	0x00AB, r29	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    19be:	c0 93 aa 00 	sts	0x00AA, r28	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    19c2:	92 cf       	rjmp	.-220    	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:243
			#endif

			#if defined(TCCR4A) && defined(COM4C1)
			case TIMER4C:
				// connect pwm to pin on timer 4, channel C
				sbi(TCCR4A, COM4C1);
    19c4:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    19c8:	88 60       	ori	r24, 0x08	; 8
    19ca:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:244
				OCR4C = val; // set pwm duty
    19ce:	d0 93 ad 00 	sts	0x00AD, r29	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7000ad>
    19d2:	c0 93 ac 00 	sts	0x00AC, r28	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7000ac>
    19d6:	88 cf       	rjmp	.-240    	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:263

							
			#if defined(TCCR5A) && defined(COM5A1)
			case TIMER5A:
				// connect pwm to pin on timer 5, channel A
				sbi(TCCR5A, COM5A1);
    19d8:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
    19dc:	80 68       	ori	r24, 0x80	; 128
    19de:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:264
				OCR5A = val; // set pwm duty
    19e2:	d0 93 29 01 	sts	0x0129, r29	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    19e6:	c0 93 28 01 	sts	0x0128, r28	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
    19ea:	7e cf       	rjmp	.-260    	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:271
			#endif

			#if defined(TCCR5A) && defined(COM5B1)
			case TIMER5B:
				// connect pwm to pin on timer 5, channel B
				sbi(TCCR5A, COM5B1);
    19ec:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
    19f0:	80 62       	ori	r24, 0x20	; 32
    19f2:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:272
				OCR5B = val; // set pwm duty
    19f6:	d0 93 2b 01 	sts	0x012B, r29	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    19fa:	c0 93 2a 01 	sts	0x012A, r28	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
    19fe:	74 cf       	rjmp	.-280    	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:279
			#endif

			#if defined(TCCR5A) && defined(COM5C1)
			case TIMER5C:
				// connect pwm to pin on timer 5, channel C
				sbi(TCCR5A, COM5C1);
    1a00:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
    1a04:	88 60       	ori	r24, 0x08	; 8
    1a06:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:280
				OCR5C = val; // set pwm duty
    1a0a:	d0 93 2d 01 	sts	0x012D, r29	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1a0e:	c0 93 2c 01 	sts	0x012C, r28	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1a12:	6a cf       	rjmp	.-300    	; 0x18e8 <analogWrite+0x78>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:286
				break;
			#endif

			case NOT_ON_TIMER:
			default:
				if (val < 128) {
    1a14:	c0 38       	cpi	r28, 0x80	; 128
    1a16:	d1 05       	cpc	r29, r1
    1a18:	0c f0       	brlt	.+2      	; 0x1a1c <analogWrite+0x1ac>
    1a1a:	3e cf       	rjmp	.-388    	; 0x1898 <analogWrite+0x28>
    1a1c:	33 cf       	rjmp	.-410    	; 0x1884 <analogWrite+0x14>

00001a1e <micros>:
micros():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:81
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    1a1e:	3f b7       	in	r19, 0x3f	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:83
	
	cli();
    1a20:	f8 94       	cli
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:84
	m = timer0_overflow_count;
    1a22:	80 91 d6 09 	lds	r24, 0x09D6	; 0x8009d6 <timer0_overflow_count>
    1a26:	90 91 d7 09 	lds	r25, 0x09D7	; 0x8009d7 <timer0_overflow_count+0x1>
    1a2a:	a0 91 d8 09 	lds	r26, 0x09D8	; 0x8009d8 <timer0_overflow_count+0x2>
    1a2e:	b0 91 d9 09 	lds	r27, 0x09D9	; 0x8009d9 <timer0_overflow_count+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:86
#if defined(TCNT0)
	t = TCNT0;
    1a32:	26 b5       	in	r18, 0x26	; 38
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:94
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    1a34:	a8 9b       	sbis	0x15, 0	; 21
    1a36:	05 c0       	rjmp	.+10     	; 0x1a42 <micros+0x24>
    1a38:	2f 3f       	cpi	r18, 0xFF	; 255
    1a3a:	19 f0       	breq	.+6      	; 0x1a42 <micros+0x24>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:95
		m++;
    1a3c:	01 96       	adiw	r24, 0x01	; 1
    1a3e:	a1 1d       	adc	r26, r1
    1a40:	b1 1d       	adc	r27, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:101
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    1a42:	3f bf       	out	0x3f, r19	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:103
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    1a44:	ba 2f       	mov	r27, r26
    1a46:	a9 2f       	mov	r26, r25
    1a48:	98 2f       	mov	r25, r24
    1a4a:	88 27       	eor	r24, r24
    1a4c:	bc 01       	movw	r22, r24
    1a4e:	cd 01       	movw	r24, r26
    1a50:	62 0f       	add	r22, r18
    1a52:	71 1d       	adc	r23, r1
    1a54:	81 1d       	adc	r24, r1
    1a56:	91 1d       	adc	r25, r1
    1a58:	42 e0       	ldi	r20, 0x02	; 2
    1a5a:	66 0f       	add	r22, r22
    1a5c:	77 1f       	adc	r23, r23
    1a5e:	88 1f       	adc	r24, r24
    1a60:	99 1f       	adc	r25, r25
    1a62:	4a 95       	dec	r20
    1a64:	d1 f7       	brne	.-12     	; 0x1a5a <micros+0x3c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:104
}
    1a66:	08 95       	ret

00001a68 <delay>:
delay():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:107

void delay(unsigned long ms)
{
    1a68:	8f 92       	push	r8
    1a6a:	9f 92       	push	r9
    1a6c:	af 92       	push	r10
    1a6e:	bf 92       	push	r11
    1a70:	cf 92       	push	r12
    1a72:	df 92       	push	r13
    1a74:	ef 92       	push	r14
    1a76:	ff 92       	push	r15
    1a78:	4b 01       	movw	r8, r22
    1a7a:	5c 01       	movw	r10, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:108
	uint32_t start = micros();
    1a7c:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    1a80:	6b 01       	movw	r12, r22
    1a82:	7c 01       	movw	r14, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:112

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    1a84:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    1a88:	6c 19       	sub	r22, r12
    1a8a:	7d 09       	sbc	r23, r13
    1a8c:	8e 09       	sbc	r24, r14
    1a8e:	9f 09       	sbc	r25, r15
    1a90:	68 3e       	cpi	r22, 0xE8	; 232
    1a92:	73 40       	sbci	r23, 0x03	; 3
    1a94:	81 05       	cpc	r24, r1
    1a96:	91 05       	cpc	r25, r1
    1a98:	a8 f3       	brcs	.-22     	; 0x1a84 <delay+0x1c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:113
			ms--;
    1a9a:	21 e0       	ldi	r18, 0x01	; 1
    1a9c:	82 1a       	sub	r8, r18
    1a9e:	91 08       	sbc	r9, r1
    1aa0:	a1 08       	sbc	r10, r1
    1aa2:	b1 08       	sbc	r11, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:114
			start += 1000;
    1aa4:	88 ee       	ldi	r24, 0xE8	; 232
    1aa6:	c8 0e       	add	r12, r24
    1aa8:	83 e0       	ldi	r24, 0x03	; 3
    1aaa:	d8 1e       	adc	r13, r24
    1aac:	e1 1c       	adc	r14, r1
    1aae:	f1 1c       	adc	r15, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:112
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    1ab0:	81 14       	cp	r8, r1
    1ab2:	91 04       	cpc	r9, r1
    1ab4:	a1 04       	cpc	r10, r1
    1ab6:	b1 04       	cpc	r11, r1
    1ab8:	29 f7       	brne	.-54     	; 0x1a84 <delay+0x1c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:117
			ms--;
			start += 1000;
		}
	}
}
    1aba:	ff 90       	pop	r15
    1abc:	ef 90       	pop	r14
    1abe:	df 90       	pop	r13
    1ac0:	cf 90       	pop	r12
    1ac2:	bf 90       	pop	r11
    1ac4:	af 90       	pop	r10
    1ac6:	9f 90       	pop	r9
    1ac8:	8f 90       	pop	r8
    1aca:	08 95       	ret

00001acc <millis>:
millis():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:68
}

unsigned long millis()
{
	unsigned long m;
	uint8_t oldSREG = SREG;
    1acc:	2f b7       	in	r18, 0x3f	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:72

	// disable interrupts while we read timer0_millis or we might get an
	// inconsistent value (e.g. in the middle of a write to timer0_millis)
	cli();
    1ace:	f8 94       	cli
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:73
	m = timer0_millis;
    1ad0:	60 91 d2 09 	lds	r22, 0x09D2	; 0x8009d2 <timer0_millis>
    1ad4:	70 91 d3 09 	lds	r23, 0x09D3	; 0x8009d3 <timer0_millis+0x1>
    1ad8:	80 91 d4 09 	lds	r24, 0x09D4	; 0x8009d4 <timer0_millis+0x2>
    1adc:	90 91 d5 09 	lds	r25, 0x09D5	; 0x8009d5 <timer0_millis+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:74
	SREG = oldSREG;
    1ae0:	2f bf       	out	0x3f, r18	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:77

	return m;
}
    1ae2:	08 95       	ret

00001ae4 <date2days(unsigned int, unsigned char, unsigned char)>:
date2days():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:128
    @param m Month
    @param d Day
    @return Number of days
*/
/**************************************************************************/
static uint16_t date2days(uint16_t y, uint8_t m, uint8_t d) {
    1ae4:	dc 01       	movw	r26, r24
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:131
  if (y >= 2000U)
    y -= 2000U;
  uint16_t days = d;
    1ae6:	50 e0       	ldi	r21, 0x00	; 0
    1ae8:	e2 ed       	ldi	r30, 0xD2	; 210
    1aea:	f3 e0       	ldi	r31, 0x03	; 3
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:132
  for (uint8_t i = 1; i < m; ++i)
    1aec:	81 e0       	ldi	r24, 0x01	; 1
    1aee:	86 17       	cp	r24, r22
    1af0:	30 f4       	brcc	.+12     	; 0x1afe <date2days(unsigned int, unsigned char, unsigned char)+0x1a>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:133
    days += pgm_read_byte(daysInMonth + i - 1);
    1af2:	94 91       	lpm	r25, Z
    1af4:	49 0f       	add	r20, r25
    1af6:	51 1d       	adc	r21, r1
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:132
/**************************************************************************/
static uint16_t date2days(uint16_t y, uint8_t m, uint8_t d) {
  if (y >= 2000U)
    y -= 2000U;
  uint16_t days = d;
  for (uint8_t i = 1; i < m; ++i)
    1af8:	8f 5f       	subi	r24, 0xFF	; 255
    1afa:	31 96       	adiw	r30, 0x01	; 1
    1afc:	f8 cf       	rjmp	.-16     	; 0x1aee <date2days(unsigned int, unsigned char, unsigned char)+0xa>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:134
    days += pgm_read_byte(daysInMonth + i - 1);
  if (m > 2 && y % 4 == 0)
    1afe:	63 30       	cpi	r22, 0x03	; 3
    1b00:	38 f0       	brcs	.+14     	; 0x1b10 <date2days(unsigned int, unsigned char, unsigned char)+0x2c>
    1b02:	cd 01       	movw	r24, r26
    1b04:	83 70       	andi	r24, 0x03	; 3
    1b06:	99 27       	eor	r25, r25
    1b08:	89 2b       	or	r24, r25
    1b0a:	11 f4       	brne	.+4      	; 0x1b10 <date2days(unsigned int, unsigned char, unsigned char)+0x2c>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:135
    ++days;
    1b0c:	4f 5f       	subi	r20, 0xFF	; 255
    1b0e:	5f 4f       	sbci	r21, 0xFF	; 255
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:136
  return days + 365 * y + (y + 3) / 4 - 1;
    1b10:	9d 01       	movw	r18, r26
    1b12:	2d 5f       	subi	r18, 0xFD	; 253
    1b14:	3f 4f       	sbci	r19, 0xFF	; 255
    1b16:	36 95       	lsr	r19
    1b18:	27 95       	ror	r18
    1b1a:	36 95       	lsr	r19
    1b1c:	27 95       	ror	r18
    1b1e:	6d e6       	ldi	r22, 0x6D	; 109
    1b20:	71 e0       	ldi	r23, 0x01	; 1
    1b22:	a6 9f       	mul	r26, r22
    1b24:	c0 01       	movw	r24, r0
    1b26:	a7 9f       	mul	r26, r23
    1b28:	90 0d       	add	r25, r0
    1b2a:	b6 9f       	mul	r27, r22
    1b2c:	90 0d       	add	r25, r0
    1b2e:	11 24       	eor	r1, r1
    1b30:	01 97       	sbiw	r24, 0x01	; 1
    1b32:	82 0f       	add	r24, r18
    1b34:	93 1f       	adc	r25, r19
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:137
}
    1b36:	84 0f       	add	r24, r20
    1b38:	95 1f       	adc	r25, r21
    1b3a:	08 95       	ret

00001b3c <SPIClass::begin()>:
begin():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:27
#ifdef SPI_TRANSACTION_MISMATCH_LED
uint8_t SPIClass::inTransactionFlag = 0;
#endif

void SPIClass::begin()
{
    1b3c:	cf 93       	push	r28
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:28
  uint8_t sreg = SREG;
    1b3e:	cf b7       	in	r28, 0x3f	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:29
  noInterrupts(); // Protect from a scheduler and prevent transactionBegin
    1b40:	f8 94       	cli
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:30
  if (!initialized) {
    1b42:	80 91 d0 09 	lds	r24, 0x09D0	; 0x8009d0 <SPIClass::initialized>
    1b46:	81 11       	cpse	r24, r1
    1b48:	27 c0       	rjmp	.+78     	; 0x1b98 <SPIClass::begin()+0x5c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:32
    // Set SS to high so a connected chip will be "deselected" by default
    uint8_t port = digitalPinToPort(SS);
    1b4a:	ee e6       	ldi	r30, 0x6E	; 110
    1b4c:	f6 e0       	ldi	r31, 0x06	; 6
    1b4e:	84 91       	lpm	r24, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:33
    uint8_t bit = digitalPinToBitMask(SS);
    1b50:	ee e0       	ldi	r30, 0x0E	; 14
    1b52:	f6 e0       	ldi	r31, 0x06	; 6
    1b54:	94 91       	lpm	r25, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:34
    volatile uint8_t *reg = portModeRegister(port);
    1b56:	e8 2f       	mov	r30, r24
    1b58:	f0 e0       	ldi	r31, 0x00	; 0
    1b5a:	ee 0f       	add	r30, r30
    1b5c:	ff 1f       	adc	r31, r31
    1b5e:	e3 52       	subi	r30, 0x23	; 35
    1b60:	fc 4f       	sbci	r31, 0xFC	; 252
    1b62:	a5 91       	lpm	r26, Z+
    1b64:	b4 91       	lpm	r27, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:38

    // if the SS pin is not already configured as an output
    // then set it high (to enable the internal pull-up resistor)
    if(!(*reg & bit)){
    1b66:	ec 91       	ld	r30, X
    1b68:	e9 23       	and	r30, r25
    1b6a:	21 f4       	brne	.+8      	; 0x1b74 <SPIClass::begin()+0x38>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:39
      digitalWrite(SS, HIGH);
    1b6c:	61 e0       	ldi	r22, 0x01	; 1
    1b6e:	85 e3       	ldi	r24, 0x35	; 53
    1b70:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:45
    }

    // When the SS pin is set as OUTPUT, it can be used as
    // a general purpose output port (it doesn't influence
    // SPI operations).
    pinMode(SS, OUTPUT);
    1b74:	61 e0       	ldi	r22, 0x01	; 1
    1b76:	85 e3       	ldi	r24, 0x35	; 53
    1b78:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:50

    // Warning: if the SS pin ever becomes a LOW INPUT then SPI
    // automatically switches to Slave, so the data direction of
    // the SS pin MUST be kept as OUTPUT.
    SPCR |= _BV(MSTR);
    1b7c:	8c b5       	in	r24, 0x2c	; 44
    1b7e:	80 61       	ori	r24, 0x10	; 16
    1b80:	8c bd       	out	0x2c, r24	; 44
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:51
    SPCR |= _BV(SPE);
    1b82:	8c b5       	in	r24, 0x2c	; 44
    1b84:	80 64       	ori	r24, 0x40	; 64
    1b86:	8c bd       	out	0x2c, r24	; 44
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:59
    // MISO pin automatically overrides to INPUT.
    // By doing this AFTER enabling SPI, we avoid accidentally
    // clocking in a single bit since the lines go directly
    // from "input" to SPI control.
    // http://code.google.com/p/arduino/issues/detail?id=888
    pinMode(SCK, OUTPUT);
    1b88:	61 e0       	ldi	r22, 0x01	; 1
    1b8a:	84 e3       	ldi	r24, 0x34	; 52
    1b8c:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:60
    pinMode(MOSI, OUTPUT);
    1b90:	61 e0       	ldi	r22, 0x01	; 1
    1b92:	83 e3       	ldi	r24, 0x33	; 51
    1b94:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:62
  }
  initialized++; // reference count
    1b98:	80 91 d0 09 	lds	r24, 0x09D0	; 0x8009d0 <SPIClass::initialized>
    1b9c:	8f 5f       	subi	r24, 0xFF	; 255
    1b9e:	80 93 d0 09 	sts	0x09D0, r24	; 0x8009d0 <SPIClass::initialized>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:63
  SREG = sreg;
    1ba2:	cf bf       	out	0x3f, r28	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.cpp:64
}
    1ba4:	cf 91       	pop	r28
    1ba6:	08 95       	ret

00001ba8 <SPIClass::endTransaction()>:
endTransaction():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:284
      #endif
      {
        SREG = interruptSave;
      }
    }
  }
    1ba8:	08 95       	ret

00001baa <Sd2Card::chipSelectHigh()>:
chipSelectHigh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:178
}
//------------------------------------------------------------------------------
static uint8_t chip_select_asserted = 0;

void Sd2Card::chipSelectHigh(void) {
  digitalWrite(chipSelectPin_, HIGH);
    1baa:	61 e0       	ldi	r22, 0x01	; 1
    1bac:	fc 01       	movw	r30, r24
    1bae:	84 81       	ldd	r24, Z+4	; 0x04
    1bb0:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:180
  #ifdef USE_SPI_LIB
  if (chip_select_asserted) {
    1bb4:	80 91 ca 09 	lds	r24, 0x09CA	; 0x8009ca <chip_select_asserted>
    1bb8:	81 11       	cpse	r24, r1
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:181
    chip_select_asserted = 0;
    1bba:	10 92 ca 09 	sts	0x09CA, r1	; 0x8009ca <chip_select_asserted>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:185
    SDCARD_SPI.endTransaction();
  }
  #endif
}
    1bbe:	08 95       	ret

00001bc0 <SPIClass::transfer(unsigned char)>:
transfer():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:209
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
    1bc0:	8e bd       	out	0x2e, r24	; 46
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:216
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
    1bc2:	00 00       	nop
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:217
    while (!(SPSR & _BV(SPIF))) ; // wait
    1bc4:	0d b4       	in	r0, 0x2d	; 45
    1bc6:	07 fe       	sbrs	r0, 7
    1bc8:	fd cf       	rjmp	.-6      	; 0x1bc4 <SPIClass::transfer(unsigned char)+0x4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:218
    return SPDR;
    1bca:	8e b5       	in	r24, 0x2e	; 46
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:219
  }
    1bcc:	08 95       	ret

00001bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>:
spixfer():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:183
 *   @brief  Encapsulate hardware and software SPI transfer into one
 * function
 *   @param x the data byte to transfer
 *   @returns the data byte read from the device
 */
uint8_t Adafruit_BME280::spixfer(uint8_t x) {
    1bce:	ef 92       	push	r14
    1bd0:	ff 92       	push	r15
    1bd2:	0f 93       	push	r16
    1bd4:	1f 93       	push	r17
    1bd6:	cf 93       	push	r28
    1bd8:	df 93       	push	r29
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:185
  // hardware SPI
  if (_sck == -1)
    1bda:	90 91 dd 10 	lds	r25, 0x10DD	; 0x8010dd <bme280+0x16>
    1bde:	9f 3f       	cpi	r25, 0xFF	; 255
    1be0:	41 f4       	brne	.+16     	; 0x1bf2 <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]+0x24>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:199
    digitalWrite(_sck, HIGH);
    if (digitalRead(_miso))
      reply |= 1;
  }
  return reply;
}
    1be2:	df 91       	pop	r29
    1be4:	cf 91       	pop	r28
    1be6:	1f 91       	pop	r17
    1be8:	0f 91       	pop	r16
    1bea:	ff 90       	pop	r15
    1bec:	ef 90       	pop	r14
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:186
 *   @returns the data byte read from the device
 */
uint8_t Adafruit_BME280::spixfer(uint8_t x) {
  // hardware SPI
  if (_sck == -1)
    return _spi->transfer(x);
    1bee:	0c 94 e0 0d 	jmp	0x1bc0	; 0x1bc0 <SPIClass::transfer(unsigned char)>
    1bf2:	d8 2f       	mov	r29, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:189

  // software SPI
  uint8_t reply = 0;
    1bf4:	c0 e0       	ldi	r28, 0x00	; 0
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:190
  for (int i = 7; i >= 0; i--) {
    1bf6:	07 e0       	ldi	r16, 0x07	; 7
    1bf8:	10 e0       	ldi	r17, 0x00	; 0
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:193
    reply <<= 1;
    digitalWrite(_sck, LOW);
    digitalWrite(_mosi, x & (1 << i));
    1bfa:	ee 24       	eor	r14, r14
    1bfc:	e3 94       	inc	r14
    1bfe:	f1 2c       	mov	r15, r1
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:191
    return _spi->transfer(x);

  // software SPI
  uint8_t reply = 0;
  for (int i = 7; i >= 0; i--) {
    reply <<= 1;
    1c00:	cc 0f       	add	r28, r28
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:192
    digitalWrite(_sck, LOW);
    1c02:	60 e0       	ldi	r22, 0x00	; 0
    1c04:	80 91 dd 10 	lds	r24, 0x10DD	; 0x8010dd <bme280+0x16>
    1c08:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:193
    digitalWrite(_mosi, x & (1 << i));
    1c0c:	b7 01       	movw	r22, r14
    1c0e:	00 2e       	mov	r0, r16
    1c10:	01 c0       	rjmp	.+2      	; 0x1c14 <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]+0x46>
    1c12:	66 0f       	add	r22, r22
    1c14:	0a 94       	dec	r0
    1c16:	ea f7       	brpl	.-6      	; 0x1c12 <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]+0x44>
    1c18:	6d 23       	and	r22, r29
    1c1a:	80 91 db 10 	lds	r24, 0x10DB	; 0x8010db <bme280+0x14>
    1c1e:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:194
    digitalWrite(_sck, HIGH);
    1c22:	61 e0       	ldi	r22, 0x01	; 1
    1c24:	80 91 dd 10 	lds	r24, 0x10DD	; 0x8010dd <bme280+0x16>
    1c28:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:195
    if (digitalRead(_miso))
    1c2c:	80 91 dc 10 	lds	r24, 0x10DC	; 0x8010dc <bme280+0x15>
    1c30:	0e 94 16 08 	call	0x102c	; 0x102c <digitalRead>
    1c34:	89 2b       	or	r24, r25
    1c36:	09 f0       	breq	.+2      	; 0x1c3a <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]+0x6c>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:196
      reply |= 1;
    1c38:	c1 60       	ori	r28, 0x01	; 1
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:190
  if (_sck == -1)
    return _spi->transfer(x);

  // software SPI
  uint8_t reply = 0;
  for (int i = 7; i >= 0; i--) {
    1c3a:	01 50       	subi	r16, 0x01	; 1
    1c3c:	11 09       	sbc	r17, r1
    1c3e:	00 f7       	brcc	.-64     	; 0x1c00 <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]+0x32>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:199
    digitalWrite(_sck, HIGH);
    if (digitalRead(_miso))
      reply |= 1;
  }
  return reply;
}
    1c40:	8c 2f       	mov	r24, r28
    1c42:	df 91       	pop	r29
    1c44:	cf 91       	pop	r28
    1c46:	1f 91       	pop	r17
    1c48:	0f 91       	pop	r16
    1c4a:	ff 90       	pop	r15
    1c4c:	ef 90       	pop	r14
    1c4e:	08 95       	ret

00001c50 <spiRec()>:
spiRec():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:51
static  uint8_t spiRec(void) {
  #ifndef USE_SPI_LIB
  spiSend(0XFF);
  return SPDR;
  #else
  return SDCARD_SPI.transfer(0xFF);
    1c50:	8f ef       	ldi	r24, 0xFF	; 255
    1c52:	0c 94 e0 0d 	jmp	0x1bc0	; 0x1bc0 <SPIClass::transfer(unsigned char)>

00001c56 <Sd2Card::waitNotBusy(unsigned int) [clone .constprop.161]>:
waitNotBusy():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:573
  return true;
}
#endif
//------------------------------------------------------------------------------
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
    1c56:	0f 93       	push	r16
    1c58:	1f 93       	push	r17
    1c5a:	cf 93       	push	r28
    1c5c:	df 93       	push	r29
    1c5e:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:574
  unsigned int t0 = millis();
    1c60:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    1c64:	8b 01       	movw	r16, r22
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:577
  unsigned int d;
  do {
    if (spiRec() == 0XFF) {
    1c66:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    1c6a:	8f 3f       	cpi	r24, 0xFF	; 255
    1c6c:	69 f0       	breq	.+26     	; 0x1c88 <Sd2Card::waitNotBusy(unsigned int) [clone .constprop.161]+0x32>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:580
      return true;
    }
    d = millis() - t0;
    1c6e:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    1c72:	60 1b       	sub	r22, r16
    1c74:	71 0b       	sbc	r23, r17
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:581
  } while (d < timeoutMillis);
    1c76:	6c 17       	cp	r22, r28
    1c78:	7d 07       	cpc	r23, r29
    1c7a:	a8 f3       	brcs	.-22     	; 0x1c66 <Sd2Card::waitNotBusy(unsigned int) [clone .constprop.161]+0x10>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:582
  return false;
    1c7c:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:583
}
    1c7e:	df 91       	pop	r29
    1c80:	cf 91       	pop	r28
    1c82:	1f 91       	pop	r17
    1c84:	0f 91       	pop	r16
    1c86:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:578
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
  unsigned int t0 = millis();
  unsigned int d;
  do {
    if (spiRec() == 0XFF) {
      return true;
    1c88:	81 e0       	ldi	r24, 0x01	; 1
    1c8a:	f9 cf       	rjmp	.-14     	; 0x1c7e <Sd2Card::waitNotBusy(unsigned int) [clone .constprop.161]+0x28>

00001c8c <SPIClass::beginTransaction(SPISettings)>:
beginTransaction():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:203
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 1;
    #endif

    SPCR = settings.spcr;
    1c8c:	8c bd       	out	0x2c, r24	; 44
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:204
    SPSR = settings.spsr;
    1c8e:	9d bd       	out	0x2d, r25	; 45
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SPI\src/SPI.h:205
  }
    1c90:	08 95       	ret

00001c92 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.105]>:
write_then_read():
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:388
 *    @param  sendvalue The 8-bits of data to write when doing the data read,
 * defaults to 0xFF
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write_then_read(uint8_t *write_buffer,
    1c92:	ef 92       	push	r14
    1c94:	ff 92       	push	r15
    1c96:	0f 93       	push	r16
    1c98:	1f 93       	push	r17
    1c9a:	cf 93       	push	r28
    1c9c:	df 93       	push	r29
    1c9e:	ec 01       	movw	r28, r24
    1ca0:	7b 01       	movw	r14, r22
    1ca2:	8a 01       	movw	r16, r20
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:391
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, uint8_t sendvalue) {
  if (_spi) {
    1ca4:	80 91 54 11 	lds	r24, 0x1154	; 0x801154 <max>
    1ca8:	90 91 55 11 	lds	r25, 0x1155	; 0x801155 <max+0x1>
    1cac:	89 2b       	or	r24, r25
    1cae:	41 f0       	breq	.+16     	; 0x1cc0 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.105]+0x2e>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:392
    _spi->beginTransaction(*_spiSetting);
    1cb0:	e0 91 56 11 	lds	r30, 0x1156	; 0x801156 <max+0x2>
    1cb4:	f0 91 57 11 	lds	r31, 0x1157	; 0x801157 <max+0x3>
    1cb8:	80 81       	ld	r24, Z
    1cba:	91 81       	ldd	r25, Z+1	; 0x01
    1cbc:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <SPIClass::beginTransaction(SPISettings)>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:395
  }

  digitalWrite(_cs, LOW);
    1cc0:	60 e0       	ldi	r22, 0x00	; 0
    1cc2:	80 91 5f 11 	lds	r24, 0x115F	; 0x80115f <max+0xb>
    1cc6:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:398
  // do the writing
  for (size_t i = 0; i < write_len; i++) {
    transfer(write_buffer[i]);
    1cca:	88 81       	ld	r24, Y
    1ccc:	0e 94 51 04 	call	0x8a2	; 0x8a2 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]>
    1cd0:	e7 01       	movw	r28, r14
    1cd2:	0e 0d       	add	r16, r14
    1cd4:	1f 1d       	adc	r17, r15
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:415
  }
  DEBUG_SERIAL.println();
#endif

  // do the reading
  for (size_t i = 0; i < read_len; i++) {
    1cd6:	0c 17       	cp	r16, r28
    1cd8:	1d 07       	cpc	r17, r29
    1cda:	29 f0       	breq	.+10     	; 0x1ce6 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.105]+0x54>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:416
    read_buffer[i] = transfer(sendvalue);
    1cdc:	8f ef       	ldi	r24, 0xFF	; 255
    1cde:	0e 94 51 04 	call	0x8a2	; 0x8a2 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]>
    1ce2:	89 93       	st	Y+, r24
    1ce4:	f8 cf       	rjmp	.-16     	; 0x1cd6 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.105]+0x44>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:432
    }
  }
  DEBUG_SERIAL.println();
#endif

  digitalWrite(_cs, HIGH);
    1ce6:	61 e0       	ldi	r22, 0x01	; 1
    1ce8:	80 91 5f 11 	lds	r24, 0x115F	; 0x80115f <max+0xb>
    1cec:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:439
  if (_spi) {
    _spi->endTransaction();
  }

  return true;
}
    1cf0:	81 e0       	ldi	r24, 0x01	; 1
    1cf2:	df 91       	pop	r29
    1cf4:	cf 91       	pop	r28
    1cf6:	1f 91       	pop	r17
    1cf8:	0f 91       	pop	r16
    1cfa:	ff 90       	pop	r15
    1cfc:	ef 90       	pop	r14
    1cfe:	08 95       	ret

00001d00 <Adafruit_MAX31856::readRegister8(unsigned char) [clone .constprop.103]>:
readRegister8():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:298
  return temp24 * 0.0078125;
}

/**********************************************/

uint8_t Adafruit_MAX31856::readRegister8(uint8_t addr) {
    1d00:	cf 93       	push	r28
    1d02:	df 93       	push	r29
    1d04:	1f 92       	push	r1
    1d06:	1f 92       	push	r1
    1d08:	cd b7       	in	r28, 0x3d	; 61
    1d0a:	de b7       	in	r29, 0x3e	; 62
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:299
  uint8_t ret = 0;
    1d0c:	1a 82       	std	Y+2, r1	; 0x02
    1d0e:	89 83       	std	Y+1, r24	; 0x01
readRegisterN():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:333

void Adafruit_MAX31856::readRegisterN(uint8_t addr, uint8_t buffer[],
                                      uint8_t n) {
  addr &= 0x7F; // MSB=0 for read, make sure top bit is not set

  spi_dev.write_then_read(&addr, 1, buffer, n);
    1d10:	41 e0       	ldi	r20, 0x01	; 1
    1d12:	50 e0       	ldi	r21, 0x00	; 0
    1d14:	be 01       	movw	r22, r28
    1d16:	6e 5f       	subi	r22, 0xFE	; 254
    1d18:	7f 4f       	sbci	r23, 0xFF	; 255
    1d1a:	ce 01       	movw	r24, r28
    1d1c:	01 96       	adiw	r24, 0x01	; 1
    1d1e:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.105]>
readRegister8():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:303
uint8_t Adafruit_MAX31856::readRegister8(uint8_t addr) {
  uint8_t ret = 0;
  readRegisterN(addr, &ret, 1);

  return ret;
}
    1d22:	8a 81       	ldd	r24, Y+2	; 0x02
    1d24:	0f 90       	pop	r0
    1d26:	0f 90       	pop	r0
    1d28:	df 91       	pop	r29
    1d2a:	cf 91       	pop	r28
    1d2c:	08 95       	ret

00001d2e <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]>:
writeRegister8():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:336
  addr &= 0x7F; // MSB=0 for read, make sure top bit is not set

  spi_dev.write_then_read(&addr, 1, buffer, n);
}

void Adafruit_MAX31856::writeRegister8(uint8_t addr, uint8_t data) {
    1d2e:	cf 93       	push	r28
    1d30:	df 93       	push	r29
    1d32:	c6 2f       	mov	r28, r22
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:337
  addr |= 0x80; // MSB=1 for write, make sure top bit is set
    1d34:	d8 2f       	mov	r29, r24
    1d36:	d0 68       	ori	r29, 0x80	; 128
write():
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:296
 *    @return Always returns true because there's no way to test success of SPI
 * writes
 */
bool Adafruit_SPIDevice::write(uint8_t *buffer, size_t len,
                               uint8_t *prefix_buffer, size_t prefix_len) {
  if (_spi) {
    1d38:	80 91 54 11 	lds	r24, 0x1154	; 0x801154 <max>
    1d3c:	90 91 55 11 	lds	r25, 0x1155	; 0x801155 <max+0x1>
    1d40:	89 2b       	or	r24, r25
    1d42:	41 f0       	breq	.+16     	; 0x1d54 <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]+0x26>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:297
    _spi->beginTransaction(*_spiSetting);
    1d44:	e0 91 56 11 	lds	r30, 0x1156	; 0x801156 <max+0x2>
    1d48:	f0 91 57 11 	lds	r31, 0x1157	; 0x801157 <max+0x3>
    1d4c:	80 81       	ld	r24, Z
    1d4e:	91 81       	ldd	r25, Z+1	; 0x01
    1d50:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <SPIClass::beginTransaction(SPISettings)>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:300
  }

  digitalWrite(_cs, LOW);
    1d54:	60 e0       	ldi	r22, 0x00	; 0
    1d56:	80 91 5f 11 	lds	r24, 0x115F	; 0x80115f <max+0xb>
    1d5a:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:306
  // do the writing
  for (size_t i = 0; i < prefix_len; i++) {
    transfer(prefix_buffer[i]);
  }
  for (size_t i = 0; i < len; i++) {
    transfer(buffer[i]);
    1d5e:	8d 2f       	mov	r24, r29
    1d60:	0e 94 51 04 	call	0x8a2	; 0x8a2 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]>
    1d64:	8c 2f       	mov	r24, r28
    1d66:	0e 94 51 04 	call	0x8a2	; 0x8a2 <Adafruit_SPIDevice::transfer(unsigned char) [clone .constprop.106]>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:308
  }
  digitalWrite(_cs, HIGH);
    1d6a:	61 e0       	ldi	r22, 0x01	; 1
    1d6c:	80 91 5f 11 	lds	r24, 0x115F	; 0x80115f <max+0xb>
writeRegister8():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:342

  uint8_t buffer[2] = {addr, data};

  spi_dev.write(buffer, 2);
}
    1d70:	df 91       	pop	r29
    1d72:	cf 91       	pop	r28
write():
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:308
    1d74:	0c 94 3f 08 	jmp	0x107e	; 0x107e <digitalWrite>

00001d78 <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]>:
readThermocoupleTemperature():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:271
/*!
    @brief  Return hot-junction (thermocouple) temperature
    @returns Floating point temperature in Celsius
*/
/**************************************************************************/
float Adafruit_MAX31856::readThermocoupleTemperature(void) {
    1d78:	cf 92       	push	r12
    1d7a:	df 92       	push	r13
    1d7c:	ef 92       	push	r14
    1d7e:	ff 92       	push	r15
    1d80:	cf 93       	push	r28
    1d82:	df 93       	push	r29
    1d84:	00 d0       	rcall	.+0      	; 0x1d86 <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]+0xe>
    1d86:	1f 92       	push	r1
    1d88:	cd b7       	in	r28, 0x3d	; 61
    1d8a:	de b7       	in	r29, 0x3e	; 62
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:274

  // for one-shot, make it happen
  if (conversionMode == MAX31856_ONESHOT) {
    1d8c:	80 91 71 11 	lds	r24, 0x1171	; 0x801171 <max+0x1d>
    1d90:	90 91 72 11 	lds	r25, 0x1172	; 0x801172 <max+0x1e>
    1d94:	89 2b       	or	r24, r25
    1d96:	59 f5       	brne	.+86     	; 0x1dee <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]+0x76>
triggerOneShot():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:234
void Adafruit_MAX31856::triggerOneShot(void) {

  if (conversionMode == MAX31856_CONTINUOUS)
    return;

  uint8_t t = readRegister8(MAX31856_CR0_REG); // get current register value
    1d98:	80 e0       	ldi	r24, 0x00	; 0
    1d9a:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <Adafruit_MAX31856::readRegister8(unsigned char) [clone .constprop.103]>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:235
  t &= ~MAX31856_CR0_AUTOCONVERT;              // turn off autoconvert
    1d9e:	8f 77       	andi	r24, 0x7F	; 127
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:236
  t |= MAX31856_CR0_1SHOT;                     // turn on one-shot
    1da0:	68 2f       	mov	r22, r24
    1da2:	60 64       	ori	r22, 0x40	; 64
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:237
  writeRegister8(MAX31856_CR0_REG, t);         // write value back to register
    1da4:	80 e0       	ldi	r24, 0x00	; 0
    1da6:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]>
readThermocoupleTemperature():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:276
float Adafruit_MAX31856::readThermocoupleTemperature(void) {

  // for one-shot, make it happen
  if (conversionMode == MAX31856_ONESHOT) {
    triggerOneShot();
    uint32_t start = millis();
    1daa:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    1dae:	6b 01       	movw	r12, r22
    1db0:	7c 01       	movw	r14, r24
conversionComplete():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:249
    @returns true if conversion complete, otherwise false
*/
/**************************************************************************/
bool Adafruit_MAX31856::conversionComplete(void) {

  if (conversionMode == MAX31856_CONTINUOUS)
    1db2:	80 91 71 11 	lds	r24, 0x1171	; 0x801171 <max+0x1d>
    1db6:	90 91 72 11 	lds	r25, 0x1172	; 0x801172 <max+0x1e>
    1dba:	02 97       	sbiw	r24, 0x02	; 2
    1dbc:	c1 f0       	breq	.+48     	; 0x1dee <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]+0x76>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:251
    return true;
  return !(readRegister8(MAX31856_CR0_REG) & MAX31856_CR0_1SHOT);
    1dbe:	80 e0       	ldi	r24, 0x00	; 0
    1dc0:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <Adafruit_MAX31856::readRegister8(unsigned char) [clone .constprop.103]>
readThermocoupleTemperature():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:277

  // for one-shot, make it happen
  if (conversionMode == MAX31856_ONESHOT) {
    triggerOneShot();
    uint32_t start = millis();
    while (!conversionComplete()) {
    1dc4:	86 ff       	sbrs	r24, 6
    1dc6:	13 c0       	rjmp	.+38     	; 0x1dee <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]+0x76>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:278
      if (millis() - start > 250)
    1dc8:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    1dcc:	6c 19       	sub	r22, r12
    1dce:	7d 09       	sbc	r23, r13
    1dd0:	8e 09       	sbc	r24, r14
    1dd2:	9f 09       	sbc	r25, r15
    1dd4:	6b 3f       	cpi	r22, 0xFB	; 251
    1dd6:	71 05       	cpc	r23, r1
    1dd8:	81 05       	cpc	r24, r1
    1dda:	91 05       	cpc	r25, r1
    1ddc:	08 f0       	brcs	.+2      	; 0x1de0 <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]+0x68>
    1dde:	41 c0       	rjmp	.+130    	; 0x1e62 <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]+0xea>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:280
        return NAN;
      delay(10);
    1de0:	6a e0       	ldi	r22, 0x0A	; 10
    1de2:	70 e0       	ldi	r23, 0x00	; 0
    1de4:	80 e0       	ldi	r24, 0x00	; 0
    1de6:	90 e0       	ldi	r25, 0x00	; 0
    1de8:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
    1dec:	e2 cf       	rjmp	.-60     	; 0x1db2 <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]+0x3a>
readRegister24():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:317

  return ret;
}

uint32_t Adafruit_MAX31856::readRegister24(uint8_t addr) {
  uint8_t buffer[3] = {0, 0, 0};
    1dee:	19 82       	std	Y+1, r1	; 0x01
    1df0:	1a 82       	std	Y+2, r1	; 0x02
    1df2:	1b 82       	std	Y+3, r1	; 0x03
    1df4:	8c e0       	ldi	r24, 0x0C	; 12
    1df6:	8c 83       	std	Y+4, r24	; 0x04
readRegisterN():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:333

void Adafruit_MAX31856::readRegisterN(uint8_t addr, uint8_t buffer[],
                                      uint8_t n) {
  addr &= 0x7F; // MSB=0 for read, make sure top bit is not set

  spi_dev.write_then_read(&addr, 1, buffer, n);
    1df8:	43 e0       	ldi	r20, 0x03	; 3
    1dfa:	50 e0       	ldi	r21, 0x00	; 0
    1dfc:	be 01       	movw	r22, r28
    1dfe:	6f 5f       	subi	r22, 0xFF	; 255
    1e00:	7f 4f       	sbci	r23, 0xFF	; 255
    1e02:	ce 01       	movw	r24, r28
    1e04:	04 96       	adiw	r24, 0x04	; 4
    1e06:	0e 94 49 0e 	call	0x1c92	; 0x1c92 <Adafruit_SPIDevice::write_then_read(unsigned char*, unsigned int, unsigned char*, unsigned int, unsigned char) [clone .constprop.105]>
    1e0a:	69 81       	ldd	r22, Y+1	; 0x01
    1e0c:	7a 81       	ldd	r23, Y+2	; 0x02
    1e0e:	76 27       	eor	r23, r22
    1e10:	67 27       	eor	r22, r23
    1e12:	76 27       	eor	r23, r22
    1e14:	cb 01       	movw	r24, r22
    1e16:	b0 e0       	ldi	r27, 0x00	; 0
    1e18:	a0 e0       	ldi	r26, 0x00	; 0
readRegister24():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:323
  readRegisterN(addr, buffer, 3);

  uint32_t ret = buffer[0];
  ret <<= 8;
  ret |= buffer[1];
  ret <<= 8;
    1e1a:	ba 2f       	mov	r27, r26
    1e1c:	a9 2f       	mov	r26, r25
    1e1e:	98 2f       	mov	r25, r24
    1e20:	88 27       	eor	r24, r24
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:324
  ret |= buffer[2];
    1e22:	2b 81       	ldd	r18, Y+3	; 0x03
readThermocoupleTemperature():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:285
      delay(10);
    }
  }

  // read the thermocouple temperature registers (3 bytes)
  int32_t temp24 = readRegister24(MAX31856_LTCBH_REG);
    1e24:	82 2b       	or	r24, r18
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:287
  // and compute temperature
  if (temp24 & 0x800000) {
    1e26:	a7 fd       	sbrc	r26, 7
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:288
    temp24 |= 0xFF000000; // fix sign
    1e28:	bf 6f       	ori	r27, 0xFF	; 255
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:291
  }

  temp24 >>= 5; // bottom 5 bits are unused
    1e2a:	bc 01       	movw	r22, r24
    1e2c:	cd 01       	movw	r24, r26
    1e2e:	25 e0       	ldi	r18, 0x05	; 5
    1e30:	95 95       	asr	r25
    1e32:	87 95       	ror	r24
    1e34:	77 95       	ror	r23
    1e36:	67 95       	ror	r22
    1e38:	2a 95       	dec	r18
    1e3a:	d1 f7       	brne	.-12     	; 0x1e30 <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]+0xb8>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:293

  return temp24 * 0.0078125;
    1e3c:	0e 94 db 68 	call	0xd1b6	; 0xd1b6 <__floatsisf>
    1e40:	20 e0       	ldi	r18, 0x00	; 0
    1e42:	30 e0       	ldi	r19, 0x00	; 0
    1e44:	40 e0       	ldi	r20, 0x00	; 0
    1e46:	5c e3       	ldi	r21, 0x3C	; 60
    1e48:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:294
}
    1e4c:	0f 90       	pop	r0
    1e4e:	0f 90       	pop	r0
    1e50:	0f 90       	pop	r0
    1e52:	0f 90       	pop	r0
    1e54:	df 91       	pop	r29
    1e56:	cf 91       	pop	r28
    1e58:	ff 90       	pop	r15
    1e5a:	ef 90       	pop	r14
    1e5c:	df 90       	pop	r13
    1e5e:	cf 90       	pop	r12
    1e60:	08 95       	ret
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:279
  if (conversionMode == MAX31856_ONESHOT) {
    triggerOneShot();
    uint32_t start = millis();
    while (!conversionComplete()) {
      if (millis() - start > 250)
        return NAN;
    1e62:	60 e0       	ldi	r22, 0x00	; 0
    1e64:	70 e0       	ldi	r23, 0x00	; 0
    1e66:	80 ec       	ldi	r24, 0xC0	; 192
    1e68:	9f e7       	ldi	r25, 0x7F	; 127
    1e6a:	f0 cf       	rjmp	.-32     	; 0x1e4c <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]+0xd4>

00001e6c <Adafruit_MAX31856::setThermocoupleType(max31856_thermocoupletype_t) [clone .constprop.24]>:
setThermocoupleType():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:138
    @brief  Set which kind of Thermocouple (K, J, T, etc) to detect & decode
    @param type The enumeration type of the thermocouple
*/
/**************************************************************************/
void Adafruit_MAX31856::setThermocoupleType(max31856_thermocoupletype_t type) {
  uint8_t t = readRegister8(MAX31856_CR1_REG);
    1e6c:	81 e0       	ldi	r24, 0x01	; 1
    1e6e:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <Adafruit_MAX31856::readRegister8(unsigned char) [clone .constprop.103]>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:139
  t &= 0xF0; // mask off bottom 4 bits
    1e72:	80 7f       	andi	r24, 0xF0	; 240
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:140
  t |= (uint8_t)type & 0x0F;
    1e74:	68 2f       	mov	r22, r24
    1e76:	63 60       	ori	r22, 0x03	; 3
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:141
  writeRegister8(MAX31856_CR1_REG, t);
    1e78:	81 e0       	ldi	r24, 0x01	; 1
    1e7a:	0c 94 97 0e 	jmp	0x1d2e	; 0x1d2e <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]>

00001e7e <Sd2Card::chipSelectLow()>:
chipSelectLow():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:187
    SDCARD_SPI.endTransaction();
  }
  #endif
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
    1e7e:	cf 93       	push	r28
    1e80:	df 93       	push	r29
    1e82:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:189
  #ifdef USE_SPI_LIB
  if (!chip_select_asserted) {
    1e84:	80 91 ca 09 	lds	r24, 0x09CA	; 0x8009ca <chip_select_asserted>
    1e88:	81 11       	cpse	r24, r1
    1e8a:	09 c0       	rjmp	.+18     	; 0x1e9e <Sd2Card::chipSelectLow()+0x20>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:190
    chip_select_asserted = 1;
    1e8c:	81 e0       	ldi	r24, 0x01	; 1
    1e8e:	80 93 ca 09 	sts	0x09CA, r24	; 0x8009ca <chip_select_asserted>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:191
    SDCARD_SPI.beginTransaction(settings);
    1e92:	80 91 f1 0e 	lds	r24, 0x0EF1	; 0x800ef1 <settings>
    1e96:	90 91 f2 0e 	lds	r25, 0x0EF2	; 0x800ef2 <settings+0x1>
    1e9a:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <SPIClass::beginTransaction(SPISettings)>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:194
  }
  #endif
  digitalWrite(chipSelectPin_, LOW);
    1e9e:	60 e0       	ldi	r22, 0x00	; 0
    1ea0:	8c 81       	ldd	r24, Y+4	; 0x04
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:195
}
    1ea2:	df 91       	pop	r29
    1ea4:	cf 91       	pop	r28
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:194
  if (!chip_select_asserted) {
    chip_select_asserted = 1;
    SDCARD_SPI.beginTransaction(settings);
  }
  #endif
  digitalWrite(chipSelectPin_, LOW);
    1ea6:	0c 94 3f 08 	jmp	0x107e	; 0x107e <digitalWrite>

00001eaa <Sd2Card::cardCommand(unsigned char, unsigned long)>:
cardCommand():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:113
  sei();
}
#endif  // SOFTWARE_SPI
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
    1eaa:	8f 92       	push	r8
    1eac:	9f 92       	push	r9
    1eae:	af 92       	push	r10
    1eb0:	bf 92       	push	r11
    1eb2:	ff 92       	push	r15
    1eb4:	0f 93       	push	r16
    1eb6:	1f 93       	push	r17
    1eb8:	cf 93       	push	r28
    1eba:	df 93       	push	r29
    1ebc:	ec 01       	movw	r28, r24
    1ebe:	f6 2e       	mov	r15, r22
    1ec0:	49 01       	movw	r8, r18
    1ec2:	5a 01       	movw	r10, r20
readEnd():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:476
  return false;
}
//------------------------------------------------------------------------------
/** Skip remaining data in a block when in partial block read mode. */
void Sd2Card::readEnd(void) {
  if (inBlock_) {
    1ec4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ec6:	88 23       	and	r24, r24
    1ec8:	89 f0       	breq	.+34     	; 0x1eec <Sd2Card::cardCommand(unsigned char, unsigned long)+0x42>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:490
    }
    // wait for last crc byte
    while (!(SPSR & (1 << SPIF)))
      ;
    #else  // OPTIMIZE_HARDWARE_SPI
    while (offset_++ < 514) {
    1eca:	8f 81       	ldd	r24, Y+7	; 0x07
    1ecc:	98 85       	ldd	r25, Y+8	; 0x08
    1ece:	9c 01       	movw	r18, r24
    1ed0:	2f 5f       	subi	r18, 0xFF	; 255
    1ed2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ed4:	38 87       	std	Y+8, r19	; 0x08
    1ed6:	2f 83       	std	Y+7, r18	; 0x07
    1ed8:	82 30       	cpi	r24, 0x02	; 2
    1eda:	92 40       	sbci	r25, 0x02	; 2
    1edc:	18 f4       	brcc	.+6      	; 0x1ee4 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x3a>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:491
      spiRec();
    1ede:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    1ee2:	f3 cf       	rjmp	.-26     	; 0x1eca <Sd2Card::cardCommand(unsigned char, unsigned long)+0x20>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:494
    }
    #endif  // OPTIMIZE_HARDWARE_SPI
    chipSelectHigh();
    1ee4:	ce 01       	movw	r24, r28
    1ee6:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <Sd2Card::chipSelectHigh()>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:495
    inBlock_ = 0;
    1eea:	1e 82       	std	Y+6, r1	; 0x06
cardCommand():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:118
uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
  // end read if in partialBlockRead mode
  readEnd();

  // select card
  chipSelectLow();
    1eec:	ce 01       	movw	r24, r28
    1eee:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <Sd2Card::chipSelectLow()>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:121

  // wait up to 300 ms if busy
  waitNotBusy(300);
    1ef2:	8c e2       	ldi	r24, 0x2C	; 44
    1ef4:	91 e0       	ldi	r25, 0x01	; 1
    1ef6:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <Sd2Card::waitNotBusy(unsigned int) [clone .constprop.161]>
spiSend():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:42
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
    1efa:	8f 2d       	mov	r24, r15
    1efc:	80 64       	ori	r24, 0x40	; 64
    1efe:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <SPIClass::transfer(unsigned char)>
    1f02:	08 e1       	ldi	r16, 0x18	; 24
    1f04:	10 e0       	ldi	r17, 0x00	; 0
cardCommand():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:128
  // send command
  spiSend(cmd | 0x40);

  // send argument
  for (int8_t s = 24; s >= 0; s -= 8) {
    spiSend(arg >> s);
    1f06:	d5 01       	movw	r26, r10
    1f08:	c4 01       	movw	r24, r8
    1f0a:	00 2e       	mov	r0, r16
    1f0c:	04 c0       	rjmp	.+8      	; 0x1f16 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x6c>
    1f0e:	b6 95       	lsr	r27
    1f10:	a7 95       	ror	r26
    1f12:	97 95       	ror	r25
    1f14:	87 95       	ror	r24
    1f16:	0a 94       	dec	r0
    1f18:	d2 f7       	brpl	.-12     	; 0x1f0e <Sd2Card::cardCommand(unsigned char, unsigned long)+0x64>
spiSend():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:42
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
    1f1a:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <SPIClass::transfer(unsigned char)>
    1f1e:	08 50       	subi	r16, 0x08	; 8
    1f20:	11 09       	sbc	r17, r1
cardCommand():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:127

  // send command
  spiSend(cmd | 0x40);

  // send argument
  for (int8_t s = 24; s >= 0; s -= 8) {
    1f22:	08 3f       	cpi	r16, 0xF8	; 248
    1f24:	8f ef       	ldi	r24, 0xFF	; 255
    1f26:	18 07       	cpc	r17, r24
    1f28:	71 f7       	brne	.-36     	; 0x1f06 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x5c>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:134
  }

  // send CRC
  uint8_t crc = 0XFF;
  if (cmd == CMD0) {
    crc = 0X95;  // correct crc for CMD0 with arg 0
    1f2a:	85 e9       	ldi	r24, 0x95	; 149
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:133
    spiSend(arg >> s);
  }

  // send CRC
  uint8_t crc = 0XFF;
  if (cmd == CMD0) {
    1f2c:	ff 20       	and	r15, r15
    1f2e:	21 f0       	breq	.+8      	; 0x1f38 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x8e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:136
    crc = 0X95;  // correct crc for CMD0 with arg 0
  }
  if (cmd == CMD8) {
    1f30:	28 e0       	ldi	r18, 0x08	; 8
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:137
    crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
    1f32:	87 e8       	ldi	r24, 0x87	; 135
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:136
  // send CRC
  uint8_t crc = 0XFF;
  if (cmd == CMD0) {
    crc = 0X95;  // correct crc for CMD0 with arg 0
  }
  if (cmd == CMD8) {
    1f34:	f2 12       	cpse	r15, r18
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:132
  for (int8_t s = 24; s >= 0; s -= 8) {
    spiSend(arg >> s);
  }

  // send CRC
  uint8_t crc = 0XFF;
    1f36:	8f ef       	ldi	r24, 0xFF	; 255
spiSend():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:42
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
    1f38:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <SPIClass::transfer(unsigned char)>
cardCommand():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:142
    crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
  }
  spiSend(crc);

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++)
    1f3c:	10 e0       	ldi	r17, 0x00	; 0
    1f3e:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    1f42:	8a 87       	std	Y+10, r24	; 0x0a
    1f44:	87 ff       	sbrs	r24, 7
    1f46:	04 c0       	rjmp	.+8      	; 0x1f50 <Sd2Card::cardCommand(unsigned char, unsigned long)+0xa6>
    1f48:	1f 3f       	cpi	r17, 0xFF	; 255
    1f4a:	11 f0       	breq	.+4      	; 0x1f50 <Sd2Card::cardCommand(unsigned char, unsigned long)+0xa6>
    1f4c:	1f 5f       	subi	r17, 0xFF	; 255
    1f4e:	f7 cf       	rjmp	.-18     	; 0x1f3e <Sd2Card::cardCommand(unsigned char, unsigned long)+0x94>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:145
    ;
  return status_;
}
    1f50:	df 91       	pop	r29
    1f52:	cf 91       	pop	r28
    1f54:	1f 91       	pop	r17
    1f56:	0f 91       	pop	r16
    1f58:	ff 90       	pop	r15
    1f5a:	bf 90       	pop	r11
    1f5c:	af 90       	pop	r10
    1f5e:	9f 90       	pop	r9
    1f60:	8f 90       	pop	r8
    1f62:	08 95       	ret

00001f64 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]>:
_ZN7Sd2Card8readDataEmjjPh.part.6():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:402
   \param[out] dst Pointer to the location that will receive the data.
   \param[in] count Number of bytes to read
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t Sd2Card::readData(uint32_t block,
    1f64:	af 92       	push	r10
    1f66:	bf 92       	push	r11
    1f68:	cf 92       	push	r12
    1f6a:	df 92       	push	r13
    1f6c:	ef 92       	push	r14
    1f6e:	ff 92       	push	r15
    1f70:	0f 93       	push	r16
    1f72:	1f 93       	push	r17
    1f74:	cf 93       	push	r28
    1f76:	df 93       	push	r29
    1f78:	ec 01       	movw	r28, r24
    1f7a:	69 01       	movw	r12, r18
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:407
                          uint16_t offset, uint16_t count, uint8_t* dst) {
  if (count == 0) {
    return true;
  }
  if ((count + offset) > 512) {
    1f7c:	c8 01       	movw	r24, r16
    1f7e:	82 0f       	add	r24, r18
    1f80:	93 1f       	adc	r25, r19
    1f82:	81 30       	cpi	r24, 0x01	; 1
    1f84:	92 40       	sbci	r25, 0x02	; 2
    1f86:	50 f5       	brcc	.+84     	; 0x1fdc <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x78>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:410
    goto fail;
  }
  if (!inBlock_ || block != block_ || offset < offset_) {
    1f88:	8e 81       	ldd	r24, Y+6	; 0x06
    1f8a:	88 23       	and	r24, r24
    1f8c:	79 f0       	breq	.+30     	; 0x1fac <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x48>
    1f8e:	88 81       	ld	r24, Y
    1f90:	99 81       	ldd	r25, Y+1	; 0x01
    1f92:	aa 81       	ldd	r26, Y+2	; 0x02
    1f94:	bb 81       	ldd	r27, Y+3	; 0x03
    1f96:	84 17       	cp	r24, r20
    1f98:	95 07       	cpc	r25, r21
    1f9a:	a6 07       	cpc	r26, r22
    1f9c:	b7 07       	cpc	r27, r23
    1f9e:	31 f4       	brne	.+12     	; 0x1fac <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x48>
    1fa0:	8f 81       	ldd	r24, Y+7	; 0x07
    1fa2:	98 85       	ldd	r25, Y+8	; 0x08
    1fa4:	c8 16       	cp	r12, r24
    1fa6:	d9 06       	cpc	r13, r25
    1fa8:	08 f0       	brcs	.+2      	; 0x1fac <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x48>
    1faa:	42 c0       	rjmp	.+132    	; 0x2030 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0xcc>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:411
    block_ = block;
    1fac:	48 83       	st	Y, r20
    1fae:	59 83       	std	Y+1, r21	; 0x01
    1fb0:	6a 83       	std	Y+2, r22	; 0x02
    1fb2:	7b 83       	std	Y+3, r23	; 0x03
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:413
    // use address if not SDHC card
    if (type() != SD_CARD_TYPE_SDHC) {
    1fb4:	8b 85       	ldd	r24, Y+11	; 0x0b
    1fb6:	83 30       	cpi	r24, 0x03	; 3
    1fb8:	39 f0       	breq	.+14     	; 0x1fc8 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x64>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:414
      block <<= 9;
    1fba:	89 e0       	ldi	r24, 0x09	; 9
    1fbc:	44 0f       	add	r20, r20
    1fbe:	55 1f       	adc	r21, r21
    1fc0:	66 1f       	adc	r22, r22
    1fc2:	77 1f       	adc	r23, r23
    1fc4:	8a 95       	dec	r24
    1fc6:	d1 f7       	brne	.-12     	; 0x1fbc <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x58>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:416
    }
    if (cardCommand(CMD17, block)) {
    1fc8:	9a 01       	movw	r18, r20
    1fca:	ab 01       	movw	r20, r22
    1fcc:	61 e1       	ldi	r22, 0x11	; 17
    1fce:	ce 01       	movw	r24, r28
    1fd0:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <Sd2Card::cardCommand(unsigned char, unsigned long)>
    1fd4:	88 23       	and	r24, r24
    1fd6:	89 f0       	breq	.+34     	; 0x1ffa <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x96>
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
      cardCommand(CMD55, 0);
      return cardCommand(cmd, arg);
    }
    uint8_t cardCommand(uint8_t cmd, uint32_t arg);
    void error(uint8_t code) {
      errorCode_ = code;
    1fd8:	83 e0       	ldi	r24, 0x03	; 3
    1fda:	8d 83       	std	Y+5, r24	; 0x05
_ZN7Sd2Card8readDataEmjjPh.part.6():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:470
    readEnd();
  }
  return true;

fail:
  chipSelectHigh();
    1fdc:	ce 01       	movw	r24, r28
    1fde:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <Sd2Card::chipSelectHigh()>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:471
  return false;
    1fe2:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:472
}
    1fe4:	df 91       	pop	r29
    1fe6:	cf 91       	pop	r28
    1fe8:	1f 91       	pop	r17
    1fea:	0f 91       	pop	r16
    1fec:	ff 90       	pop	r15
    1fee:	ef 90       	pop	r14
    1ff0:	df 90       	pop	r13
    1ff2:	cf 90       	pop	r12
    1ff4:	bf 90       	pop	r11
    1ff6:	af 90       	pop	r10
    1ff8:	08 95       	ret
waitStartBlock():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:587
  return false;
}
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
  unsigned int t0 = millis();
    1ffa:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    1ffe:	5b 01       	movw	r10, r22
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:588
  while ((status_ = spiRec()) == 0XFF) {
    2000:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    2004:	8a 87       	std	Y+10, r24	; 0x0a
    2006:	8f 3f       	cpi	r24, 0xFF	; 255
    2008:	69 f4       	brne	.+26     	; 0x2024 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0xc0>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:589
    unsigned int d = millis() - t0;
    200a:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    200e:	6a 19       	sub	r22, r10
    2010:	7b 09       	sbc	r23, r11
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:590
    if (d > SD_READ_TIMEOUT) {
    2012:	6d 32       	cpi	r22, 0x2D	; 45
    2014:	71 40       	sbci	r23, 0x01	; 1
    2016:	a0 f3       	brcs	.-24     	; 0x2000 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x9c>
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
    2018:	8f e0       	ldi	r24, 0x0F	; 15
    201a:	8d 83       	std	Y+5, r24	; 0x05
waitStartBlock():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:602
    goto fail;
  }
  return true;

fail:
  chipSelectHigh();
    201c:	ce 01       	movw	r24, r28
    201e:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <Sd2Card::chipSelectHigh()>
    2022:	dc cf       	rjmp	.-72     	; 0x1fdc <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x78>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:595
    if (d > SD_READ_TIMEOUT) {
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  if (status_ != DATA_START_BLOCK) {
    2024:	8e 3f       	cpi	r24, 0xFE	; 254
    2026:	89 f4       	brne	.+34     	; 0x204a <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0xe6>
_ZN7Sd2Card8readDataEmjjPh.part.6():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:423
      goto fail;
    }
    if (!waitStartBlock()) {
      goto fail;
    }
    offset_ = 0;
    2028:	18 86       	std	Y+8, r1	; 0x08
    202a:	1f 82       	std	Y+7, r1	; 0x07
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:424
    inBlock_ = 1;
    202c:	81 e0       	ldi	r24, 0x01	; 1
    202e:	8e 83       	std	Y+6, r24	; 0x06
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:453
  dst[n] = SPDR;

  #else  // OPTIMIZE_HARDWARE_SPI

  // skip data before offset
  for (; offset_ < offset; offset_++) {
    2030:	8f 81       	ldd	r24, Y+7	; 0x07
    2032:	98 85       	ldd	r25, Y+8	; 0x08
    2034:	8c 15       	cp	r24, r12
    2036:	9d 05       	cpc	r25, r13
    2038:	50 f4       	brcc	.+20     	; 0x204e <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0xea>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:454
    spiRec();
    203a:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:453
  dst[n] = SPDR;

  #else  // OPTIMIZE_HARDWARE_SPI

  // skip data before offset
  for (; offset_ < offset; offset_++) {
    203e:	8f 81       	ldd	r24, Y+7	; 0x07
    2040:	98 85       	ldd	r25, Y+8	; 0x08
    2042:	01 96       	adiw	r24, 0x01	; 1
    2044:	98 87       	std	Y+8, r25	; 0x08
    2046:	8f 83       	std	Y+7, r24	; 0x07
    2048:	f3 cf       	rjmp	.-26     	; 0x2030 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0xcc>
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
    204a:	8d e0       	ldi	r24, 0x0D	; 13
    204c:	e6 cf       	rjmp	.-52     	; 0x201a <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0xb6>
    204e:	67 01       	movw	r12, r14
    2050:	e0 0e       	add	r14, r16
    2052:	f1 1e       	adc	r15, r17
_ZN7Sd2Card8readDataEmjjPh.part.6():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:458
    spiRec();
  }
  // transfer data
  for (uint16_t i = 0; i < count; i++) {
    dst[i] = spiRec();
    2054:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    2058:	f6 01       	movw	r30, r12
    205a:	81 93       	st	Z+, r24
    205c:	6f 01       	movw	r12, r30
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:457
  // skip data before offset
  for (; offset_ < offset; offset_++) {
    spiRec();
  }
  // transfer data
  for (uint16_t i = 0; i < count; i++) {
    205e:	ee 15       	cp	r30, r14
    2060:	ff 05       	cpc	r31, r15
    2062:	c1 f7       	brne	.-16     	; 0x2054 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0xf0>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:462
    dst[i] = spiRec();
  }
  #endif  // OPTIMIZE_HARDWARE_SPI

  offset_ += count;
    2064:	8f 81       	ldd	r24, Y+7	; 0x07
    2066:	98 85       	ldd	r25, Y+8	; 0x08
    2068:	08 0f       	add	r16, r24
    206a:	19 1f       	adc	r17, r25
    206c:	18 87       	std	Y+8, r17	; 0x08
    206e:	0f 83       	std	Y+7, r16	; 0x07
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:463
  if (!partialBlockRead_ || offset_ >= 512) {
    2070:	89 85       	ldd	r24, Y+9	; 0x09
    2072:	88 23       	and	r24, r24
    2074:	19 f0       	breq	.+6      	; 0x207c <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x118>
    2076:	01 15       	cp	r16, r1
    2078:	12 40       	sbci	r17, 0x02	; 2
    207a:	a0 f0       	brcs	.+40     	; 0x20a4 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x140>
readEnd():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:476
  return false;
}
//------------------------------------------------------------------------------
/** Skip remaining data in a block when in partial block read mode. */
void Sd2Card::readEnd(void) {
  if (inBlock_) {
    207c:	8e 81       	ldd	r24, Y+6	; 0x06
    207e:	88 23       	and	r24, r24
    2080:	89 f0       	breq	.+34     	; 0x20a4 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x140>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:490
    }
    // wait for last crc byte
    while (!(SPSR & (1 << SPIF)))
      ;
    #else  // OPTIMIZE_HARDWARE_SPI
    while (offset_++ < 514) {
    2082:	8f 81       	ldd	r24, Y+7	; 0x07
    2084:	98 85       	ldd	r25, Y+8	; 0x08
    2086:	9c 01       	movw	r18, r24
    2088:	2f 5f       	subi	r18, 0xFF	; 255
    208a:	3f 4f       	sbci	r19, 0xFF	; 255
    208c:	38 87       	std	Y+8, r19	; 0x08
    208e:	2f 83       	std	Y+7, r18	; 0x07
    2090:	82 30       	cpi	r24, 0x02	; 2
    2092:	92 40       	sbci	r25, 0x02	; 2
    2094:	18 f4       	brcc	.+6      	; 0x209c <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x138>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:491
      spiRec();
    2096:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    209a:	f3 cf       	rjmp	.-26     	; 0x2082 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x11e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:494
    }
    #endif  // OPTIMIZE_HARDWARE_SPI
    chipSelectHigh();
    209c:	ce 01       	movw	r24, r28
    209e:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <Sd2Card::chipSelectHigh()>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:495
    inBlock_ = 0;
    20a2:	1e 82       	std	Y+6, r1	; 0x06
_ZN7Sd2Card8readDataEmjjPh.part.6():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:467
  offset_ += count;
  if (!partialBlockRead_ || offset_ >= 512) {
    // read rest of data, checksum and set chip select high
    readEnd();
  }
  return true;
    20a4:	81 e0       	ldi	r24, 0x01	; 1
    20a6:	9e cf       	rjmp	.-196    	; 0x1fe4 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]+0x80>

000020a8 <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)>:
writeBlock():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:615
   \param[in] src Pointer to the location of the data to be written.
   \param[in] blocking If the write should be blocking.
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src, uint8_t blocking) {
    20a8:	cf 92       	push	r12
    20aa:	df 92       	push	r13
    20ac:	ef 92       	push	r14
    20ae:	ff 92       	push	r15
    20b0:	0f 93       	push	r16
    20b2:	cf 93       	push	r28
    20b4:	df 93       	push	r29
    20b6:	ec 01       	movw	r28, r24
    20b8:	69 01       	movw	r12, r18
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
    20ba:	82 e1       	ldi	r24, 0x12	; 18
writeBlock():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:618
  #if SD_PROTECT_BLOCK_ZERO
  // don't allow write to first block
  if (blockNumber == 0) {
    20bc:	41 15       	cp	r20, r1
    20be:	51 05       	cpc	r21, r1
    20c0:	61 05       	cpc	r22, r1
    20c2:	71 05       	cpc	r23, r1
    20c4:	99 f0       	breq	.+38     	; 0x20ec <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0x44>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:625
    goto fail;
  }
  #endif  // SD_PROTECT_BLOCK_ZERO

  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    20c6:	8b 85       	ldd	r24, Y+11	; 0x0b
    20c8:	83 30       	cpi	r24, 0x03	; 3
    20ca:	39 f0       	breq	.+14     	; 0x20da <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0x32>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:626
    blockNumber <<= 9;
    20cc:	89 e0       	ldi	r24, 0x09	; 9
    20ce:	44 0f       	add	r20, r20
    20d0:	55 1f       	adc	r21, r21
    20d2:	66 1f       	adc	r22, r22
    20d4:	77 1f       	adc	r23, r23
    20d6:	8a 95       	dec	r24
    20d8:	d1 f7       	brne	.-12     	; 0x20ce <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0x26>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:628
  }
  if (cardCommand(CMD24, blockNumber)) {
    20da:	9a 01       	movw	r18, r20
    20dc:	ab 01       	movw	r20, r22
    20de:	68 e1       	ldi	r22, 0x18	; 24
    20e0:	ce 01       	movw	r24, r28
    20e2:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <Sd2Card::cardCommand(unsigned char, unsigned long)>
    20e6:	88 23       	and	r24, r24
    20e8:	19 f0       	breq	.+6      	; 0x20f0 <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0x48>
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
    20ea:	84 e0       	ldi	r24, 0x04	; 4
    20ec:	8d 83       	std	Y+5, r24	; 0x05
    20ee:	2d c0       	rjmp	.+90     	; 0x214a <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0xa2>
spiSend():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:42
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
    20f0:	8e ef       	ldi	r24, 0xFE	; 254
    20f2:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <SPIClass::transfer(unsigned char)>
    20f6:	76 01       	movw	r14, r12
    20f8:	8e ef       	ldi	r24, 0xFE	; 254
    20fa:	d8 1a       	sub	r13, r24
    20fc:	f7 01       	movw	r30, r14
    20fe:	81 91       	ld	r24, Z+
    2100:	7f 01       	movw	r14, r30
    2102:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <SPIClass::transfer(unsigned char)>
writeData():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:689
  while (!(SPSR & (1 << SPIF)))
    ;

  #else  // OPTIMIZE_HARDWARE_SPI
  spiSend(token);
  for (uint16_t i = 0; i < 512; i++) {
    2106:	ec 14       	cp	r14, r12
    2108:	fd 04       	cpc	r15, r13
    210a:	c1 f7       	brne	.-16     	; 0x20fc <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0x54>
spiSend():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:42
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
    210c:	8f ef       	ldi	r24, 0xFF	; 255
    210e:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <SPIClass::transfer(unsigned char)>
    2112:	8f ef       	ldi	r24, 0xFF	; 255
    2114:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <SPIClass::transfer(unsigned char)>
writeData():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:696
  }
  #endif  // OPTIMIZE_HARDWARE_SPI
  spiSend(0xff);  // dummy crc
  spiSend(0xff);  // dummy crc

  status_ = spiRec();
    2118:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    211c:	8a 87       	std	Y+10, r24	; 0x0a
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:697
  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    211e:	8f 71       	andi	r24, 0x1F	; 31
    2120:	85 30       	cpi	r24, 0x05	; 5
    2122:	71 f4       	brne	.+28     	; 0x2140 <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0x98>
writeBlock():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:635
    goto fail;
  }
  if (!writeData(DATA_START_BLOCK, src)) {
    goto fail;
  }
  if (blocking) {
    2124:	01 11       	cpse	r16, r1
    2126:	16 c0       	rjmp	.+44     	; 0x2154 <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0xac>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:647
    if (cardCommand(CMD13, 0) || spiRec()) {
      error(SD_CARD_ERROR_WRITE_PROGRAMMING);
      goto fail;
    }
  }
  chipSelectHigh();
    2128:	ce 01       	movw	r24, r28
    212a:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <Sd2Card::chipSelectHigh()>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:648
  return true;
    212e:	81 e0       	ldi	r24, 0x01	; 1
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:653

fail:
  chipSelectHigh();
  return false;
}
    2130:	df 91       	pop	r29
    2132:	cf 91       	pop	r28
    2134:	0f 91       	pop	r16
    2136:	ff 90       	pop	r15
    2138:	ef 90       	pop	r14
    213a:	df 90       	pop	r13
    213c:	cf 90       	pop	r12
    213e:	08 95       	ret
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
    2140:	81 e1       	ldi	r24, 0x11	; 17
    2142:	8d 83       	std	Y+5, r24	; 0x05
writeData():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:699
  spiSend(0xff);  // dummy crc

  status_ = spiRec();
  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE);
    chipSelectHigh();
    2144:	ce 01       	movw	r24, r28
    2146:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <Sd2Card::chipSelectHigh()>
writeBlock():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:651
  }
  chipSelectHigh();
  return true;

fail:
  chipSelectHigh();
    214a:	ce 01       	movw	r24, r28
    214c:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <Sd2Card::chipSelectHigh()>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:652
  return false;
    2150:	80 e0       	ldi	r24, 0x00	; 0
    2152:	ee cf       	rjmp	.-36     	; 0x2130 <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0x88>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:637
  if (!writeData(DATA_START_BLOCK, src)) {
    goto fail;
  }
  if (blocking) {
    // wait for flash programming to complete
    if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    2154:	88 e5       	ldi	r24, 0x58	; 88
    2156:	92 e0       	ldi	r25, 0x02	; 2
    2158:	0e 94 2b 0e 	call	0x1c56	; 0x1c56 <Sd2Card::waitNotBusy(unsigned int) [clone .constprop.161]>
    215c:	81 11       	cpse	r24, r1
    215e:	02 c0       	rjmp	.+4      	; 0x2164 <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0xbc>
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
    2160:	85 e1       	ldi	r24, 0x15	; 21
    2162:	c4 cf       	rjmp	.-120    	; 0x20ec <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0x44>
writeBlock():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:642
      error(SD_CARD_ERROR_WRITE_TIMEOUT);
      goto fail;
    }
    // response is r2 so get and check two bytes for nonzero
    if (cardCommand(CMD13, 0) || spiRec()) {
    2164:	20 e0       	ldi	r18, 0x00	; 0
    2166:	30 e0       	ldi	r19, 0x00	; 0
    2168:	a9 01       	movw	r20, r18
    216a:	6d e0       	ldi	r22, 0x0D	; 13
    216c:	ce 01       	movw	r24, r28
    216e:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <Sd2Card::cardCommand(unsigned char, unsigned long)>
    2172:	88 23       	and	r24, r24
    2174:	11 f0       	breq	.+4      	; 0x217a <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0xd2>
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
    2176:	84 e1       	ldi	r24, 0x14	; 20
    2178:	b9 cf       	rjmp	.-142    	; 0x20ec <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0x44>
writeBlock():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:642
    217a:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    217e:	81 11       	cpse	r24, r1
    2180:	fa cf       	rjmp	.-12     	; 0x2176 <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0xce>
    2182:	d2 cf       	rjmp	.-92     	; 0x2128 <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)+0x80>

00002184 <SdVolume::cacheMirrorBlockFlush(unsigned char)>:
cacheMirrorBlockFlush():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:130
    cacheDirty_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheMirrorBlockFlush(uint8_t blocking) {
    2184:	0f 93       	push	r16
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:131
  if (cacheMirrorBlock_) {
    2186:	40 91 cc 09 	lds	r20, 0x09CC	; 0x8009cc <SdVolume::cacheMirrorBlock_>
    218a:	50 91 cd 09 	lds	r21, 0x09CD	; 0x8009cd <SdVolume::cacheMirrorBlock_+0x1>
    218e:	60 91 ce 09 	lds	r22, 0x09CE	; 0x8009ce <SdVolume::cacheMirrorBlock_+0x2>
    2192:	70 91 cf 09 	lds	r23, 0x09CF	; 0x8009cf <SdVolume::cacheMirrorBlock_+0x3>
    2196:	41 15       	cp	r20, r1
    2198:	51 05       	cpc	r21, r1
    219a:	61 05       	cpc	r22, r1
    219c:	71 05       	cpc	r23, r1
    219e:	99 f0       	breq	.+38     	; 0x21c6 <SdVolume::cacheMirrorBlockFlush(unsigned char)+0x42>
    21a0:	08 2f       	mov	r16, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:132
    if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data, blocking)) {
    21a2:	2b ef       	ldi	r18, 0xFB	; 251
    21a4:	39 e0       	ldi	r19, 0x09	; 9
    21a6:	80 91 fb 0b 	lds	r24, 0x0BFB	; 0x800bfb <SdVolume::sdCard_>
    21aa:	90 91 fc 0b 	lds	r25, 0x0BFC	; 0x800bfc <SdVolume::sdCard_+0x1>
    21ae:	0e 94 54 10 	call	0x20a8	; 0x20a8 <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)>
    21b2:	88 23       	and	r24, r24
    21b4:	49 f0       	breq	.+18     	; 0x21c8 <SdVolume::cacheMirrorBlockFlush(unsigned char)+0x44>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:135
      return false;
    }
    cacheMirrorBlock_ = 0;
    21b6:	10 92 cc 09 	sts	0x09CC, r1	; 0x8009cc <SdVolume::cacheMirrorBlock_>
    21ba:	10 92 cd 09 	sts	0x09CD, r1	; 0x8009cd <SdVolume::cacheMirrorBlock_+0x1>
    21be:	10 92 ce 09 	sts	0x09CE, r1	; 0x8009ce <SdVolume::cacheMirrorBlock_+0x2>
    21c2:	10 92 cf 09 	sts	0x09CF, r1	; 0x8009cf <SdVolume::cacheMirrorBlock_+0x3>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:137
  }
  return true;
    21c6:	81 e0       	ldi	r24, 0x01	; 1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:138
}
    21c8:	0f 91       	pop	r16
    21ca:	08 95       	ret

000021cc <SdVolume::cacheFlush(unsigned char)>:
cacheFlush():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:111
  }

  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(uint8_t blocking) {
    21cc:	0f 93       	push	r16
    21ce:	cf 93       	push	r28
    21d0:	c8 2f       	mov	r28, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:112
  if (cacheDirty_) {
    21d2:	80 91 cb 09 	lds	r24, 0x09CB	; 0x8009cb <SdVolume::cacheDirty_>
    21d6:	81 11       	cpse	r24, r1
    21d8:	05 c0       	rjmp	.+10     	; 0x21e4 <SdVolume::cacheFlush(unsigned char)+0x18>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:127
    if (!cacheMirrorBlockFlush(blocking)) {
      return false;
    }
    cacheDirty_ = 0;
  }
  return true;
    21da:	c1 e0       	ldi	r28, 0x01	; 1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:128
}
    21dc:	8c 2f       	mov	r24, r28
    21de:	cf 91       	pop	r28
    21e0:	0f 91       	pop	r16
    21e2:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:113
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(uint8_t blocking) {
  if (cacheDirty_) {
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data, blocking)) {
    21e4:	40 91 14 02 	lds	r20, 0x0214	; 0x800214 <SdVolume::cacheBlockNumber_>
    21e8:	50 91 15 02 	lds	r21, 0x0215	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    21ec:	60 91 16 02 	lds	r22, 0x0216	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    21f0:	70 91 17 02 	lds	r23, 0x0217	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
    21f4:	0c 2f       	mov	r16, r28
    21f6:	2b ef       	ldi	r18, 0xFB	; 251
    21f8:	39 e0       	ldi	r19, 0x09	; 9
    21fa:	80 91 fb 0b 	lds	r24, 0x0BFB	; 0x800bfb <SdVolume::sdCard_>
    21fe:	90 91 fc 0b 	lds	r25, 0x0BFC	; 0x800bfc <SdVolume::sdCard_+0x1>
    2202:	0e 94 54 10 	call	0x20a8	; 0x20a8 <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)>
    2206:	81 11       	cpse	r24, r1
    2208:	02 c0       	rjmp	.+4      	; 0x220e <__stack+0xf>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:114
      return false;
    220a:	c0 e0       	ldi	r28, 0x00	; 0
    220c:	e7 cf       	rjmp	.-50     	; 0x21dc <SdVolume::cacheFlush(unsigned char)+0x10>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:117
    }

    if (!blocking) {
    220e:	cc 23       	and	r28, r28
    2210:	21 f3       	breq	.-56     	; 0x21da <SdVolume::cacheFlush(unsigned char)+0xe>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:122
      return true;
    }

    // mirror FAT tables
    if (!cacheMirrorBlockFlush(blocking)) {
    2212:	81 e0       	ldi	r24, 0x01	; 1
    2214:	0e 94 c2 10 	call	0x2184	; 0x2184 <SdVolume::cacheMirrorBlockFlush(unsigned char)>
    2218:	88 23       	and	r24, r24
    221a:	b9 f3       	breq	.-18     	; 0x220a <__stack+0xb>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:125
      return false;
    }
    cacheDirty_ = 0;
    221c:	10 92 cb 09 	sts	0x09CB, r1	; 0x8009cb <SdVolume::cacheDirty_>
    2220:	dd cf       	rjmp	.-70     	; 0x21dc <SdVolume::cacheFlush(unsigned char)+0x10>

00002222 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>:
cacheRawBlock():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:140
    cacheMirrorBlock_ = 0;
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
    2222:	8f 92       	push	r8
    2224:	9f 92       	push	r9
    2226:	af 92       	push	r10
    2228:	bf 92       	push	r11
    222a:	ef 92       	push	r14
    222c:	ff 92       	push	r15
    222e:	0f 93       	push	r16
    2230:	1f 93       	push	r17
    2232:	cf 93       	push	r28
    2234:	4b 01       	movw	r8, r22
    2236:	5c 01       	movw	r10, r24
    2238:	c4 2f       	mov	r28, r20
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:141
  if (cacheBlockNumber_ != blockNumber) {
    223a:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <SdVolume::cacheBlockNumber_>
    223e:	90 91 15 02 	lds	r25, 0x0215	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    2242:	a0 91 16 02 	lds	r26, 0x0216	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    2246:	b0 91 17 02 	lds	r27, 0x0217	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
    224a:	88 15       	cp	r24, r8
    224c:	99 05       	cpc	r25, r9
    224e:	aa 05       	cpc	r26, r10
    2250:	bb 05       	cpc	r27, r11
    2252:	51 f1       	breq	.+84     	; 0x22a8 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x86>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:142
    if (!cacheFlush()) {
    2254:	81 e0       	ldi	r24, 0x01	; 1
    2256:	0e 94 e6 10 	call	0x21cc	; 0x21cc <SdVolume::cacheFlush(unsigned char)>
    225a:	81 11       	cpse	r24, r1
    225c:	0b c0       	rjmp	.+22     	; 0x2274 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x52>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:143
      return false;
    225e:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:152
    }
    cacheBlockNumber_ = blockNumber;
  }
  cacheDirty_ |= action;
  return true;
}
    2260:	cf 91       	pop	r28
    2262:	1f 91       	pop	r17
    2264:	0f 91       	pop	r16
    2266:	ff 90       	pop	r15
    2268:	ef 90       	pop	r14
    226a:	bf 90       	pop	r11
    226c:	af 90       	pop	r10
    226e:	9f 90       	pop	r9
    2270:	8f 90       	pop	r8
    2272:	08 95       	ret
readData():
    2274:	8b ef       	ldi	r24, 0xFB	; 251
    2276:	e8 2e       	mov	r14, r24
    2278:	89 e0       	ldi	r24, 0x09	; 9
    227a:	f8 2e       	mov	r15, r24
    227c:	00 e0       	ldi	r16, 0x00	; 0
    227e:	12 e0       	ldi	r17, 0x02	; 2
    2280:	30 e0       	ldi	r19, 0x00	; 0
    2282:	20 e0       	ldi	r18, 0x00	; 0
    2284:	b5 01       	movw	r22, r10
    2286:	a4 01       	movw	r20, r8
    2288:	80 91 fb 0b 	lds	r24, 0x0BFB	; 0x800bfb <SdVolume::sdCard_>
    228c:	90 91 fc 0b 	lds	r25, 0x0BFC	; 0x800bfc <SdVolume::sdCard_+0x1>
    2290:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]>
cacheRawBlock():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:145
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
  if (cacheBlockNumber_ != blockNumber) {
    if (!cacheFlush()) {
      return false;
    }
    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) {
    2294:	88 23       	and	r24, r24
    2296:	19 f3       	breq	.-58     	; 0x225e <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x3c>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:148
      return false;
    }
    cacheBlockNumber_ = blockNumber;
    2298:	80 92 14 02 	sts	0x0214, r8	; 0x800214 <SdVolume::cacheBlockNumber_>
    229c:	90 92 15 02 	sts	0x0215, r9	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    22a0:	a0 92 16 02 	sts	0x0216, r10	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    22a4:	b0 92 17 02 	sts	0x0217, r11	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:150
  }
  cacheDirty_ |= action;
    22a8:	40 91 cb 09 	lds	r20, 0x09CB	; 0x8009cb <SdVolume::cacheDirty_>
    22ac:	4c 2b       	or	r20, r28
    22ae:	40 93 cb 09 	sts	0x09CB, r20	; 0x8009cb <SdVolume::cacheDirty_>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:151
  return true;
    22b2:	81 e0       	ldi	r24, 0x01	; 1
    22b4:	d5 cf       	rjmp	.-86     	; 0x2260 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x3e>

000022b6 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]>:
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:275
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.  Reasons for
   failure include not finding a valid partition, not finding a valid
   FAT file system in the specified partition or an I/O error.
*/
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
    22b6:	8f 92       	push	r8
    22b8:	9f 92       	push	r9
    22ba:	af 92       	push	r10
    22bc:	bf 92       	push	r11
    22be:	cf 92       	push	r12
    22c0:	df 92       	push	r13
    22c2:	ef 92       	push	r14
    22c4:	ff 92       	push	r15
    22c6:	cf 93       	push	r28
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:277
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
    22c8:	23 ef       	ldi	r18, 0xF3	; 243
    22ca:	3e e0       	ldi	r19, 0x0E	; 14
    22cc:	30 93 fc 0b 	sts	0x0BFC, r19	; 0x800bfc <SdVolume::sdCard_+0x1>
    22d0:	20 93 fb 0b 	sts	0x0BFB, r18	; 0x800bfb <SdVolume::sdCard_>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:280
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    22d4:	88 23       	and	r24, r24
    22d6:	09 f4       	brne	.+2      	; 0x22da <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x24>
    22d8:	6d c0       	rjmp	.+218    	; 0x23b4 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0xfe>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:284
    if (part > 4) {
      return false;
    }
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) {
    22da:	40 e0       	ldi	r20, 0x00	; 0
    22dc:	60 e0       	ldi	r22, 0x00	; 0
    22de:	70 e0       	ldi	r23, 0x00	; 0
    22e0:	cb 01       	movw	r24, r22
    22e2:	0e 94 11 11 	call	0x2222	; 0x2222 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    22e6:	81 11       	cpse	r24, r1
    22e8:	0b c0       	rjmp	.+22     	; 0x2300 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x4a>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:315
  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
    // error if not power of 2
    if (clusterSizeShift_++ > 7) {
      return false;
    22ea:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:351
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
    22ec:	cf 91       	pop	r28
    22ee:	ff 90       	pop	r15
    22f0:	ef 90       	pop	r14
    22f2:	df 90       	pop	r13
    22f4:	cf 90       	pop	r12
    22f6:	bf 90       	pop	r11
    22f8:	af 90       	pop	r10
    22fa:	9f 90       	pop	r9
    22fc:	8f 90       	pop	r8
    22fe:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:288
    }
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) {
      return false;
    }
    part_t* p = &cacheBuffer_.mbr.part[part - 1];
    if ((p->boot & 0X7F) != 0  ||
    2300:	80 91 b9 0b 	lds	r24, 0x0BB9	; 0x800bb9 <SdVolume::cacheBuffer_+0x1be>
    2304:	8f 77       	andi	r24, 0x7F	; 127
    2306:	89 f7       	brne	.-30     	; 0x22ea <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x34>
    2308:	80 91 c5 0b 	lds	r24, 0x0BC5	; 0x800bc5 <SdVolume::cacheBuffer_+0x1ca>
    230c:	90 91 c6 0b 	lds	r25, 0x0BC6	; 0x800bc6 <SdVolume::cacheBuffer_+0x1cb>
    2310:	a0 91 c7 0b 	lds	r26, 0x0BC7	; 0x800bc7 <SdVolume::cacheBuffer_+0x1cc>
    2314:	b0 91 c8 0b 	lds	r27, 0x0BC8	; 0x800bc8 <SdVolume::cacheBuffer_+0x1cd>
    2318:	84 36       	cpi	r24, 0x64	; 100
    231a:	91 05       	cpc	r25, r1
    231c:	a1 05       	cpc	r26, r1
    231e:	b1 05       	cpc	r27, r1
    2320:	20 f3       	brcs	.-56     	; 0x22ea <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x34>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:290
        p->totalSectors < 100 ||
        p->firstSector == 0) {
    2322:	c0 90 c1 0b 	lds	r12, 0x0BC1	; 0x800bc1 <SdVolume::cacheBuffer_+0x1c6>
    2326:	d0 90 c2 0b 	lds	r13, 0x0BC2	; 0x800bc2 <SdVolume::cacheBuffer_+0x1c7>
    232a:	e0 90 c3 0b 	lds	r14, 0x0BC3	; 0x800bc3 <SdVolume::cacheBuffer_+0x1c8>
    232e:	f0 90 c4 0b 	lds	r15, 0x0BC4	; 0x800bc4 <SdVolume::cacheBuffer_+0x1c9>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:289
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) {
      return false;
    }
    part_t* p = &cacheBuffer_.mbr.part[part - 1];
    if ((p->boot & 0X7F) != 0  ||
        p->totalSectors < 100 ||
    2332:	c1 14       	cp	r12, r1
    2334:	d1 04       	cpc	r13, r1
    2336:	e1 04       	cpc	r14, r1
    2338:	f1 04       	cpc	r15, r1
    233a:	b9 f2       	breq	.-82     	; 0x22ea <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x34>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:296
      // not a valid partition
      return false;
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) {
    233c:	40 e0       	ldi	r20, 0x00	; 0
    233e:	c7 01       	movw	r24, r14
    2340:	b6 01       	movw	r22, r12
    2342:	0e 94 11 11 	call	0x2222	; 0x2222 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    2346:	88 23       	and	r24, r24
    2348:	81 f2       	breq	.-96     	; 0x22ea <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x34>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:300
    return false;
  }
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
    234a:	80 91 06 0a 	lds	r24, 0x0A06	; 0x800a06 <SdVolume::cacheBuffer_+0xb>
    234e:	90 91 07 0a 	lds	r25, 0x0A07	; 0x800a07 <SdVolume::cacheBuffer_+0xc>
    2352:	81 15       	cp	r24, r1
    2354:	92 40       	sbci	r25, 0x02	; 2
    2356:	49 f6       	brne	.-110    	; 0x22ea <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x34>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:301
      bpb->fatCount == 0 ||
    2358:	a0 91 0b 0a 	lds	r26, 0x0A0B	; 0x800a0b <SdVolume::cacheBuffer_+0x10>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:300
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) {
    return false;
  }
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
    235c:	aa 23       	and	r26, r26
    235e:	29 f2       	breq	.-118    	; 0x22ea <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x34>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:302
      bpb->fatCount == 0 ||
      bpb->reservedSectorCount == 0 ||
    2360:	60 91 09 0a 	lds	r22, 0x0A09	; 0x800a09 <SdVolume::cacheBuffer_+0xe>
    2364:	70 91 0a 0a 	lds	r23, 0x0A0A	; 0x800a0a <SdVolume::cacheBuffer_+0xf>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:301
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) {
    return false;
  }
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
      bpb->fatCount == 0 ||
    2368:	61 15       	cp	r22, r1
    236a:	71 05       	cpc	r23, r1
    236c:	09 f4       	brne	.+2      	; 0x2370 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0xba>
    236e:	bd cf       	rjmp	.-134    	; 0x22ea <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x34>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:303
      bpb->reservedSectorCount == 0 ||
      bpb->sectorsPerCluster == 0) {
    2370:	20 91 08 0a 	lds	r18, 0x0A08	; 0x800a08 <SdVolume::cacheBuffer_+0xd>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:302
    return false;
  }
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
      bpb->fatCount == 0 ||
      bpb->reservedSectorCount == 0 ||
    2374:	22 23       	and	r18, r18
    2376:	09 f4       	brne	.+2      	; 0x237a <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0xc4>
    2378:	b8 cf       	rjmp	.-144    	; 0x22ea <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x34>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:307
      bpb->sectorsPerCluster == 0) {
    // not valid FAT volume
    return false;
  }
  fatCount_ = bpb->fatCount;
    237a:	a0 93 11 0f 	sts	0x0F11, r26	; 0x800f11 <SDLib::SD+0x1e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:308
  blocksPerCluster_ = bpb->sectorsPerCluster;
    237e:	20 93 03 0f 	sts	0x0F03, r18	; 0x800f03 <SDLib::SD+0x10>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:311

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
    2382:	90 e0       	ldi	r25, 0x00	; 0
    2384:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:312
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
    2386:	30 e0       	ldi	r19, 0x00	; 0
    2388:	e1 e0       	ldi	r30, 0x01	; 1
    238a:	f0 e0       	ldi	r31, 0x00	; 0
    238c:	c8 2f       	mov	r28, r24
    238e:	af 01       	movw	r20, r30
    2390:	08 2e       	mov	r0, r24
    2392:	02 c0       	rjmp	.+4      	; 0x2398 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0xe2>
    2394:	44 0f       	add	r20, r20
    2396:	55 1f       	adc	r21, r21
    2398:	0a 94       	dec	r0
    239a:	e2 f7       	brpl	.-8      	; 0x2394 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0xde>
    239c:	24 17       	cp	r18, r20
    239e:	35 07       	cpc	r19, r21
    23a0:	69 f0       	breq	.+26     	; 0x23bc <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x106>
    23a2:	41 e0       	ldi	r20, 0x01	; 1
    23a4:	48 0f       	add	r20, r24
    23a6:	01 96       	adiw	r24, 0x01	; 1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:314
    // error if not power of 2
    if (clusterSizeShift_++ > 7) {
    23a8:	89 30       	cpi	r24, 0x09	; 9
    23aa:	91 05       	cpc	r25, r1
    23ac:	79 f7       	brne	.-34     	; 0x238c <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0xd6>
    23ae:	40 93 0c 0f 	sts	0x0F0C, r20	; 0x800f0c <SDLib::SD+0x19>
    23b2:	9b cf       	rjmp	.-202    	; 0x22ea <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x34>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:276
   the value zero, false, is returned for failure.  Reasons for
   failure include not finding a valid partition, not finding a valid
   FAT file system in the specified partition or an I/O error.
*/
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
  uint32_t volumeStartBlock = 0;
    23b4:	c1 2c       	mov	r12, r1
    23b6:	d1 2c       	mov	r13, r1
    23b8:	76 01       	movw	r14, r12
    23ba:	c0 cf       	rjmp	.-128    	; 0x233c <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x86>
    23bc:	80 93 0c 0f 	sts	0x0F0C, r24	; 0x800f0c <SDLib::SD+0x19>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:318
    // error if not power of 2
    if (clusterSizeShift_++ > 7) {
      return false;
    }
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
    23c0:	20 91 11 0a 	lds	r18, 0x0A11	; 0x800a11 <SdVolume::cacheBuffer_+0x16>
    23c4:	30 91 12 0a 	lds	r19, 0x0A12	; 0x800a12 <SdVolume::cacheBuffer_+0x17>
    23c8:	50 e0       	ldi	r21, 0x00	; 0
    23ca:	40 e0       	ldi	r20, 0x00	; 0
    23cc:	21 15       	cp	r18, r1
    23ce:	31 05       	cpc	r19, r1
    23d0:	41 f4       	brne	.+16     	; 0x23e2 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x12c>
    23d2:	20 91 1f 0a 	lds	r18, 0x0A1F	; 0x800a1f <SdVolume::cacheBuffer_+0x24>
    23d6:	30 91 20 0a 	lds	r19, 0x0A20	; 0x800a20 <SdVolume::cacheBuffer_+0x25>
    23da:	40 91 21 0a 	lds	r20, 0x0A21	; 0x800a21 <SdVolume::cacheBuffer_+0x26>
    23de:	50 91 22 0a 	lds	r21, 0x0A22	; 0x800a22 <SdVolume::cacheBuffer_+0x27>
    23e2:	20 93 04 0f 	sts	0x0F04, r18	; 0x800f04 <SDLib::SD+0x11>
    23e6:	30 93 05 0f 	sts	0x0F05, r19	; 0x800f05 <SDLib::SD+0x12>
    23ea:	40 93 06 0f 	sts	0x0F06, r20	; 0x800f06 <SDLib::SD+0x13>
    23ee:	50 93 07 0f 	sts	0x0F07, r21	; 0x800f07 <SDLib::SD+0x14>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:321
                  bpb->sectorsPerFat16 : bpb->sectorsPerFat32;

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;
    23f2:	46 01       	movw	r8, r12
    23f4:	57 01       	movw	r10, r14
    23f6:	86 0e       	add	r8, r22
    23f8:	97 1e       	adc	r9, r23
    23fa:	a1 1c       	adc	r10, r1
    23fc:	b1 1c       	adc	r11, r1
    23fe:	80 92 12 0f 	sts	0x0F12, r8	; 0x800f12 <SDLib::SD+0x1f>
    2402:	90 92 13 0f 	sts	0x0F13, r9	; 0x800f13 <SDLib::SD+0x20>
    2406:	a0 92 14 0f 	sts	0x0F14, r10	; 0x800f14 <SDLib::SD+0x21>
    240a:	b0 92 15 0f 	sts	0x0F15, r11	; 0x800f15 <SDLib::SD+0x22>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:324

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;
    240e:	e0 91 0c 0a 	lds	r30, 0x0A0C	; 0x800a0c <SdVolume::cacheBuffer_+0x11>
    2412:	f0 91 0d 0a 	lds	r31, 0x0A0D	; 0x800a0d <SdVolume::cacheBuffer_+0x12>
    2416:	f0 93 18 0f 	sts	0x0F18, r31	; 0x800f18 <SDLib::SD+0x25>
    241a:	e0 93 17 0f 	sts	0x0F17, r30	; 0x800f17 <SDLib::SD+0x24>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:327

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
    241e:	b0 e0       	ldi	r27, 0x00	; 0
    2420:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
    2424:	dc 01       	movw	r26, r24
    2426:	cb 01       	movw	r24, r22
    2428:	88 0d       	add	r24, r8
    242a:	99 1d       	adc	r25, r9
    242c:	aa 1d       	adc	r26, r10
    242e:	bb 1d       	adc	r27, r11
    2430:	80 93 19 0f 	sts	0x0F19, r24	; 0x800f19 <SDLib::SD+0x26>
    2434:	90 93 1a 0f 	sts	0x0F1A, r25	; 0x800f1a <SDLib::SD+0x27>
    2438:	a0 93 1b 0f 	sts	0x0F1B, r26	; 0x800f1b <SDLib::SD+0x28>
    243c:	b0 93 1c 0f 	sts	0x0F1C, r27	; 0x800f1c <SDLib::SD+0x29>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:330

  // data start for FAT16 and FAT32
  dataStartBlock_ = rootDirStart_ + ((32 * bpb->rootDirEntryCount + 511) / 512);
    2440:	25 e0       	ldi	r18, 0x05	; 5
    2442:	ee 0f       	add	r30, r30
    2444:	ff 1f       	adc	r31, r31
    2446:	2a 95       	dec	r18
    2448:	e1 f7       	brne	.-8      	; 0x2442 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x18c>
    244a:	e1 50       	subi	r30, 0x01	; 1
    244c:	fe 4f       	sbci	r31, 0xFE	; 254
    244e:	ef 2f       	mov	r30, r31
    2450:	ff 27       	eor	r31, r31
    2452:	e6 95       	lsr	r30
    2454:	8e 0f       	add	r24, r30
    2456:	9f 1f       	adc	r25, r31
    2458:	a1 1d       	adc	r26, r1
    245a:	b1 1d       	adc	r27, r1
    245c:	80 93 0d 0f 	sts	0x0F0D, r24	; 0x800f0d <SDLib::SD+0x1a>
    2460:	90 93 0e 0f 	sts	0x0F0E, r25	; 0x800f0e <SDLib::SD+0x1b>
    2464:	a0 93 0f 0f 	sts	0x0F0F, r26	; 0x800f0f <SDLib::SD+0x1c>
    2468:	b0 93 10 0f 	sts	0x0F10, r27	; 0x800f10 <SDLib::SD+0x1d>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:333

  // total blocks for FAT16 or FAT32
  uint32_t totalBlocks = bpb->totalSectors16 ?
    246c:	80 90 0e 0a 	lds	r8, 0x0A0E	; 0x800a0e <SdVolume::cacheBuffer_+0x13>
    2470:	90 90 0f 0a 	lds	r9, 0x0A0F	; 0x800a0f <SdVolume::cacheBuffer_+0x14>
    2474:	b1 2c       	mov	r11, r1
    2476:	a1 2c       	mov	r10, r1
    2478:	81 14       	cp	r8, r1
    247a:	91 04       	cpc	r9, r1
    247c:	41 f4       	brne	.+16     	; 0x248e <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x1d8>
    247e:	80 90 1b 0a 	lds	r8, 0x0A1B	; 0x800a1b <SdVolume::cacheBuffer_+0x20>
    2482:	90 90 1c 0a 	lds	r9, 0x0A1C	; 0x800a1c <SdVolume::cacheBuffer_+0x21>
    2486:	a0 90 1d 0a 	lds	r10, 0x0A1D	; 0x800a1d <SdVolume::cacheBuffer_+0x22>
    248a:	b0 90 1e 0a 	lds	r11, 0x0A1E	; 0x800a1e <SdVolume::cacheBuffer_+0x23>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:336
                         bpb->totalSectors16 : bpb->totalSectors32;
  // total data blocks
  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);
    248e:	c8 1a       	sub	r12, r24
    2490:	d9 0a       	sbc	r13, r25
    2492:	ea 0a       	sbc	r14, r26
    2494:	fb 0a       	sbc	r15, r27
    2496:	c8 0c       	add	r12, r8
    2498:	d9 1c       	adc	r13, r9
    249a:	ea 1c       	adc	r14, r10
    249c:	fb 1c       	adc	r15, r11
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:339

  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;
    249e:	04 c0       	rjmp	.+8      	; 0x24a8 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x1f2>
    24a0:	f6 94       	lsr	r15
    24a2:	e7 94       	ror	r14
    24a4:	d7 94       	ror	r13
    24a6:	c7 94       	ror	r12
    24a8:	ca 95       	dec	r28
    24aa:	d2 f7       	brpl	.-12     	; 0x24a0 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x1ea>
    24ac:	c0 92 08 0f 	sts	0x0F08, r12	; 0x800f08 <SDLib::SD+0x15>
    24b0:	d0 92 09 0f 	sts	0x0F09, r13	; 0x800f09 <SDLib::SD+0x16>
    24b4:	e0 92 0a 0f 	sts	0x0F0A, r14	; 0x800f0a <SDLib::SD+0x17>
    24b8:	f0 92 0b 0f 	sts	0x0F0B, r15	; 0x800f0b <SDLib::SD+0x18>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:342

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
    24bc:	85 ef       	ldi	r24, 0xF5	; 245
    24be:	c8 16       	cp	r12, r24
    24c0:	8f e0       	ldi	r24, 0x0F	; 15
    24c2:	d8 06       	cpc	r13, r24
    24c4:	e1 04       	cpc	r14, r1
    24c6:	f1 04       	cpc	r15, r1
    24c8:	28 f4       	brcc	.+10     	; 0x24d4 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x21e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:343
    fatType_ = 12;
    24ca:	8c e0       	ldi	r24, 0x0C	; 12
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:348
  } else if (clusterCount_ < 65525) {
    fatType_ = 16;
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
    24cc:	80 93 16 0f 	sts	0x0F16, r24	; 0x800f16 <SDLib::SD+0x23>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:350
  }
  return true;
    24d0:	81 e0       	ldi	r24, 0x01	; 1
    24d2:	0c cf       	rjmp	.-488    	; 0x22ec <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x36>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:345

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
    fatType_ = 16;
    24d4:	80 e1       	ldi	r24, 0x10	; 16
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:344
  clusterCount_ >>= clusterSizeShift_;

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
    24d6:	25 ef       	ldi	r18, 0xF5	; 245
    24d8:	c2 16       	cp	r12, r18
    24da:	2f ef       	ldi	r18, 0xFF	; 255
    24dc:	d2 06       	cpc	r13, r18
    24de:	e1 04       	cpc	r14, r1
    24e0:	f1 04       	cpc	r15, r1
    24e2:	a0 f3       	brcs	.-24     	; 0x24cc <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x216>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:347
    fatType_ = 16;
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    24e4:	80 91 27 0a 	lds	r24, 0x0A27	; 0x800a27 <SdVolume::cacheBuffer_+0x2c>
    24e8:	90 91 28 0a 	lds	r25, 0x0A28	; 0x800a28 <SdVolume::cacheBuffer_+0x2d>
    24ec:	a0 91 29 0a 	lds	r26, 0x0A29	; 0x800a29 <SdVolume::cacheBuffer_+0x2e>
    24f0:	b0 91 2a 0a 	lds	r27, 0x0A2A	; 0x800a2a <SdVolume::cacheBuffer_+0x2f>
    24f4:	80 93 19 0f 	sts	0x0F19, r24	; 0x800f19 <SDLib::SD+0x26>
    24f8:	90 93 1a 0f 	sts	0x0F1A, r25	; 0x800f1a <SDLib::SD+0x27>
    24fc:	a0 93 1b 0f 	sts	0x0F1B, r26	; 0x800f1b <SDLib::SD+0x28>
    2500:	b0 93 1c 0f 	sts	0x0F1C, r27	; 0x800f1c <SDLib::SD+0x29>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:348
    fatType_ = 32;
    2504:	80 e2       	ldi	r24, 0x20	; 32
    2506:	e2 cf       	rjmp	.-60     	; 0x24cc <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]+0x216>

00002508 <SdVolume::fatPut(unsigned long, unsigned long)>:
fatPut():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:203
  }
  return true;
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
    2508:	4f 92       	push	r4
    250a:	5f 92       	push	r5
    250c:	6f 92       	push	r6
    250e:	7f 92       	push	r7
    2510:	8f 92       	push	r8
    2512:	9f 92       	push	r9
    2514:	af 92       	push	r10
    2516:	bf 92       	push	r11
    2518:	cf 92       	push	r12
    251a:	df 92       	push	r13
    251c:	ef 92       	push	r14
    251e:	ff 92       	push	r15
    2520:	0f 93       	push	r16
    2522:	1f 93       	push	r17
    2524:	cf 93       	push	r28
    2526:	df 93       	push	r29
    2528:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:205
  // error if reserved cluster
  if (cluster < 2) {
    252a:	42 30       	cpi	r20, 0x02	; 2
    252c:	51 05       	cpc	r21, r1
    252e:	61 05       	cpc	r22, r1
    2530:	71 05       	cpc	r23, r1
    2532:	90 f4       	brcc	.+36     	; 0x2558 <SdVolume::fatPut(unsigned long, unsigned long)+0x50>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:206
    return false;
    2534:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:236
  // mirror second FAT
  if (fatCount_ > 1) {
    cacheMirrorBlock_ = lba + blocksPerFat_;
  }
  return true;
}
    2536:	df 91       	pop	r29
    2538:	cf 91       	pop	r28
    253a:	1f 91       	pop	r17
    253c:	0f 91       	pop	r16
    253e:	ff 90       	pop	r15
    2540:	ef 90       	pop	r14
    2542:	df 90       	pop	r13
    2544:	cf 90       	pop	r12
    2546:	bf 90       	pop	r11
    2548:	af 90       	pop	r10
    254a:	9f 90       	pop	r9
    254c:	8f 90       	pop	r8
    254e:	7f 90       	pop	r7
    2550:	6f 90       	pop	r6
    2552:	5f 90       	pop	r5
    2554:	4f 90       	pop	r4
    2556:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:210
  if (cluster < 2) {
    return false;
  }

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) {
    2558:	89 85       	ldd	r24, Y+9	; 0x09
    255a:	9a 85       	ldd	r25, Y+10	; 0x0a
    255c:	ab 85       	ldd	r26, Y+11	; 0x0b
    255e:	bc 85       	ldd	r27, Y+12	; 0x0c
    2560:	01 96       	adiw	r24, 0x01	; 1
    2562:	a1 1d       	adc	r26, r1
    2564:	b1 1d       	adc	r27, r1
    2566:	84 17       	cp	r24, r20
    2568:	95 07       	cpc	r25, r21
    256a:	a6 07       	cpc	r26, r22
    256c:	b7 07       	cpc	r27, r23
    256e:	10 f3       	brcs	.-60     	; 0x2534 <SdVolume::fatPut(unsigned long, unsigned long)+0x2c>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:215
    return false;
  }

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
    2570:	cb 88       	ldd	r12, Y+19	; 0x13
    2572:	dc 88       	ldd	r13, Y+20	; 0x14
    2574:	ed 88       	ldd	r14, Y+21	; 0x15
    2576:	fe 88       	ldd	r15, Y+22	; 0x16
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:216
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    2578:	8f 89       	ldd	r24, Y+23	; 0x17
    257a:	80 31       	cpi	r24, 0x10	; 16
    257c:	09 f0       	breq	.+2      	; 0x2580 <SdVolume::fatPut(unsigned long, unsigned long)+0x78>
    257e:	42 c0       	rjmp	.+132    	; 0x2604 <SdVolume::fatPut(unsigned long, unsigned long)+0xfc>
    2580:	bb 27       	eor	r27, r27
    2582:	a7 2f       	mov	r26, r23
    2584:	96 2f       	mov	r25, r22
    2586:	85 2f       	mov	r24, r21
    2588:	48 01       	movw	r8, r16
    258a:	59 01       	movw	r10, r18
    258c:	2a 01       	movw	r4, r20
    258e:	3b 01       	movw	r6, r22
    2590:	c8 0e       	add	r12, r24
    2592:	d9 1e       	adc	r13, r25
    2594:	ea 1e       	adc	r14, r26
    2596:	fb 1e       	adc	r15, r27
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:218

  if (lba != cacheBlockNumber_) {
    2598:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <SdVolume::cacheBlockNumber_>
    259c:	90 91 15 02 	lds	r25, 0x0215	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    25a0:	a0 91 16 02 	lds	r26, 0x0216	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    25a4:	b0 91 17 02 	lds	r27, 0x0217	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
    25a8:	c8 16       	cp	r12, r24
    25aa:	d9 06       	cpc	r13, r25
    25ac:	ea 06       	cpc	r14, r26
    25ae:	fb 06       	cpc	r15, r27
    25b0:	99 f5       	brne	.+102    	; 0x2618 <SdVolume::fatPut(unsigned long, unsigned long)+0x110>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:224
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) {
      return false;
    }
  }
  // store entry
  if (fatType_ == 16) {
    25b2:	8f 89       	ldd	r24, Y+23	; 0x17
    25b4:	80 31       	cpi	r24, 0x10	; 16
    25b6:	c1 f5       	brne	.+112    	; 0x2628 <SdVolume::fatPut(unsigned long, unsigned long)+0x120>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:225
    cacheBuffer_.fat16[cluster & 0XFF] = value;
    25b8:	b3 01       	movw	r22, r6
    25ba:	a2 01       	movw	r20, r4
    25bc:	55 27       	eor	r21, r21
    25be:	66 27       	eor	r22, r22
    25c0:	77 27       	eor	r23, r23
    25c2:	44 0f       	add	r20, r20
    25c4:	55 1f       	adc	r21, r21
    25c6:	45 50       	subi	r20, 0x05	; 5
    25c8:	56 4f       	sbci	r21, 0xF6	; 246
    25ca:	fa 01       	movw	r30, r20
    25cc:	91 82       	std	Z+1, r9	; 0x01
    25ce:	80 82       	st	Z, r8
cacheSetDirty():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:611
    }
    static uint8_t cacheFlush(uint8_t blocking = 1);
    static uint8_t cacheMirrorBlockFlush(uint8_t blocking);
    static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
    static void cacheSetDirty(void) {
      cacheDirty_ |= CACHE_FOR_WRITE;
    25d0:	80 91 cb 09 	lds	r24, 0x09CB	; 0x8009cb <SdVolume::cacheDirty_>
    25d4:	81 60       	ori	r24, 0x01	; 1
    25d6:	80 93 cb 09 	sts	0x09CB, r24	; 0x8009cb <SdVolume::cacheDirty_>
fatPut():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:232
    cacheBuffer_.fat32[cluster & 0X7F] = value;
  }
  cacheSetDirty();

  // mirror second FAT
  if (fatCount_ > 1) {
    25da:	8a 89       	ldd	r24, Y+18	; 0x12
    25dc:	82 30       	cpi	r24, 0x02	; 2
    25de:	80 f0       	brcs	.+32     	; 0x2600 <SdVolume::fatPut(unsigned long, unsigned long)+0xf8>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:233
    cacheMirrorBlock_ = lba + blocksPerFat_;
    25e0:	8d 81       	ldd	r24, Y+5	; 0x05
    25e2:	9e 81       	ldd	r25, Y+6	; 0x06
    25e4:	af 81       	ldd	r26, Y+7	; 0x07
    25e6:	b8 85       	ldd	r27, Y+8	; 0x08
    25e8:	8c 0d       	add	r24, r12
    25ea:	9d 1d       	adc	r25, r13
    25ec:	ae 1d       	adc	r26, r14
    25ee:	bf 1d       	adc	r27, r15
    25f0:	80 93 cc 09 	sts	0x09CC, r24	; 0x8009cc <SdVolume::cacheMirrorBlock_>
    25f4:	90 93 cd 09 	sts	0x09CD, r25	; 0x8009cd <SdVolume::cacheMirrorBlock_+0x1>
    25f8:	a0 93 ce 09 	sts	0x09CE, r26	; 0x8009ce <SdVolume::cacheMirrorBlock_+0x2>
    25fc:	b0 93 cf 09 	sts	0x09CF, r27	; 0x8009cf <SdVolume::cacheMirrorBlock_+0x3>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:235
  }
  return true;
    2600:	81 e0       	ldi	r24, 0x01	; 1
    2602:	99 cf       	rjmp	.-206    	; 0x2536 <SdVolume::fatPut(unsigned long, unsigned long)+0x2e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:216
    return false;
  }

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    2604:	db 01       	movw	r26, r22
    2606:	ca 01       	movw	r24, r20
    2608:	e7 e0       	ldi	r30, 0x07	; 7
    260a:	b6 95       	lsr	r27
    260c:	a7 95       	ror	r26
    260e:	97 95       	ror	r25
    2610:	87 95       	ror	r24
    2612:	ea 95       	dec	r30
    2614:	d1 f7       	brne	.-12     	; 0x260a <SdVolume::fatPut(unsigned long, unsigned long)+0x102>
    2616:	b8 cf       	rjmp	.-144    	; 0x2588 <SdVolume::fatPut(unsigned long, unsigned long)+0x80>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:219

  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) {
    2618:	40 e0       	ldi	r20, 0x00	; 0
    261a:	c7 01       	movw	r24, r14
    261c:	b6 01       	movw	r22, r12
    261e:	0e 94 11 11 	call	0x2222	; 0x2222 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    2622:	81 11       	cpse	r24, r1
    2624:	c6 cf       	rjmp	.-116    	; 0x25b2 <SdVolume::fatPut(unsigned long, unsigned long)+0xaa>
    2626:	86 cf       	rjmp	.-244    	; 0x2534 <SdVolume::fatPut(unsigned long, unsigned long)+0x2c>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:227
  }
  // store entry
  if (fatType_ == 16) {
    cacheBuffer_.fat16[cluster & 0XFF] = value;
  } else {
    cacheBuffer_.fat32[cluster & 0X7F] = value;
    2628:	b3 01       	movw	r22, r6
    262a:	a2 01       	movw	r20, r4
    262c:	4f 77       	andi	r20, 0x7F	; 127
    262e:	55 27       	eor	r21, r21
    2630:	66 27       	eor	r22, r22
    2632:	77 27       	eor	r23, r23
    2634:	44 0f       	add	r20, r20
    2636:	55 1f       	adc	r21, r21
    2638:	44 0f       	add	r20, r20
    263a:	55 1f       	adc	r21, r21
    263c:	45 50       	subi	r20, 0x05	; 5
    263e:	56 4f       	sbci	r21, 0xF6	; 246
    2640:	fa 01       	movw	r30, r20
    2642:	80 82       	st	Z, r8
    2644:	91 82       	std	Z+1, r9	; 0x01
    2646:	a2 82       	std	Z+2, r10	; 0x02
    2648:	b3 82       	std	Z+3, r11	; 0x03
    264a:	c2 cf       	rjmp	.-124    	; 0x25d0 <SdVolume::fatPut(unsigned long, unsigned long)+0xc8>

0000264c <SdVolume::fatGet(unsigned long, unsigned long*) const>:
fatGet():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:183
  *size = s;
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
    264c:	8f 92       	push	r8
    264e:	9f 92       	push	r9
    2650:	af 92       	push	r10
    2652:	bf 92       	push	r11
    2654:	cf 92       	push	r12
    2656:	df 92       	push	r13
    2658:	ef 92       	push	r14
    265a:	ff 92       	push	r15
    265c:	0f 93       	push	r16
    265e:	1f 93       	push	r17
    2660:	cf 93       	push	r28
    2662:	df 93       	push	r29
    2664:	fc 01       	movw	r30, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:184
  if (cluster > (clusterCount_ + 1)) {
    2666:	81 85       	ldd	r24, Z+9	; 0x09
    2668:	92 85       	ldd	r25, Z+10	; 0x0a
    266a:	a3 85       	ldd	r26, Z+11	; 0x0b
    266c:	b4 85       	ldd	r27, Z+12	; 0x0c
    266e:	01 96       	adiw	r24, 0x01	; 1
    2670:	a1 1d       	adc	r26, r1
    2672:	b1 1d       	adc	r27, r1
    2674:	84 17       	cp	r24, r20
    2676:	95 07       	cpc	r25, r21
    2678:	a6 07       	cpc	r26, r22
    267a:	b7 07       	cpc	r27, r23
    267c:	70 f4       	brcc	.+28     	; 0x269a <SdVolume::fatGet(unsigned long, unsigned long*) const+0x4e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:185
    return false;
    267e:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:200
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
  }
  return true;
}
    2680:	df 91       	pop	r29
    2682:	cf 91       	pop	r28
    2684:	1f 91       	pop	r17
    2686:	0f 91       	pop	r16
    2688:	ff 90       	pop	r15
    268a:	ef 90       	pop	r14
    268c:	df 90       	pop	r13
    268e:	cf 90       	pop	r12
    2690:	bf 90       	pop	r11
    2692:	af 90       	pop	r10
    2694:	9f 90       	pop	r9
    2696:	8f 90       	pop	r8
    2698:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:187
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) {
    return false;
  }
  uint32_t lba = fatStartBlock_;
    269a:	83 88       	ldd	r8, Z+19	; 0x13
    269c:	94 88       	ldd	r9, Z+20	; 0x14
    269e:	a5 88       	ldd	r10, Z+21	; 0x15
    26a0:	b6 88       	ldd	r11, Z+22	; 0x16
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:188
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    26a2:	87 89       	ldd	r24, Z+23	; 0x17
    26a4:	80 31       	cpi	r24, 0x10	; 16
    26a6:	89 f5       	brne	.+98     	; 0x270a <SdVolume::fatGet(unsigned long, unsigned long*) const+0xbe>
    26a8:	bb 27       	eor	r27, r27
    26aa:	a7 2f       	mov	r26, r23
    26ac:	96 2f       	mov	r25, r22
    26ae:	85 2f       	mov	r24, r21
    26b0:	e9 01       	movw	r28, r18
    26b2:	6a 01       	movw	r12, r20
    26b4:	7b 01       	movw	r14, r22
    26b6:	8f 01       	movw	r16, r30
    26b8:	bc 01       	movw	r22, r24
    26ba:	cd 01       	movw	r24, r26
    26bc:	68 0d       	add	r22, r8
    26be:	79 1d       	adc	r23, r9
    26c0:	8a 1d       	adc	r24, r10
    26c2:	9b 1d       	adc	r25, r11
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:189
  if (lba != cacheBlockNumber_) {
    26c4:	80 90 14 02 	lds	r8, 0x0214	; 0x800214 <SdVolume::cacheBlockNumber_>
    26c8:	90 90 15 02 	lds	r9, 0x0215	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    26cc:	a0 90 16 02 	lds	r10, 0x0216	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    26d0:	b0 90 17 02 	lds	r11, 0x0217	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
    26d4:	86 16       	cp	r8, r22
    26d6:	97 06       	cpc	r9, r23
    26d8:	a8 06       	cpc	r10, r24
    26da:	b9 06       	cpc	r11, r25
    26dc:	01 f5       	brne	.+64     	; 0x271e <SdVolume::fatGet(unsigned long, unsigned long*) const+0xd2>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:194
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) {
      return false;
    }
  }
  if (fatType_ == 16) {
    26de:	f8 01       	movw	r30, r16
    26e0:	87 89       	ldd	r24, Z+23	; 0x17
    26e2:	80 31       	cpi	r24, 0x10	; 16
    26e4:	11 f5       	brne	.+68     	; 0x272a <SdVolume::fatGet(unsigned long, unsigned long*) const+0xde>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:195
    *value = cacheBuffer_.fat16[cluster & 0XFF];
    26e6:	dd 24       	eor	r13, r13
    26e8:	ee 24       	eor	r14, r14
    26ea:	ff 24       	eor	r15, r15
    26ec:	f6 01       	movw	r30, r12
    26ee:	ee 0f       	add	r30, r30
    26f0:	ff 1f       	adc	r31, r31
    26f2:	e5 50       	subi	r30, 0x05	; 5
    26f4:	f6 4f       	sbci	r31, 0xF6	; 246
    26f6:	80 81       	ld	r24, Z
    26f8:	91 81       	ldd	r25, Z+1	; 0x01
    26fa:	b0 e0       	ldi	r27, 0x00	; 0
    26fc:	a0 e0       	ldi	r26, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:197
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
    26fe:	88 83       	st	Y, r24
    2700:	99 83       	std	Y+1, r25	; 0x01
    2702:	aa 83       	std	Y+2, r26	; 0x02
    2704:	bb 83       	std	Y+3, r27	; 0x03
    2706:	81 e0       	ldi	r24, 0x01	; 1
    2708:	bb cf       	rjmp	.-138    	; 0x2680 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x34>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:188
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) {
    return false;
  }
  uint32_t lba = fatStartBlock_;
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    270a:	db 01       	movw	r26, r22
    270c:	ca 01       	movw	r24, r20
    270e:	c7 e0       	ldi	r28, 0x07	; 7
    2710:	b6 95       	lsr	r27
    2712:	a7 95       	ror	r26
    2714:	97 95       	ror	r25
    2716:	87 95       	ror	r24
    2718:	ca 95       	dec	r28
    271a:	d1 f7       	brne	.-12     	; 0x2710 <SdVolume::fatGet(unsigned long, unsigned long*) const+0xc4>
    271c:	c9 cf       	rjmp	.-110    	; 0x26b0 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x64>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:190
  if (lba != cacheBlockNumber_) {
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) {
    271e:	40 e0       	ldi	r20, 0x00	; 0
    2720:	0e 94 11 11 	call	0x2222	; 0x2222 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    2724:	81 11       	cpse	r24, r1
    2726:	db cf       	rjmp	.-74     	; 0x26de <SdVolume::fatGet(unsigned long, unsigned long*) const+0x92>
    2728:	aa cf       	rjmp	.-172    	; 0x267e <SdVolume::fatGet(unsigned long, unsigned long*) const+0x32>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:197
    }
  }
  if (fatType_ == 16) {
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
    272a:	e8 94       	clt
    272c:	c7 f8       	bld	r12, 7
    272e:	dd 24       	eor	r13, r13
    2730:	ee 24       	eor	r14, r14
    2732:	ff 24       	eor	r15, r15
    2734:	f6 01       	movw	r30, r12
    2736:	ee 0f       	add	r30, r30
    2738:	ff 1f       	adc	r31, r31
    273a:	ee 0f       	add	r30, r30
    273c:	ff 1f       	adc	r31, r31
    273e:	e5 50       	subi	r30, 0x05	; 5
    2740:	f6 4f       	sbci	r31, 0xF6	; 246
    2742:	80 81       	ld	r24, Z
    2744:	91 81       	ldd	r25, Z+1	; 0x01
    2746:	a2 81       	ldd	r26, Z+2	; 0x02
    2748:	b3 81       	ldd	r27, Z+3	; 0x03
    274a:	bf 70       	andi	r27, 0x0F	; 15
    274c:	d8 cf       	rjmp	.-80     	; 0x26fe <SdVolume::fatGet(unsigned long, unsigned long*) const+0xb2>

0000274e <SdVolume::chainSize(unsigned long, unsigned long*) const>:
chainSize():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:170
  cacheSetDirty();
  return true;
}
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
    274e:	4f 92       	push	r4
    2750:	5f 92       	push	r5
    2752:	6f 92       	push	r6
    2754:	7f 92       	push	r7
    2756:	af 92       	push	r10
    2758:	bf 92       	push	r11
    275a:	cf 92       	push	r12
    275c:	df 92       	push	r13
    275e:	ef 92       	push	r14
    2760:	ff 92       	push	r15
    2762:	0f 93       	push	r16
    2764:	1f 93       	push	r17
    2766:	cf 93       	push	r28
    2768:	df 93       	push	r29
    276a:	00 d0       	rcall	.+0      	; 0x276c <SdVolume::chainSize(unsigned long, unsigned long*) const+0x1e>
    276c:	1f 92       	push	r1
    276e:	cd b7       	in	r28, 0x3d	; 61
    2770:	de b7       	in	r29, 0x3e	; 62
    2772:	8c 01       	movw	r16, r24
    2774:	49 83       	std	Y+1, r20	; 0x01
    2776:	5a 83       	std	Y+2, r21	; 0x02
    2778:	6b 83       	std	Y+3, r22	; 0x03
    277a:	7c 83       	std	Y+4, r23	; 0x04
    277c:	59 01       	movw	r10, r18
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:171
  uint32_t s = 0;
    277e:	c1 2c       	mov	r12, r1
    2780:	d1 2c       	mov	r13, r1
    2782:	76 01       	movw	r14, r12
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:176
  do {
    if (!fatGet(cluster, &cluster)) {
      return false;
    }
    s += 512UL << clusterSizeShift_;
    2784:	41 2c       	mov	r4, r1
    2786:	82 e0       	ldi	r24, 0x02	; 2
    2788:	58 2e       	mov	r5, r24
    278a:	61 2c       	mov	r6, r1
    278c:	71 2c       	mov	r7, r1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:173
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
  uint32_t s = 0;
  do {
    if (!fatGet(cluster, &cluster)) {
    278e:	49 81       	ldd	r20, Y+1	; 0x01
    2790:	5a 81       	ldd	r21, Y+2	; 0x02
    2792:	6b 81       	ldd	r22, Y+3	; 0x03
    2794:	7c 81       	ldd	r23, Y+4	; 0x04
    2796:	9e 01       	movw	r18, r28
    2798:	2f 5f       	subi	r18, 0xFF	; 255
    279a:	3f 4f       	sbci	r19, 0xFF	; 255
    279c:	c8 01       	movw	r24, r16
    279e:	0e 94 26 13 	call	0x264c	; 0x264c <SdVolume::fatGet(unsigned long, unsigned long*) const>
    27a2:	88 23       	and	r24, r24
    27a4:	39 f1       	breq	.+78     	; 0x27f4 <SdVolume::chainSize(unsigned long, unsigned long*) const+0xa6>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:176
      return false;
    }
    s += 512UL << clusterSizeShift_;
    27a6:	f8 01       	movw	r30, r16
    27a8:	85 85       	ldd	r24, Z+13	; 0x0d
    27aa:	a3 01       	movw	r20, r6
    27ac:	92 01       	movw	r18, r4
    27ae:	04 c0       	rjmp	.+8      	; 0x27b8 <SdVolume::chainSize(unsigned long, unsigned long*) const+0x6a>
    27b0:	22 0f       	add	r18, r18
    27b2:	33 1f       	adc	r19, r19
    27b4:	44 1f       	adc	r20, r20
    27b6:	55 1f       	adc	r21, r21
    27b8:	8a 95       	dec	r24
    27ba:	d2 f7       	brpl	.-12     	; 0x27b0 <SdVolume::chainSize(unsigned long, unsigned long*) const+0x62>
    27bc:	da 01       	movw	r26, r20
    27be:	c9 01       	movw	r24, r18
    27c0:	c8 0e       	add	r12, r24
    27c2:	d9 1e       	adc	r13, r25
    27c4:	ea 1e       	adc	r14, r26
    27c6:	fb 1e       	adc	r15, r27
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:177
  } while (!isEOC(cluster));
    27c8:	49 81       	ldd	r20, Y+1	; 0x01
    27ca:	5a 81       	ldd	r21, Y+2	; 0x02
    27cc:	6b 81       	ldd	r22, Y+3	; 0x03
    27ce:	7c 81       	ldd	r23, Y+4	; 0x04
_ZNK8SdVolume5isEOCEm():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:622
    uint8_t fatPutEOC(uint32_t cluster) {
      return fatPut(cluster, 0x0FFFFFFF);
    }
    uint8_t freeChain(uint32_t cluster);
    uint8_t isEOC(uint32_t cluster) const {
      return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
    27d0:	87 89       	ldd	r24, Z+23	; 0x17
    27d2:	80 31       	cpi	r24, 0x10	; 16
    27d4:	11 f1       	breq	.+68     	; 0x281a <SdVolume::chainSize(unsigned long, unsigned long*) const+0xcc>
chainSize():
    27d6:	88 ef       	ldi	r24, 0xF8	; 248
    27d8:	9f ef       	ldi	r25, 0xFF	; 255
    27da:	af ef       	ldi	r26, 0xFF	; 255
    27dc:	bf e0       	ldi	r27, 0x0F	; 15
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:177
    27de:	48 17       	cp	r20, r24
    27e0:	59 07       	cpc	r21, r25
    27e2:	6a 07       	cpc	r22, r26
    27e4:	7b 07       	cpc	r23, r27
    27e6:	98 f2       	brcs	.-90     	; 0x278e <SdVolume::chainSize(unsigned long, unsigned long*) const+0x40>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:178
  *size = s;
    27e8:	f5 01       	movw	r30, r10
    27ea:	c0 82       	st	Z, r12
    27ec:	d1 82       	std	Z+1, r13	; 0x01
    27ee:	e2 82       	std	Z+2, r14	; 0x02
    27f0:	f3 82       	std	Z+3, r15	; 0x03
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:179
  return true;
    27f2:	81 e0       	ldi	r24, 0x01	; 1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:180
}
    27f4:	0f 90       	pop	r0
    27f6:	0f 90       	pop	r0
    27f8:	0f 90       	pop	r0
    27fa:	0f 90       	pop	r0
    27fc:	df 91       	pop	r29
    27fe:	cf 91       	pop	r28
    2800:	1f 91       	pop	r17
    2802:	0f 91       	pop	r16
    2804:	ff 90       	pop	r15
    2806:	ef 90       	pop	r14
    2808:	df 90       	pop	r13
    280a:	cf 90       	pop	r12
    280c:	bf 90       	pop	r11
    280e:	af 90       	pop	r10
    2810:	7f 90       	pop	r7
    2812:	6f 90       	pop	r6
    2814:	5f 90       	pop	r5
    2816:	4f 90       	pop	r4
    2818:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:622
    281a:	88 ef       	ldi	r24, 0xF8	; 248
    281c:	9f ef       	ldi	r25, 0xFF	; 255
    281e:	a0 e0       	ldi	r26, 0x00	; 0
    2820:	b0 e0       	ldi	r27, 0x00	; 0
    2822:	dd cf       	rjmp	.-70     	; 0x27de <SdVolume::chainSize(unsigned long, unsigned long*) const+0x90>

00002824 <SdFile::openRoot(SdVolume*) [clone .constprop.152]>:
openRoot():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:653
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include the FAT volume has not been initialized
   or it a FAT12 volume.
*/
uint8_t SdFile::openRoot(SdVolume* vol) {
    2824:	cf 93       	push	r28
    2826:	df 93       	push	r29
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:655
  // error if file is already open
  if (isOpen()) {
    2828:	fc 01       	movw	r30, r24
    282a:	25 81       	ldd	r18, Z+5	; 0x05
    282c:	22 23       	and	r18, r18
    282e:	21 f0       	breq	.+8      	; 0x2838 <SdFile::openRoot(SdVolume*) [clone .constprop.152]+0x14>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:656
    return false;
    2830:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:685

  // root has no directory entry
  dirBlock_ = 0;
  dirIndex_ = 0;
  return true;
}
    2832:	df 91       	pop	r29
    2834:	cf 91       	pop	r28
    2836:	08 95       	ret
    2838:	ec 01       	movw	r28, r24
    283a:	80 91 16 0f 	lds	r24, 0x0F16	; 0x800f16 <SDLib::SD+0x23>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:659
  // error if file is already open
  if (isOpen()) {
    return false;
  }

  if (vol->fatType() == 16) {
    283e:	80 31       	cpi	r24, 0x10	; 16
    2840:	59 f5       	brne	.+86     	; 0x2898 <SdFile::openRoot(SdVolume*) [clone .constprop.152]+0x74>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:660
    type_ = FAT_FILE_TYPE_ROOT16;
    2842:	82 e0       	ldi	r24, 0x02	; 2
    2844:	85 83       	std	Z+5, r24	; 0x05
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:661
    firstCluster_ = 0;
    2846:	17 8a       	std	Z+23, r1	; 0x17
    2848:	10 8e       	std	Z+24, r1	; 0x18
    284a:	11 8e       	std	Z+25, r1	; 0x19
    284c:	12 8e       	std	Z+26, r1	; 0x1a
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:662
    fileSize_ = 32 * vol->rootDirEntryCount();
    284e:	80 91 17 0f 	lds	r24, 0x0F17	; 0x800f17 <SDLib::SD+0x24>
    2852:	90 91 18 0f 	lds	r25, 0x0F18	; 0x800f18 <SDLib::SD+0x25>
    2856:	b0 e0       	ldi	r27, 0x00	; 0
    2858:	a0 e0       	ldi	r26, 0x00	; 0
    285a:	25 e0       	ldi	r18, 0x05	; 5
    285c:	88 0f       	add	r24, r24
    285e:	99 1f       	adc	r25, r25
    2860:	aa 1f       	adc	r26, r26
    2862:	bb 1f       	adc	r27, r27
    2864:	2a 95       	dec	r18
    2866:	d1 f7       	brne	.-12     	; 0x285c <SdFile::openRoot(SdVolume*) [clone .constprop.152]+0x38>
    2868:	83 8b       	std	Z+19, r24	; 0x13
    286a:	94 8b       	std	Z+20, r25	; 0x14
    286c:	a5 8b       	std	Z+21, r26	; 0x15
    286e:	b6 8b       	std	Z+22, r27	; 0x16
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:673
    }
  } else {
    // volume is not initialized or FAT12
    return false;
  }
  vol_ = vol;
    2870:	8f ef       	ldi	r24, 0xFF	; 255
    2872:	9e e0       	ldi	r25, 0x0E	; 14
    2874:	9c 8f       	std	Y+28, r25	; 0x1c
    2876:	8b 8f       	std	Y+27, r24	; 0x1b
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:675
  // read only
  flags_ = O_READ;
    2878:	81 e0       	ldi	r24, 0x01	; 1
    287a:	8c 83       	std	Y+4, r24	; 0x04
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:678

  // set to start of file
  curCluster_ = 0;
    287c:	1e 82       	std	Y+6, r1	; 0x06
    287e:	1f 82       	std	Y+7, r1	; 0x07
    2880:	18 86       	std	Y+8, r1	; 0x08
    2882:	19 86       	std	Y+9, r1	; 0x09
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:679
  curPosition_ = 0;
    2884:	1a 86       	std	Y+10, r1	; 0x0a
    2886:	1b 86       	std	Y+11, r1	; 0x0b
    2888:	1c 86       	std	Y+12, r1	; 0x0c
    288a:	1d 86       	std	Y+13, r1	; 0x0d
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:682

  // root has no directory entry
  dirBlock_ = 0;
    288c:	1e 86       	std	Y+14, r1	; 0x0e
    288e:	1f 86       	std	Y+15, r1	; 0x0f
    2890:	18 8a       	std	Y+16, r1	; 0x10
    2892:	19 8a       	std	Y+17, r1	; 0x11
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:683
  dirIndex_ = 0;
    2894:	1a 8a       	std	Y+18, r1	; 0x12
    2896:	cd cf       	rjmp	.-102    	; 0x2832 <SdFile::openRoot(SdVolume*) [clone .constprop.152]+0xe>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:663

  if (vol->fatType() == 16) {
    type_ = FAT_FILE_TYPE_ROOT16;
    firstCluster_ = 0;
    fileSize_ = 32 * vol->rootDirEntryCount();
  } else if (vol->fatType() == 32) {
    2898:	80 32       	cpi	r24, 0x20	; 32
    289a:	51 f6       	brne	.-108    	; 0x2830 <SdFile::openRoot(SdVolume*) [clone .constprop.152]+0xc>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:664
    type_ = FAT_FILE_TYPE_ROOT32;
    289c:	83 e0       	ldi	r24, 0x03	; 3
    289e:	85 83       	std	Z+5, r24	; 0x05
_ZNK8SdVolume12rootDirStartEv():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:550
      return rootDirEntryCount_;
    }
    /** \return The logical block number for the start of the root directory
         on FAT16 volumes or the first cluster number on FAT32 volumes. */
    uint32_t rootDirStart(void) const {
      return rootDirStart_;
    28a0:	40 91 19 0f 	lds	r20, 0x0F19	; 0x800f19 <SDLib::SD+0x26>
    28a4:	50 91 1a 0f 	lds	r21, 0x0F1A	; 0x800f1a <SDLib::SD+0x27>
    28a8:	60 91 1b 0f 	lds	r22, 0x0F1B	; 0x800f1b <SDLib::SD+0x28>
    28ac:	70 91 1c 0f 	lds	r23, 0x0F1C	; 0x800f1c <SDLib::SD+0x29>
openRoot():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:665
    firstCluster_ = vol->rootDirStart();
    28b0:	47 8b       	std	Z+23, r20	; 0x17
    28b2:	50 8f       	std	Z+24, r21	; 0x18
    28b4:	61 8f       	std	Z+25, r22	; 0x19
    28b6:	72 8f       	std	Z+26, r23	; 0x1a
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:666
    if (!vol->chainSize(firstCluster_, &fileSize_)) {
    28b8:	9f 01       	movw	r18, r30
    28ba:	2d 5e       	subi	r18, 0xED	; 237
    28bc:	3f 4f       	sbci	r19, 0xFF	; 255
    28be:	8f ef       	ldi	r24, 0xFF	; 255
    28c0:	9e e0       	ldi	r25, 0x0E	; 14
    28c2:	0e 94 a7 13 	call	0x274e	; 0x274e <SdVolume::chainSize(unsigned long, unsigned long*) const>
    28c6:	81 11       	cpse	r24, r1
    28c8:	d3 cf       	rjmp	.-90     	; 0x2870 <SdFile::openRoot(SdVolume*) [clone .constprop.152]+0x4c>
    28ca:	b2 cf       	rjmp	.-156    	; 0x2830 <SdFile::openRoot(SdVolume*) [clone .constprop.152]+0xc>

000028cc <SdFile::seekSet(unsigned long)>:
seekSet():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1085
   \param[in] pos The new position in bytes from the beginning of the file.

   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t SdFile::seekSet(uint32_t pos) {
    28cc:	8f 92       	push	r8
    28ce:	9f 92       	push	r9
    28d0:	af 92       	push	r10
    28d2:	bf 92       	push	r11
    28d4:	cf 92       	push	r12
    28d6:	df 92       	push	r13
    28d8:	ef 92       	push	r14
    28da:	ff 92       	push	r15
    28dc:	0f 93       	push	r16
    28de:	1f 93       	push	r17
    28e0:	cf 93       	push	r28
    28e2:	df 93       	push	r29
    28e4:	ec 01       	movw	r28, r24
    28e6:	8d 81       	ldd	r24, Y+5	; 0x05
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1087
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) {
    28e8:	81 11       	cpse	r24, r1
    28ea:	0e c0       	rjmp	.+28     	; 0x2908 <SdFile::seekSet(unsigned long)+0x3c>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1088
    return false;
    28ec:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1119
      return false;
    }
  }
  curPosition_ = pos;
  return true;
}
    28ee:	df 91       	pop	r29
    28f0:	cf 91       	pop	r28
    28f2:	1f 91       	pop	r17
    28f4:	0f 91       	pop	r16
    28f6:	ff 90       	pop	r15
    28f8:	ef 90       	pop	r14
    28fa:	df 90       	pop	r13
    28fc:	cf 90       	pop	r12
    28fe:	bf 90       	pop	r11
    2900:	af 90       	pop	r10
    2902:	9f 90       	pop	r9
    2904:	8f 90       	pop	r8
    2906:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1087
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
*/
uint8_t SdFile::seekSet(uint32_t pos) {
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) {
    2908:	0b 89       	ldd	r16, Y+19	; 0x13
    290a:	1c 89       	ldd	r17, Y+20	; 0x14
    290c:	2d 89       	ldd	r18, Y+21	; 0x15
    290e:	3e 89       	ldd	r19, Y+22	; 0x16
    2910:	04 17       	cp	r16, r20
    2912:	15 07       	cpc	r17, r21
    2914:	26 07       	cpc	r18, r22
    2916:	37 07       	cpc	r19, r23
    2918:	48 f3       	brcs	.-46     	; 0x28ec <SdFile::seekSet(unsigned long)+0x20>
    291a:	4a 01       	movw	r8, r20
    291c:	5b 01       	movw	r10, r22
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1091
    return false;
  }

  if (type_ == FAT_FILE_TYPE_ROOT16) {
    291e:	82 30       	cpi	r24, 0x02	; 2
    2920:	31 f4       	brne	.+12     	; 0x292e <SdFile::seekSet(unsigned long)+0x62>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1092
    curPosition_ = pos;
    2922:	8a 86       	std	Y+10, r8	; 0x0a
    2924:	9b 86       	std	Y+11, r9	; 0x0b
    2926:	ac 86       	std	Y+12, r10	; 0x0c
    2928:	bd 86       	std	Y+13, r11	; 0x0d
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1099
  }
  if (pos == 0) {
    // set position to start of file
    curCluster_ = 0;
    curPosition_ = 0;
    return true;
    292a:	81 e0       	ldi	r24, 0x01	; 1
    292c:	e0 cf       	rjmp	.-64     	; 0x28ee <SdFile::seekSet(unsigned long)+0x22>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1095

  if (type_ == FAT_FILE_TYPE_ROOT16) {
    curPosition_ = pos;
    return true;
  }
  if (pos == 0) {
    292e:	81 14       	cp	r8, r1
    2930:	91 04       	cpc	r9, r1
    2932:	a1 04       	cpc	r10, r1
    2934:	b1 04       	cpc	r11, r1
    2936:	49 f4       	brne	.+18     	; 0x294a <SdFile::seekSet(unsigned long)+0x7e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1097
    // set position to start of file
    curCluster_ = 0;
    2938:	1e 82       	std	Y+6, r1	; 0x06
    293a:	1f 82       	std	Y+7, r1	; 0x07
    293c:	18 86       	std	Y+8, r1	; 0x08
    293e:	19 86       	std	Y+9, r1	; 0x09
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1098
    curPosition_ = 0;
    2940:	1a 86       	std	Y+10, r1	; 0x0a
    2942:	1b 86       	std	Y+11, r1	; 0x0b
    2944:	1c 86       	std	Y+12, r1	; 0x0c
    2946:	1d 86       	std	Y+13, r1	; 0x0d
    2948:	f0 cf       	rjmp	.-32     	; 0x292a <SdFile::seekSet(unsigned long)+0x5e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1102
    return true;
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
    294a:	0a 85       	ldd	r16, Y+10	; 0x0a
    294c:	1b 85       	ldd	r17, Y+11	; 0x0b
    294e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2950:	3d 85       	ldd	r19, Y+13	; 0x0d
    2952:	eb 8d       	ldd	r30, Y+27	; 0x1b
    2954:	fc 8d       	ldd	r31, Y+28	; 0x1c
    2956:	85 85       	ldd	r24, Z+13	; 0x0d
    2958:	90 e0       	ldi	r25, 0x00	; 0
    295a:	09 96       	adiw	r24, 0x09	; 9
    295c:	b9 01       	movw	r22, r18
    295e:	a8 01       	movw	r20, r16
    2960:	41 50       	subi	r20, 0x01	; 1
    2962:	51 09       	sbc	r21, r1
    2964:	61 09       	sbc	r22, r1
    2966:	71 09       	sbc	r23, r1
    2968:	08 2e       	mov	r0, r24
    296a:	04 c0       	rjmp	.+8      	; 0x2974 <SdFile::seekSet(unsigned long)+0xa8>
    296c:	76 95       	lsr	r23
    296e:	67 95       	ror	r22
    2970:	57 95       	ror	r21
    2972:	47 95       	ror	r20
    2974:	0a 94       	dec	r0
    2976:	d2 f7       	brpl	.-12     	; 0x296c <SdFile::seekSet(unsigned long)+0xa0>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1103
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
    2978:	75 01       	movw	r14, r10
    297a:	64 01       	movw	r12, r8
    297c:	e1 e0       	ldi	r30, 0x01	; 1
    297e:	ce 1a       	sub	r12, r30
    2980:	d1 08       	sbc	r13, r1
    2982:	e1 08       	sbc	r14, r1
    2984:	f1 08       	sbc	r15, r1
    2986:	04 c0       	rjmp	.+8      	; 0x2990 <SdFile::seekSet(unsigned long)+0xc4>
    2988:	f6 94       	lsr	r15
    298a:	e7 94       	ror	r14
    298c:	d7 94       	ror	r13
    298e:	c7 94       	ror	r12
    2990:	8a 95       	dec	r24
    2992:	d2 f7       	brpl	.-12     	; 0x2988 <SdFile::seekSet(unsigned long)+0xbc>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1105

  if (nNew < nCur || curPosition_ == 0) {
    2994:	c4 16       	cp	r12, r20
    2996:	d5 06       	cpc	r13, r21
    2998:	e6 06       	cpc	r14, r22
    299a:	f7 06       	cpc	r15, r23
    299c:	20 f0       	brcs	.+8      	; 0x29a6 <SdFile::seekSet(unsigned long)+0xda>
    299e:	01 2b       	or	r16, r17
    29a0:	02 2b       	or	r16, r18
    29a2:	03 2b       	or	r16, r19
    29a4:	11 f5       	brne	.+68     	; 0x29ea <SdFile::seekSet(unsigned long)+0x11e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1107
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
    29a6:	8f 89       	ldd	r24, Y+23	; 0x17
    29a8:	98 8d       	ldd	r25, Y+24	; 0x18
    29aa:	a9 8d       	ldd	r26, Y+25	; 0x19
    29ac:	ba 8d       	ldd	r27, Y+26	; 0x1a
    29ae:	8e 83       	std	Y+6, r24	; 0x06
    29b0:	9f 83       	std	Y+7, r25	; 0x07
    29b2:	a8 87       	std	Y+8, r26	; 0x08
    29b4:	b9 87       	std	Y+9, r27	; 0x09
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1113
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) {
    29b6:	8e 01       	movw	r16, r28
    29b8:	0a 5f       	subi	r16, 0xFA	; 250
    29ba:	1f 4f       	sbci	r17, 0xFF	; 255
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1112
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    29bc:	c1 14       	cp	r12, r1
    29be:	d1 04       	cpc	r13, r1
    29c0:	e1 04       	cpc	r14, r1
    29c2:	f1 04       	cpc	r15, r1
    29c4:	09 f4       	brne	.+2      	; 0x29c8 <SdFile::seekSet(unsigned long)+0xfc>
    29c6:	ad cf       	rjmp	.-166    	; 0x2922 <SdFile::seekSet(unsigned long)+0x56>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1113
    if (!vol_->fatGet(curCluster_, &curCluster_)) {
    29c8:	4e 81       	ldd	r20, Y+6	; 0x06
    29ca:	5f 81       	ldd	r21, Y+7	; 0x07
    29cc:	68 85       	ldd	r22, Y+8	; 0x08
    29ce:	79 85       	ldd	r23, Y+9	; 0x09
    29d0:	98 01       	movw	r18, r16
    29d2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    29d4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    29d6:	0e 94 26 13 	call	0x264c	; 0x264c <SdVolume::fatGet(unsigned long, unsigned long*) const>
    29da:	91 e0       	ldi	r25, 0x01	; 1
    29dc:	c9 1a       	sub	r12, r25
    29de:	d1 08       	sbc	r13, r1
    29e0:	e1 08       	sbc	r14, r1
    29e2:	f1 08       	sbc	r15, r1
    29e4:	81 11       	cpse	r24, r1
    29e6:	ea cf       	rjmp	.-44     	; 0x29bc <SdFile::seekSet(unsigned long)+0xf0>
    29e8:	81 cf       	rjmp	.-254    	; 0x28ec <SdFile::seekSet(unsigned long)+0x20>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1110
  if (nNew < nCur || curPosition_ == 0) {
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
    29ea:	c4 1a       	sub	r12, r20
    29ec:	d5 0a       	sbc	r13, r21
    29ee:	e6 0a       	sbc	r14, r22
    29f0:	f7 0a       	sbc	r15, r23
    29f2:	e1 cf       	rjmp	.-62     	; 0x29b6 <SdFile::seekSet(unsigned long)+0xea>

000029f4 <SdFile::addCluster()>:
addCluster():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:35
  // suppress cpplint warnings with NOLINT comment
  void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
    29f4:	3f 92       	push	r3
    29f6:	4f 92       	push	r4
    29f8:	5f 92       	push	r5
    29fa:	6f 92       	push	r6
    29fc:	7f 92       	push	r7
    29fe:	8f 92       	push	r8
    2a00:	9f 92       	push	r9
    2a02:	af 92       	push	r10
    2a04:	bf 92       	push	r11
    2a06:	cf 92       	push	r12
    2a08:	df 92       	push	r13
    2a0a:	ef 92       	push	r14
    2a0c:	ff 92       	push	r15
    2a0e:	0f 93       	push	r16
    2a10:	1f 93       	push	r17
    2a12:	cf 93       	push	r28
    2a14:	df 93       	push	r29
    2a16:	cd b7       	in	r28, 0x3d	; 61
    2a18:	de b7       	in	r29, 0x3e	; 62
    2a1a:	2c 97       	sbiw	r28, 0x0c	; 12
    2a1c:	0f b6       	in	r0, 0x3f	; 63
    2a1e:	f8 94       	cli
    2a20:	de bf       	out	0x3e, r29	; 62
    2a22:	0f be       	out	0x3f, r0	; 63
    2a24:	cd bf       	out	0x3d, r28	; 61
    2a26:	5c 01       	movw	r10, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:36
  if (!vol_->allocContiguous(1, &curCluster_)) {
    2a28:	dc 01       	movw	r26, r24
    2a2a:	5b 96       	adiw	r26, 0x1b	; 27
    2a2c:	8d 90       	ld	r8, X+
    2a2e:	9c 90       	ld	r9, X
    2a30:	5c 97       	sbiw	r26, 0x1c	; 28
allocContiguous():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:39

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
    2a32:	16 96       	adiw	r26, 0x06	; 6
    2a34:	4d 90       	ld	r4, X+
    2a36:	5d 90       	ld	r5, X+
    2a38:	6d 90       	ld	r6, X+
    2a3a:	7c 90       	ld	r7, X
    2a3c:	19 97       	sbiw	r26, 0x09	; 9
    2a3e:	41 14       	cp	r4, r1
    2a40:	51 04       	cpc	r5, r1
    2a42:	61 04       	cpc	r6, r1
    2a44:	71 04       	cpc	r7, r1
    2a46:	09 f4       	brne	.+2      	; 0x2a4a <SdFile::addCluster()+0x56>
    2a48:	68 c0       	rjmp	.+208    	; 0x2b1a <SdFile::addCluster()+0x126>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:41
    // try to make file contiguous
    bgnCluster = *curCluster + 1;
    2a4a:	bf ef       	ldi	r27, 0xFF	; 255
    2a4c:	4b 1a       	sub	r4, r27
    2a4e:	5b 0a       	sbc	r5, r27
    2a50:	6b 0a       	sbc	r6, r27
    2a52:	7b 0a       	sbc	r7, r27
addCluster():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:44

    // don't save new start location
    setStart = false;
    2a54:	31 2c       	mov	r3, r1
allocContiguous():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:56
  }
  // end of group
  uint32_t endCluster = bgnCluster;

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;
    2a56:	f4 01       	movw	r30, r8
    2a58:	81 85       	ldd	r24, Z+9	; 0x09
    2a5a:	92 85       	ldd	r25, Z+10	; 0x0a
    2a5c:	a3 85       	ldd	r26, Z+11	; 0x0b
    2a5e:	b4 85       	ldd	r27, Z+12	; 0x0c
    2a60:	9c 01       	movw	r18, r24
    2a62:	ad 01       	movw	r20, r26
    2a64:	2f 5f       	subi	r18, 0xFF	; 255
    2a66:	3f 4f       	sbci	r19, 0xFF	; 255
    2a68:	4f 4f       	sbci	r20, 0xFF	; 255
    2a6a:	5f 4f       	sbci	r21, 0xFF	; 255
    2a6c:	29 87       	std	Y+9, r18	; 0x09
    2a6e:	3a 87       	std	Y+10, r19	; 0x0a
    2a70:	4b 87       	std	Y+11, r20	; 0x0b
    2a72:	5c 87       	std	Y+12, r21	; 0x0c
addCluster():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:53

    // save next search start if one cluster
    setStart = 1 == count;
  }
  // end of group
  uint32_t endCluster = bgnCluster;
    2a74:	73 01       	movw	r14, r6
    2a76:	62 01       	movw	r12, r4
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:59

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    2a78:	1d 82       	std	Y+5, r1	; 0x05
    2a7a:	1e 82       	std	Y+6, r1	; 0x06
    2a7c:	1f 82       	std	Y+7, r1	; 0x07
    2a7e:	18 86       	std	Y+8, r1	; 0x08
allocContiguous():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:61
    // can't find space checked all clusters
    if (n >= clusterCount_) {
    2a80:	f4 01       	movw	r30, r8
    2a82:	81 85       	ldd	r24, Z+9	; 0x09
    2a84:	92 85       	ldd	r25, Z+10	; 0x0a
    2a86:	a3 85       	ldd	r26, Z+11	; 0x0b
    2a88:	b4 85       	ldd	r27, Z+12	; 0x0c
    2a8a:	2d 81       	ldd	r18, Y+5	; 0x05
    2a8c:	3e 81       	ldd	r19, Y+6	; 0x06
    2a8e:	4f 81       	ldd	r20, Y+7	; 0x07
    2a90:	58 85       	ldd	r21, Y+8	; 0x08
    2a92:	28 17       	cp	r18, r24
    2a94:	39 07       	cpc	r19, r25
    2a96:	4a 07       	cpc	r20, r26
    2a98:	5b 07       	cpc	r21, r27
    2a9a:	08 f0       	brcs	.+2      	; 0x2a9e <SdFile::addCluster()+0xaa>
    2a9c:	56 c0       	rjmp	.+172    	; 0x2b4a <SdFile::addCluster()+0x156>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:66
      return false;
    }

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
    2a9e:	89 85       	ldd	r24, Y+9	; 0x09
    2aa0:	9a 85       	ldd	r25, Y+10	; 0x0a
    2aa2:	ab 85       	ldd	r26, Y+11	; 0x0b
    2aa4:	bc 85       	ldd	r27, Y+12	; 0x0c
    2aa6:	8c 15       	cp	r24, r12
    2aa8:	9d 05       	cpc	r25, r13
    2aaa:	ae 05       	cpc	r26, r14
    2aac:	bf 05       	cpc	r27, r15
    2aae:	50 f4       	brcc	.+20     	; 0x2ac4 <SdFile::addCluster()+0xd0>
addCluster():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:67
      bgnCluster = endCluster = 2;
    2ab0:	82 e0       	ldi	r24, 0x02	; 2
    2ab2:	c8 2e       	mov	r12, r24
    2ab4:	d1 2c       	mov	r13, r1
    2ab6:	e1 2c       	mov	r14, r1
    2ab8:	f1 2c       	mov	r15, r1
    2aba:	92 e0       	ldi	r25, 0x02	; 2
    2abc:	49 2e       	mov	r4, r25
    2abe:	51 2c       	mov	r5, r1
    2ac0:	61 2c       	mov	r6, r1
    2ac2:	71 2c       	mov	r7, r1
allocContiguous():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:70
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) {
    2ac4:	9e 01       	movw	r18, r28
    2ac6:	2f 5f       	subi	r18, 0xFF	; 255
    2ac8:	3f 4f       	sbci	r19, 0xFF	; 255
    2aca:	b7 01       	movw	r22, r14
    2acc:	a6 01       	movw	r20, r12
    2ace:	c4 01       	movw	r24, r8
    2ad0:	0e 94 26 13 	call	0x264c	; 0x264c <SdVolume::fatGet(unsigned long, unsigned long*) const>
    2ad4:	88 23       	and	r24, r24
    2ad6:	c9 f1       	breq	.+114    	; 0x2b4a <SdFile::addCluster()+0x156>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:74
      return false;
    }

    if (f != 0) {
    2ad8:	89 81       	ldd	r24, Y+1	; 0x01
    2ada:	9a 81       	ldd	r25, Y+2	; 0x02
    2adc:	ab 81       	ldd	r26, Y+3	; 0x03
    2ade:	bc 81       	ldd	r27, Y+4	; 0x04
    2ae0:	89 2b       	or	r24, r25
    2ae2:	8a 2b       	or	r24, r26
    2ae4:	8b 2b       	or	r24, r27
    2ae6:	09 f1       	breq	.+66     	; 0x2b2a <SdFile::addCluster()+0x136>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:76
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    2ae8:	26 01       	movw	r4, r12
    2aea:	37 01       	movw	r6, r14
    2aec:	9f ef       	ldi	r25, 0xFF	; 255
    2aee:	49 1a       	sub	r4, r25
    2af0:	59 0a       	sbc	r5, r25
    2af2:	69 0a       	sbc	r6, r25
    2af4:	79 0a       	sbc	r7, r25
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:59

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    2af6:	2d 81       	ldd	r18, Y+5	; 0x05
    2af8:	3e 81       	ldd	r19, Y+6	; 0x06
    2afa:	4f 81       	ldd	r20, Y+7	; 0x07
    2afc:	58 85       	ldd	r21, Y+8	; 0x08
    2afe:	2f 5f       	subi	r18, 0xFF	; 255
    2b00:	3f 4f       	sbci	r19, 0xFF	; 255
    2b02:	4f 4f       	sbci	r20, 0xFF	; 255
    2b04:	5f 4f       	sbci	r21, 0xFF	; 255
    2b06:	2d 83       	std	Y+5, r18	; 0x05
    2b08:	3e 83       	std	Y+6, r19	; 0x06
    2b0a:	4f 83       	std	Y+7, r20	; 0x07
    2b0c:	58 87       	std	Y+8, r21	; 0x08
    2b0e:	3f ef       	ldi	r19, 0xFF	; 255
    2b10:	c3 1a       	sub	r12, r19
    2b12:	d3 0a       	sbc	r13, r19
    2b14:	e3 0a       	sbc	r14, r19
    2b16:	f3 0a       	sbc	r15, r19
    2b18:	b3 cf       	rjmp	.-154    	; 0x2a80 <SdFile::addCluster()+0x8c>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:47

    // don't save new start location
    setStart = false;
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;
    2b1a:	f4 01       	movw	r30, r8
    2b1c:	40 80       	ld	r4, Z
    2b1e:	51 80       	ldd	r5, Z+1	; 0x01
    2b20:	62 80       	ldd	r6, Z+2	; 0x02
    2b22:	73 80       	ldd	r7, Z+3	; 0x03
addCluster():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:50

    // save next search start if one cluster
    setStart = 1 == count;
    2b24:	33 24       	eor	r3, r3
    2b26:	33 94       	inc	r3
    2b28:	96 cf       	rjmp	.-212    	; 0x2a56 <SdFile::addCluster()+0x62>
allocContiguous():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:77
    }

    if (f != 0) {
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    } else if ((endCluster - bgnCluster + 1) == count) {
    2b2a:	c4 14       	cp	r12, r4
    2b2c:	d5 04       	cpc	r13, r5
    2b2e:	e6 04       	cpc	r14, r6
    2b30:	f7 04       	cpc	r15, r7
    2b32:	09 f7       	brne	.-62     	; 0x2af6 <SdFile::addCluster()+0x102>
fatPutEOC():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:618
    static uint8_t cacheZeroBlock(uint32_t blockNumber);
    uint8_t chainSize(uint32_t beginCluster, uint32_t* size) const;
    uint8_t fatGet(uint32_t cluster, uint32_t* value) const;
    uint8_t fatPut(uint32_t cluster, uint32_t value);
    uint8_t fatPutEOC(uint32_t cluster) {
      return fatPut(cluster, 0x0FFFFFFF);
    2b34:	0f ef       	ldi	r16, 0xFF	; 255
    2b36:	1f ef       	ldi	r17, 0xFF	; 255
    2b38:	2f ef       	ldi	r18, 0xFF	; 255
    2b3a:	3f e0       	ldi	r19, 0x0F	; 15
    2b3c:	b7 01       	movw	r22, r14
    2b3e:	a6 01       	movw	r20, r12
    2b40:	c4 01       	movw	r24, r8
    2b42:	0e 94 84 12 	call	0x2508	; 0x2508 <SdVolume::fatPut(unsigned long, unsigned long)>
allocContiguous():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:83
      // done - found space
      break;
    }
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) {
    2b46:	81 11       	cpse	r24, r1
    2b48:	19 c0       	rjmp	.+50     	; 0x2b7c <SdFile::addCluster()+0x188>
addCluster():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:37
    return false;
    2b4a:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:47
    firstCluster_ = curCluster_;
    flags_ |= F_FILE_DIR_DIRTY;
  }
  flags_ |= F_FILE_CLUSTER_ADDED;
  return true;
}
    2b4c:	2c 96       	adiw	r28, 0x0c	; 12
    2b4e:	0f b6       	in	r0, 0x3f	; 63
    2b50:	f8 94       	cli
    2b52:	de bf       	out	0x3e, r29	; 62
    2b54:	0f be       	out	0x3f, r0	; 63
    2b56:	cd bf       	out	0x3d, r28	; 61
    2b58:	df 91       	pop	r29
    2b5a:	cf 91       	pop	r28
    2b5c:	1f 91       	pop	r17
    2b5e:	0f 91       	pop	r16
    2b60:	ff 90       	pop	r15
    2b62:	ef 90       	pop	r14
    2b64:	df 90       	pop	r13
    2b66:	cf 90       	pop	r12
    2b68:	bf 90       	pop	r11
    2b6a:	af 90       	pop	r10
    2b6c:	9f 90       	pop	r9
    2b6e:	8f 90       	pop	r8
    2b70:	7f 90       	pop	r7
    2b72:	6f 90       	pop	r6
    2b74:	5f 90       	pop	r5
    2b76:	4f 90       	pop	r4
    2b78:	3f 90       	pop	r3
    2b7a:	08 95       	ret
allocContiguous():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:94
    if (!fatPut(endCluster - 1, endCluster)) {
      return false;
    }
    endCluster--;
  }
  if (*curCluster != 0) {
    2b7c:	d5 01       	movw	r26, r10
    2b7e:	16 96       	adiw	r26, 0x06	; 6
    2b80:	4d 91       	ld	r20, X+
    2b82:	5d 91       	ld	r21, X+
    2b84:	6d 91       	ld	r22, X+
    2b86:	7c 91       	ld	r23, X
    2b88:	19 97       	sbiw	r26, 0x09	; 9
    2b8a:	41 15       	cp	r20, r1
    2b8c:	51 05       	cpc	r21, r1
    2b8e:	61 05       	cpc	r22, r1
    2b90:	71 05       	cpc	r23, r1
    2b92:	39 f0       	breq	.+14     	; 0x2ba2 <SdFile::addCluster()+0x1ae>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:96
    // connect chains
    if (!fatPut(*curCluster, bgnCluster)) {
    2b94:	97 01       	movw	r18, r14
    2b96:	86 01       	movw	r16, r12
    2b98:	c4 01       	movw	r24, r8
    2b9a:	0e 94 84 12 	call	0x2508	; 0x2508 <SdVolume::fatPut(unsigned long, unsigned long)>
    2b9e:	88 23       	and	r24, r24
    2ba0:	a1 f2       	breq	.-88     	; 0x2b4a <SdFile::addCluster()+0x156>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:101
      return false;
    }
  }
  // return first cluster number to caller
  *curCluster = bgnCluster;
    2ba2:	d5 01       	movw	r26, r10
    2ba4:	16 96       	adiw	r26, 0x06	; 6
    2ba6:	cd 92       	st	X+, r12
    2ba8:	dd 92       	st	X+, r13
    2baa:	ed 92       	st	X+, r14
    2bac:	fc 92       	st	X, r15
    2bae:	19 97       	sbiw	r26, 0x09	; 9
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:104

  // remember possible next free cluster
  if (setStart) {
    2bb0:	33 20       	and	r3, r3
    2bb2:	51 f0       	breq	.+20     	; 0x2bc8 <SdFile::addCluster()+0x1d4>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:105
    allocSearchStart_ = bgnCluster + 1;
    2bb4:	d7 01       	movw	r26, r14
    2bb6:	c6 01       	movw	r24, r12
    2bb8:	01 96       	adiw	r24, 0x01	; 1
    2bba:	a1 1d       	adc	r26, r1
    2bbc:	b1 1d       	adc	r27, r1
    2bbe:	f4 01       	movw	r30, r8
    2bc0:	80 83       	st	Z, r24
    2bc2:	91 83       	std	Z+1, r25	; 0x01
    2bc4:	a2 83       	std	Z+2, r26	; 0x02
    2bc6:	b3 83       	std	Z+3, r27	; 0x03
addCluster():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:41
  if (!vol_->allocContiguous(1, &curCluster_)) {
    return false;
  }

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
    2bc8:	f5 01       	movw	r30, r10
    2bca:	87 89       	ldd	r24, Z+23	; 0x17
    2bcc:	90 8d       	ldd	r25, Z+24	; 0x18
    2bce:	a1 8d       	ldd	r26, Z+25	; 0x19
    2bd0:	b2 8d       	ldd	r27, Z+26	; 0x1a
    2bd2:	89 2b       	or	r24, r25
    2bd4:	8a 2b       	or	r24, r26
    2bd6:	8b 2b       	or	r24, r27
    2bd8:	39 f4       	brne	.+14     	; 0x2be8 <SdFile::addCluster()+0x1f4>
    2bda:	84 81       	ldd	r24, Z+4	; 0x04
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:42
    firstCluster_ = curCluster_;
    2bdc:	c7 8a       	std	Z+23, r12	; 0x17
    2bde:	d0 8e       	std	Z+24, r13	; 0x18
    2be0:	e1 8e       	std	Z+25, r14	; 0x19
    2be2:	f2 8e       	std	Z+26, r15	; 0x1a
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:43
    flags_ |= F_FILE_DIR_DIRTY;
    2be4:	80 68       	ori	r24, 0x80	; 128
    2be6:	84 83       	std	Z+4, r24	; 0x04
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:45
  }
  flags_ |= F_FILE_CLUSTER_ADDED;
    2be8:	f5 01       	movw	r30, r10
    2bea:	84 81       	ldd	r24, Z+4	; 0x04
    2bec:	80 62       	ori	r24, 0x20	; 32
    2bee:	84 83       	std	Z+4, r24	; 0x04
    2bf0:	81 e0       	ldi	r24, 0x01	; 1
    2bf2:	ac cf       	rjmp	.-168    	; 0x2b4c <SdFile::addCluster()+0x158>

00002bf4 <SdFile::sync(unsigned char)>:
sync():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1132
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include a call to sync() before a file has been
   opened or an I/O error.
*/
uint8_t SdFile::sync(uint8_t blocking) {
    2bf4:	1f 93       	push	r17
    2bf6:	cf 93       	push	r28
    2bf8:	df 93       	push	r29
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1134
  // only allow open files and directories
  if (!isOpen()) {
    2bfa:	fc 01       	movw	r30, r24
    2bfc:	25 81       	ldd	r18, Z+5	; 0x05
    2bfe:	22 23       	and	r18, r18
    2c00:	d1 f1       	breq	.+116    	; 0x2c76 <SdFile::sync(unsigned char)+0x82>
    2c02:	16 2f       	mov	r17, r22
    2c04:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1138
    return false;
  }

  if (flags_ & F_FILE_DIR_DIRTY) {
    2c06:	84 81       	ldd	r24, Z+4	; 0x04
    2c08:	87 ff       	sbrs	r24, 7
    2c0a:	2a c0       	rjmp	.+84     	; 0x2c60 <SdFile::sync(unsigned char)+0x6c>
cacheDirEntry():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:71
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) {
    2c0c:	66 85       	ldd	r22, Z+14	; 0x0e
    2c0e:	77 85       	ldd	r23, Z+15	; 0x0f
    2c10:	80 89       	ldd	r24, Z+16	; 0x10
    2c12:	91 89       	ldd	r25, Z+17	; 0x11
    2c14:	41 e0       	ldi	r20, 0x01	; 1
    2c16:	0e 94 11 11 	call	0x2222	; 0x2222 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    2c1a:	88 23       	and	r24, r24
    2c1c:	61 f1       	breq	.+88     	; 0x2c76 <SdFile::sync(unsigned char)+0x82>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:74
    return NULL;
  }
  return SdVolume::cacheBuffer_.dir + dirIndex_;
    2c1e:	ea 89       	ldd	r30, Y+18	; 0x12
    2c20:	80 e2       	ldi	r24, 0x20	; 32
    2c22:	e8 9f       	mul	r30, r24
    2c24:	f0 01       	movw	r30, r0
    2c26:	11 24       	eor	r1, r1
    2c28:	e5 50       	subi	r30, 0x05	; 5
    2c2a:	f6 4f       	sbci	r31, 0xF6	; 246
sync():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1140
    return false;
  }

  if (flags_ & F_FILE_DIR_DIRTY) {
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    if (!d) {
    2c2c:	30 97       	sbiw	r30, 0x00	; 0
    2c2e:	19 f1       	breq	.+70     	; 0x2c76 <SdFile::sync(unsigned char)+0x82>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1145
      return false;
    }

    // do not set filesize for dir files
    if (!isDir()) {
    2c30:	8d 81       	ldd	r24, Y+5	; 0x05
    2c32:	82 30       	cpi	r24, 0x02	; 2
    2c34:	40 f4       	brcc	.+16     	; 0x2c46 <SdFile::sync(unsigned char)+0x52>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1146
      d->fileSize = fileSize_;
    2c36:	8b 89       	ldd	r24, Y+19	; 0x13
    2c38:	9c 89       	ldd	r25, Y+20	; 0x14
    2c3a:	ad 89       	ldd	r26, Y+21	; 0x15
    2c3c:	be 89       	ldd	r27, Y+22	; 0x16
    2c3e:	84 8f       	std	Z+28, r24	; 0x1c
    2c40:	95 8f       	std	Z+29, r25	; 0x1d
    2c42:	a6 8f       	std	Z+30, r26	; 0x1e
    2c44:	b7 8f       	std	Z+31, r27	; 0x1f
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1150
    }

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
    2c46:	8f 89       	ldd	r24, Y+23	; 0x17
    2c48:	98 8d       	ldd	r25, Y+24	; 0x18
    2c4a:	93 8f       	std	Z+27, r25	; 0x1b
    2c4c:	82 8f       	std	Z+26, r24	; 0x1a
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1151
    d->firstClusterHigh = firstCluster_ >> 16;
    2c4e:	8f 89       	ldd	r24, Y+23	; 0x17
    2c50:	98 8d       	ldd	r25, Y+24	; 0x18
    2c52:	a9 8d       	ldd	r26, Y+25	; 0x19
    2c54:	ba 8d       	ldd	r27, Y+26	; 0x1a
    2c56:	b5 8b       	std	Z+21, r27	; 0x15
    2c58:	a4 8b       	std	Z+20, r26	; 0x14
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1159
    if (dateTime_) {
      dateTime_(&d->lastWriteDate, &d->lastWriteTime);
      d->lastAccessDate = d->lastWriteDate;
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
    2c5a:	8c 81       	ldd	r24, Y+4	; 0x04
    2c5c:	8f 77       	andi	r24, 0x7F	; 127
    2c5e:	8c 83       	std	Y+4, r24	; 0x04
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1162
  }

  if (!blocking) {
    2c60:	11 11       	cpse	r17, r1
    2c62:	03 c0       	rjmp	.+6      	; 0x2c6a <SdFile::sync(unsigned char)+0x76>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1163
    flags_ &= ~F_FILE_NON_BLOCKING_WRITE;
    2c64:	8c 81       	ldd	r24, Y+4	; 0x04
    2c66:	8f 7e       	andi	r24, 0xEF	; 239
    2c68:	8c 83       	std	Y+4, r24	; 0x04
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1166
  }

  return SdVolume::cacheFlush(blocking);
    2c6a:	81 2f       	mov	r24, r17
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1167
}
    2c6c:	df 91       	pop	r29
    2c6e:	cf 91       	pop	r28
    2c70:	1f 91       	pop	r17
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1166

  if (!blocking) {
    flags_ &= ~F_FILE_NON_BLOCKING_WRITE;
  }

  return SdVolume::cacheFlush(blocking);
    2c72:	0c 94 e6 10 	jmp	0x21cc	; 0x21cc <SdVolume::cacheFlush(unsigned char)>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1167
}
    2c76:	80 e0       	ldi	r24, 0x00	; 0
    2c78:	df 91       	pop	r29
    2c7a:	cf 91       	pop	r28
    2c7c:	1f 91       	pop	r17
    2c7e:	08 95       	ret

00002c80 <SdFile::availableForWrite()>:
availableForWrite():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1492
/**
   Check how many bytes can be written without blocking.

   \return The number of bytes that can be written without blocking.
*/
int SdFile::availableForWrite() {
    2c80:	ff 92       	push	r15
    2c82:	0f 93       	push	r16
    2c84:	1f 93       	push	r17
    2c86:	cf 93       	push	r28
    2c88:	df 93       	push	r29
    2c8a:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1493
  if (!isFile() || !(flags_ & O_WRITE)) {
    2c8c:	8d 81       	ldd	r24, Y+5	; 0x05
    2c8e:	81 30       	cpi	r24, 0x01	; 1
    2c90:	41 f0       	breq	.+16     	; 0x2ca2 <SdFile::availableForWrite()+0x22>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1518
  }

  if (vol_->isCacheMirrorBlockDirty()) {
    // cache mirror block is dirty, trigger a non-blocking sync
    vol_->cacheMirrorBlockFlush(0);
    return 0;
    2c92:	90 e0       	ldi	r25, 0x00	; 0
    2c94:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1527

  uint16_t blockOffset = curPosition_ & 0X1FF;
  uint16_t n = 512 - blockOffset;

  return n;
}
    2c96:	df 91       	pop	r29
    2c98:	cf 91       	pop	r28
    2c9a:	1f 91       	pop	r17
    2c9c:	0f 91       	pop	r16
    2c9e:	ff 90       	pop	r15
    2ca0:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1493
   Check how many bytes can be written without blocking.

   \return The number of bytes that can be written without blocking.
*/
int SdFile::availableForWrite() {
  if (!isFile() || !(flags_ & O_WRITE)) {
    2ca2:	8c 81       	ldd	r24, Y+4	; 0x04
    2ca4:	81 ff       	sbrs	r24, 1
    2ca6:	f5 cf       	rjmp	.-22     	; 0x2c92 <SdFile::availableForWrite()+0x12>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1498
    return 0;
  }

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    2ca8:	82 fd       	sbrc	r24, 2
    2caa:	1b c0       	rjmp	.+54     	; 0x2ce2 <SdFile::availableForWrite()+0x62>
_ZN8SdVolume6isBusyEv.isra.16():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:635
    }
    uint8_t writeBlock(uint32_t block, const uint8_t* dst, uint8_t blocking = 1) {
      return sdCard_->writeBlock(block, dst, blocking);
    }
    uint8_t isBusy(void) {
      return sdCard_->isBusy();
    2cac:	00 91 fb 0b 	lds	r16, 0x0BFB	; 0x800bfb <SdVolume::sdCard_>
    2cb0:	10 91 fc 0b 	lds	r17, 0x0BFC	; 0x800bfc <SdVolume::sdCard_+0x1>
isBusy():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:772

  \return The value one, true, is returned when is busy and
   the value zero, false, is returned for when is NOT busy.
*/
uint8_t Sd2Card::isBusy(void) {
  chipSelectLow();
    2cb4:	c8 01       	movw	r24, r16
    2cb6:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <Sd2Card::chipSelectLow()>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:773
  byte b = spiRec();
    2cba:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    2cbe:	f8 2e       	mov	r15, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:774
  chipSelectHigh();
    2cc0:	c8 01       	movw	r24, r16
    2cc2:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <Sd2Card::chipSelectHigh()>
availableForWrite():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1504
    if (!seekEnd()) {
      return 0;
    }
  }

  if (vol_->isBusy()) {
    2cc6:	8f ef       	ldi	r24, 0xFF	; 255
    2cc8:	f8 12       	cpse	r15, r24
    2cca:	e3 cf       	rjmp	.-58     	; 0x2c92 <SdFile::availableForWrite()+0x12>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1508
    return 0;
  }

  if (flags_ & F_FILE_CLUSTER_ADDED) {
    2ccc:	8c 81       	ldd	r24, Y+4	; 0x04
    2cce:	85 ff       	sbrs	r24, 5
    2cd0:	1b c0       	rjmp	.+54     	; 0x2d08 <SdFile::availableForWrite()+0x88>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1510
    // new cluster added, trigger a non-blocking sync
    sync(0);
    2cd2:	60 e0       	ldi	r22, 0x00	; 0
    2cd4:	ce 01       	movw	r24, r28
    2cd6:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <SdFile::sync(unsigned char)>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1511
    flags_ &= ~F_FILE_CLUSTER_ADDED;
    2cda:	8c 81       	ldd	r24, Y+4	; 0x04
    2cdc:	8f 7d       	andi	r24, 0xDF	; 223
    2cde:	8c 83       	std	Y+4, r24	; 0x04
    2ce0:	d8 cf       	rjmp	.-80     	; 0x2c92 <SdFile::availableForWrite()+0x12>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1498
  if (!isFile() || !(flags_ & O_WRITE)) {
    return 0;
  }

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    2ce2:	4b 89       	ldd	r20, Y+19	; 0x13
    2ce4:	5c 89       	ldd	r21, Y+20	; 0x14
    2ce6:	6d 89       	ldd	r22, Y+21	; 0x15
    2ce8:	7e 89       	ldd	r23, Y+22	; 0x16
    2cea:	8a 85       	ldd	r24, Y+10	; 0x0a
    2cec:	9b 85       	ldd	r25, Y+11	; 0x0b
    2cee:	ac 85       	ldd	r26, Y+12	; 0x0c
    2cf0:	bd 85       	ldd	r27, Y+13	; 0x0d
    2cf2:	84 17       	cp	r24, r20
    2cf4:	95 07       	cpc	r25, r21
    2cf6:	a6 07       	cpc	r26, r22
    2cf8:	b7 07       	cpc	r27, r23
    2cfa:	c1 f2       	breq	.-80     	; 0x2cac <SdFile::availableForWrite()+0x2c>
seekEnd():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:296
    /**
        Set the files current position to end of file.  Useful to position
        a file for append. See seekSet().
    */
    uint8_t seekEnd(void) {
      return seekSet(fileSize_);
    2cfc:	ce 01       	movw	r24, r28
    2cfe:	0e 94 66 14 	call	0x28cc	; 0x28cc <SdFile::seekSet(unsigned long)>
availableForWrite():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1499
    if (!seekEnd()) {
    2d02:	81 11       	cpse	r24, r1
    2d04:	d3 cf       	rjmp	.-90     	; 0x2cac <SdFile::availableForWrite()+0x2c>
    2d06:	c5 cf       	rjmp	.-118    	; 0x2c92 <SdFile::availableForWrite()+0x12>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1515
    sync(0);
    flags_ &= ~F_FILE_CLUSTER_ADDED;
    return 0;
  }

  if (vol_->isCacheMirrorBlockDirty()) {
    2d08:	40 91 cc 09 	lds	r20, 0x09CC	; 0x8009cc <SdVolume::cacheMirrorBlock_>
    2d0c:	50 91 cd 09 	lds	r21, 0x09CD	; 0x8009cd <SdVolume::cacheMirrorBlock_+0x1>
    2d10:	60 91 ce 09 	lds	r22, 0x09CE	; 0x8009ce <SdVolume::cacheMirrorBlock_+0x2>
    2d14:	70 91 cf 09 	lds	r23, 0x09CF	; 0x8009cf <SdVolume::cacheMirrorBlock_+0x3>
    2d18:	45 2b       	or	r20, r21
    2d1a:	46 2b       	or	r20, r22
    2d1c:	47 2b       	or	r20, r23
    2d1e:	21 f0       	breq	.+8      	; 0x2d28 <SdFile::availableForWrite()+0xa8>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1517
    // cache mirror block is dirty, trigger a non-blocking sync
    vol_->cacheMirrorBlockFlush(0);
    2d20:	80 e0       	ldi	r24, 0x00	; 0
    2d22:	0e 94 c2 10 	call	0x2184	; 0x2184 <SdVolume::cacheMirrorBlockFlush(unsigned char)>
    2d26:	b5 cf       	rjmp	.-150    	; 0x2c92 <SdFile::availableForWrite()+0x12>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1521
    return 0;
  }

  flags_ |= F_FILE_NON_BLOCKING_WRITE;
    2d28:	80 61       	ori	r24, 0x10	; 16
    2d2a:	8c 83       	std	Y+4, r24	; 0x04
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1523

  uint16_t blockOffset = curPosition_ & 0X1FF;
    2d2c:	2a 85       	ldd	r18, Y+10	; 0x0a
    2d2e:	3b 85       	ldd	r19, Y+11	; 0x0b
    2d30:	31 70       	andi	r19, 0x01	; 1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1524
  uint16_t n = 512 - blockOffset;
    2d32:	80 e0       	ldi	r24, 0x00	; 0
    2d34:	92 e0       	ldi	r25, 0x02	; 2
    2d36:	82 1b       	sub	r24, r18
    2d38:	93 0b       	sbc	r25, r19
    2d3a:	ad cf       	rjmp	.-166    	; 0x2c96 <SdFile::availableForWrite()+0x16>

00002d3c <SdFile::close()>:
close():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:85

   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.
   Reasons for failure include no file is open or an I/O error.
*/
uint8_t SdFile::close(void) {
    2d3c:	cf 93       	push	r28
    2d3e:	df 93       	push	r29
    2d40:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:86
  if (!sync()) {
    2d42:	61 e0       	ldi	r22, 0x01	; 1
    2d44:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <SdFile::sync(unsigned char)>
    2d48:	88 23       	and	r24, r24
    2d4a:	11 f0       	breq	.+4      	; 0x2d50 <SdFile::close()+0x14>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:89
    return false;
  }
  type_ = FAT_FILE_TYPE_CLOSED;
    2d4c:	1d 82       	std	Y+5, r1	; 0x05
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:90
  return true;
    2d4e:	81 e0       	ldi	r24, 0x01	; 1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:91
}
    2d50:	df 91       	pop	r29
    2d52:	cf 91       	pop	r28
    2d54:	08 95       	ret

00002d56 <SdFile::write(void const*, unsigned int)>:
write():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1330
   \a nbyte.  If an error occurs, write() returns 0.  Possible errors
   include write() is called before a file has been opened, write is called
   for a read-only file, device is full, a corrupt file system or an I/O error.

*/
size_t SdFile::write(const void* buf, uint16_t nbyte) {
    2d56:	2f 92       	push	r2
    2d58:	3f 92       	push	r3
    2d5a:	4f 92       	push	r4
    2d5c:	5f 92       	push	r5
    2d5e:	6f 92       	push	r6
    2d60:	7f 92       	push	r7
    2d62:	8f 92       	push	r8
    2d64:	9f 92       	push	r9
    2d66:	af 92       	push	r10
    2d68:	bf 92       	push	r11
    2d6a:	cf 92       	push	r12
    2d6c:	df 92       	push	r13
    2d6e:	ef 92       	push	r14
    2d70:	ff 92       	push	r15
    2d72:	0f 93       	push	r16
    2d74:	1f 93       	push	r17
    2d76:	cf 93       	push	r28
    2d78:	df 93       	push	r29
    2d7a:	00 d0       	rcall	.+0      	; 0x2d7c <SdFile::write(void const*, unsigned int)+0x26>
    2d7c:	1f 92       	push	r1
    2d7e:	1f 92       	push	r1
    2d80:	cd b7       	in	r28, 0x3d	; 61
    2d82:	de b7       	in	r29, 0x3e	; 62
    2d84:	7c 01       	movw	r14, r24
    2d86:	5b 01       	movw	r10, r22
    2d88:	34 2e       	mov	r3, r20
    2d8a:	5d 83       	std	Y+5, r21	; 0x05
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1340
  uint16_t nToWrite = nbyte;
  // if blocking writes should be used
  uint8_t blocking = (flags_ & F_FILE_NON_BLOCKING_WRITE) == 0x00;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) {
    2d8c:	dc 01       	movw	r26, r24
    2d8e:	15 96       	adiw	r26, 0x05	; 5
    2d90:	8c 91       	ld	r24, X
    2d92:	15 97       	sbiw	r26, 0x05	; 5
    2d94:	81 30       	cpi	r24, 0x01	; 1
    2d96:	09 f0       	breq	.+2      	; 0x2d9a <SdFile::write(void const*, unsigned int)+0x44>
    2d98:	ce c0       	rjmp	.+412    	; 0x2f36 <SdFile::write(void const*, unsigned int)+0x1e0>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1337
  const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);

  // number of bytes left to write  -  must be before goto statements
  uint16_t nToWrite = nbyte;
  // if blocking writes should be used
  uint8_t blocking = (flags_ & F_FILE_NON_BLOCKING_WRITE) == 0x00;
    2d9a:	14 96       	adiw	r26, 0x04	; 4
    2d9c:	2c 90       	ld	r2, X
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1340

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) {
    2d9e:	21 fe       	sbrs	r2, 1
    2da0:	ca c0       	rjmp	.+404    	; 0x2f36 <SdFile::write(void const*, unsigned int)+0x1e0>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1345
    goto writeErrorReturn;
  }

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    2da2:	22 fc       	sbrc	r2, 2
    2da4:	b4 c0       	rjmp	.+360    	; 0x2f0e <SdFile::write(void const*, unsigned int)+0x1b8>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1330
   \a nbyte.  If an error occurs, write() returns 0.  Possible errors
   include write() is called before a file has been opened, write is called
   for a read-only file, device is full, a corrupt file system or an I/O error.

*/
size_t SdFile::write(const void* buf, uint16_t nbyte) {
    2da6:	c3 2c       	mov	r12, r3
    2da8:	dd 80       	ldd	r13, Y+5	; 0x05
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1337
  const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);

  // number of bytes left to write  -  must be before goto statements
  uint16_t nToWrite = nbyte;
  // if blocking writes should be used
  uint8_t blocking = (flags_ & F_FILE_NON_BLOCKING_WRITE) == 0x00;
    2daa:	22 94       	swap	r2
    2dac:	7f e0       	ldi	r23, 0x0F	; 15
    2dae:	27 22       	and	r2, r23
    2db0:	20 94       	com	r2
    2db2:	b2 2d       	mov	r27, r2
    2db4:	b1 70       	andi	r27, 0x01	; 1
    2db6:	2b 2e       	mov	r2, r27
    2db8:	d7 01       	movw	r26, r14
    2dba:	1a 96       	adiw	r26, 0x0a	; 10
    2dbc:	4d 91       	ld	r20, X+
    2dbe:	5d 91       	ld	r21, X+
    2dc0:	6d 91       	ld	r22, X+
    2dc2:	7c 91       	ld	r23, X
    2dc4:	1d 97       	sbiw	r26, 0x0d	; 13
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1351
    if (!seekEnd()) {
      goto writeErrorReturn;
    }
  }

  while (nToWrite > 0) {
    2dc6:	c1 14       	cp	r12, r1
    2dc8:	d1 04       	cpc	r13, r1
    2dca:	09 f4       	brne	.+2      	; 0x2dce <SdFile::write(void const*, unsigned int)+0x78>
    2dcc:	28 c1       	rjmp	.+592    	; 0x301e <SdFile::write(void const*, unsigned int)+0x2c8>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1352
    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
    2dce:	5b 96       	adiw	r26, 0x1b	; 27
    2dd0:	8d 91       	ld	r24, X+
    2dd2:	9c 91       	ld	r25, X
    2dd4:	5c 97       	sbiw	r26, 0x1c	; 28
_ZNK8SdVolume14blockOfClusterEm():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:599
    uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
    uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
    //----------------------------------------------------------------------------
    uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
    uint8_t blockOfCluster(uint32_t position) const {
      return (position >> 9) & (blocksPerCluster_ - 1);
    2dd6:	fc 01       	movw	r30, r24
    2dd8:	74 80       	ldd	r7, Z+4	; 0x04
    2dda:	7a 94       	dec	r7
    2ddc:	8a 01       	movw	r16, r20
    2dde:	9b 01       	movw	r18, r22
    2de0:	69 e0       	ldi	r22, 0x09	; 9
    2de2:	36 95       	lsr	r19
    2de4:	27 95       	ror	r18
    2de6:	17 95       	ror	r17
    2de8:	07 95       	ror	r16
    2dea:	6a 95       	dec	r22
    2dec:	d1 f7       	brne	.-12     	; 0x2de2 <SdFile::write(void const*, unsigned int)+0x8c>
    2dee:	70 22       	and	r7, r16
write():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1353
    uint16_t blockOffset = curPosition_ & 0X1FF;
    2df0:	8a 01       	movw	r16, r20
    2df2:	11 70       	andi	r17, 0x01	; 1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1354
    if (blockOfCluster == 0 && blockOffset == 0) {
    2df4:	71 10       	cpse	r7, r1
    2df6:	20 c0       	rjmp	.+64     	; 0x2e38 <SdFile::write(void const*, unsigned int)+0xe2>
    2df8:	01 15       	cp	r16, r1
    2dfa:	11 05       	cpc	r17, r1
    2dfc:	e9 f4       	brne	.+58     	; 0x2e38 <SdFile::write(void const*, unsigned int)+0xe2>
    2dfe:	16 96       	adiw	r26, 0x06	; 6
    2e00:	4d 91       	ld	r20, X+
    2e02:	5d 91       	ld	r21, X+
    2e04:	6d 91       	ld	r22, X+
    2e06:	7c 91       	ld	r23, X
    2e08:	19 97       	sbiw	r26, 0x09	; 9
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1356
      // start of new cluster
      if (curCluster_ == 0) {
    2e0a:	41 15       	cp	r20, r1
    2e0c:	51 05       	cpc	r21, r1
    2e0e:	61 05       	cpc	r22, r1
    2e10:	71 05       	cpc	r23, r1
    2e12:	09 f0       	breq	.+2      	; 0x2e16 <SdFile::write(void const*, unsigned int)+0xc0>
    2e14:	99 c0       	rjmp	.+306    	; 0x2f48 <SdFile::write(void const*, unsigned int)+0x1f2>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1357
        if (firstCluster_ == 0) {
    2e16:	57 96       	adiw	r26, 0x17	; 23
    2e18:	8d 91       	ld	r24, X+
    2e1a:	9d 91       	ld	r25, X+
    2e1c:	0d 90       	ld	r0, X+
    2e1e:	bc 91       	ld	r27, X
    2e20:	a0 2d       	mov	r26, r0
    2e22:	00 97       	sbiw	r24, 0x00	; 0
    2e24:	a1 05       	cpc	r26, r1
    2e26:	b1 05       	cpc	r27, r1
    2e28:	09 f0       	breq	.+2      	; 0x2e2c <SdFile::write(void const*, unsigned int)+0xd6>
    2e2a:	b0 c0       	rjmp	.+352    	; 0x2f8c <SdFile::write(void const*, unsigned int)+0x236>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1372
        if (!vol_->fatGet(curCluster_, &next)) {
          return false;
        }
        if (vol_->isEOC(next)) {
          // add cluster if at end of chain
          if (!addCluster()) {
    2e2c:	c7 01       	movw	r24, r14
    2e2e:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <SdFile::addCluster()>
    2e32:	88 23       	and	r24, r24
    2e34:	09 f4       	brne	.+2      	; 0x2e38 <SdFile::write(void const*, unsigned int)+0xe2>
    2e36:	7f c0       	rjmp	.+254    	; 0x2f36 <SdFile::write(void const*, unsigned int)+0x1e0>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1381
          curCluster_ = next;
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
    2e38:	80 e0       	ldi	r24, 0x00	; 0
    2e3a:	92 e0       	ldi	r25, 0x02	; 2
    2e3c:	80 1b       	sub	r24, r16
    2e3e:	91 0b       	sbc	r25, r17
    2e40:	46 01       	movw	r8, r12
    2e42:	8c 15       	cp	r24, r12
    2e44:	9d 05       	cpc	r25, r13
    2e46:	08 f4       	brcc	.+2      	; 0x2e4a <SdFile::write(void const*, unsigned int)+0xf4>
    2e48:	4c 01       	movw	r8, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1389
    if (n > nToWrite) {
      n = nToWrite;
    }

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    2e4a:	d7 01       	movw	r26, r14
    2e4c:	5b 96       	adiw	r26, 0x1b	; 27
    2e4e:	4d 91       	ld	r20, X+
    2e50:	5c 91       	ld	r21, X
    2e52:	5c 97       	sbiw	r26, 0x1c	; 28
_ZNK8SdVolume17clusterStartBlockEm():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:602
    }
    uint32_t clusterStartBlock(uint32_t cluster) const {
      return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);
    2e54:	16 96       	adiw	r26, 0x06	; 6
    2e56:	8d 91       	ld	r24, X+
    2e58:	9d 91       	ld	r25, X+
    2e5a:	0d 90       	ld	r0, X+
    2e5c:	bc 91       	ld	r27, X
    2e5e:	a0 2d       	mov	r26, r0
    2e60:	02 97       	sbiw	r24, 0x02	; 2
    2e62:	a1 09       	sbc	r26, r1
    2e64:	b1 09       	sbc	r27, r1
    2e66:	fa 01       	movw	r30, r20
    2e68:	25 85       	ldd	r18, Z+13	; 0x0d
    2e6a:	04 c0       	rjmp	.+8      	; 0x2e74 <SdFile::write(void const*, unsigned int)+0x11e>
    2e6c:	88 0f       	add	r24, r24
    2e6e:	99 1f       	adc	r25, r25
    2e70:	aa 1f       	adc	r26, r26
    2e72:	bb 1f       	adc	r27, r27
    2e74:	2a 95       	dec	r18
    2e76:	d2 f7       	brpl	.-12     	; 0x2e6c <SdFile::write(void const*, unsigned int)+0x116>
    2e78:	46 85       	ldd	r20, Z+14	; 0x0e
    2e7a:	57 85       	ldd	r21, Z+15	; 0x0f
    2e7c:	60 89       	ldd	r22, Z+16	; 0x10
    2e7e:	71 89       	ldd	r23, Z+17	; 0x11
    2e80:	84 0f       	add	r24, r20
    2e82:	95 1f       	adc	r25, r21
    2e84:	a6 1f       	adc	r26, r22
    2e86:	b7 1f       	adc	r27, r23
write():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1389
    2e88:	9c 01       	movw	r18, r24
    2e8a:	ad 01       	movw	r20, r26
    2e8c:	27 0d       	add	r18, r7
    2e8e:	31 1d       	adc	r19, r1
    2e90:	41 1d       	adc	r20, r1
    2e92:	51 1d       	adc	r21, r1
    2e94:	29 01       	movw	r4, r18
    2e96:	3a 01       	movw	r6, r20
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1390
    if (n == 512) {
    2e98:	81 14       	cp	r8, r1
    2e9a:	32 e0       	ldi	r19, 0x02	; 2
    2e9c:	93 06       	cpc	r9, r19
    2e9e:	09 f0       	breq	.+2      	; 0x2ea2 <SdFile::write(void const*, unsigned int)+0x14c>
    2ea0:	7b c0       	rjmp	.+246    	; 0x2f98 <SdFile::write(void const*, unsigned int)+0x242>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1393
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
    2ea2:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <SdVolume::cacheBlockNumber_>
    2ea6:	90 91 15 02 	lds	r25, 0x0215	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    2eaa:	a0 91 16 02 	lds	r26, 0x0216	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    2eae:	b0 91 17 02 	lds	r27, 0x0217	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
    2eb2:	84 15       	cp	r24, r4
    2eb4:	95 05       	cpc	r25, r5
    2eb6:	a6 05       	cpc	r26, r6
    2eb8:	b7 05       	cpc	r27, r7
    2eba:	59 f4       	brne	.+22     	; 0x2ed2 <SdFile::write(void const*, unsigned int)+0x17c>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1394
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
    2ebc:	8f ef       	ldi	r24, 0xFF	; 255
    2ebe:	9f ef       	ldi	r25, 0xFF	; 255
    2ec0:	dc 01       	movw	r26, r24
    2ec2:	80 93 14 02 	sts	0x0214, r24	; 0x800214 <SdVolume::cacheBlockNumber_>
    2ec6:	90 93 15 02 	sts	0x0215, r25	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    2eca:	a0 93 16 02 	sts	0x0216, r26	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    2ece:	b0 93 17 02 	sts	0x0217, r27	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
_ZN8SdVolume10writeBlockEmPKhh.isra.15():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:632
    uint8_t readData(uint32_t block, uint16_t offset,
                     uint16_t count, uint8_t* dst) {
      return sdCard_->readData(block, offset, count, dst);
    }
    uint8_t writeBlock(uint32_t block, const uint8_t* dst, uint8_t blocking = 1) {
      return sdCard_->writeBlock(block, dst, blocking);
    2ed2:	02 2d       	mov	r16, r2
    2ed4:	95 01       	movw	r18, r10
    2ed6:	b3 01       	movw	r22, r6
    2ed8:	a2 01       	movw	r20, r4
    2eda:	80 91 fb 0b 	lds	r24, 0x0BFB	; 0x800bfb <SdVolume::sdCard_>
    2ede:	90 91 fc 0b 	lds	r25, 0x0BFC	; 0x800bfc <SdVolume::sdCard_+0x1>
    2ee2:	0e 94 54 10 	call	0x20a8	; 0x20a8 <Sd2Card::writeBlock(unsigned long, unsigned char const*, unsigned char)>
write():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1396
      }
      if (!vol_->writeBlock(block, src, blocking)) {
    2ee6:	88 23       	and	r24, r24
    2ee8:	31 f1       	breq	.+76     	; 0x2f36 <SdFile::write(void const*, unsigned int)+0x1e0>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1399
        goto writeErrorReturn;
      }
      src += 512;
    2eea:	9e ef       	ldi	r25, 0xFE	; 254
    2eec:	b9 1a       	sub	r11, r25
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1420
      uint8_t* end = dst + n;
      while (dst != end) {
        *dst++ = *src++;
      }
    }
    nToWrite -= n;
    2eee:	c8 18       	sub	r12, r8
    2ef0:	d9 08       	sbc	r13, r9
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1421
    curPosition_ += n;
    2ef2:	f7 01       	movw	r30, r14
    2ef4:	82 85       	ldd	r24, Z+10	; 0x0a
    2ef6:	93 85       	ldd	r25, Z+11	; 0x0b
    2ef8:	a4 85       	ldd	r26, Z+12	; 0x0c
    2efa:	b5 85       	ldd	r27, Z+13	; 0x0d
    2efc:	88 0d       	add	r24, r8
    2efe:	99 1d       	adc	r25, r9
    2f00:	a1 1d       	adc	r26, r1
    2f02:	b1 1d       	adc	r27, r1
    2f04:	82 87       	std	Z+10, r24	; 0x0a
    2f06:	93 87       	std	Z+11, r25	; 0x0b
    2f08:	a4 87       	std	Z+12, r26	; 0x0c
    2f0a:	b5 87       	std	Z+13, r27	; 0x0d
    2f0c:	55 cf       	rjmp	.-342    	; 0x2db8 <SdFile::write(void const*, unsigned int)+0x62>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1345
  if (!isFile() || !(flags_ & O_WRITE)) {
    goto writeErrorReturn;
  }

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    2f0e:	f7 01       	movw	r30, r14
    2f10:	43 89       	ldd	r20, Z+19	; 0x13
    2f12:	54 89       	ldd	r21, Z+20	; 0x14
    2f14:	65 89       	ldd	r22, Z+21	; 0x15
    2f16:	76 89       	ldd	r23, Z+22	; 0x16
    2f18:	82 85       	ldd	r24, Z+10	; 0x0a
    2f1a:	93 85       	ldd	r25, Z+11	; 0x0b
    2f1c:	a4 85       	ldd	r26, Z+12	; 0x0c
    2f1e:	b5 85       	ldd	r27, Z+13	; 0x0d
    2f20:	48 17       	cp	r20, r24
    2f22:	59 07       	cpc	r21, r25
    2f24:	6a 07       	cpc	r22, r26
    2f26:	7b 07       	cpc	r23, r27
    2f28:	09 f4       	brne	.+2      	; 0x2f2c <SdFile::write(void const*, unsigned int)+0x1d6>
    2f2a:	3d cf       	rjmp	.-390    	; 0x2da6 <SdFile::write(void const*, unsigned int)+0x50>
seekEnd():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:296
    /**
        Set the files current position to end of file.  Useful to position
        a file for append. See seekSet().
    */
    uint8_t seekEnd(void) {
      return seekSet(fileSize_);
    2f2c:	c7 01       	movw	r24, r14
    2f2e:	0e 94 66 14 	call	0x28cc	; 0x28cc <SdFile::seekSet(unsigned long)>
write():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1346
    if (!seekEnd()) {
    2f32:	81 11       	cpse	r24, r1
    2f34:	38 cf       	rjmp	.-400    	; 0x2da6 <SdFile::write(void const*, unsigned int)+0x50>
_ZN5Print13setWriteErrorEi():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:44
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    2f36:	81 e0       	ldi	r24, 0x01	; 1
    2f38:	90 e0       	ldi	r25, 0x00	; 0
    2f3a:	d7 01       	movw	r26, r14
    2f3c:	13 96       	adiw	r26, 0x03	; 3
    2f3e:	9c 93       	st	X, r25
    2f40:	8e 93       	st	-X, r24
    2f42:	12 97       	sbiw	r26, 0x02	; 2
write():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1443

writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
  return 0;
    2f44:	80 e0       	ldi	r24, 0x00	; 0
    2f46:	07 c0       	rjmp	.+14     	; 0x2f56 <SdFile::write(void const*, unsigned int)+0x200>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1367
        } else {
          curCluster_ = firstCluster_;
        }
      } else {
        uint32_t next;
        if (!vol_->fatGet(curCluster_, &next)) {
    2f48:	9e 01       	movw	r18, r28
    2f4a:	2f 5f       	subi	r18, 0xFF	; 255
    2f4c:	3f 4f       	sbci	r19, 0xFF	; 255
    2f4e:	0e 94 26 13 	call	0x264c	; 0x264c <SdVolume::fatGet(unsigned long, unsigned long*) const>
    2f52:	81 11       	cpse	r24, r1
    2f54:	02 c0       	rjmp	.+4      	; 0x2f5a <SdFile::write(void const*, unsigned int)+0x204>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1443

writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
  return 0;
    2f56:	90 e0       	ldi	r25, 0x00	; 0
    2f58:	79 c0       	rjmp	.+242    	; 0x304c <SdFile::write(void const*, unsigned int)+0x2f6>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1370
      } else {
        uint32_t next;
        if (!vol_->fatGet(curCluster_, &next)) {
          return false;
        }
        if (vol_->isEOC(next)) {
    2f5a:	89 81       	ldd	r24, Y+1	; 0x01
    2f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    2f5e:	ab 81       	ldd	r26, Y+3	; 0x03
    2f60:	bc 81       	ldd	r27, Y+4	; 0x04
_ZNK8SdVolume5isEOCEm():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:622
    uint8_t fatPutEOC(uint32_t cluster) {
      return fatPut(cluster, 0x0FFFFFFF);
    }
    uint8_t freeChain(uint32_t cluster);
    uint8_t isEOC(uint32_t cluster) const {
      return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
    2f62:	f7 01       	movw	r30, r14
    2f64:	23 8d       	ldd	r18, Z+27	; 0x1b
    2f66:	34 8d       	ldd	r19, Z+28	; 0x1c
    2f68:	f9 01       	movw	r30, r18
    2f6a:	27 89       	ldd	r18, Z+23	; 0x17
write():
    2f6c:	48 ef       	ldi	r20, 0xF8	; 248
    2f6e:	5f ef       	ldi	r21, 0xFF	; 255
    2f70:	60 e0       	ldi	r22, 0x00	; 0
    2f72:	70 e0       	ldi	r23, 0x00	; 0
_ZNK8SdVolume5isEOCEm():
    2f74:	20 31       	cpi	r18, 0x10	; 16
    2f76:	21 f0       	breq	.+8      	; 0x2f80 <SdFile::write(void const*, unsigned int)+0x22a>
write():
    2f78:	48 ef       	ldi	r20, 0xF8	; 248
    2f7a:	5f ef       	ldi	r21, 0xFF	; 255
    2f7c:	6f ef       	ldi	r22, 0xFF	; 255
    2f7e:	7f e0       	ldi	r23, 0x0F	; 15
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1370
    2f80:	84 17       	cp	r24, r20
    2f82:	95 07       	cpc	r25, r21
    2f84:	a6 07       	cpc	r26, r22
    2f86:	b7 07       	cpc	r27, r23
    2f88:	08 f0       	brcs	.+2      	; 0x2f8c <SdFile::write(void const*, unsigned int)+0x236>
    2f8a:	50 cf       	rjmp	.-352    	; 0x2e2c <SdFile::write(void const*, unsigned int)+0xd6>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1376
          // add cluster if at end of chain
          if (!addCluster()) {
            goto writeErrorReturn;
          }
        } else {
          curCluster_ = next;
    2f8c:	f7 01       	movw	r30, r14
    2f8e:	86 83       	std	Z+6, r24	; 0x06
    2f90:	97 83       	std	Z+7, r25	; 0x07
    2f92:	a0 87       	std	Z+8, r26	; 0x08
    2f94:	b1 87       	std	Z+9, r27	; 0x09
    2f96:	50 cf       	rjmp	.-352    	; 0x2e38 <SdFile::write(void const*, unsigned int)+0xe2>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1401
      if (!vol_->writeBlock(block, src, blocking)) {
        goto writeErrorReturn;
      }
      src += 512;
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
    2f98:	01 15       	cp	r16, r1
    2f9a:	11 05       	cpc	r17, r1
    2f9c:	99 f5       	brne	.+102    	; 0x3004 <SdFile::write(void const*, unsigned int)+0x2ae>
    2f9e:	d7 01       	movw	r26, r14
    2fa0:	1a 96       	adiw	r26, 0x0a	; 10
    2fa2:	4d 91       	ld	r20, X+
    2fa4:	5d 91       	ld	r21, X+
    2fa6:	6d 91       	ld	r22, X+
    2fa8:	7c 91       	ld	r23, X
    2faa:	1d 97       	sbiw	r26, 0x0d	; 13
    2fac:	53 96       	adiw	r26, 0x13	; 19
    2fae:	8d 91       	ld	r24, X+
    2fb0:	9d 91       	ld	r25, X+
    2fb2:	0d 90       	ld	r0, X+
    2fb4:	bc 91       	ld	r27, X
    2fb6:	a0 2d       	mov	r26, r0
    2fb8:	48 17       	cp	r20, r24
    2fba:	59 07       	cpc	r21, r25
    2fbc:	6a 07       	cpc	r22, r26
    2fbe:	7b 07       	cpc	r23, r27
    2fc0:	08 f1       	brcs	.+66     	; 0x3004 <SdFile::write(void const*, unsigned int)+0x2ae>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1403
        // start of new block don't need to read into cache
        if (!SdVolume::cacheFlush()) {
    2fc2:	81 e0       	ldi	r24, 0x01	; 1
    2fc4:	0e 94 e6 10 	call	0x21cc	; 0x21cc <SdVolume::cacheFlush(unsigned char)>
    2fc8:	88 23       	and	r24, r24
    2fca:	09 f4       	brne	.+2      	; 0x2fce <SdFile::write(void const*, unsigned int)+0x278>
    2fcc:	b4 cf       	rjmp	.-152    	; 0x2f36 <SdFile::write(void const*, unsigned int)+0x1e0>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1406
          goto writeErrorReturn;
        }
        SdVolume::cacheBlockNumber_ = block;
    2fce:	40 92 14 02 	sts	0x0214, r4	; 0x800214 <SdVolume::cacheBlockNumber_>
    2fd2:	50 92 15 02 	sts	0x0215, r5	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    2fd6:	60 92 16 02 	sts	0x0216, r6	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    2fda:	70 92 17 02 	sts	0x0217, r7	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
cacheSetDirty():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:611
    }
    static uint8_t cacheFlush(uint8_t blocking = 1);
    static uint8_t cacheMirrorBlockFlush(uint8_t blocking);
    static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
    static void cacheSetDirty(void) {
      cacheDirty_ |= CACHE_FOR_WRITE;
    2fde:	80 91 cb 09 	lds	r24, 0x09CB	; 0x8009cb <SdVolume::cacheDirty_>
    2fe2:	81 60       	ori	r24, 0x01	; 1
    2fe4:	80 93 cb 09 	sts	0x09CB, r24	; 0x8009cb <SdVolume::cacheDirty_>
write():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1414
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
    2fe8:	c8 01       	movw	r24, r16
    2fea:	85 50       	subi	r24, 0x05	; 5
    2fec:	96 4f       	sbci	r25, 0xF6	; 246
    2fee:	d5 01       	movw	r26, r10
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1415
      uint8_t* end = dst + n;
    2ff0:	9c 01       	movw	r18, r24
    2ff2:	28 0d       	add	r18, r8
    2ff4:	39 1d       	adc	r19, r9
    2ff6:	fc 01       	movw	r30, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1416
      while (dst != end) {
    2ff8:	2e 17       	cp	r18, r30
    2ffa:	3f 07       	cpc	r19, r31
    2ffc:	59 f0       	breq	.+22     	; 0x3014 <SdFile::write(void const*, unsigned int)+0x2be>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1417
        *dst++ = *src++;
    2ffe:	4d 91       	ld	r20, X+
    3000:	41 93       	st	Z+, r20
    3002:	fa cf       	rjmp	.-12     	; 0x2ff8 <SdFile::write(void const*, unsigned int)+0x2a2>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1410
        }
        SdVolume::cacheBlockNumber_ = block;
        SdVolume::cacheSetDirty();
      } else {
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
    3004:	41 e0       	ldi	r20, 0x01	; 1
    3006:	c3 01       	movw	r24, r6
    3008:	b2 01       	movw	r22, r4
    300a:	0e 94 11 11 	call	0x2222	; 0x2222 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    300e:	81 11       	cpse	r24, r1
    3010:	eb cf       	rjmp	.-42     	; 0x2fe8 <SdFile::write(void const*, unsigned int)+0x292>
    3012:	91 cf       	rjmp	.-222    	; 0x2f36 <SdFile::write(void const*, unsigned int)+0x1e0>
    3014:	28 1b       	sub	r18, r24
    3016:	39 0b       	sbc	r19, r25
    3018:	a2 0e       	add	r10, r18
    301a:	b3 1e       	adc	r11, r19
    301c:	68 cf       	rjmp	.-304    	; 0x2eee <SdFile::write(void const*, unsigned int)+0x198>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1423
      }
    }
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
    301e:	f7 01       	movw	r30, r14
    3020:	83 89       	ldd	r24, Z+19	; 0x13
    3022:	94 89       	ldd	r25, Z+20	; 0x14
    3024:	a5 89       	ldd	r26, Z+21	; 0x15
    3026:	b6 89       	ldd	r27, Z+22	; 0x16
    3028:	84 17       	cp	r24, r20
    302a:	95 07       	cpc	r25, r21
    302c:	a6 07       	cpc	r26, r22
    302e:	b7 07       	cpc	r27, r23
    3030:	38 f4       	brcc	.+14     	; 0x3040 <SdFile::write(void const*, unsigned int)+0x2ea>
    3032:	84 81       	ldd	r24, Z+4	; 0x04
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1425
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    3034:	43 8b       	std	Z+19, r20	; 0x13
    3036:	54 8b       	std	Z+20, r21	; 0x14
    3038:	65 8b       	std	Z+21, r22	; 0x15
    303a:	76 8b       	std	Z+22, r23	; 0x16
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1426
    flags_ |= F_FILE_DIR_DIRTY;
    303c:	80 68       	ori	r24, 0x80	; 128
    303e:	84 83       	std	Z+4, r24	; 0x04
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1432
  } else if (dateTime_ && nbyte) {
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
  }

  if (flags_ & O_SYNC) {
    3040:	f7 01       	movw	r30, r14
    3042:	84 81       	ldd	r24, Z+4	; 0x04
    3044:	83 fd       	sbrc	r24, 3
    3046:	1a c0       	rjmp	.+52     	; 0x307c <SdFile::write(void const*, unsigned int)+0x326>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1437
    if (!sync()) {
      goto writeErrorReturn;
    }
  }
  return nbyte;
    3048:	83 2d       	mov	r24, r3
    304a:	9d 81       	ldd	r25, Y+5	; 0x05
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1444
writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
  return 0;
}
    304c:	0f 90       	pop	r0
    304e:	0f 90       	pop	r0
    3050:	0f 90       	pop	r0
    3052:	0f 90       	pop	r0
    3054:	0f 90       	pop	r0
    3056:	df 91       	pop	r29
    3058:	cf 91       	pop	r28
    305a:	1f 91       	pop	r17
    305c:	0f 91       	pop	r16
    305e:	ff 90       	pop	r15
    3060:	ef 90       	pop	r14
    3062:	df 90       	pop	r13
    3064:	cf 90       	pop	r12
    3066:	bf 90       	pop	r11
    3068:	af 90       	pop	r10
    306a:	9f 90       	pop	r9
    306c:	8f 90       	pop	r8
    306e:	7f 90       	pop	r7
    3070:	6f 90       	pop	r6
    3072:	5f 90       	pop	r5
    3074:	4f 90       	pop	r4
    3076:	3f 90       	pop	r3
    3078:	2f 90       	pop	r2
    307a:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1433
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
  }

  if (flags_ & O_SYNC) {
    if (!sync()) {
    307c:	61 e0       	ldi	r22, 0x01	; 1
    307e:	c7 01       	movw	r24, r14
    3080:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <SdFile::sync(unsigned char)>
    3084:	88 23       	and	r24, r24
    3086:	09 f4       	brne	.+2      	; 0x308a <SdFile::write(void const*, unsigned int)+0x334>
    3088:	56 cf       	rjmp	.-340    	; 0x2f36 <SdFile::write(void const*, unsigned int)+0x1e0>
    308a:	de cf       	rjmp	.-68     	; 0x3048 <SdFile::write(void const*, unsigned int)+0x2f2>

0000308c <SdFile::write(unsigned char)>:
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1451
/**
   Write a byte to a file. Required by the Arduino Print class.

   Use SdFile::writeError to check for errors.
*/
size_t SdFile::write(uint8_t b) {
    308c:	cf 93       	push	r28
    308e:	df 93       	push	r29
    3090:	1f 92       	push	r1
    3092:	cd b7       	in	r28, 0x3d	; 61
    3094:	de b7       	in	r29, 0x3e	; 62
    3096:	69 83       	std	Y+1, r22	; 0x01
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1452
  return write(&b, 1);
    3098:	41 e0       	ldi	r20, 0x01	; 1
    309a:	50 e0       	ldi	r21, 0x00	; 0
    309c:	be 01       	movw	r22, r28
    309e:	6f 5f       	subi	r22, 0xFF	; 255
    30a0:	7f 4f       	sbci	r23, 0xFF	; 255
    30a2:	0e 94 ab 16 	call	0x2d56	; 0x2d56 <SdFile::write(void const*, unsigned int)>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:1453
}
    30a6:	0f 90       	pop	r0
    30a8:	df 91       	pop	r29
    30aa:	cf 91       	pop	r28
    30ac:	08 95       	ret

000030ae <SdFile::SdFile(SdFile const&)>:
__base_ctor ():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:151
//------------------------------------------------------------------------------
/**
   \class SdFile
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
    30ae:	fc 01       	movw	r30, r24
    30b0:	db 01       	movw	r26, r22
_ZN5PrintC2ERKS_():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:37
#ifdef BIN // Prevent warnings if BIN is previously defined in "iotnx4.h" or similar
#undef BIN
#endif
#define BIN 2

class Print
    30b2:	12 96       	adiw	r26, 0x02	; 2
    30b4:	8d 91       	ld	r24, X+
    30b6:	9c 91       	ld	r25, X
    30b8:	13 97       	sbiw	r26, 0x03	; 3
    30ba:	93 83       	std	Z+3, r25	; 0x03
    30bc:	82 83       	std	Z+2, r24	; 0x02
__base_ctor ():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:151
    30be:	8d e0       	ldi	r24, 0x0D	; 13
    30c0:	93 e0       	ldi	r25, 0x03	; 3
    30c2:	91 83       	std	Z+1, r25	; 0x01
    30c4:	80 83       	st	Z, r24
    30c6:	14 96       	adiw	r26, 0x04	; 4
    30c8:	8c 91       	ld	r24, X
    30ca:	14 97       	sbiw	r26, 0x04	; 4
    30cc:	84 83       	std	Z+4, r24	; 0x04
    30ce:	15 96       	adiw	r26, 0x05	; 5
    30d0:	8c 91       	ld	r24, X
    30d2:	15 97       	sbiw	r26, 0x05	; 5
    30d4:	85 83       	std	Z+5, r24	; 0x05
    30d6:	16 96       	adiw	r26, 0x06	; 6
    30d8:	4d 91       	ld	r20, X+
    30da:	5d 91       	ld	r21, X+
    30dc:	6d 91       	ld	r22, X+
    30de:	7c 91       	ld	r23, X
    30e0:	19 97       	sbiw	r26, 0x09	; 9
    30e2:	46 83       	std	Z+6, r20	; 0x06
    30e4:	57 83       	std	Z+7, r21	; 0x07
    30e6:	60 87       	std	Z+8, r22	; 0x08
    30e8:	71 87       	std	Z+9, r23	; 0x09
    30ea:	1a 96       	adiw	r26, 0x0a	; 10
    30ec:	4d 91       	ld	r20, X+
    30ee:	5d 91       	ld	r21, X+
    30f0:	6d 91       	ld	r22, X+
    30f2:	7c 91       	ld	r23, X
    30f4:	1d 97       	sbiw	r26, 0x0d	; 13
    30f6:	42 87       	std	Z+10, r20	; 0x0a
    30f8:	53 87       	std	Z+11, r21	; 0x0b
    30fa:	64 87       	std	Z+12, r22	; 0x0c
    30fc:	75 87       	std	Z+13, r23	; 0x0d
    30fe:	1e 96       	adiw	r26, 0x0e	; 14
    3100:	4d 91       	ld	r20, X+
    3102:	5d 91       	ld	r21, X+
    3104:	6d 91       	ld	r22, X+
    3106:	7c 91       	ld	r23, X
    3108:	51 97       	sbiw	r26, 0x11	; 17
    310a:	46 87       	std	Z+14, r20	; 0x0e
    310c:	57 87       	std	Z+15, r21	; 0x0f
    310e:	60 8b       	std	Z+16, r22	; 0x10
    3110:	71 8b       	std	Z+17, r23	; 0x11
    3112:	52 96       	adiw	r26, 0x12	; 18
    3114:	8c 91       	ld	r24, X
    3116:	52 97       	sbiw	r26, 0x12	; 18
    3118:	82 8b       	std	Z+18, r24	; 0x12
    311a:	53 96       	adiw	r26, 0x13	; 19
    311c:	4d 91       	ld	r20, X+
    311e:	5d 91       	ld	r21, X+
    3120:	6d 91       	ld	r22, X+
    3122:	7c 91       	ld	r23, X
    3124:	56 97       	sbiw	r26, 0x16	; 22
    3126:	43 8b       	std	Z+19, r20	; 0x13
    3128:	54 8b       	std	Z+20, r21	; 0x14
    312a:	65 8b       	std	Z+21, r22	; 0x15
    312c:	76 8b       	std	Z+22, r23	; 0x16
    312e:	57 96       	adiw	r26, 0x17	; 23
    3130:	4d 91       	ld	r20, X+
    3132:	5d 91       	ld	r21, X+
    3134:	6d 91       	ld	r22, X+
    3136:	7c 91       	ld	r23, X
    3138:	5a 97       	sbiw	r26, 0x1a	; 26
    313a:	47 8b       	std	Z+23, r20	; 0x17
    313c:	50 8f       	std	Z+24, r21	; 0x18
    313e:	61 8f       	std	Z+25, r22	; 0x19
    3140:	72 8f       	std	Z+26, r23	; 0x1a
    3142:	5b 96       	adiw	r26, 0x1b	; 27
    3144:	8d 91       	ld	r24, X+
    3146:	9c 91       	ld	r25, X
    3148:	94 8f       	std	Z+28, r25	; 0x1c
    314a:	83 8f       	std	Z+27, r24	; 0x1b
    314c:	08 95       	ret

0000314e <SDLib::File::flush()>:
flush():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:121

  return n > 0X7FFF ? 0X7FFF : n;
}

void File::flush() {
  if (_file) {
    314e:	fc 01       	movw	r30, r24
    3150:	81 8d       	ldd	r24, Z+25	; 0x19
    3152:	92 8d       	ldd	r25, Z+26	; 0x1a
    3154:	00 97       	sbiw	r24, 0x00	; 0
    3156:	19 f0       	breq	.+6      	; 0x315e <SDLib::File::flush()+0x10>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:122
    _file->sync();
    3158:	61 e0       	ldi	r22, 0x01	; 1
    315a:	0c 94 fa 15 	jmp	0x2bf4	; 0x2bf4 <SdFile::sync(unsigned char)>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:124
  }
}
    315e:	08 95       	ret

00003160 <SDLib::File::available()>:
available():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:111
  }
  return 0;
}

int File::available() {
  if (! _file) {
    3160:	dc 01       	movw	r26, r24
    3162:	59 96       	adiw	r26, 0x19	; 25
    3164:	ed 91       	ld	r30, X+
    3166:	fc 91       	ld	r31, X
    3168:	30 97       	sbiw	r30, 0x00	; 0
    316a:	b9 f0       	breq	.+46     	; 0x319a <SDLib::File::available()+0x3a>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:115
    return 0;
  }

  uint32_t n = size() - position();
    316c:	83 89       	ldd	r24, Z+19	; 0x13
    316e:	94 89       	ldd	r25, Z+20	; 0x14
    3170:	a5 89       	ldd	r26, Z+21	; 0x15
    3172:	b6 89       	ldd	r27, Z+22	; 0x16
    3174:	42 85       	ldd	r20, Z+10	; 0x0a
    3176:	53 85       	ldd	r21, Z+11	; 0x0b
    3178:	64 85       	ldd	r22, Z+12	; 0x0c
    317a:	75 85       	ldd	r23, Z+13	; 0x0d
    317c:	84 1b       	sub	r24, r20
    317e:	95 0b       	sbc	r25, r21
    3180:	a6 0b       	sbc	r26, r22
    3182:	b7 0b       	sbc	r27, r23
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:117

  return n > 0X7FFF ? 0X7FFF : n;
    3184:	81 15       	cp	r24, r1
    3186:	20 e8       	ldi	r18, 0x80	; 128
    3188:	92 07       	cpc	r25, r18
    318a:	a1 05       	cpc	r26, r1
    318c:	b1 05       	cpc	r27, r1
    318e:	38 f0       	brcs	.+14     	; 0x319e <SDLib::File::available()+0x3e>
    3190:	8f ef       	ldi	r24, 0xFF	; 255
    3192:	9f e7       	ldi	r25, 0x7F	; 127
    3194:	a0 e0       	ldi	r26, 0x00	; 0
    3196:	b0 e0       	ldi	r27, 0x00	; 0
    3198:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:112
  return 0;
}

int File::available() {
  if (! _file) {
    return 0;
    319a:	90 e0       	ldi	r25, 0x00	; 0
    319c:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:118
  }

  uint32_t n = size() - position();

  return n > 0X7FFF ? 0X7FFF : n;
}
    319e:	08 95       	ret

000031a0 <SDLib::File::availableForWrite()>:
availableForWrite():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:77
  }
  return t;
}

int File::availableForWrite() {
  if (_file) {
    31a0:	dc 01       	movw	r26, r24
    31a2:	59 96       	adiw	r26, 0x19	; 25
    31a4:	8d 91       	ld	r24, X+
    31a6:	9c 91       	ld	r25, X
    31a8:	00 97       	sbiw	r24, 0x00	; 0
    31aa:	39 f0       	breq	.+14     	; 0x31ba <SDLib::File::availableForWrite()+0x1a>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:78
    return _file->availableForWrite();
    31ac:	dc 01       	movw	r26, r24
    31ae:	ed 91       	ld	r30, X+
    31b0:	fc 91       	ld	r31, X
    31b2:	04 80       	ldd	r0, Z+4	; 0x04
    31b4:	f5 81       	ldd	r31, Z+5	; 0x05
    31b6:	e0 2d       	mov	r30, r0
    31b8:	19 94       	eijmp
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:81
  }
  return 0;
}
    31ba:	90 e0       	ldi	r25, 0x00	; 0
    31bc:	80 e0       	ldi	r24, 0x00	; 0
    31be:	08 95       	ret

000031c0 <SDLib::File::write(unsigned char const*, unsigned int)>:
write():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:61

size_t File::write(uint8_t val) {
  return write(&val, 1);
}

size_t File::write(const uint8_t *buf, size_t size) {
    31c0:	cf 93       	push	r28
    31c2:	df 93       	push	r29
    31c4:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:63
  size_t t;
  if (!_file) {
    31c6:	e9 8d       	ldd	r30, Y+25	; 0x19
    31c8:	fa 8d       	ldd	r31, Y+26	; 0x1a
    31ca:	30 97       	sbiw	r30, 0x00	; 0
    31cc:	49 f4       	brne	.+18     	; 0x31e0 <SDLib::File::write(unsigned char const*, unsigned int)+0x20>
_ZN5Print13setWriteErrorEi():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:44
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    31ce:	81 e0       	ldi	r24, 0x01	; 1
    31d0:	90 e0       	ldi	r25, 0x00	; 0
    31d2:	9b 83       	std	Y+3, r25	; 0x03
    31d4:	8a 83       	std	Y+2, r24	; 0x02
write():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:65
    setWriteError();
    return 0;
    31d6:	90 e0       	ldi	r25, 0x00	; 0
    31d8:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:74
  if (_file->getWriteError()) {
    setWriteError();
    return 0;
  }
  return t;
}
    31da:	df 91       	pop	r29
    31dc:	cf 91       	pop	r28
    31de:	08 95       	ret
_ZN5Print13setWriteErrorEi():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:44
    31e0:	13 82       	std	Z+3, r1	; 0x03
    31e2:	12 82       	std	Z+2, r1	; 0x02
write():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:68
  if (!_file) {
    setWriteError();
    return 0;
  }
  _file->clearWriteError();
  t = _file->write(buf, size);
    31e4:	89 8d       	ldd	r24, Y+25	; 0x19
    31e6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    31e8:	0e 94 ab 16 	call	0x2d56	; 0x2d56 <SdFile::write(void const*, unsigned int)>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:69
  if (_file->getWriteError()) {
    31ec:	e9 8d       	ldd	r30, Y+25	; 0x19
    31ee:	fa 8d       	ldd	r31, Y+26	; 0x1a
    31f0:	22 81       	ldd	r18, Z+2	; 0x02
    31f2:	33 81       	ldd	r19, Z+3	; 0x03
    31f4:	23 2b       	or	r18, r19
    31f6:	59 f7       	brne	.-42     	; 0x31ce <SDLib::File::write(unsigned char const*, unsigned int)+0xe>
    31f8:	f0 cf       	rjmp	.-32     	; 0x31da <SDLib::File::write(unsigned char const*, unsigned int)+0x1a>

000031fa <SDLib::File::write(unsigned char)>:
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:57
boolean File::isDirectory(void) {
  return (_file && _file->isDir());
}


size_t File::write(uint8_t val) {
    31fa:	cf 93       	push	r28
    31fc:	df 93       	push	r29
    31fe:	1f 92       	push	r1
    3200:	cd b7       	in	r28, 0x3d	; 61
    3202:	de b7       	in	r29, 0x3e	; 62
    3204:	69 83       	std	Y+1, r22	; 0x01
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:58
  return write(&val, 1);
    3206:	dc 01       	movw	r26, r24
    3208:	ed 91       	ld	r30, X+
    320a:	fc 91       	ld	r31, X
    320c:	02 80       	ldd	r0, Z+2	; 0x02
    320e:	f3 81       	ldd	r31, Z+3	; 0x03
    3210:	e0 2d       	mov	r30, r0
    3212:	41 e0       	ldi	r20, 0x01	; 1
    3214:	50 e0       	ldi	r21, 0x00	; 0
    3216:	be 01       	movw	r22, r28
    3218:	6f 5f       	subi	r22, 0xFF	; 255
    321a:	7f 4f       	sbci	r23, 0xFF	; 255
    321c:	19 95       	eicall
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:59
}
    321e:	0f 90       	pop	r0
    3220:	df 91       	pop	r29
    3222:	cf 91       	pop	r28
    3224:	08 95       	ret

00003226 <SdFile::read()>:
read():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:273
       Read the next byte from a file.

       \return For success read returns the next byte in the file as an int.
       If an error occurs or end of file is reached -1 is returned.
    */
    int16_t read(void) {
    3226:	2f 92       	push	r2
    3228:	3f 92       	push	r3
    322a:	4f 92       	push	r4
    322c:	5f 92       	push	r5
    322e:	6f 92       	push	r6
    3230:	7f 92       	push	r7
    3232:	8f 92       	push	r8
    3234:	9f 92       	push	r9
    3236:	af 92       	push	r10
    3238:	bf 92       	push	r11
    323a:	cf 92       	push	r12
    323c:	df 92       	push	r13
    323e:	ef 92       	push	r14
    3240:	ff 92       	push	r15
    3242:	0f 93       	push	r16
    3244:	1f 93       	push	r17
    3246:	cf 93       	push	r28
    3248:	df 93       	push	r29
    324a:	00 d0       	rcall	.+0      	; 0x324c <SdFile::read()+0x26>
    324c:	cd b7       	in	r28, 0x3d	; 61
    324e:	de b7       	in	r29, 0x3e	; 62
    3250:	fc 01       	movw	r30, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:773
*/
int16_t SdFile::read(void* buf, uint16_t nbyte) {
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);

  // error if not open or write only
  if (!isOpen() || !(flags_ & O_READ)) {
    3252:	85 81       	ldd	r24, Z+5	; 0x05
    3254:	81 11       	cpse	r24, r1
    3256:	18 c0       	rjmp	.+48     	; 0x3288 <SdFile::read()+0x62>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:275
      uint8_t b;
      return read(&b, 1) == 1 ? b : -1;
    3258:	8f ef       	ldi	r24, 0xFF	; 255
    325a:	9f ef       	ldi	r25, 0xFF	; 255
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:276
    }
    325c:	0f 90       	pop	r0
    325e:	0f 90       	pop	r0
    3260:	0f 90       	pop	r0
    3262:	df 91       	pop	r29
    3264:	cf 91       	pop	r28
    3266:	1f 91       	pop	r17
    3268:	0f 91       	pop	r16
    326a:	ff 90       	pop	r15
    326c:	ef 90       	pop	r14
    326e:	df 90       	pop	r13
    3270:	cf 90       	pop	r12
    3272:	bf 90       	pop	r11
    3274:	af 90       	pop	r10
    3276:	9f 90       	pop	r9
    3278:	8f 90       	pop	r8
    327a:	7f 90       	pop	r7
    327c:	6f 90       	pop	r6
    327e:	5f 90       	pop	r5
    3280:	4f 90       	pop	r4
    3282:	3f 90       	pop	r3
    3284:	2f 90       	pop	r2
    3286:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:773
    3288:	84 81       	ldd	r24, Z+4	; 0x04
    328a:	80 ff       	sbrs	r24, 0
    328c:	e5 cf       	rjmp	.-54     	; 0x3258 <SdFile::read()+0x32>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:778
    return -1;
  }

  // max bytes left in file
  if (nbyte > (fileSize_ - curPosition_)) {
    328e:	43 89       	ldd	r20, Z+19	; 0x13
    3290:	54 89       	ldd	r21, Z+20	; 0x14
    3292:	65 89       	ldd	r22, Z+21	; 0x15
    3294:	76 89       	ldd	r23, Z+22	; 0x16
    3296:	82 85       	ldd	r24, Z+10	; 0x0a
    3298:	93 85       	ldd	r25, Z+11	; 0x0b
    329a:	a4 85       	ldd	r26, Z+12	; 0x0c
    329c:	b5 85       	ldd	r27, Z+13	; 0x0d
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:779
    nbyte = fileSize_ - curPosition_;
    329e:	31 2c       	mov	r3, r1
    32a0:	21 2c       	mov	r2, r1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:778
  if (!isOpen() || !(flags_ & O_READ)) {
    return -1;
  }

  // max bytes left in file
  if (nbyte > (fileSize_ - curPosition_)) {
    32a2:	48 17       	cp	r20, r24
    32a4:	59 07       	cpc	r21, r25
    32a6:	6a 07       	cpc	r22, r26
    32a8:	7b 07       	cpc	r23, r27
    32aa:	19 f0       	breq	.+6      	; 0x32b2 <SdFile::read()+0x8c>
    32ac:	22 24       	eor	r2, r2
    32ae:	23 94       	inc	r2
    32b0:	31 2c       	mov	r3, r1
    32b2:	6f 01       	movw	r12, r30
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:783
    nbyte = fileSize_ - curPosition_;
  }

  // amount left to read
  uint16_t toRead = nbyte;
    32b4:	21 01       	movw	r4, r2
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:770
   If an error occurs, read() returns -1.  Possible errors include
   read() called before a file has been opened, corrupt file system
   or an I/O error occurred.
*/
int16_t SdFile::read(void* buf, uint16_t nbyte) {
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
    32b6:	ce 01       	movw	r24, r28
    32b8:	01 96       	adiw	r24, 0x01	; 1
    32ba:	3c 01       	movw	r6, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:798
        if (curPosition_ == 0) {
          // use first cluster in file
          curCluster_ = firstCluster_;
        } else {
          // get next cluster from FAT
          if (!vol_->fatGet(curCluster_, &curCluster_)) {
    32bc:	df 01       	movw	r26, r30
    32be:	16 96       	adiw	r26, 0x06	; 6
    32c0:	bb 83       	std	Y+3, r27	; 0x03
    32c2:	aa 83       	std	Y+2, r26	; 0x02
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:784
    nbyte = fileSize_ - curPosition_;
  }

  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
    32c4:	41 14       	cp	r4, r1
    32c6:	51 04       	cpc	r5, r1
    32c8:	09 f4       	brne	.+2      	; 0x32cc <SdFile::read()+0xa6>
    32ca:	c5 c0       	rjmp	.+394    	; 0x3456 <SdFile::read()+0x230>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:786
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    32cc:	f6 01       	movw	r30, r12
    32ce:	42 85       	ldd	r20, Z+10	; 0x0a
    32d0:	53 85       	ldd	r21, Z+11	; 0x0b
    32d2:	64 85       	ldd	r22, Z+12	; 0x0c
    32d4:	75 85       	ldd	r23, Z+13	; 0x0d
    32d6:	4a 01       	movw	r8, r20
    32d8:	f1 e0       	ldi	r31, 0x01	; 1
    32da:	9f 22       	and	r9, r31
    32dc:	d6 01       	movw	r26, r12
    32de:	5b 96       	adiw	r26, 0x1b	; 27
    32e0:	8d 91       	ld	r24, X+
    32e2:	9c 91       	ld	r25, X
    32e4:	5c 97       	sbiw	r26, 0x1c	; 28
    32e6:	8a 01       	movw	r16, r20
    32e8:	9b 01       	movw	r18, r22
    32ea:	e9 e0       	ldi	r30, 0x09	; 9
    32ec:	36 95       	lsr	r19
    32ee:	27 95       	ror	r18
    32f0:	17 95       	ror	r17
    32f2:	07 95       	ror	r16
    32f4:	ea 95       	dec	r30
    32f6:	d1 f7       	brne	.-12     	; 0x32ec <SdFile::read()+0xc6>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:787
    if (type_ == FAT_FILE_TYPE_ROOT16) {
    32f8:	15 96       	adiw	r26, 0x05	; 5
    32fa:	ec 91       	ld	r30, X
    32fc:	e2 30       	cpi	r30, 0x02	; 2
    32fe:	e9 f5       	brne	.+122    	; 0x337a <SdFile::read()+0x154>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:788
      block = vol_->rootDirStart() + (curPosition_ >> 9);
    3300:	fc 01       	movw	r30, r24
    3302:	62 8d       	ldd	r22, Z+26	; 0x1a
    3304:	73 8d       	ldd	r23, Z+27	; 0x1b
    3306:	84 8d       	ldd	r24, Z+28	; 0x1c
    3308:	95 8d       	ldd	r25, Z+29	; 0x1d
    330a:	60 0f       	add	r22, r16
    330c:	71 1f       	adc	r23, r17
    330e:	82 1f       	adc	r24, r18
    3310:	93 1f       	adc	r25, r19
    3312:	a1 2c       	mov	r10, r1
    3314:	22 e0       	ldi	r18, 0x02	; 2
    3316:	b2 2e       	mov	r11, r18
    3318:	a8 18       	sub	r10, r8
    331a:	b9 08       	sbc	r11, r9
    331c:	4a 14       	cp	r4, r10
    331e:	5b 04       	cpc	r5, r11
    3320:	08 f4       	brcc	.+2      	; 0x3324 <SdFile::read()+0xfe>
    3322:	52 01       	movw	r10, r4
_ZNK6SdFile14unbufferedReadEv():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:324
      return type_;
    }
    uint8_t truncate(uint32_t size);
    /** \return Unbuffered read flag. */
    uint8_t unbufferedRead(void) const {
      return flags_ & F_FILE_UNBUFFERED_READ;
    3324:	f6 01       	movw	r30, r12
    3326:	24 81       	ldd	r18, Z+4	; 0x04
read():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:813
    if (n > (512 - offset)) {
      n = 512 - offset;
    }

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
    3328:	26 fd       	sbrc	r18, 6
    332a:	04 c0       	rjmp	.+8      	; 0x3334 <SdFile::read()+0x10e>
    332c:	a1 14       	cp	r10, r1
    332e:	f2 e0       	ldi	r31, 0x02	; 2
    3330:	bf 06       	cpc	r11, r31
    3332:	71 f4       	brne	.+28     	; 0x3350 <SdFile::read()+0x12a>
    3334:	00 91 14 02 	lds	r16, 0x0214	; 0x800214 <SdVolume::cacheBlockNumber_>
    3338:	10 91 15 02 	lds	r17, 0x0215	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    333c:	20 91 16 02 	lds	r18, 0x0216	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    3340:	30 91 17 02 	lds	r19, 0x0217	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
    3344:	06 17       	cp	r16, r22
    3346:	17 07       	cpc	r17, r23
    3348:	28 07       	cpc	r18, r24
    334a:	39 07       	cpc	r19, r25
    334c:	09 f0       	breq	.+2      	; 0x3350 <SdFile::read()+0x12a>
    334e:	5e c0       	rjmp	.+188    	; 0x340c <SdFile::read()+0x1e6>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:821
        return -1;
      }
      dst += n;
    } else {
      // read block to cache and copy data to caller
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) {
    3350:	40 e0       	ldi	r20, 0x00	; 0
    3352:	0e 94 11 11 	call	0x2222	; 0x2222 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    3356:	88 23       	and	r24, r24
    3358:	09 f4       	brne	.+2      	; 0x335c <SdFile::read()+0x136>
    335a:	7e cf       	rjmp	.-260    	; 0x3258 <SdFile::read()+0x32>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:824
        return -1;
      }
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
    335c:	c4 01       	movw	r24, r8
    335e:	85 50       	subi	r24, 0x05	; 5
    3360:	96 4f       	sbci	r25, 0xF6	; 246
    3362:	d3 01       	movw	r26, r6
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:825
      uint8_t* end = src + n;
    3364:	9c 01       	movw	r18, r24
    3366:	2a 0d       	add	r18, r10
    3368:	3b 1d       	adc	r19, r11
    336a:	fc 01       	movw	r30, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:826
      while (src != end) {
    336c:	2e 17       	cp	r18, r30
    336e:	3f 07       	cpc	r19, r31
    3370:	09 f4       	brne	.+2      	; 0x3374 <SdFile::read()+0x14e>
    3372:	6c c0       	rjmp	.+216    	; 0x344c <SdFile::read()+0x226>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:827
        *dst++ = *src++;
    3374:	41 91       	ld	r20, Z+
    3376:	4d 93       	st	X+, r20
    3378:	f9 cf       	rjmp	.-14     	; 0x336c <SdFile::read()+0x146>
_ZNK8SdVolume14blockOfClusterEm():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:599
    uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
    uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
    //----------------------------------------------------------------------------
    uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
    uint8_t blockOfCluster(uint32_t position) const {
      return (position >> 9) & (blocksPerCluster_ - 1);
    337a:	dc 01       	movw	r26, r24
    337c:	14 96       	adiw	r26, 0x04	; 4
    337e:	bc 90       	ld	r11, X
    3380:	ba 94       	dec	r11
    3382:	b0 22       	and	r11, r16
read():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:791
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
    if (type_ == FAT_FILE_TYPE_ROOT16) {
      block = vol_->rootDirStart() + (curPosition_ >> 9);
    } else {
      uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
      if (offset == 0 && blockOfCluster == 0) {
    3384:	81 14       	cp	r8, r1
    3386:	91 04       	cpc	r9, r1
    3388:	79 f4       	brne	.+30     	; 0x33a8 <SdFile::read()+0x182>
    338a:	b1 10       	cpse	r11, r1
    338c:	0d c0       	rjmp	.+26     	; 0x33a8 <SdFile::read()+0x182>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:793
        // start of new cluster
        if (curPosition_ == 0) {
    338e:	45 2b       	or	r20, r21
    3390:	46 2b       	or	r20, r22
    3392:	47 2b       	or	r20, r23
    3394:	69 f5       	brne	.+90     	; 0x33f0 <SdFile::read()+0x1ca>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:795
          // use first cluster in file
          curCluster_ = firstCluster_;
    3396:	f6 01       	movw	r30, r12
    3398:	87 89       	ldd	r24, Z+23	; 0x17
    339a:	90 8d       	ldd	r25, Z+24	; 0x18
    339c:	a1 8d       	ldd	r26, Z+25	; 0x19
    339e:	b2 8d       	ldd	r27, Z+26	; 0x1a
    33a0:	86 83       	std	Z+6, r24	; 0x06
    33a2:	97 83       	std	Z+7, r25	; 0x07
    33a4:	a0 87       	std	Z+8, r26	; 0x08
    33a6:	b1 87       	std	Z+9, r27	; 0x09
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:803
          if (!vol_->fatGet(curCluster_, &curCluster_)) {
            return -1;
          }
        }
      }
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    33a8:	d6 01       	movw	r26, r12
    33aa:	5b 96       	adiw	r26, 0x1b	; 27
    33ac:	ed 91       	ld	r30, X+
    33ae:	fc 91       	ld	r31, X
    33b0:	5c 97       	sbiw	r26, 0x1c	; 28
_ZNK8SdVolume17clusterStartBlockEm():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:602
    }
    uint32_t clusterStartBlock(uint32_t cluster) const {
      return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);
    33b2:	16 96       	adiw	r26, 0x06	; 6
    33b4:	6d 91       	ld	r22, X+
    33b6:	7d 91       	ld	r23, X+
    33b8:	8d 91       	ld	r24, X+
    33ba:	9c 91       	ld	r25, X
    33bc:	19 97       	sbiw	r26, 0x09	; 9
    33be:	62 50       	subi	r22, 0x02	; 2
    33c0:	71 09       	sbc	r23, r1
    33c2:	81 09       	sbc	r24, r1
    33c4:	91 09       	sbc	r25, r1
    33c6:	25 85       	ldd	r18, Z+13	; 0x0d
    33c8:	04 c0       	rjmp	.+8      	; 0x33d2 <SdFile::read()+0x1ac>
    33ca:	66 0f       	add	r22, r22
    33cc:	77 1f       	adc	r23, r23
    33ce:	88 1f       	adc	r24, r24
    33d0:	99 1f       	adc	r25, r25
    33d2:	2a 95       	dec	r18
    33d4:	d2 f7       	brpl	.-12     	; 0x33ca <SdFile::read()+0x1a4>
    33d6:	06 85       	ldd	r16, Z+14	; 0x0e
    33d8:	17 85       	ldd	r17, Z+15	; 0x0f
    33da:	20 89       	ldd	r18, Z+16	; 0x10
    33dc:	31 89       	ldd	r19, Z+17	; 0x11
    33de:	60 0f       	add	r22, r16
    33e0:	71 1f       	adc	r23, r17
    33e2:	82 1f       	adc	r24, r18
    33e4:	93 1f       	adc	r25, r19
read():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:803
    33e6:	6b 0d       	add	r22, r11
    33e8:	71 1d       	adc	r23, r1
    33ea:	81 1d       	adc	r24, r1
    33ec:	91 1d       	adc	r25, r1
    33ee:	91 cf       	rjmp	.-222    	; 0x3312 <SdFile::read()+0xec>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:798
        if (curPosition_ == 0) {
          // use first cluster in file
          curCluster_ = firstCluster_;
        } else {
          // get next cluster from FAT
          if (!vol_->fatGet(curCluster_, &curCluster_)) {
    33f0:	d6 01       	movw	r26, r12
    33f2:	16 96       	adiw	r26, 0x06	; 6
    33f4:	4d 91       	ld	r20, X+
    33f6:	5d 91       	ld	r21, X+
    33f8:	6d 91       	ld	r22, X+
    33fa:	7c 91       	ld	r23, X
    33fc:	19 97       	sbiw	r26, 0x09	; 9
    33fe:	2a 81       	ldd	r18, Y+2	; 0x02
    3400:	3b 81       	ldd	r19, Y+3	; 0x03
    3402:	0e 94 26 13 	call	0x264c	; 0x264c <SdVolume::fatGet(unsigned long, unsigned long*) const>
    3406:	81 11       	cpse	r24, r1
    3408:	cf cf       	rjmp	.-98     	; 0x33a8 <SdFile::read()+0x182>
    340a:	26 cf       	rjmp	.-436    	; 0x3258 <SdFile::read()+0x32>
readData():
    340c:	73 01       	movw	r14, r6
    340e:	85 01       	movw	r16, r10
    3410:	94 01       	movw	r18, r8
    3412:	ab 01       	movw	r20, r22
    3414:	bc 01       	movw	r22, r24
    3416:	80 91 fb 0b 	lds	r24, 0x0BFB	; 0x800bfb <SdVolume::sdCard_>
    341a:	90 91 fc 0b 	lds	r25, 0x0BFC	; 0x800bfc <SdVolume::sdCard_+0x1>
    341e:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <Sd2Card::readData(unsigned long, unsigned int, unsigned int, unsigned char*) [clone .part.6]>
read():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:815
    }

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
        block != SdVolume::cacheBlockNumber_) {
      if (!vol_->readData(block, offset, n, dst)) {
    3422:	88 23       	and	r24, r24
    3424:	09 f4       	brne	.+2      	; 0x3428 <SdFile::read()+0x202>
    3426:	18 cf       	rjmp	.-464    	; 0x3258 <SdFile::read()+0x32>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:818
        return -1;
      }
      dst += n;
    3428:	6a 0c       	add	r6, r10
    342a:	7b 1c       	adc	r7, r11
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:830
      uint8_t* end = src + n;
      while (src != end) {
        *dst++ = *src++;
      }
    }
    curPosition_ += n;
    342c:	f6 01       	movw	r30, r12
    342e:	82 85       	ldd	r24, Z+10	; 0x0a
    3430:	93 85       	ldd	r25, Z+11	; 0x0b
    3432:	a4 85       	ldd	r26, Z+12	; 0x0c
    3434:	b5 85       	ldd	r27, Z+13	; 0x0d
    3436:	8a 0d       	add	r24, r10
    3438:	9b 1d       	adc	r25, r11
    343a:	a1 1d       	adc	r26, r1
    343c:	b1 1d       	adc	r27, r1
    343e:	82 87       	std	Z+10, r24	; 0x0a
    3440:	93 87       	std	Z+11, r25	; 0x0b
    3442:	a4 87       	std	Z+12, r26	; 0x0c
    3444:	b5 87       	std	Z+13, r27	; 0x0d
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:831
    toRead -= n;
    3446:	4a 18       	sub	r4, r10
    3448:	5b 08       	sbc	r5, r11
    344a:	3c cf       	rjmp	.-392    	; 0x32c4 <SdFile::read()+0x9e>
    344c:	28 1b       	sub	r18, r24
    344e:	39 0b       	sbc	r19, r25
    3450:	62 0e       	add	r6, r18
    3452:	73 1e       	adc	r7, r19
    3454:	eb cf       	rjmp	.-42     	; 0x342c <SdFile::read()+0x206>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:275
       \return For success read returns the next byte in the file as an int.
       If an error occurs or end of file is reached -1 is returned.
    */
    int16_t read(void) {
      uint8_t b;
      return read(&b, 1) == 1 ? b : -1;
    3456:	2a 94       	dec	r2
    3458:	23 28       	or	r2, r3
    345a:	09 f0       	breq	.+2      	; 0x345e <SdFile::read()+0x238>
    345c:	fd ce       	rjmp	.-518    	; 0x3258 <SdFile::read()+0x32>
    345e:	89 81       	ldd	r24, Y+1	; 0x01
    3460:	90 e0       	ldi	r25, 0x00	; 0
    3462:	fc ce       	rjmp	.-520    	; 0x325c <SdFile::read()+0x36>

00003464 <SDLib::File::read()>:
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:96
  }
  return c;
}

int File::read() {
  if (_file) {
    3464:	fc 01       	movw	r30, r24
    3466:	81 8d       	ldd	r24, Z+25	; 0x19
    3468:	92 8d       	ldd	r25, Z+26	; 0x1a
    346a:	00 97       	sbiw	r24, 0x00	; 0
    346c:	11 f0       	breq	.+4      	; 0x3472 <SDLib::File::read()+0xe>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:97
    return _file->read();
    346e:	0c 94 13 19 	jmp	0x3226	; 0x3226 <SdFile::read()>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:100
  }
  return -1;
}
    3472:	8f ef       	ldi	r24, 0xFF	; 255
    3474:	9f ef       	ldi	r25, 0xFF	; 255
    3476:	08 95       	ret

00003478 <SDLib::File::peek()>:
peek():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:83
    return _file->availableForWrite();
  }
  return 0;
}

int File::peek() {
    3478:	0f 93       	push	r16
    347a:	1f 93       	push	r17
    347c:	cf 93       	push	r28
    347e:	df 93       	push	r29
    3480:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:84
  if (! _file) {
    3482:	89 8d       	ldd	r24, Y+25	; 0x19
    3484:	9a 8d       	ldd	r25, Y+26	; 0x1a
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:85
    return 0;
    3486:	10 e0       	ldi	r17, 0x00	; 0
    3488:	00 e0       	ldi	r16, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:84
  }
  return 0;
}

int File::peek() {
  if (! _file) {
    348a:	00 97       	sbiw	r24, 0x00	; 0
    348c:	99 f0       	breq	.+38     	; 0x34b4 <SDLib::File::peek()+0x3c>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:88
    return 0;
  }

  int c = _file->read();
    348e:	0e 94 13 19 	call	0x3226	; 0x3226 <SdFile::read()>
    3492:	8c 01       	movw	r16, r24
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:89
  if (c != -1) {
    3494:	0f 3f       	cpi	r16, 0xFF	; 255
    3496:	10 07       	cpc	r17, r16
    3498:	69 f0       	breq	.+26     	; 0x34b4 <SDLib::File::peek()+0x3c>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:90
    _file->seekCur(-1);
    349a:	89 8d       	ldd	r24, Y+25	; 0x19
    349c:	9a 8d       	ldd	r25, Y+26	; 0x1a
seekCur():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:289
    }
    uint8_t rmDir(void);
    uint8_t rmRfStar(void);
    /** Set the files position to current position + \a pos. See seekSet(). */
    uint8_t seekCur(uint32_t pos) {
      return seekSet(curPosition_ + pos);
    349e:	fc 01       	movw	r30, r24
    34a0:	42 85       	ldd	r20, Z+10	; 0x0a
    34a2:	53 85       	ldd	r21, Z+11	; 0x0b
    34a4:	64 85       	ldd	r22, Z+12	; 0x0c
    34a6:	75 85       	ldd	r23, Z+13	; 0x0d
    34a8:	41 50       	subi	r20, 0x01	; 1
    34aa:	51 09       	sbc	r21, r1
    34ac:	61 09       	sbc	r22, r1
    34ae:	71 09       	sbc	r23, r1
    34b0:	0e 94 66 14 	call	0x28cc	; 0x28cc <SdFile::seekSet(unsigned long)>
peek():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:93
  }
  return c;
}
    34b4:	c8 01       	movw	r24, r16
    34b6:	df 91       	pop	r29
    34b8:	cf 91       	pop	r28
    34ba:	1f 91       	pop	r17
    34bc:	0f 91       	pop	r16
    34be:	08 95       	ret

000034c0 <twi_transmit>:
twi_transmit():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:347
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
    34c0:	20 91 a5 09 	lds	r18, 0x09A5	; 0x8009a5 <twi_txBufferLength>
    34c4:	26 0f       	add	r18, r22
    34c6:	33 27       	eor	r19, r19
    34c8:	33 1f       	adc	r19, r19
    34ca:	21 32       	cpi	r18, 0x21	; 33
    34cc:	31 05       	cpc	r19, r1
    34ce:	ec f4       	brge	.+58     	; 0x350a <twi_transmit+0x4a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:352
    return 1;
  }
  
  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
    34d0:	20 91 4f 0c 	lds	r18, 0x0C4F	; 0x800c4f <twi_state>
    34d4:	fc 01       	movw	r30, r24
    34d6:	90 e0       	ldi	r25, 0x00	; 0
    34d8:	80 e0       	ldi	r24, 0x00	; 0
    34da:	24 30       	cpi	r18, 0x04	; 4
    34dc:	69 f0       	breq	.+26     	; 0x34f8 <twi_transmit+0x38>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:353
    return 2;
    34de:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:363
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
  
  return 0;
}
    34e0:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:358
    return 2;
  }
  
  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
    twi_txBuffer[twi_txBufferLength+i] = data[i];
    34e2:	a0 91 a5 09 	lds	r26, 0x09A5	; 0x8009a5 <twi_txBufferLength>
    34e6:	21 91       	ld	r18, Z+
    34e8:	ac 01       	movw	r20, r24
    34ea:	4b 57       	subi	r20, 0x7B	; 123
    34ec:	56 4f       	sbci	r21, 0xF6	; 246
    34ee:	a4 0f       	add	r26, r20
    34f0:	b5 2f       	mov	r27, r21
    34f2:	b1 1d       	adc	r27, r1
    34f4:	2c 93       	st	X, r18
    34f6:	01 96       	adiw	r24, 0x01	; 1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:357
  if(TWI_STX != twi_state){
    return 2;
  }
  
  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
    34f8:	86 17       	cp	r24, r22
    34fa:	98 f3       	brcs	.-26     	; 0x34e2 <twi_transmit+0x22>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:360
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
    34fc:	80 91 a5 09 	lds	r24, 0x09A5	; 0x8009a5 <twi_txBufferLength>
    3500:	68 0f       	add	r22, r24
    3502:	60 93 a5 09 	sts	0x09A5, r22	; 0x8009a5 <twi_txBufferLength>
    3506:	80 e0       	ldi	r24, 0x00	; 0
    3508:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:348
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < (twi_txBufferLength+length)){
    return 1;
    350a:	81 e0       	ldi	r24, 0x01	; 1
    350c:	08 95       	ret

0000350e <twi_init>:
twi_init():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:83
 * Output   none
 */
void twi_init(void)
{
  // initialize state
  twi_state = TWI_READY;
    350e:	10 92 4f 0c 	sts	0x0C4F, r1	; 0x800c4f <twi_state>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:84
  twi_sendStop = true;		// default value
    3512:	81 e0       	ldi	r24, 0x01	; 1
    3514:	80 93 4e 0c 	sts	0x0C4E, r24	; 0x800c4e <twi_sendStop>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:85
  twi_inRepStart = false;
    3518:	10 92 49 0c 	sts	0x0C49, r1	; 0x800c49 <twi_inRepStart>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:88
  
  // activate internal pullups for twi.
  digitalWrite(SDA, 1);
    351c:	61 e0       	ldi	r22, 0x01	; 1
    351e:	84 e1       	ldi	r24, 0x14	; 20
    3520:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:89
  digitalWrite(SCL, 1);
    3524:	61 e0       	ldi	r22, 0x01	; 1
    3526:	85 e1       	ldi	r24, 0x15	; 21
    3528:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:92

  // initialize twi prescaler and bit rate
  cbi(TWSR, TWPS0);
    352c:	e9 eb       	ldi	r30, 0xB9	; 185
    352e:	f0 e0       	ldi	r31, 0x00	; 0
    3530:	80 81       	ld	r24, Z
    3532:	8e 7f       	andi	r24, 0xFE	; 254
    3534:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:93
  cbi(TWSR, TWPS1);
    3536:	80 81       	ld	r24, Z
    3538:	8d 7f       	andi	r24, 0xFD	; 253
    353a:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:94
  TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;
    353c:	88 e4       	ldi	r24, 0x48	; 72
    353e:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:102
  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))
  note: TWBR should be 10 or higher for master mode
  It is 72 for a 16mhz Wiring board with 100kHz TWI */

  // enable twi module, acks, and twi interrupt
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);
    3542:	85 e4       	ldi	r24, 0x45	; 69
    3544:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:103
}
    3548:	08 95       	ret

0000354a <TwoWire::begin() [clone .constprop.113]>:
begin():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:58

// Public Methods //////////////////////////////////////////////////////////////

void TwoWire::begin(void)
{
  rxBufferIndex = 0;
    354a:	10 92 76 0c 	sts	0x0C76, r1	; 0x800c76 <TwoWire::rxBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:59
  rxBufferLength = 0;
    354e:	10 92 75 0c 	sts	0x0C75, r1	; 0x800c75 <TwoWire::rxBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:61

  txBufferIndex = 0;
    3552:	10 92 78 0c 	sts	0x0C78, r1	; 0x800c78 <TwoWire::txBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:62
  txBufferLength = 0;
    3556:	10 92 77 0c 	sts	0x0C77, r1	; 0x800c77 <TwoWire::txBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:64

  twi_init();
    355a:	0e 94 87 1a 	call	0x350e	; 0x350e <twi_init>
twi_attachSlaveTxEvent():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:384
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveTxEvent( void (*function)(void) )
{
  twi_onSlaveTransmit = function;
    355e:	8f e4       	ldi	r24, 0x4F	; 79
    3560:	94 e0       	ldi	r25, 0x04	; 4
    3562:	90 93 20 0c 	sts	0x0C20, r25	; 0x800c20 <twi_onSlaveTransmit+0x1>
    3566:	80 93 1f 0c 	sts	0x0C1F, r24	; 0x800c1f <twi_onSlaveTransmit>
twi_attachSlaveRxEvent():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:373
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveRxEvent( void (*function)(uint8_t*, int) )
{
  twi_onSlaveReceive = function;
    356a:	80 e5       	ldi	r24, 0x50	; 80
    356c:	94 e0       	ldi	r25, 0x04	; 4
    356e:	90 93 1e 0c 	sts	0x0C1E, r25	; 0x800c1e <twi_onSlaveReceive+0x1>
    3572:	80 93 1d 0c 	sts	0x0C1D, r24	; 0x800c1d <twi_onSlaveReceive>
begin():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:67
  twi_attachSlaveTxEvent(onRequestService); // default callback must exist
  twi_attachSlaveRxEvent(onReceiveService); // default callback must exist
}
    3576:	08 95       	ret

00003578 <twi_handleTimeout>:
twi_handleTimeout():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:470
 * Desc     this gets called whenever a while loop here has lasted longer than
 *          twi_timeout_us microseconds. always sets twi_timed_out_flag
 * Input    reset: true causes this function to reset the twi hardware interface
 * Output   none
 */
void twi_handleTimeout(bool reset){
    3578:	cf 93       	push	r28
    357a:	df 93       	push	r29
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:471
  twi_timed_out_flag = true;
    357c:	91 e0       	ldi	r25, 0x01	; 1
    357e:	90 93 84 09 	sts	0x0984, r25	; 0x800984 <twi_timed_out_flag>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:473

  if (reset) {
    3582:	88 23       	and	r24, r24
    3584:	b9 f0       	breq	.+46     	; 0x35b4 <twi_handleTimeout+0x3c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:475
    // remember bitrate and address settings
    uint8_t previous_TWBR = TWBR;
    3586:	c0 91 b8 00 	lds	r28, 0x00B8	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:476
    uint8_t previous_TWAR = TWAR;
    358a:	d0 91 ba 00 	lds	r29, 0x00BA	; 0x8000ba <__TEXT_REGION_LENGTH__+0x7000ba>
twi_disable():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:114
 * Output   none
 */
void twi_disable(void)
{
  // disable twi module, acks, and twi interrupt
  TWCR &= ~(_BV(TWEN) | _BV(TWIE) | _BV(TWEA));
    358e:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    3592:	8a 7b       	andi	r24, 0xBA	; 186
    3594:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:117

  // deactivate internal pullups for twi.
  digitalWrite(SDA, 0);
    3598:	60 e0       	ldi	r22, 0x00	; 0
    359a:	84 e1       	ldi	r24, 0x14	; 20
    359c:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:118
  digitalWrite(SCL, 0);
    35a0:	60 e0       	ldi	r22, 0x00	; 0
    35a2:	85 e1       	ldi	r24, 0x15	; 21
    35a4:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
twi_handleTimeout():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:480
    uint8_t previous_TWBR = TWBR;
    uint8_t previous_TWAR = TWAR;

    // reset the interface
    twi_disable();
    twi_init();
    35a8:	0e 94 87 1a 	call	0x350e	; 0x350e <twi_init>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:483

    // reapply the previous register values
    TWAR = previous_TWAR;
    35ac:	d0 93 ba 00 	sts	0x00BA, r29	; 0x8000ba <__TEXT_REGION_LENGTH__+0x7000ba>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:484
    TWBR = previous_TWBR;
    35b0:	c0 93 b8 00 	sts	0x00B8, r28	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:486
  }
}
    35b4:	df 91       	pop	r29
    35b6:	cf 91       	pop	r28
    35b8:	08 95       	ret

000035ba <twi_readFrom.constprop.140>:
twi_readFrom():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:159
 *          data: pointer to byte array
 *          length: number of bytes to read into array
 *          sendStop: Boolean indicating whether to send a stop at the end
 * Output   number of bytes read
 */
uint8_t twi_readFrom(uint8_t address, uint8_t* data, uint8_t length, uint8_t sendStop)
    35ba:	cf 92       	push	r12
    35bc:	df 92       	push	r13
    35be:	ef 92       	push	r14
    35c0:	ff 92       	push	r15
    35c2:	0f 93       	push	r16
    35c4:	1f 93       	push	r17
    35c6:	cf 93       	push	r28
    35c8:	df 93       	push	r29
    35ca:	d8 2f       	mov	r29, r24
    35cc:	c6 2f       	mov	r28, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:164
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < length){
    35ce:	61 32       	cpi	r22, 0x21	; 33
    35d0:	08 f0       	brcs	.+2      	; 0x35d4 <twi_readFrom.constprop.140+0x1a>
    35d2:	98 c0       	rjmp	.+304    	; 0x3704 <twi_readFrom.constprop.140+0x14a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:169
    return 0;
  }

  // wait until twi is ready, become master receiver
  uint32_t startMicros = micros();
    35d4:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    35d8:	6b 01       	movw	r12, r22
    35da:	7c 01       	movw	r14, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:170
  while(TWI_READY != twi_state){
    35dc:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <twi_state>
    35e0:	81 11       	cpse	r24, r1
    35e2:	6b c0       	rjmp	.+214    	; 0x36ba <twi_readFrom.constprop.140+0x100>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:176
    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {
      twi_handleTimeout(twi_do_reset_on_timeout);
      return 0;
    }
  }
  twi_state = TWI_MRX;
    35e4:	81 e0       	ldi	r24, 0x01	; 1
    35e6:	80 93 4f 0c 	sts	0x0C4F, r24	; 0x800c4f <twi_state>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:177
  twi_sendStop = sendStop;
    35ea:	80 93 4e 0c 	sts	0x0C4E, r24	; 0x800c4e <twi_sendStop>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:179
  // reset error state (0xFF.. no error occured)
  twi_error = 0xFF;
    35ee:	9f ef       	ldi	r25, 0xFF	; 255
    35f0:	90 93 4d 0c 	sts	0x0C4D, r25	; 0x800c4d <twi_error>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:182

  // initialize buffer iteration vars
  twi_masterBufferIndex = 0;
    35f4:	10 92 4c 0c 	sts	0x0C4C, r1	; 0x800c4c <twi_masterBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:183
  twi_masterBufferLength = length-1;  // This is not intuitive, read on...
    35f8:	9c 0f       	add	r25, r28
    35fa:	90 93 4b 0c 	sts	0x0C4B, r25	; 0x800c4b <twi_masterBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:191
  // Therefor we must actually set NACK when the _next_ to last byte is
  // received, causing that NACK to be sent in response to receiving the last
  // expected byte of data.

  // build sla+w, slave device address + w bit
  twi_slarw = TW_READ;
    35fe:	80 93 4a 0c 	sts	0x0C4A, r24	; 0x800c4a <twi_slarw>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:192
  twi_slarw |= address << 1;
    3602:	80 91 4a 0c 	lds	r24, 0x0C4A	; 0x800c4a <twi_slarw>
    3606:	dd 0f       	add	r29, r29
    3608:	d8 2b       	or	r29, r24
    360a:	d0 93 4a 0c 	sts	0x0C4A, r29	; 0x800c4a <twi_slarw>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:194

  if (true == twi_inRepStart) {
    360e:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <twi_inRepStart>
    3612:	81 30       	cpi	r24, 0x01	; 1
    3614:	09 f0       	breq	.+2      	; 0x3618 <twi_readFrom.constprop.140+0x5e>
    3616:	78 c0       	rjmp	.+240    	; 0x3708 <twi_readFrom.constprop.140+0x14e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:201
    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
    // We need to remove ourselves from the repeated start state before we enable interrupts,
    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
    // up. Also, don't enable the START interrupt. There may be one pending from the 
    // repeated start that we sent ourselves, and that would really confuse things.
    twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
    3618:	10 92 49 0c 	sts	0x0C49, r1	; 0x800c49 <twi_inRepStart>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:202
    startMicros = micros();
    361c:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    3620:	6b 01       	movw	r12, r22
    3622:	7c 01       	movw	r14, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:204
    do {
      TWDR = twi_slarw;
    3624:	80 91 4a 0c 	lds	r24, 0x0C4A	; 0x800c4a <twi_slarw>
    3628:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:205
      if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {
    362c:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <twi_timeout_us>
    3630:	90 91 52 0c 	lds	r25, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    3634:	a0 91 53 0c 	lds	r26, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    3638:	b0 91 54 0c 	lds	r27, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    363c:	89 2b       	or	r24, r25
    363e:	8a 2b       	or	r24, r26
    3640:	8b 2b       	or	r24, r27
    3642:	a1 f0       	breq	.+40     	; 0x366c <twi_readFrom.constprop.140+0xb2>
    3644:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    3648:	00 91 51 0c 	lds	r16, 0x0C51	; 0x800c51 <twi_timeout_us>
    364c:	10 91 52 0c 	lds	r17, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    3650:	20 91 53 0c 	lds	r18, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    3654:	30 91 54 0c 	lds	r19, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    3658:	6c 19       	sub	r22, r12
    365a:	7d 09       	sbc	r23, r13
    365c:	8e 09       	sbc	r24, r14
    365e:	9f 09       	sbc	r25, r15
    3660:	06 17       	cp	r16, r22
    3662:	17 07       	cpc	r17, r23
    3664:	28 07       	cpc	r18, r24
    3666:	39 07       	cpc	r19, r25
    3668:	08 f4       	brcc	.+2      	; 0x366c <twi_readFrom.constprop.140+0xb2>
    366a:	48 c0       	rjmp	.+144    	; 0x36fc <twi_readFrom.constprop.140+0x142>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:209
        twi_handleTimeout(twi_do_reset_on_timeout);
        return 0;
      }
    } while(TWCR & _BV(TWWC));
    366c:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    3670:	83 fd       	sbrc	r24, 3
    3672:	d8 cf       	rjmp	.-80     	; 0x3624 <twi_readFrom.constprop.140+0x6a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:210
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
    3674:	85 ec       	ldi	r24, 0xC5	; 197
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:213
  } else {
    // send start condition
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);
    3676:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:217
  }

  // wait for read operation to complete
  startMicros = micros();
    367a:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    367e:	6b 01       	movw	r12, r22
    3680:	7c 01       	movw	r14, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:218
  while(TWI_MRX == twi_state){
    3682:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <twi_state>
    3686:	81 30       	cpi	r24, 0x01	; 1
    3688:	09 f4       	brne	.+2      	; 0x368c <twi_readFrom.constprop.140+0xd2>
    368a:	40 c0       	rjmp	.+128    	; 0x370c <twi_readFrom.constprop.140+0x152>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:225
      twi_handleTimeout(twi_do_reset_on_timeout);
      return 0;
    }
  }

  if (twi_masterBufferIndex < length) {
    368c:	80 91 4c 0c 	lds	r24, 0x0C4C	; 0x800c4c <twi_masterBufferIndex>
    3690:	8c 17       	cp	r24, r28
    3692:	10 f4       	brcc	.+4      	; 0x3698 <twi_readFrom.constprop.140+0xde>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:226
    length = twi_masterBufferIndex;
    3694:	c0 91 4c 0c 	lds	r28, 0x0C4C	; 0x800c4c <twi_masterBufferIndex>
    3698:	e9 e2       	ldi	r30, 0x29	; 41
    369a:	fc e0       	ldi	r31, 0x0C	; 12
    369c:	a5 e5       	ldi	r26, 0x55	; 85
    369e:	bc e0       	ldi	r27, 0x0C	; 12
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:230
  }

  // copy twi buffer to data
  for(i = 0; i < length; ++i){
    36a0:	80 e0       	ldi	r24, 0x00	; 0
    36a2:	8c 13       	cpse	r24, r28
    36a4:	55 c0       	rjmp	.+170    	; 0x3750 <twi_readFrom.constprop.140+0x196>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:235
    data[i] = twi_masterBuffer[i];
  }

  return length;
}
    36a6:	8c 2f       	mov	r24, r28
    36a8:	df 91       	pop	r29
    36aa:	cf 91       	pop	r28
    36ac:	1f 91       	pop	r17
    36ae:	0f 91       	pop	r16
    36b0:	ff 90       	pop	r15
    36b2:	ef 90       	pop	r14
    36b4:	df 90       	pop	r13
    36b6:	cf 90       	pop	r12
    36b8:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:171
  }

  // wait until twi is ready, become master receiver
  uint32_t startMicros = micros();
  while(TWI_READY != twi_state){
    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {
    36ba:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <twi_timeout_us>
    36be:	90 91 52 0c 	lds	r25, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    36c2:	a0 91 53 0c 	lds	r26, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    36c6:	b0 91 54 0c 	lds	r27, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    36ca:	89 2b       	or	r24, r25
    36cc:	8a 2b       	or	r24, r26
    36ce:	8b 2b       	or	r24, r27
    36d0:	09 f4       	brne	.+2      	; 0x36d4 <twi_readFrom.constprop.140+0x11a>
    36d2:	84 cf       	rjmp	.-248    	; 0x35dc <twi_readFrom.constprop.140+0x22>
    36d4:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    36d8:	00 91 51 0c 	lds	r16, 0x0C51	; 0x800c51 <twi_timeout_us>
    36dc:	10 91 52 0c 	lds	r17, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    36e0:	20 91 53 0c 	lds	r18, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    36e4:	30 91 54 0c 	lds	r19, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    36e8:	6c 19       	sub	r22, r12
    36ea:	7d 09       	sbc	r23, r13
    36ec:	8e 09       	sbc	r24, r14
    36ee:	9f 09       	sbc	r25, r15
    36f0:	06 17       	cp	r16, r22
    36f2:	17 07       	cpc	r17, r23
    36f4:	28 07       	cpc	r18, r24
    36f6:	39 07       	cpc	r19, r25
    36f8:	08 f0       	brcs	.+2      	; 0x36fc <twi_readFrom.constprop.140+0x142>
    36fa:	70 cf       	rjmp	.-288    	; 0x35dc <twi_readFrom.constprop.140+0x22>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:220

  // wait for read operation to complete
  startMicros = micros();
  while(TWI_MRX == twi_state){
    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {
      twi_handleTimeout(twi_do_reset_on_timeout);
    36fc:	80 91 50 0c 	lds	r24, 0x0C50	; 0x800c50 <twi_do_reset_on_timeout>
    3700:	0e 94 bc 1a 	call	0x3578	; 0x3578 <twi_handleTimeout>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:165
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < length){
    return 0;
    3704:	c0 e0       	ldi	r28, 0x00	; 0
    3706:	cf cf       	rjmp	.-98     	; 0x36a6 <twi_readFrom.constprop.140+0xec>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:213
      }
    } while(TWCR & _BV(TWWC));
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
  } else {
    // send start condition
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);
    3708:	85 ee       	ldi	r24, 0xE5	; 229
    370a:	b5 cf       	rjmp	.-150    	; 0x3676 <twi_readFrom.constprop.140+0xbc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:219
  }

  // wait for read operation to complete
  startMicros = micros();
  while(TWI_MRX == twi_state){
    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {
    370c:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <twi_timeout_us>
    3710:	90 91 52 0c 	lds	r25, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    3714:	a0 91 53 0c 	lds	r26, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    3718:	b0 91 54 0c 	lds	r27, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    371c:	89 2b       	or	r24, r25
    371e:	8a 2b       	or	r24, r26
    3720:	8b 2b       	or	r24, r27
    3722:	09 f4       	brne	.+2      	; 0x3726 <twi_readFrom.constprop.140+0x16c>
    3724:	ae cf       	rjmp	.-164    	; 0x3682 <twi_readFrom.constprop.140+0xc8>
    3726:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    372a:	00 91 51 0c 	lds	r16, 0x0C51	; 0x800c51 <twi_timeout_us>
    372e:	10 91 52 0c 	lds	r17, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    3732:	20 91 53 0c 	lds	r18, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    3736:	30 91 54 0c 	lds	r19, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    373a:	6c 19       	sub	r22, r12
    373c:	7d 09       	sbc	r23, r13
    373e:	8e 09       	sbc	r24, r14
    3740:	9f 09       	sbc	r25, r15
    3742:	06 17       	cp	r16, r22
    3744:	17 07       	cpc	r17, r23
    3746:	28 07       	cpc	r18, r24
    3748:	39 07       	cpc	r19, r25
    374a:	08 f0       	brcs	.+2      	; 0x374e <twi_readFrom.constprop.140+0x194>
    374c:	9a cf       	rjmp	.-204    	; 0x3682 <twi_readFrom.constprop.140+0xc8>
    374e:	d6 cf       	rjmp	.-84     	; 0x36fc <twi_readFrom.constprop.140+0x142>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:231
    length = twi_masterBufferIndex;
  }

  // copy twi buffer to data
  for(i = 0; i < length; ++i){
    data[i] = twi_masterBuffer[i];
    3750:	91 91       	ld	r25, Z+
    3752:	9d 93       	st	X+, r25
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:230
  if (twi_masterBufferIndex < length) {
    length = twi_masterBufferIndex;
  }

  // copy twi buffer to data
  for(i = 0; i < length; ++i){
    3754:	8f 5f       	subi	r24, 0xFF	; 255
    3756:	a5 cf       	rjmp	.-182    	; 0x36a2 <twi_readFrom.constprop.140+0xe8>

00003758 <TwoWire::flush()>:
flush():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:321
}

void TwoWire::flush(void)
{
  // XXX: to be implemented.
}
    3758:	08 95       	ret

0000375a <TwoWire::peek()>:
peek():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:311
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  int value = -1;
  
  if(rxBufferIndex < rxBufferLength){
    375a:	e0 91 76 0c 	lds	r30, 0x0C76	; 0x800c76 <TwoWire::rxBufferIndex>
    375e:	80 91 75 0c 	lds	r24, 0x0C75	; 0x800c75 <TwoWire::rxBufferLength>
    3762:	e8 17       	cp	r30, r24
    3764:	30 f4       	brcc	.+12     	; 0x3772 <TwoWire::peek()+0x18>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:312
    value = rxBuffer[rxBufferIndex];
    3766:	f0 e0       	ldi	r31, 0x00	; 0
    3768:	eb 5a       	subi	r30, 0xAB	; 171
    376a:	f3 4f       	sbci	r31, 0xF3	; 243
    376c:	80 81       	ld	r24, Z
    376e:	90 e0       	ldi	r25, 0x00	; 0
    3770:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:309
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  int value = -1;
    3772:	8f ef       	ldi	r24, 0xFF	; 255
    3774:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:316
  if(rxBufferIndex < rxBufferLength){
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
    3776:	08 95       	ret

00003778 <TwoWire::write(unsigned char const*, unsigned int)>:
write():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:266

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    3778:	cf 92       	push	r12
    377a:	df 92       	push	r13
    377c:	ef 92       	push	r14
    377e:	ff 92       	push	r15
    3780:	0f 93       	push	r16
    3782:	1f 93       	push	r17
    3784:	cf 93       	push	r28
    3786:	df 93       	push	r29
    3788:	7c 01       	movw	r14, r24
    378a:	cb 01       	movw	r24, r22
    378c:	8a 01       	movw	r16, r20
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:267
  if(transmitting){
    378e:	20 91 7a 0c 	lds	r18, 0x0C7A	; 0x800c7a <TwoWire::transmitting>
    3792:	22 23       	and	r18, r18
    3794:	89 f0       	breq	.+34     	; 0x37b8 <TwoWire::write(unsigned char const*, unsigned int)+0x40>
    3796:	eb 01       	movw	r28, r22
    3798:	6b 01       	movw	r12, r22
    379a:	c4 0e       	add	r12, r20
    379c:	d5 1e       	adc	r13, r21
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:269
  // in master transmitter mode
    for(size_t i = 0; i < quantity; ++i){
    379e:	cc 15       	cp	r28, r12
    37a0:	dd 05       	cpc	r29, r13
    37a2:	69 f0       	breq	.+26     	; 0x37be <TwoWire::write(unsigned char const*, unsigned int)+0x46>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:270
      write(data[i]);
    37a4:	69 91       	ld	r22, Y+
    37a6:	d7 01       	movw	r26, r14
    37a8:	ed 91       	ld	r30, X+
    37aa:	fc 91       	ld	r31, X
    37ac:	01 90       	ld	r0, Z+
    37ae:	f0 81       	ld	r31, Z
    37b0:	e0 2d       	mov	r30, r0
    37b2:	c7 01       	movw	r24, r14
    37b4:	19 95       	eicall
    37b6:	f3 cf       	rjmp	.-26     	; 0x379e <TwoWire::write(unsigned char const*, unsigned int)+0x26>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:275
    }
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(data, quantity);
    37b8:	64 2f       	mov	r22, r20
    37ba:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <twi_transmit>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:278
  }
  return quantity;
}
    37be:	c8 01       	movw	r24, r16
    37c0:	df 91       	pop	r29
    37c2:	cf 91       	pop	r28
    37c4:	1f 91       	pop	r17
    37c6:	0f 91       	pop	r16
    37c8:	ff 90       	pop	r15
    37ca:	ef 90       	pop	r14
    37cc:	df 90       	pop	r13
    37ce:	cf 90       	pop	r12
    37d0:	08 95       	ret

000037d2 <TwoWire::write(unsigned char)>:
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:241

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
    37d2:	cf 93       	push	r28
    37d4:	df 93       	push	r29
    37d6:	1f 92       	push	r1
    37d8:	cd b7       	in	r28, 0x3d	; 61
    37da:	de b7       	in	r29, 0x3e	; 62
    37dc:	69 83       	std	Y+1, r22	; 0x01
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:242
  if(transmitting){
    37de:	20 91 7a 0c 	lds	r18, 0x0C7A	; 0x800c7a <TwoWire::transmitting>
    37e2:	22 23       	and	r18, r18
    37e4:	f9 f0       	breq	.+62     	; 0x3824 <TwoWire::write(unsigned char)+0x52>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:245
  // in master transmitter mode
    // don't bother if buffer is full
    if(txBufferLength >= BUFFER_LENGTH){
    37e6:	20 91 77 0c 	lds	r18, 0x0C77	; 0x800c77 <TwoWire::txBufferLength>
    37ea:	20 32       	cpi	r18, 0x20	; 32
    37ec:	58 f0       	brcs	.+22     	; 0x3804 <TwoWire::write(unsigned char)+0x32>
_ZN5Print13setWriteErrorEi():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:44
    37ee:	21 e0       	ldi	r18, 0x01	; 1
    37f0:	30 e0       	ldi	r19, 0x00	; 0
    37f2:	fc 01       	movw	r30, r24
    37f4:	33 83       	std	Z+3, r19	; 0x03
    37f6:	22 83       	std	Z+2, r18	; 0x02
write():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:247
      setWriteError();
      return 0;
    37f8:	90 e0       	ldi	r25, 0x00	; 0
    37fa:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:260
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
  }
  return 1;
}
    37fc:	0f 90       	pop	r0
    37fe:	df 91       	pop	r29
    3800:	cf 91       	pop	r28
    3802:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:250
    if(txBufferLength >= BUFFER_LENGTH){
      setWriteError();
      return 0;
    }
    // put byte in tx buffer
    txBuffer[txBufferIndex] = data;
    3804:	80 91 78 0c 	lds	r24, 0x0C78	; 0x800c78 <TwoWire::txBufferIndex>
    3808:	e8 2f       	mov	r30, r24
    380a:	f0 e0       	ldi	r31, 0x00	; 0
    380c:	ec 59       	subi	r30, 0x9C	; 156
    380e:	f6 4f       	sbci	r31, 0xF6	; 246
    3810:	99 81       	ldd	r25, Y+1	; 0x01
    3812:	90 83       	st	Z, r25
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:251
    ++txBufferIndex;
    3814:	8f 5f       	subi	r24, 0xFF	; 255
    3816:	80 93 78 0c 	sts	0x0C78, r24	; 0x800c78 <TwoWire::txBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:253
    // update amount in buffer   
    txBufferLength = txBufferIndex;
    381a:	80 93 77 0c 	sts	0x0C77, r24	; 0x800c77 <TwoWire::txBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:259
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
  }
  return 1;
    381e:	81 e0       	ldi	r24, 0x01	; 1
    3820:	90 e0       	ldi	r25, 0x00	; 0
    3822:	ec cf       	rjmp	.-40     	; 0x37fc <TwoWire::write(unsigned char)+0x2a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:257
    // update amount in buffer   
    txBufferLength = txBufferIndex;
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
    3824:	61 e0       	ldi	r22, 0x01	; 1
    3826:	ce 01       	movw	r24, r28
    3828:	01 96       	adiw	r24, 0x01	; 1
    382a:	0e 94 60 1a 	call	0x34c0	; 0x34c0 <twi_transmit>
    382e:	f7 cf       	rjmp	.-18     	; 0x381e <TwoWire::write(unsigned char)+0x4c>

00003830 <TwoWire::endTransmission()>:
endTransmission():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:233

//	This provides backwards compatibility with the original
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
    3830:	cf 92       	push	r12
    3832:	df 92       	push	r13
    3834:	ef 92       	push	r14
    3836:	ff 92       	push	r15
    3838:	0f 93       	push	r16
    383a:	1f 93       	push	r17
    383c:	cf 93       	push	r28
    383e:	df 93       	push	r29
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:220
//	devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
  // transmit buffer (blocking)
  uint8_t ret = twi_writeTo(txAddress, txBuffer, txBufferLength, 1, sendStop);
    3840:	d0 91 77 0c 	lds	r29, 0x0C77	; 0x800c77 <TwoWire::txBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:259
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < length){
    return 1;
    3844:	81 e0       	ldi	r24, 0x01	; 1
twi_writeTo():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:258
uint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_LENGTH < length){
    3846:	d1 32       	cpi	r29, 0x21	; 33
    3848:	08 f0       	brcs	.+2      	; 0x384c <TwoWire::endTransmission()+0x1c>
    384a:	9c c0       	rjmp	.+312    	; 0x3984 <TwoWire::endTransmission()+0x154>
endTransmission():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:220
    384c:	c0 91 79 0c 	lds	r28, 0x0C79	; 0x800c79 <TwoWire::txAddress>
twi_writeTo():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:263
    return 1;
  }

  // wait until twi is ready, become master transmitter
  uint32_t startMicros = micros();
    3850:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    3854:	6b 01       	movw	r12, r22
    3856:	7c 01       	movw	r14, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:264
  while(TWI_READY != twi_state){
    3858:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <twi_state>
    385c:	81 11       	cpse	r24, r1
    385e:	6c c0       	rjmp	.+216    	; 0x3938 <TwoWire::endTransmission()+0x108>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:270
    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {
      twi_handleTimeout(twi_do_reset_on_timeout);
      return (5);
    }
  }
  twi_state = TWI_MTX;
    3860:	82 e0       	ldi	r24, 0x02	; 2
    3862:	80 93 4f 0c 	sts	0x0C4F, r24	; 0x800c4f <twi_state>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:271
  twi_sendStop = sendStop;
    3866:	81 e0       	ldi	r24, 0x01	; 1
    3868:	80 93 4e 0c 	sts	0x0C4E, r24	; 0x800c4e <twi_sendStop>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:273
  // reset error state (0xFF.. no error occured)
  twi_error = 0xFF;
    386c:	8f ef       	ldi	r24, 0xFF	; 255
    386e:	80 93 4d 0c 	sts	0x0C4D, r24	; 0x800c4d <twi_error>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:276

  // initialize buffer iteration vars
  twi_masterBufferIndex = 0;
    3872:	10 92 4c 0c 	sts	0x0C4C, r1	; 0x800c4c <twi_masterBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:277
  twi_masterBufferLength = length;
    3876:	d0 93 4b 0c 	sts	0x0C4B, r29	; 0x800c4b <twi_masterBufferLength>
    387a:	a4 e6       	ldi	r26, 0x64	; 100
    387c:	b9 e0       	ldi	r27, 0x09	; 9
    387e:	e9 e2       	ldi	r30, 0x29	; 41
    3880:	fc e0       	ldi	r31, 0x0C	; 12
endTransmission():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:280
  
  // copy data to twi buffer
  for(i = 0; i < length; ++i){
    3882:	80 e0       	ldi	r24, 0x00	; 0
twi_writeTo():
    3884:	d8 13       	cpse	r29, r24
    3886:	8d c0       	rjmp	.+282    	; 0x39a2 <TwoWire::endTransmission()+0x172>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:285
    twi_masterBuffer[i] = data[i];
  }
  
  // build sla+w, slave device address + w bit
  twi_slarw = TW_WRITE;
    3888:	10 92 4a 0c 	sts	0x0C4A, r1	; 0x800c4a <twi_slarw>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:286
  twi_slarw |= address << 1;
    388c:	80 91 4a 0c 	lds	r24, 0x0C4A	; 0x800c4a <twi_slarw>
    3890:	cc 0f       	add	r28, r28
    3892:	c8 2b       	or	r28, r24
    3894:	c0 93 4a 0c 	sts	0x0C4A, r28	; 0x800c4a <twi_slarw>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:291
  
  // if we're in a repeated start, then we've already sent the START
  // in the ISR. Don't do it again.
  //
  if (true == twi_inRepStart) {
    3898:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <twi_inRepStart>
    389c:	81 30       	cpi	r24, 0x01	; 1
    389e:	09 f0       	breq	.+2      	; 0x38a2 <TwoWire::endTransmission()+0x72>
    38a0:	84 c0       	rjmp	.+264    	; 0x39aa <TwoWire::endTransmission()+0x17a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:298
    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
    // We need to remove ourselves from the repeated start state before we enable interrupts,
    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
    // up. Also, don't enable the START interrupt. There may be one pending from the 
    // repeated start that we sent outselves, and that would really confuse things.
    twi_inRepStart = false;			// remember, we're dealing with an ASYNC ISR
    38a2:	10 92 49 0c 	sts	0x0C49, r1	; 0x800c49 <twi_inRepStart>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:299
    startMicros = micros();
    38a6:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    38aa:	6b 01       	movw	r12, r22
    38ac:	7c 01       	movw	r14, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:301
    do {
      TWDR = twi_slarw;
    38ae:	80 91 4a 0c 	lds	r24, 0x0C4A	; 0x800c4a <twi_slarw>
    38b2:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:302
      if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {
    38b6:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <twi_timeout_us>
    38ba:	90 91 52 0c 	lds	r25, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    38be:	a0 91 53 0c 	lds	r26, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    38c2:	b0 91 54 0c 	lds	r27, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    38c6:	89 2b       	or	r24, r25
    38c8:	8a 2b       	or	r24, r26
    38ca:	8b 2b       	or	r24, r27
    38cc:	a1 f0       	breq	.+40     	; 0x38f6 <TwoWire::endTransmission()+0xc6>
    38ce:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    38d2:	00 91 51 0c 	lds	r16, 0x0C51	; 0x800c51 <twi_timeout_us>
    38d6:	10 91 52 0c 	lds	r17, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    38da:	20 91 53 0c 	lds	r18, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    38de:	30 91 54 0c 	lds	r19, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    38e2:	6c 19       	sub	r22, r12
    38e4:	7d 09       	sbc	r23, r13
    38e6:	8e 09       	sbc	r24, r14
    38e8:	9f 09       	sbc	r25, r15
    38ea:	06 17       	cp	r16, r22
    38ec:	17 07       	cpc	r17, r23
    38ee:	28 07       	cpc	r18, r24
    38f0:	39 07       	cpc	r19, r25
    38f2:	08 f4       	brcc	.+2      	; 0x38f6 <TwoWire::endTransmission()+0xc6>
    38f4:	42 c0       	rjmp	.+132    	; 0x397a <TwoWire::endTransmission()+0x14a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:306
        twi_handleTimeout(twi_do_reset_on_timeout);
        return (5);
      }
    } while(TWCR & _BV(TWWC));
    38f6:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    38fa:	83 fd       	sbrc	r24, 3
    38fc:	d8 cf       	rjmp	.-80     	; 0x38ae <TwoWire::endTransmission()+0x7e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:307
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
    38fe:	85 ec       	ldi	r24, 0xC5	; 197
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:310
  } else {
    // send start condition
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);	// enable INTs
    3900:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:314
  }

  // wait for write operation to complete
  startMicros = micros();
    3904:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    3908:	6b 01       	movw	r12, r22
    390a:	7c 01       	movw	r14, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:315
  while(wait && (TWI_MTX == twi_state)){
    390c:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <twi_state>
    3910:	82 30       	cpi	r24, 0x02	; 2
    3912:	09 f4       	brne	.+2      	; 0x3916 <TwoWire::endTransmission()+0xe6>
    3914:	4c c0       	rjmp	.+152    	; 0x39ae <TwoWire::endTransmission()+0x17e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:322
      twi_handleTimeout(twi_do_reset_on_timeout);
      return (5);
    }
  }
  
  if (twi_error == 0xFF)
    3916:	80 91 4d 0c 	lds	r24, 0x0C4D	; 0x800c4d <twi_error>
    391a:	8f 3f       	cpi	r24, 0xFF	; 255
    391c:	09 f4       	brne	.+2      	; 0x3920 <TwoWire::endTransmission()+0xf0>
    391e:	69 c0       	rjmp	.+210    	; 0x39f2 <TwoWire::endTransmission()+0x1c2>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:324
    return 0;	// success
  else if (twi_error == TW_MT_SLA_NACK)
    3920:	80 91 4d 0c 	lds	r24, 0x0C4D	; 0x800c4d <twi_error>
    3924:	80 32       	cpi	r24, 0x20	; 32
    3926:	09 f4       	brne	.+2      	; 0x392a <TwoWire::endTransmission()+0xfa>
    3928:	66 c0       	rjmp	.+204    	; 0x39f6 <TwoWire::endTransmission()+0x1c6>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:326
    return 2;	// error: address send, nack received
  else if (twi_error == TW_MT_DATA_NACK)
    392a:	80 91 4d 0c 	lds	r24, 0x0C4D	; 0x800c4d <twi_error>
    392e:	80 33       	cpi	r24, 0x30	; 48
    3930:	09 f4       	brne	.+2      	; 0x3934 <TwoWire::endTransmission()+0x104>
    3932:	63 c0       	rjmp	.+198    	; 0x39fa <TwoWire::endTransmission()+0x1ca>
endTransmission():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:329
    return 3;	// error: data send, nack received
  else
    return 4;	// other twi error
    3934:	84 e0       	ldi	r24, 0x04	; 4
    3936:	26 c0       	rjmp	.+76     	; 0x3984 <TwoWire::endTransmission()+0x154>
twi_writeTo():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:265
  }

  // wait until twi is ready, become master transmitter
  uint32_t startMicros = micros();
  while(TWI_READY != twi_state){
    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {
    3938:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <twi_timeout_us>
    393c:	90 91 52 0c 	lds	r25, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    3940:	a0 91 53 0c 	lds	r26, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    3944:	b0 91 54 0c 	lds	r27, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    3948:	89 2b       	or	r24, r25
    394a:	8a 2b       	or	r24, r26
    394c:	8b 2b       	or	r24, r27
    394e:	09 f4       	brne	.+2      	; 0x3952 <TwoWire::endTransmission()+0x122>
    3950:	83 cf       	rjmp	.-250    	; 0x3858 <TwoWire::endTransmission()+0x28>
    3952:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    3956:	00 91 51 0c 	lds	r16, 0x0C51	; 0x800c51 <twi_timeout_us>
    395a:	10 91 52 0c 	lds	r17, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    395e:	20 91 53 0c 	lds	r18, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    3962:	30 91 54 0c 	lds	r19, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    3966:	6c 19       	sub	r22, r12
    3968:	7d 09       	sbc	r23, r13
    396a:	8e 09       	sbc	r24, r14
    396c:	9f 09       	sbc	r25, r15
    396e:	06 17       	cp	r16, r22
    3970:	17 07       	cpc	r17, r23
    3972:	28 07       	cpc	r18, r24
    3974:	39 07       	cpc	r19, r25
    3976:	08 f0       	brcs	.+2      	; 0x397a <TwoWire::endTransmission()+0x14a>
    3978:	6f cf       	rjmp	.-290    	; 0x3858 <TwoWire::endTransmission()+0x28>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:317

  // wait for write operation to complete
  startMicros = micros();
  while(wait && (TWI_MTX == twi_state)){
    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {
      twi_handleTimeout(twi_do_reset_on_timeout);
    397a:	80 91 50 0c 	lds	r24, 0x0C50	; 0x800c50 <twi_do_reset_on_timeout>
    397e:	0e 94 bc 1a 	call	0x3578	; 0x3578 <twi_handleTimeout>
endTransmission():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:318
      return (5);
    3982:	85 e0       	ldi	r24, 0x05	; 5
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:222
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    3984:	10 92 78 0c 	sts	0x0C78, r1	; 0x800c78 <TwoWire::txBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:223
  txBufferLength = 0;
    3988:	10 92 77 0c 	sts	0x0C77, r1	; 0x800c77 <TwoWire::txBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:225
  // indicate that we are done transmitting
  transmitting = 0;
    398c:	10 92 7a 0c 	sts	0x0C7A, r1	; 0x800c7a <TwoWire::transmitting>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:235
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
  return endTransmission(true);
}
    3990:	df 91       	pop	r29
    3992:	cf 91       	pop	r28
    3994:	1f 91       	pop	r17
    3996:	0f 91       	pop	r16
    3998:	ff 90       	pop	r15
    399a:	ef 90       	pop	r14
    399c:	df 90       	pop	r13
    399e:	cf 90       	pop	r12
    39a0:	08 95       	ret
twi_writeTo():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:281
  twi_masterBufferIndex = 0;
  twi_masterBufferLength = length;
  
  // copy data to twi buffer
  for(i = 0; i < length; ++i){
    twi_masterBuffer[i] = data[i];
    39a2:	9d 91       	ld	r25, X+
    39a4:	91 93       	st	Z+, r25
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:280
  // initialize buffer iteration vars
  twi_masterBufferIndex = 0;
  twi_masterBufferLength = length;
  
  // copy data to twi buffer
  for(i = 0; i < length; ++i){
    39a6:	8f 5f       	subi	r24, 0xFF	; 255
    39a8:	6d cf       	rjmp	.-294    	; 0x3884 <TwoWire::endTransmission()+0x54>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:310
      }
    } while(TWCR & _BV(TWWC));
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);	// enable INTs, but not START
  } else {
    // send start condition
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA);	// enable INTs
    39aa:	85 ee       	ldi	r24, 0xE5	; 229
    39ac:	a9 cf       	rjmp	.-174    	; 0x3900 <TwoWire::endTransmission()+0xd0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:316
  }

  // wait for write operation to complete
  startMicros = micros();
  while(wait && (TWI_MTX == twi_state)){
    if((twi_timeout_us > 0ul) && ((micros() - startMicros) > twi_timeout_us)) {
    39ae:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <twi_timeout_us>
    39b2:	90 91 52 0c 	lds	r25, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    39b6:	a0 91 53 0c 	lds	r26, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    39ba:	b0 91 54 0c 	lds	r27, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    39be:	89 2b       	or	r24, r25
    39c0:	8a 2b       	or	r24, r26
    39c2:	8b 2b       	or	r24, r27
    39c4:	09 f4       	brne	.+2      	; 0x39c8 <TwoWire::endTransmission()+0x198>
    39c6:	a2 cf       	rjmp	.-188    	; 0x390c <TwoWire::endTransmission()+0xdc>
    39c8:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <micros>
    39cc:	00 91 51 0c 	lds	r16, 0x0C51	; 0x800c51 <twi_timeout_us>
    39d0:	10 91 52 0c 	lds	r17, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    39d4:	20 91 53 0c 	lds	r18, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    39d8:	30 91 54 0c 	lds	r19, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    39dc:	6c 19       	sub	r22, r12
    39de:	7d 09       	sbc	r23, r13
    39e0:	8e 09       	sbc	r24, r14
    39e2:	9f 09       	sbc	r25, r15
    39e4:	06 17       	cp	r16, r22
    39e6:	17 07       	cpc	r17, r23
    39e8:	28 07       	cpc	r18, r24
    39ea:	39 07       	cpc	r19, r25
    39ec:	08 f0       	brcs	.+2      	; 0x39f0 <TwoWire::endTransmission()+0x1c0>
    39ee:	8e cf       	rjmp	.-228    	; 0x390c <TwoWire::endTransmission()+0xdc>
    39f0:	c4 cf       	rjmp	.-120    	; 0x397a <TwoWire::endTransmission()+0x14a>
endTransmission():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:323
      return (5);
    }
  }
  
  if (twi_error == 0xFF)
    return 0;	// success
    39f2:	80 e0       	ldi	r24, 0x00	; 0
    39f4:	c7 cf       	rjmp	.-114    	; 0x3984 <TwoWire::endTransmission()+0x154>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:325
  else if (twi_error == TW_MT_SLA_NACK)
    return 2;	// error: address send, nack received
    39f6:	82 e0       	ldi	r24, 0x02	; 2
    39f8:	c5 cf       	rjmp	.-118    	; 0x3984 <TwoWire::endTransmission()+0x154>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:327
  else if (twi_error == TW_MT_DATA_NACK)
    return 3;	// error: data send, nack received
    39fa:	83 e0       	ldi	r24, 0x03	; 3
    39fc:	c3 cf       	rjmp	.-122    	; 0x3984 <TwoWire::endTransmission()+0x154>

000039fe <Adafruit_BME280::write8(unsigned char, unsigned char) [clone .constprop.82]>:
write8():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:206
/*!
 *   @brief  Writes an 8 bit value over I2C or SPI
 *   @param reg the register address to write to
 *   @param value the value to write to the register
 */
void Adafruit_BME280::write8(byte reg, byte value) {
    39fe:	cf 93       	push	r28
    3a00:	df 93       	push	r29
    3a02:	d8 2f       	mov	r29, r24
    3a04:	c6 2f       	mov	r28, r22
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:207
  if (_cs == -1) {
    3a06:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    3a0a:	8f 3f       	cpi	r24, 0xFF	; 255
    3a0c:	21 f5       	brne	.+72     	; 0x3a56 <Adafruit_BME280::write8(unsigned char, unsigned char) [clone .constprop.82]+0x58>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:208
    _wire->beginTransmission((uint8_t)_i2caddr);
    3a0e:	80 91 d1 10 	lds	r24, 0x10D1	; 0x8010d1 <bme280+0xa>
    3a12:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:209
    _wire->write((uint8_t)reg);
    3a16:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    3a1a:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    3a1e:	dc 01       	movw	r26, r24
    3a20:	ed 91       	ld	r30, X+
    3a22:	fc 91       	ld	r31, X
    3a24:	01 90       	ld	r0, Z+
    3a26:	f0 81       	ld	r31, Z
    3a28:	e0 2d       	mov	r30, r0
    3a2a:	6d 2f       	mov	r22, r29
    3a2c:	19 95       	eicall
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:210
    _wire->write((uint8_t)value);
    3a2e:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    3a32:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    3a36:	dc 01       	movw	r26, r24
    3a38:	ed 91       	ld	r30, X+
    3a3a:	fc 91       	ld	r31, X
    3a3c:	01 90       	ld	r0, Z+
    3a3e:	f0 81       	ld	r31, Z
    3a40:	e0 2d       	mov	r30, r0
    3a42:	6c 2f       	mov	r22, r28
    3a44:	19 95       	eicall
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:211
    _wire->endTransmission();
    3a46:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    3a4a:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:222
    spixfer(value);
    digitalWrite(_cs, HIGH);
    if (_sck == -1)
      _spi->endTransaction(); // release the SPI bus
  }
}
    3a4e:	df 91       	pop	r29
    3a50:	cf 91       	pop	r28
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:211
void Adafruit_BME280::write8(byte reg, byte value) {
  if (_cs == -1) {
    _wire->beginTransmission((uint8_t)_i2caddr);
    _wire->write((uint8_t)reg);
    _wire->write((uint8_t)value);
    _wire->endTransmission();
    3a52:	0c 94 18 1c 	jmp	0x3830	; 0x3830 <TwoWire::endTransmission()>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:213
  } else {
    if (_sck == -1)
    3a56:	80 91 dd 10 	lds	r24, 0x10DD	; 0x8010dd <bme280+0x16>
    3a5a:	8f 3f       	cpi	r24, 0xFF	; 255
    3a5c:	21 f4       	brne	.+8      	; 0x3a66 <Adafruit_BME280::write8(unsigned char, unsigned char) [clone .constprop.82]+0x68>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:214
      _spi->beginTransaction(SPISettings(500000, MSBFIRST, SPI_MODE0));
    3a5e:	82 e5       	ldi	r24, 0x52	; 82
    3a60:	91 e0       	ldi	r25, 0x01	; 1
    3a62:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <SPIClass::beginTransaction(SPISettings)>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:215
    digitalWrite(_cs, LOW);
    3a66:	60 e0       	ldi	r22, 0x00	; 0
    3a68:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    3a6c:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:216
    spixfer(reg & ~0x80); // write, bit 7 low
    3a70:	8d 2f       	mov	r24, r29
    3a72:	8f 77       	andi	r24, 0x7F	; 127
    3a74:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:217
    spixfer(value);
    3a78:	8c 2f       	mov	r24, r28
    3a7a:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:218
    digitalWrite(_cs, HIGH);
    3a7e:	61 e0       	ldi	r22, 0x01	; 1
    3a80:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:222
    if (_sck == -1)
      _spi->endTransaction(); // release the SPI bus
  }
}
    3a84:	df 91       	pop	r29
    3a86:	cf 91       	pop	r28
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:218
    if (_sck == -1)
      _spi->beginTransaction(SPISettings(500000, MSBFIRST, SPI_MODE0));
    digitalWrite(_cs, LOW);
    spixfer(reg & ~0x80); // write, bit 7 low
    spixfer(value);
    digitalWrite(_cs, HIGH);
    3a88:	0c 94 3f 08 	jmp	0x107e	; 0x107e <digitalWrite>

00003a8c <LiquidCrystal_I2C::expanderWrite(unsigned char)>:
expanderWrite():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:252
void LiquidCrystal_I2C::write4bits(uint8_t value) {
	expanderWrite(value);
	pulseEnable(value);
}

void LiquidCrystal_I2C::expanderWrite(uint8_t _data){                                        
    3a8c:	0f 93       	push	r16
    3a8e:	1f 93       	push	r17
    3a90:	cf 93       	push	r28
    3a92:	8c 01       	movw	r16, r24
    3a94:	c6 2f       	mov	r28, r22
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:253
	Wire.beginTransmission(_Addr);
    3a96:	fc 01       	movw	r30, r24
    3a98:	84 81       	ldd	r24, Z+4	; 0x04
    3a9a:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:254
	printIIC((int)(_data) | _backlightval);
    3a9e:	f8 01       	movw	r30, r16
    3aa0:	63 85       	ldd	r22, Z+11	; 0x0b
    3aa2:	6c 2b       	or	r22, r28
write():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.h:82
    void onRequest( void (*)(void) );

    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
    3aa4:	8c e3       	ldi	r24, 0x3C	; 60
    3aa6:	9f e0       	ldi	r25, 0x0F	; 15
    3aa8:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
expanderWrite():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:255
	Wire.endTransmission();   
    3aac:	8c e3       	ldi	r24, 0x3C	; 60
    3aae:	9f e0       	ldi	r25, 0x0F	; 15
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:256
}
    3ab0:	cf 91       	pop	r28
    3ab2:	1f 91       	pop	r17
    3ab4:	0f 91       	pop	r16
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:255
}

void LiquidCrystal_I2C::expanderWrite(uint8_t _data){                                        
	Wire.beginTransmission(_Addr);
	printIIC((int)(_data) | _backlightval);
	Wire.endTransmission();   
    3ab6:	0c 94 18 1c 	jmp	0x3830	; 0x3830 <TwoWire::endTransmission()>

00003aba <Print::availableForWrite()>:
availableForWrite():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:63
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
    3aba:	90 e0       	ldi	r25, 0x00	; 0
    3abc:	80 e0       	ldi	r24, 0x00	; 0
    3abe:	08 95       	ret

00003ac0 <BlinkControl::resume()>:
resume():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:189
  this->_prevState = this->_state;
  this->_state = BC_STATE_OFF;
  this->_lastAction = 0;
}

void BlinkControl::resume() {
    3ac0:	fc 01       	movw	r30, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:190
  if (this->_prevState != BC_STATE_BLINK && this->_prevState != BC_STATE_BREATHE && this->_prevState != BC_STATE_PULSE) {
    3ac2:	82 81       	ldd	r24, Z+2	; 0x02
    3ac4:	93 81       	ldd	r25, Z+3	; 0x03
    3ac6:	9c 01       	movw	r18, r24
    3ac8:	22 50       	subi	r18, 0x02	; 2
    3aca:	31 09       	sbc	r19, r1
    3acc:	23 30       	cpi	r18, 0x03	; 3
    3ace:	31 05       	cpc	r19, r1
    3ad0:	60 f4       	brcc	.+24     	; 0x3aea <BlinkControl::resume()+0x2a>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:200
  #if defined(ESP32)
  if (this->_prevState == BC_STATE_BREATHE || this->_prevState == BC_STATE_PULSE) {
    this->_pwmAttachPin();
  }
  #endif
  if (this->_prevState == BC_STATE_BREATHE) {
    3ad2:	83 30       	cpi	r24, 0x03	; 3
    3ad4:	91 05       	cpc	r25, r1
    3ad6:	51 f4       	brne	.+20     	; 0x3aec <BlinkControl::resume()+0x2c>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:201
    this->_dutyCycle = 0;
    3ad8:	df 01       	movw	r26, r30
    3ada:	ab 5b       	subi	r26, 0xBB	; 187
    3adc:	bf 4f       	sbci	r27, 0xFF	; 255
    3ade:	1d 92       	st	X+, r1
    3ae0:	1c 92       	st	X, r1
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:206
  } else if (this->_prevState == BC_STATE_PULSE) {
    this->_dutyCycle = this->_brightStepMax;
  }
  
  this->_state = this->_prevState;
    3ae2:	91 83       	std	Z+1, r25	; 0x01
    3ae4:	80 83       	st	Z, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:207
  this->_prevState = BC_STATE_OFF;
    3ae6:	13 82       	std	Z+3, r1	; 0x03
    3ae8:	12 82       	std	Z+2, r1	; 0x02
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:208
}
    3aea:	08 95       	ret
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:202
    this->_pwmAttachPin();
  }
  #endif
  if (this->_prevState == BC_STATE_BREATHE) {
    this->_dutyCycle = 0;
  } else if (this->_prevState == BC_STATE_PULSE) {
    3aec:	84 30       	cpi	r24, 0x04	; 4
    3aee:	91 05       	cpc	r25, r1
    3af0:	c1 f7       	brne	.-16     	; 0x3ae2 <BlinkControl::resume()+0x22>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:203
    this->_dutyCycle = this->_brightStepMax;
    3af2:	df 01       	movw	r26, r30
    3af4:	a9 5b       	subi	r26, 0xB9	; 185
    3af6:	bf 4f       	sbci	r27, 0xFF	; 255
    3af8:	2d 91       	ld	r18, X+
    3afa:	3c 91       	ld	r19, X
    3afc:	11 97       	sbiw	r26, 0x01	; 1
    3afe:	12 97       	sbiw	r26, 0x02	; 2
    3b00:	2d 93       	st	X+, r18
    3b02:	3c 93       	st	X, r19
    3b04:	ee cf       	rjmp	.-36     	; 0x3ae2 <BlinkControl::resume()+0x22>

00003b06 <TinyGPSDecimal::commit()>:
commit():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:437
   updated = false;
   return time % 100;
}

void TinyGPSDecimal::commit()
{
    3b06:	cf 93       	push	r28
    3b08:	df 93       	push	r29
    3b0a:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:438
   val = newval;
    3b0c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b0e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3b10:	ac 85       	ldd	r26, Y+12	; 0x0c
    3b12:	bd 85       	ldd	r27, Y+13	; 0x0d
    3b14:	8e 83       	std	Y+6, r24	; 0x06
    3b16:	9f 83       	std	Y+7, r25	; 0x07
    3b18:	a8 87       	std	Y+8, r26	; 0x08
    3b1a:	b9 87       	std	Y+9, r27	; 0x09
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:439
   lastCommitTime = millis();
    3b1c:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    3b20:	6a 83       	std	Y+2, r22	; 0x02
    3b22:	7b 83       	std	Y+3, r23	; 0x03
    3b24:	8c 83       	std	Y+4, r24	; 0x04
    3b26:	9d 83       	std	Y+5, r25	; 0x05
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:440
   valid = updated = true;
    3b28:	81 e0       	ldi	r24, 0x01	; 1
    3b2a:	89 83       	std	Y+1, r24	; 0x01
    3b2c:	88 83       	st	Y, r24
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:441
}
    3b2e:	df 91       	pop	r29
    3b30:	cf 91       	pop	r28
    3b32:	08 95       	ret

00003b34 <TinyGPSDate::commit()>:
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:370
   double ret = rawLngData.deg + rawLngData.billionths / 1000000000.0;
   return rawLngData.negative ? -ret : ret;
}

void TinyGPSDate::commit()
{
    3b34:	cf 93       	push	r28
    3b36:	df 93       	push	r29
    3b38:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:371
   date = newDate;
    3b3a:	8e 81       	ldd	r24, Y+6	; 0x06
    3b3c:	9f 81       	ldd	r25, Y+7	; 0x07
    3b3e:	a8 85       	ldd	r26, Y+8	; 0x08
    3b40:	b9 85       	ldd	r27, Y+9	; 0x09
    3b42:	8a 83       	std	Y+2, r24	; 0x02
    3b44:	9b 83       	std	Y+3, r25	; 0x03
    3b46:	ac 83       	std	Y+4, r26	; 0x04
    3b48:	bd 83       	std	Y+5, r27	; 0x05
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:372
   lastCommitTime = millis();
    3b4a:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    3b4e:	6a 87       	std	Y+10, r22	; 0x0a
    3b50:	7b 87       	std	Y+11, r23	; 0x0b
    3b52:	8c 87       	std	Y+12, r24	; 0x0c
    3b54:	9d 87       	std	Y+13, r25	; 0x0d
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:373
   valid = updated = true;
    3b56:	81 e0       	ldi	r24, 0x01	; 1
    3b58:	89 83       	std	Y+1, r24	; 0x01
    3b5a:	88 83       	st	Y, r24
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:374
}
    3b5c:	df 91       	pop	r29
    3b5e:	cf 91       	pop	r28
    3b60:	08 95       	ret

00003b62 <waring()>:
waring():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/tone_function.ino:6
void notice() {
	tone(buzzerpin, 50, 100);
}

void waring() {
	tone(buzzerpin, 50, 1000);
    3b62:	48 ee       	ldi	r20, 0xE8	; 232
    3b64:	53 e0       	ldi	r21, 0x03	; 3
    3b66:	60 e0       	ldi	r22, 0x00	; 0
    3b68:	70 e0       	ldi	r23, 0x00	; 0
    3b6a:	82 e3       	ldi	r24, 0x32	; 50
    3b6c:	90 e0       	ldi	r25, 0x00	; 0
    3b6e:	0c 94 44 09 	jmp	0x1288	; 0x1288 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]>

00003b72 <pumpControl(int)>:
pumpControl():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:1
void pumpControl(int freq) {
    3b72:	9c 01       	movw	r18, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:3
	int pwm = 0;
	if (freq != 0) {
    3b74:	89 2b       	or	r24, r25
    3b76:	b1 f0       	breq	.+44     	; 0x3ba4 <pumpControl(int)+0x32>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:4
		pwm = map(freq,1,100,70,255);
    3b78:	03 2e       	mov	r0, r19
    3b7a:	00 0c       	add	r0, r0
    3b7c:	44 0b       	sbc	r20, r20
    3b7e:	55 0b       	sbc	r21, r21
map():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WMath.cpp:54
  return random(diff) + howsmall;
}

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    3b80:	21 50       	subi	r18, 0x01	; 1
    3b82:	31 09       	sbc	r19, r1
    3b84:	41 09       	sbc	r20, r1
    3b86:	51 09       	sbc	r21, r1
    3b88:	a9 eb       	ldi	r26, 0xB9	; 185
    3b8a:	b0 e0       	ldi	r27, 0x00	; 0
    3b8c:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
    3b90:	23 e6       	ldi	r18, 0x63	; 99
    3b92:	30 e0       	ldi	r19, 0x00	; 0
    3b94:	40 e0       	ldi	r20, 0x00	; 0
    3b96:	50 e0       	ldi	r21, 0x00	; 0
    3b98:	0e 94 11 6a 	call	0xd422	; 0xd422 <__divmodsi4>
    3b9c:	2a 5b       	subi	r18, 0xBA	; 186
    3b9e:	3f 4f       	sbci	r19, 0xFF	; 255
    3ba0:	4f 4f       	sbci	r20, 0xFF	; 255
    3ba2:	5f 4f       	sbci	r21, 0xFF	; 255
pumpControl():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:7
	}
	if (freq == 0) pwm = 0;
	analogWrite(pump_pin, pwm);
    3ba4:	b9 01       	movw	r22, r18
    3ba6:	86 e0       	ldi	r24, 0x06	; 6
    3ba8:	0c 94 38 0c 	jmp	0x1870	; 0x1870 <analogWrite>

00003bac <VoltageInPercent()>:
VoltageInPercent():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:22
	voltage = GetBatteryVoltage();
	if (VoltageInPercent() > 20)	battery.off();
	if (VoltageInPercent() <= 10)	battery.resume();
}

int VoltageInPercent() {
    3bac:	8f 92       	push	r8
    3bae:	9f 92       	push	r9
    3bb0:	af 92       	push	r10
    3bb2:	bf 92       	push	r11
    3bb4:	cf 92       	push	r12
    3bb6:	df 92       	push	r13
    3bb8:	ef 92       	push	r14
    3bba:	ff 92       	push	r15
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:23
	int value = (voltage - V_min) / (V_max - V_min) * 100;
    3bbc:	c0 90 1c 09 	lds	r12, 0x091C	; 0x80091c <V_min>
    3bc0:	d0 90 1d 09 	lds	r13, 0x091D	; 0x80091d <V_min+0x1>
    3bc4:	e0 90 1e 09 	lds	r14, 0x091E	; 0x80091e <V_min+0x2>
    3bc8:	f0 90 1f 09 	lds	r15, 0x091F	; 0x80091f <V_min+0x3>
    3bcc:	a7 01       	movw	r20, r14
    3bce:	96 01       	movw	r18, r12
    3bd0:	60 91 26 09 	lds	r22, 0x0926	; 0x800926 <voltage>
    3bd4:	70 91 27 09 	lds	r23, 0x0927	; 0x800927 <voltage+0x1>
    3bd8:	80 91 28 09 	lds	r24, 0x0928	; 0x800928 <voltage+0x2>
    3bdc:	90 91 29 09 	lds	r25, 0x0929	; 0x800929 <voltage+0x3>
    3be0:	0e 94 74 6a 	call	0xd4e8	; 0xd4e8 <__subsf3>
    3be4:	4b 01       	movw	r8, r22
    3be6:	5c 01       	movw	r10, r24
    3be8:	a7 01       	movw	r20, r14
    3bea:	96 01       	movw	r18, r12
    3bec:	60 91 18 09 	lds	r22, 0x0918	; 0x800918 <__data_end>
    3bf0:	70 91 19 09 	lds	r23, 0x0919	; 0x800919 <__data_end+0x1>
    3bf4:	80 91 1a 09 	lds	r24, 0x091A	; 0x80091a <__data_end+0x2>
    3bf8:	90 91 1b 09 	lds	r25, 0x091B	; 0x80091b <__data_end+0x3>
    3bfc:	0e 94 74 6a 	call	0xd4e8	; 0xd4e8 <__subsf3>
    3c00:	9b 01       	movw	r18, r22
    3c02:	ac 01       	movw	r20, r24
    3c04:	c5 01       	movw	r24, r10
    3c06:	b4 01       	movw	r22, r8
    3c08:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
    3c0c:	20 e0       	ldi	r18, 0x00	; 0
    3c0e:	30 e0       	ldi	r19, 0x00	; 0
    3c10:	48 ec       	ldi	r20, 0xC8	; 200
    3c12:	52 e4       	ldi	r21, 0x42	; 66
    3c14:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
    3c18:	0e 94 53 6b 	call	0xd6a6	; 0xd6a6 <__fixsfsi>
    3c1c:	77 ff       	sbrs	r23, 7
    3c1e:	02 c0       	rjmp	.+4      	; 0x3c24 <VoltageInPercent()+0x78>
    3c20:	70 e0       	ldi	r23, 0x00	; 0
    3c22:	60 e0       	ldi	r22, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:26
	if (value > 100) value = 100;
	if (value < 0)	value = 0;
	return value;
    3c24:	cb 01       	movw	r24, r22
    3c26:	65 36       	cpi	r22, 0x65	; 101
    3c28:	71 05       	cpc	r23, r1
    3c2a:	14 f0       	brlt	.+4      	; 0x3c30 <VoltageInPercent()+0x84>
    3c2c:	84 e6       	ldi	r24, 0x64	; 100
    3c2e:	90 e0       	ldi	r25, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:27
    3c30:	ff 90       	pop	r15
    3c32:	ef 90       	pop	r14
    3c34:	df 90       	pop	r13
    3c36:	cf 90       	pop	r12
    3c38:	bf 90       	pop	r11
    3c3a:	af 90       	pop	r10
    3c3c:	9f 90       	pop	r9
    3c3e:	8f 90       	pop	r8
    3c40:	08 95       	ret

00003c42 <flush_pH_serial()>:
flush_pH_serial():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:69
	if (!isDigit(data[0]))	return;
	pH = data.toFloat();
}

void flush_pH_serial() {
  while (Atlas_pH.available() > 0)
    3c42:	8b e7       	ldi	r24, 0x7B	; 123
    3c44:	9c e0       	ldi	r25, 0x0C	; 12
    3c46:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <HardwareSerial::available()>
    3c4a:	18 16       	cp	r1, r24
    3c4c:	19 06       	cpc	r1, r25
    3c4e:	2c f4       	brge	.+10     	; 0x3c5a <flush_pH_serial()+0x18>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:71
  {
    Atlas_pH.read();
    3c50:	8b e7       	ldi	r24, 0x7B	; 123
    3c52:	9c e0       	ldi	r25, 0x0C	; 12
    3c54:	0e 94 ca 06 	call	0xd94	; 0xd94 <HardwareSerial::read()>
    3c58:	f4 cf       	rjmp	.-24     	; 0x3c42 <flush_pH_serial()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:74
    //delay(1);
  }
}
    3c5a:	08 95       	ret

00003c5c <flush_EC_serial()>:
flush_EC_serial():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:55
}



void flush_EC_serial() {
  while (Atlas_EC.available() > 0) {
    3c5c:	88 e1       	ldi	r24, 0x18	; 24
    3c5e:	9d e0       	ldi	r25, 0x0D	; 13
    3c60:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <HardwareSerial::available()>
    3c64:	18 16       	cp	r1, r24
    3c66:	19 06       	cpc	r1, r25
    3c68:	2c f4       	brge	.+10     	; 0x3c74 <flush_EC_serial()+0x18>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:56
    Atlas_EC.read();
    3c6a:	88 e1       	ldi	r24, 0x18	; 24
    3c6c:	9d e0       	ldi	r25, 0x0D	; 13
    3c6e:	0e 94 ca 06 	call	0xd94	; 0xd94 <HardwareSerial::read()>
    3c72:	f4 cf       	rjmp	.-24     	; 0x3c5c <flush_EC_serial()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:58
  }
}
    3c74:	08 95       	ret

00003c76 <SdFile::openCachedEntry(unsigned char, unsigned char)>:
openCachedEntry():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:599
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
    3c76:	cf 92       	push	r12
    3c78:	df 92       	push	r13
    3c7a:	ef 92       	push	r14
    3c7c:	ff 92       	push	r15
    3c7e:	1f 93       	push	r17
    3c80:	cf 93       	push	r28
    3c82:	df 93       	push	r29
    3c84:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:601
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;
    3c86:	80 e2       	ldi	r24, 0x20	; 32
    3c88:	68 9f       	mul	r22, r24
    3c8a:	f0 01       	movw	r30, r0
    3c8c:	11 24       	eor	r1, r1
    3c8e:	e5 50       	subi	r30, 0x05	; 5
    3c90:	f6 4f       	sbci	r31, 0xF6	; 246
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:604

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
    3c92:	93 85       	ldd	r25, Z+11	; 0x0b
    3c94:	91 71       	andi	r25, 0x11	; 17
    3c96:	61 f0       	breq	.+24     	; 0x3cb0 <SdFile::openCachedEntry(unsigned char, unsigned char)+0x3a>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:605
    if (oflag & (O_WRITE | O_TRUNC)) {
    3c98:	84 2f       	mov	r24, r20
    3c9a:	82 74       	andi	r24, 0x42	; 66
    3c9c:	49 f0       	breq	.+18     	; 0x3cb0 <SdFile::openCachedEntry(unsigned char, unsigned char)+0x3a>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:606
      return false;
    3c9e:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:641
  // truncate file to zero length if requested
  if (oflag & O_TRUNC) {
    return truncate(0);
  }
  return true;
}
    3ca0:	df 91       	pop	r29
    3ca2:	cf 91       	pop	r28
    3ca4:	1f 91       	pop	r17
    3ca6:	ff 90       	pop	r15
    3ca8:	ef 90       	pop	r14
    3caa:	df 90       	pop	r13
    3cac:	cf 90       	pop	r12
    3cae:	08 95       	ret
    3cb0:	14 2f       	mov	r17, r20
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:610
    if (oflag & (O_WRITE | O_TRUNC)) {
      return false;
    }
  }
  // remember location of directory entry on SD
  dirIndex_ = dirIndex;
    3cb2:	6a 8b       	std	Y+18, r22	; 0x12
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:611
  dirBlock_ = SdVolume::cacheBlockNumber_;
    3cb4:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <SdVolume::cacheBlockNumber_>
    3cb8:	90 91 15 02 	lds	r25, 0x0215	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    3cbc:	a0 91 16 02 	lds	r26, 0x0216	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    3cc0:	b0 91 17 02 	lds	r27, 0x0217	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
    3cc4:	8e 87       	std	Y+14, r24	; 0x0e
    3cc6:	9f 87       	std	Y+15, r25	; 0x0f
    3cc8:	a8 8b       	std	Y+16, r26	; 0x10
    3cca:	b9 8b       	std	Y+17, r27	; 0x11
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:614

  // copy first cluster number for directory fields
  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
    3ccc:	c4 88       	ldd	r12, Z+20	; 0x14
    3cce:	d5 88       	ldd	r13, Z+21	; 0x15
    3cd0:	f1 2c       	mov	r15, r1
    3cd2:	e1 2c       	mov	r14, r1
    3cd4:	76 01       	movw	r14, r12
    3cd6:	dd 24       	eor	r13, r13
    3cd8:	cc 24       	eor	r12, r12
    3cda:	cf 8a       	std	Y+23, r12	; 0x17
    3cdc:	d8 8e       	std	Y+24, r13	; 0x18
    3cde:	e9 8e       	std	Y+25, r14	; 0x19
    3ce0:	fa 8e       	std	Y+26, r15	; 0x1a
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:615
  firstCluster_ |= p->firstClusterLow;
    3ce2:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ce4:	93 8d       	ldd	r25, Z+27	; 0x1b
    3ce6:	b0 e0       	ldi	r27, 0x00	; 0
    3ce8:	a0 e0       	ldi	r26, 0x00	; 0
    3cea:	ac 01       	movw	r20, r24
    3cec:	bd 01       	movw	r22, r26
    3cee:	4c 29       	or	r20, r12
    3cf0:	5d 29       	or	r21, r13
    3cf2:	6e 29       	or	r22, r14
    3cf4:	7f 29       	or	r23, r15
    3cf6:	4f 8b       	std	Y+23, r20	; 0x17
    3cf8:	58 8f       	std	Y+24, r21	; 0x18
    3cfa:	69 8f       	std	Y+25, r22	; 0x19
    3cfc:	7a 8f       	std	Y+26, r23	; 0x1a
    3cfe:	83 85       	ldd	r24, Z+11	; 0x0b
    3d00:	88 71       	andi	r24, 0x18	; 24
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:618

  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
    3d02:	b1 f4       	brne	.+44     	; 0x3d30 <SdFile::openCachedEntry(unsigned char, unsigned char)+0xba>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:619
    fileSize_ = p->fileSize;
    3d04:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d06:	95 8d       	ldd	r25, Z+29	; 0x1d
    3d08:	a6 8d       	ldd	r26, Z+30	; 0x1e
    3d0a:	b7 8d       	ldd	r27, Z+31	; 0x1f
    3d0c:	8b 8b       	std	Y+19, r24	; 0x13
    3d0e:	9c 8b       	std	Y+20, r25	; 0x14
    3d10:	ad 8b       	std	Y+21, r26	; 0x15
    3d12:	be 8b       	std	Y+22, r27	; 0x16
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:620
    type_ = FAT_FILE_TYPE_NORMAL;
    3d14:	81 e0       	ldi	r24, 0x01	; 1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:625
  } else if (DIR_IS_SUBDIR(p)) {
    if (!vol_->chainSize(firstCluster_, &fileSize_)) {
      return false;
    }
    type_ = FAT_FILE_TYPE_SUBDIR;
    3d16:	8d 83       	std	Y+5, r24	; 0x05
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:630
  } else {
    return false;
  }
  // save open flags for read/write
  flags_ = oflag & (O_ACCMODE | O_SYNC | O_APPEND);
    3d18:	1f 70       	andi	r17, 0x0F	; 15
    3d1a:	1c 83       	std	Y+4, r17	; 0x04
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:633

  // set to start of file
  curCluster_ = 0;
    3d1c:	1e 82       	std	Y+6, r1	; 0x06
    3d1e:	1f 82       	std	Y+7, r1	; 0x07
    3d20:	18 86       	std	Y+8, r1	; 0x08
    3d22:	19 86       	std	Y+9, r1	; 0x09
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:634
  curPosition_ = 0;
    3d24:	1a 86       	std	Y+10, r1	; 0x0a
    3d26:	1b 86       	std	Y+11, r1	; 0x0b
    3d28:	1c 86       	std	Y+12, r1	; 0x0c
    3d2a:	1d 86       	std	Y+13, r1	; 0x0d
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:640

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) {
    return truncate(0);
  }
  return true;
    3d2c:	81 e0       	ldi	r24, 0x01	; 1
    3d2e:	b8 cf       	rjmp	.-144    	; 0x3ca0 <SdFile::openCachedEntry(unsigned char, unsigned char)+0x2a>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:621

  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
    fileSize_ = p->fileSize;
    type_ = FAT_FILE_TYPE_NORMAL;
  } else if (DIR_IS_SUBDIR(p)) {
    3d30:	80 31       	cpi	r24, 0x10	; 16
    3d32:	09 f0       	breq	.+2      	; 0x3d36 <SdFile::openCachedEntry(unsigned char, unsigned char)+0xc0>
    3d34:	b4 cf       	rjmp	.-152    	; 0x3c9e <SdFile::openCachedEntry(unsigned char, unsigned char)+0x28>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:622
    if (!vol_->chainSize(firstCluster_, &fileSize_)) {
    3d36:	9e 01       	movw	r18, r28
    3d38:	2d 5e       	subi	r18, 0xED	; 237
    3d3a:	3f 4f       	sbci	r19, 0xFF	; 255
    3d3c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3d3e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3d40:	0e 94 a7 13 	call	0x274e	; 0x274e <SdVolume::chainSize(unsigned long, unsigned long*) const>
    3d44:	88 23       	and	r24, r24
    3d46:	09 f4       	brne	.+2      	; 0x3d4a <SdFile::openCachedEntry(unsigned char, unsigned char)+0xd4>
    3d48:	aa cf       	rjmp	.-172    	; 0x3c9e <SdFile::openCachedEntry(unsigned char, unsigned char)+0x28>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:625
      return false;
    }
    type_ = FAT_FILE_TYPE_SUBDIR;
    3d4a:	84 e0       	ldi	r24, 0x04	; 4
    3d4c:	e4 cf       	rjmp	.-56     	; 0x3d16 <SdFile::openCachedEntry(unsigned char, unsigned char)+0xa0>

00003d4e <TwoWire::requestFrom(unsigned char, unsigned char)>:
requestFrom():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:174
uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop) {
	return requestFrom((uint8_t)address, (uint8_t)quantity, (uint32_t)0, (uint8_t)0, (uint8_t)sendStop);
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)
{
    3d4e:	86 2f       	mov	r24, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:161
  // clamp to buffer length
  if(quantity > BUFFER_LENGTH){
    quantity = BUFFER_LENGTH;
  }
  // perform blocking read into buffer
  uint8_t read = twi_readFrom(address, rxBuffer, quantity, sendStop);
    3d50:	64 2f       	mov	r22, r20
    3d52:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <twi_readFrom.constprop.140>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:163
  // set rx buffer iterator vars
  rxBufferIndex = 0;
    3d56:	10 92 76 0c 	sts	0x0C76, r1	; 0x800c76 <TwoWire::rxBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:164
  rxBufferLength = read;
    3d5a:	80 93 75 0c 	sts	0x0C75, r24	; 0x800c75 <TwoWire::rxBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:176
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)
{
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
}
    3d5e:	08 95       	ret

00003d60 <read_i2c_register(unsigned char, unsigned char) [clone .constprop.130]>:
read_i2c_register():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:83
    @param reg Register address
    @return Register value
*/
/**************************************************************************/
static uint8_t read_i2c_register(uint8_t addr, uint8_t reg) {
  Wire.beginTransmission(addr);
    3d60:	88 e6       	ldi	r24, 0x68	; 104
    3d62:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:84
  Wire._I2C_WRITE((byte)reg);
    3d66:	6f e0       	ldi	r22, 0x0F	; 15
    3d68:	8c e3       	ldi	r24, 0x3C	; 60
    3d6a:	9f e0       	ldi	r25, 0x0F	; 15
    3d6c:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:85
  Wire.endTransmission();
    3d70:	8c e3       	ldi	r24, 0x3C	; 60
    3d72:	9f e0       	ldi	r25, 0x0F	; 15
    3d74:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:87

  Wire.requestFrom(addr, (byte)1);
    3d78:	41 e0       	ldi	r20, 0x01	; 1
    3d7a:	68 e6       	ldi	r22, 0x68	; 104
    3d7c:	8c e3       	ldi	r24, 0x3C	; 60
    3d7e:	9f e0       	ldi	r25, 0x0F	; 15
    3d80:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <TwoWire::requestFrom(unsigned char, unsigned char)>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:88
  return Wire._I2C_READ();
    3d84:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:89
}
    3d88:	08 95       	ret

00003d8a <RTC_DS3231::adjust(DateTime const&)>:
adjust():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1563
/*!
    @brief  Set the date and flip the Oscillator Stop Flag
    @param dt DateTime object containing the date/time to set
*/
/**************************************************************************/
void RTC_DS3231::adjust(const DateTime &dt) {
    3d8a:	1f 93       	push	r17
    3d8c:	cf 93       	push	r28
    3d8e:	df 93       	push	r29
    3d90:	ec 01       	movw	r28, r24
beginTransmission():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:201
  txBufferLength = 0;
}

void TwoWire::beginTransmission(int address)
{
  beginTransmission((uint8_t)address);
    3d92:	88 e6       	ldi	r24, 0x68	; 104
    3d94:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
adjust():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1565
  Wire.beginTransmission(DS3231_ADDRESS);
  Wire._I2C_WRITE((byte)DS3231_TIME); // start at location 0
    3d98:	60 e0       	ldi	r22, 0x00	; 0
    3d9a:	8c e3       	ldi	r24, 0x3C	; 60
    3d9c:	9f e0       	ldi	r25, 0x0F	; 15
    3d9e:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
    3da2:	2d 81       	ldd	r18, Y+5	; 0x05
bin2bcd():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:804
    @brief  Convert a binary value to BCD format for the RTC registers
    @param val Binary value
    @return BCD value
*/
/**************************************************************************/
static uint8_t bin2bcd(uint8_t val) { return val + 6 * (val / 10); }
    3da4:	1a e0       	ldi	r17, 0x0A	; 10
    3da6:	82 2f       	mov	r24, r18
    3da8:	61 2f       	mov	r22, r17
    3daa:	0e 94 f7 6b 	call	0xd7ee	; 0xd7ee <__udivmodqi4>
    3dae:	68 2f       	mov	r22, r24
    3db0:	66 0f       	add	r22, r22
    3db2:	68 0f       	add	r22, r24
    3db4:	66 0f       	add	r22, r22
    3db6:	62 0f       	add	r22, r18
adjust():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1566
*/
/**************************************************************************/
void RTC_DS3231::adjust(const DateTime &dt) {
  Wire.beginTransmission(DS3231_ADDRESS);
  Wire._I2C_WRITE((byte)DS3231_TIME); // start at location 0
  Wire._I2C_WRITE(bin2bcd(dt.second()));
    3db8:	8c e3       	ldi	r24, 0x3C	; 60
    3dba:	9f e0       	ldi	r25, 0x0F	; 15
    3dbc:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
    3dc0:	2c 81       	ldd	r18, Y+4	; 0x04
bin2bcd():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:804
    @brief  Convert a binary value to BCD format for the RTC registers
    @param val Binary value
    @return BCD value
*/
/**************************************************************************/
static uint8_t bin2bcd(uint8_t val) { return val + 6 * (val / 10); }
    3dc2:	82 2f       	mov	r24, r18
    3dc4:	61 2f       	mov	r22, r17
    3dc6:	0e 94 f7 6b 	call	0xd7ee	; 0xd7ee <__udivmodqi4>
    3dca:	68 2f       	mov	r22, r24
    3dcc:	66 0f       	add	r22, r22
    3dce:	68 0f       	add	r22, r24
    3dd0:	66 0f       	add	r22, r22
    3dd2:	62 0f       	add	r22, r18
adjust():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1567
/**************************************************************************/
void RTC_DS3231::adjust(const DateTime &dt) {
  Wire.beginTransmission(DS3231_ADDRESS);
  Wire._I2C_WRITE((byte)DS3231_TIME); // start at location 0
  Wire._I2C_WRITE(bin2bcd(dt.second()));
  Wire._I2C_WRITE(bin2bcd(dt.minute()));
    3dd4:	8c e3       	ldi	r24, 0x3C	; 60
    3dd6:	9f e0       	ldi	r25, 0x0F	; 15
    3dd8:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
    3ddc:	2b 81       	ldd	r18, Y+3	; 0x03
bin2bcd():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:804
    @brief  Convert a binary value to BCD format for the RTC registers
    @param val Binary value
    @return BCD value
*/
/**************************************************************************/
static uint8_t bin2bcd(uint8_t val) { return val + 6 * (val / 10); }
    3dde:	82 2f       	mov	r24, r18
    3de0:	61 2f       	mov	r22, r17
    3de2:	0e 94 f7 6b 	call	0xd7ee	; 0xd7ee <__udivmodqi4>
    3de6:	68 2f       	mov	r22, r24
    3de8:	66 0f       	add	r22, r22
    3dea:	68 0f       	add	r22, r24
    3dec:	66 0f       	add	r22, r22
    3dee:	62 0f       	add	r22, r18
adjust():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1568
void RTC_DS3231::adjust(const DateTime &dt) {
  Wire.beginTransmission(DS3231_ADDRESS);
  Wire._I2C_WRITE((byte)DS3231_TIME); // start at location 0
  Wire._I2C_WRITE(bin2bcd(dt.second()));
  Wire._I2C_WRITE(bin2bcd(dt.minute()));
  Wire._I2C_WRITE(bin2bcd(dt.hour()));
    3df0:	8c e3       	ldi	r24, 0x3C	; 60
    3df2:	9f e0       	ldi	r25, 0x0F	; 15
    3df4:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
dayOfTheWeek():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:575
    @brief  Return the day of the week.
    @return Day of week as an integer from 0 (Sunday) to 6 (Saturday).
*/
/**************************************************************************/
uint8_t DateTime::dayOfTheWeek() const {
  uint16_t day = date2days(yOff, m, d);
    3df8:	88 81       	ld	r24, Y
    3dfa:	4a 81       	ldd	r20, Y+2	; 0x02
    3dfc:	69 81       	ldd	r22, Y+1	; 0x01
    3dfe:	90 e0       	ldi	r25, 0x00	; 0
    3e00:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <date2days(unsigned int, unsigned char, unsigned char)>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:576
  return (day + 6) % 7; // Jan 1, 2000 is a Saturday, i.e. returns 6
    3e04:	06 96       	adiw	r24, 0x06	; 6
    3e06:	67 e0       	ldi	r22, 0x07	; 7
    3e08:	70 e0       	ldi	r23, 0x00	; 0
    3e0a:	0e 94 03 6c 	call	0xd806	; 0xd806 <__udivmodhi4>
    3e0e:	68 2f       	mov	r22, r24
dowToDS3231():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1529
            storing in the DS3231: from 1 (Monday) to 7 (Sunday).
    @param  d Day of the week as represented by the library:
            from 0 (Sunday) to 6 (Saturday).
*/
/**************************************************************************/
static uint8_t dowToDS3231(uint8_t d) { return d == 0 ? 7 : d; }
    3e10:	81 11       	cpse	r24, r1
    3e12:	01 c0       	rjmp	.+2      	; 0x3e16 <RTC_DS3231::adjust(DateTime const&)+0x8c>
adjust():
    3e14:	67 e0       	ldi	r22, 0x07	; 7
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1570
  Wire._I2C_WRITE((byte)DS3231_TIME); // start at location 0
  Wire._I2C_WRITE(bin2bcd(dt.second()));
  Wire._I2C_WRITE(bin2bcd(dt.minute()));
  Wire._I2C_WRITE(bin2bcd(dt.hour()));
  // The RTC must know the day of the week for the weekly alarms to work.
  Wire._I2C_WRITE(bin2bcd(dowToDS3231(dt.dayOfTheWeek())));
    3e16:	8c e3       	ldi	r24, 0x3C	; 60
    3e18:	9f e0       	ldi	r25, 0x0F	; 15
    3e1a:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
    3e1e:	2a 81       	ldd	r18, Y+2	; 0x02
bin2bcd():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:804
    @brief  Convert a binary value to BCD format for the RTC registers
    @param val Binary value
    @return BCD value
*/
/**************************************************************************/
static uint8_t bin2bcd(uint8_t val) { return val + 6 * (val / 10); }
    3e20:	1a e0       	ldi	r17, 0x0A	; 10
    3e22:	82 2f       	mov	r24, r18
    3e24:	61 2f       	mov	r22, r17
    3e26:	0e 94 f7 6b 	call	0xd7ee	; 0xd7ee <__udivmodqi4>
    3e2a:	68 2f       	mov	r22, r24
    3e2c:	66 0f       	add	r22, r22
    3e2e:	68 0f       	add	r22, r24
    3e30:	66 0f       	add	r22, r22
    3e32:	62 0f       	add	r22, r18
adjust():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1571
  Wire._I2C_WRITE(bin2bcd(dt.second()));
  Wire._I2C_WRITE(bin2bcd(dt.minute()));
  Wire._I2C_WRITE(bin2bcd(dt.hour()));
  // The RTC must know the day of the week for the weekly alarms to work.
  Wire._I2C_WRITE(bin2bcd(dowToDS3231(dt.dayOfTheWeek())));
  Wire._I2C_WRITE(bin2bcd(dt.day()));
    3e34:	8c e3       	ldi	r24, 0x3C	; 60
    3e36:	9f e0       	ldi	r25, 0x0F	; 15
    3e38:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
    3e3c:	29 81       	ldd	r18, Y+1	; 0x01
bin2bcd():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:804
    @brief  Convert a binary value to BCD format for the RTC registers
    @param val Binary value
    @return BCD value
*/
/**************************************************************************/
static uint8_t bin2bcd(uint8_t val) { return val + 6 * (val / 10); }
    3e3e:	82 2f       	mov	r24, r18
    3e40:	61 2f       	mov	r22, r17
    3e42:	0e 94 f7 6b 	call	0xd7ee	; 0xd7ee <__udivmodqi4>
    3e46:	68 2f       	mov	r22, r24
    3e48:	66 0f       	add	r22, r22
    3e4a:	68 0f       	add	r22, r24
    3e4c:	66 0f       	add	r22, r22
    3e4e:	62 0f       	add	r22, r18
adjust():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1572
  Wire._I2C_WRITE(bin2bcd(dt.minute()));
  Wire._I2C_WRITE(bin2bcd(dt.hour()));
  // The RTC must know the day of the week for the weekly alarms to work.
  Wire._I2C_WRITE(bin2bcd(dowToDS3231(dt.dayOfTheWeek())));
  Wire._I2C_WRITE(bin2bcd(dt.day()));
  Wire._I2C_WRITE(bin2bcd(dt.month()));
    3e50:	8c e3       	ldi	r24, 0x3C	; 60
    3e52:	9f e0       	ldi	r25, 0x0F	; 15
    3e54:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
    3e58:	28 81       	ld	r18, Y
bin2bcd():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:804
    @brief  Convert a binary value to BCD format for the RTC registers
    @param val Binary value
    @return BCD value
*/
/**************************************************************************/
static uint8_t bin2bcd(uint8_t val) { return val + 6 * (val / 10); }
    3e5a:	82 2f       	mov	r24, r18
    3e5c:	61 2f       	mov	r22, r17
    3e5e:	0e 94 f7 6b 	call	0xd7ee	; 0xd7ee <__udivmodqi4>
    3e62:	68 2f       	mov	r22, r24
    3e64:	66 0f       	add	r22, r22
    3e66:	68 0f       	add	r22, r24
    3e68:	66 0f       	add	r22, r22
    3e6a:	62 0f       	add	r22, r18
adjust():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1573
  Wire._I2C_WRITE(bin2bcd(dt.hour()));
  // The RTC must know the day of the week for the weekly alarms to work.
  Wire._I2C_WRITE(bin2bcd(dowToDS3231(dt.dayOfTheWeek())));
  Wire._I2C_WRITE(bin2bcd(dt.day()));
  Wire._I2C_WRITE(bin2bcd(dt.month()));
  Wire._I2C_WRITE(bin2bcd(dt.year() - 2000U));
    3e6c:	8c e3       	ldi	r24, 0x3C	; 60
    3e6e:	9f e0       	ldi	r25, 0x0F	; 15
    3e70:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1574
  Wire.endTransmission();
    3e74:	8c e3       	ldi	r24, 0x3C	; 60
    3e76:	9f e0       	ldi	r25, 0x0F	; 15
    3e78:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1576

  uint8_t statreg = read_i2c_register(DS3231_ADDRESS, DS3231_STATUSREG);
    3e7c:	0e 94 b0 1e 	call	0x3d60	; 0x3d60 <read_i2c_register(unsigned char, unsigned char) [clone .constprop.130]>
    3e80:	c8 2f       	mov	r28, r24
write_i2c_register():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:100
    @param reg Register address
    @param val Value to write
*/
/**************************************************************************/
static void write_i2c_register(uint8_t addr, uint8_t reg, uint8_t val) {
  Wire.beginTransmission(addr);
    3e82:	88 e6       	ldi	r24, 0x68	; 104
    3e84:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:101
  Wire._I2C_WRITE((byte)reg);
    3e88:	6f e0       	ldi	r22, 0x0F	; 15
    3e8a:	8c e3       	ldi	r24, 0x3C	; 60
    3e8c:	9f e0       	ldi	r25, 0x0F	; 15
    3e8e:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
adjust():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1577
  Wire._I2C_WRITE(bin2bcd(dt.month()));
  Wire._I2C_WRITE(bin2bcd(dt.year() - 2000U));
  Wire.endTransmission();

  uint8_t statreg = read_i2c_register(DS3231_ADDRESS, DS3231_STATUSREG);
  statreg &= ~0x80; // flip OSF bit
    3e92:	6c 2f       	mov	r22, r28
    3e94:	6f 77       	andi	r22, 0x7F	; 127
write_i2c_register():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:102
*/
/**************************************************************************/
static void write_i2c_register(uint8_t addr, uint8_t reg, uint8_t val) {
  Wire.beginTransmission(addr);
  Wire._I2C_WRITE((byte)reg);
  Wire._I2C_WRITE((byte)val);
    3e96:	8c e3       	ldi	r24, 0x3C	; 60
    3e98:	9f e0       	ldi	r25, 0x0F	; 15
    3e9a:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:103
  Wire.endTransmission();
    3e9e:	8c e3       	ldi	r24, 0x3C	; 60
    3ea0:	9f e0       	ldi	r25, 0x0F	; 15
adjust():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1579
  Wire.endTransmission();

  uint8_t statreg = read_i2c_register(DS3231_ADDRESS, DS3231_STATUSREG);
  statreg &= ~0x80; // flip OSF bit
  write_i2c_register(DS3231_ADDRESS, DS3231_STATUSREG, statreg);
}
    3ea2:	df 91       	pop	r29
    3ea4:	cf 91       	pop	r28
    3ea6:	1f 91       	pop	r17
write_i2c_register():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:103
/**************************************************************************/
static void write_i2c_register(uint8_t addr, uint8_t reg, uint8_t val) {
  Wire.beginTransmission(addr);
  Wire._I2C_WRITE((byte)reg);
  Wire._I2C_WRITE((byte)val);
  Wire.endTransmission();
    3ea8:	0c 94 18 1c 	jmp	0x3830	; 0x3830 <TwoWire::endTransmission()>

00003eac <Adafruit_BME280::read24(unsigned char) [clone .constprop.88]>:
read24():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:310
/*!
 *   @brief  Reads a 24 bit value over I2C
 *   @param reg the register address to read from
 *   @returns the 24 bit data value read from the device
 */
uint32_t Adafruit_BME280::read24(byte reg) {
    3eac:	8f 92       	push	r8
    3eae:	9f 92       	push	r9
    3eb0:	af 92       	push	r10
    3eb2:	bf 92       	push	r11
    3eb4:	cf 92       	push	r12
    3eb6:	df 92       	push	r13
    3eb8:	ef 92       	push	r14
    3eba:	ff 92       	push	r15
    3ebc:	f8 2e       	mov	r15, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:313
  uint32_t value;

  if (_cs == -1) {
    3ebe:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    3ec2:	8f 3f       	cpi	r24, 0xFF	; 255
    3ec4:	09 f0       	breq	.+2      	; 0x3ec8 <Adafruit_BME280::read24(unsigned char) [clone .constprop.88]+0x1c>
    3ec6:	69 c0       	rjmp	.+210    	; 0x3f9a <Adafruit_BME280::read24(unsigned char) [clone .constprop.88]+0xee>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:314
    _wire->beginTransmission((uint8_t)_i2caddr);
    3ec8:	80 91 d1 10 	lds	r24, 0x10D1	; 0x8010d1 <bme280+0xa>
    3ecc:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:315
    _wire->write((uint8_t)reg);
    3ed0:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    3ed4:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    3ed8:	dc 01       	movw	r26, r24
    3eda:	ed 91       	ld	r30, X+
    3edc:	fc 91       	ld	r31, X
    3ede:	01 90       	ld	r0, Z+
    3ee0:	f0 81       	ld	r31, Z
    3ee2:	e0 2d       	mov	r30, r0
    3ee4:	6f 2d       	mov	r22, r15
    3ee6:	19 95       	eicall
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:316
    _wire->endTransmission();
    3ee8:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    3eec:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    3ef0:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:317
    _wire->requestFrom((uint8_t)_i2caddr, (byte)3);
    3ef4:	43 e0       	ldi	r20, 0x03	; 3
    3ef6:	60 91 d1 10 	lds	r22, 0x10D1	; 0x8010d1 <bme280+0xa>
    3efa:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    3efe:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    3f02:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <TwoWire::requestFrom(unsigned char, unsigned char)>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:319

    value = _wire->read();
    3f06:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    3f0a:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    3f0e:	dc 01       	movw	r26, r24
    3f10:	ed 91       	ld	r30, X+
    3f12:	fc 91       	ld	r31, X
    3f14:	02 84       	ldd	r0, Z+10	; 0x0a
    3f16:	f3 85       	ldd	r31, Z+11	; 0x0b
    3f18:	e0 2d       	mov	r30, r0
    3f1a:	19 95       	eicall
    3f1c:	4c 01       	movw	r8, r24
    3f1e:	99 0f       	add	r25, r25
    3f20:	aa 08       	sbc	r10, r10
    3f22:	bb 08       	sbc	r11, r11
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:320
    value <<= 8;
    3f24:	ba 2c       	mov	r11, r10
    3f26:	a9 2c       	mov	r10, r9
    3f28:	98 2c       	mov	r9, r8
    3f2a:	88 24       	eor	r8, r8
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:321
    value |= _wire->read();
    3f2c:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    3f30:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    3f34:	dc 01       	movw	r26, r24
    3f36:	ed 91       	ld	r30, X+
    3f38:	fc 91       	ld	r31, X
    3f3a:	02 84       	ldd	r0, Z+10	; 0x0a
    3f3c:	f3 85       	ldd	r31, Z+11	; 0x0b
    3f3e:	e0 2d       	mov	r30, r0
    3f40:	19 95       	eicall
    3f42:	09 2e       	mov	r0, r25
    3f44:	00 0c       	add	r0, r0
    3f46:	aa 0b       	sbc	r26, r26
    3f48:	bb 0b       	sbc	r27, r27
    3f4a:	88 2a       	or	r8, r24
    3f4c:	99 2a       	or	r9, r25
    3f4e:	aa 2a       	or	r10, r26
    3f50:	bb 2a       	or	r11, r27
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:322
    value <<= 8;
    3f52:	ba 2c       	mov	r11, r10
    3f54:	a9 2c       	mov	r10, r9
    3f56:	98 2c       	mov	r9, r8
    3f58:	88 24       	eor	r8, r8
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:323
    value |= _wire->read();
    3f5a:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    3f5e:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    3f62:	dc 01       	movw	r26, r24
    3f64:	ed 91       	ld	r30, X+
    3f66:	fc 91       	ld	r31, X
    3f68:	02 84       	ldd	r0, Z+10	; 0x0a
    3f6a:	f3 85       	ldd	r31, Z+11	; 0x0b
    3f6c:	e0 2d       	mov	r30, r0
    3f6e:	19 95       	eicall
    3f70:	09 2e       	mov	r0, r25
    3f72:	00 0c       	add	r0, r0
    3f74:	aa 0b       	sbc	r26, r26
    3f76:	bb 0b       	sbc	r27, r27
    3f78:	6c 01       	movw	r12, r24
    3f7a:	7d 01       	movw	r14, r26
    3f7c:	c8 28       	or	r12, r8
    3f7e:	d9 28       	or	r13, r9
    3f80:	ea 28       	or	r14, r10
    3f82:	fb 28       	or	r15, r11
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:342
    if (_sck == -1)
      _spi->endTransaction(); // release the SPI bus
  }

  return value;
}
    3f84:	c7 01       	movw	r24, r14
    3f86:	b6 01       	movw	r22, r12
    3f88:	ff 90       	pop	r15
    3f8a:	ef 90       	pop	r14
    3f8c:	df 90       	pop	r13
    3f8e:	cf 90       	pop	r12
    3f90:	bf 90       	pop	r11
    3f92:	af 90       	pop	r10
    3f94:	9f 90       	pop	r9
    3f96:	8f 90       	pop	r8
    3f98:	08 95       	ret
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:325
    value <<= 8;
    value |= _wire->read();
    value <<= 8;
    value |= _wire->read();
  } else {
    if (_sck == -1)
    3f9a:	80 91 dd 10 	lds	r24, 0x10DD	; 0x8010dd <bme280+0x16>
    3f9e:	8f 3f       	cpi	r24, 0xFF	; 255
    3fa0:	21 f4       	brne	.+8      	; 0x3faa <Adafruit_BME280::read24(unsigned char) [clone .constprop.88]+0xfe>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:326
      _spi->beginTransaction(SPISettings(500000, MSBFIRST, SPI_MODE0));
    3fa2:	82 e5       	ldi	r24, 0x52	; 82
    3fa4:	91 e0       	ldi	r25, 0x01	; 1
    3fa6:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <SPIClass::beginTransaction(SPISettings)>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:327
    digitalWrite(_cs, LOW);
    3faa:	60 e0       	ldi	r22, 0x00	; 0
    3fac:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    3fb0:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:328
    spixfer(reg | 0x80); // read, bit 7 high
    3fb4:	8f 2d       	mov	r24, r15
    3fb6:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:330

    value = spixfer(0);
    3fba:	80 e0       	ldi	r24, 0x00	; 0
    3fbc:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>
    3fc0:	90 e0       	ldi	r25, 0x00	; 0
    3fc2:	b0 e0       	ldi	r27, 0x00	; 0
    3fc4:	a0 e0       	ldi	r26, 0x00	; 0
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:331
    value <<= 8;
    3fc6:	cc 24       	eor	r12, r12
    3fc8:	d8 2e       	mov	r13, r24
    3fca:	e9 2e       	mov	r14, r25
    3fcc:	fa 2e       	mov	r15, r26
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:332
    value |= spixfer(0);
    3fce:	80 e0       	ldi	r24, 0x00	; 0
    3fd0:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>
    3fd4:	c8 2a       	or	r12, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:333
    value <<= 8;
    3fd6:	fe 2c       	mov	r15, r14
    3fd8:	ed 2c       	mov	r14, r13
    3fda:	dc 2c       	mov	r13, r12
    3fdc:	cc 24       	eor	r12, r12
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:334
    value |= spixfer(0);
    3fde:	80 e0       	ldi	r24, 0x00	; 0
    3fe0:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>
    3fe4:	c8 2a       	or	r12, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:336

    digitalWrite(_cs, HIGH);
    3fe6:	61 e0       	ldi	r22, 0x01	; 1
    3fe8:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    3fec:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
    3ff0:	c9 cf       	rjmp	.-110    	; 0x3f84 <Adafruit_BME280::read24(unsigned char) [clone .constprop.88]+0xd8>

00003ff2 <Adafruit_BME280::readTemperature() [clone .constprop.87]>:
readTemperature():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:416

/*!
 *   @brief  Returns the temperature from the sensor
 *   @returns the temperature read from the device
 */
float Adafruit_BME280::readTemperature(void) {
    3ff2:	8f 92       	push	r8
    3ff4:	9f 92       	push	r9
    3ff6:	af 92       	push	r10
    3ff8:	bf 92       	push	r11
    3ffa:	cf 92       	push	r12
    3ffc:	df 92       	push	r13
    3ffe:	ef 92       	push	r14
    4000:	ff 92       	push	r15
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:419
  int32_t var1, var2;

  int32_t adc_T = read24(BME280_REGISTER_TEMPDATA);
    4002:	8a ef       	ldi	r24, 0xFA	; 250
    4004:	0e 94 56 1f 	call	0x3eac	; 0x3eac <Adafruit_BME280::read24(unsigned char) [clone .constprop.88]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:420
  if (adc_T == 0x800000) // value in case temp measurement was disabled
    4008:	61 15       	cp	r22, r1
    400a:	71 05       	cpc	r23, r1
    400c:	20 e8       	ldi	r18, 0x80	; 128
    400e:	82 07       	cpc	r24, r18
    4010:	91 05       	cpc	r25, r1
    4012:	09 f4       	brne	.+2      	; 0x4016 <Adafruit_BME280::readTemperature() [clone .constprop.87]+0x24>
    4014:	85 c0       	rjmp	.+266    	; 0x4120 <Adafruit_BME280::readTemperature() [clone .constprop.87]+0x12e>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:424
    return NAN;
  adc_T >>= 4;

  var1 = ((((adc_T >> 3) - ((int32_t)_bme280_calib.dig_T1 << 1))) *
    4016:	80 90 e2 10 	lds	r8, 0x10E2	; 0x8010e2 <bme280+0x1b>
    401a:	90 90 e3 10 	lds	r9, 0x10E3	; 0x8010e3 <bme280+0x1c>
    401e:	b1 2c       	mov	r11, r1
    4020:	a1 2c       	mov	r10, r1
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:428
          ((int32_t)_bme280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bme280_calib.dig_T1)) *
    4022:	c7 2e       	mov	r12, r23
    4024:	d8 2e       	mov	r13, r24
    4026:	e9 2e       	mov	r14, r25
    4028:	ff 24       	eor	r15, r15
    402a:	e7 fc       	sbrc	r14, 7
    402c:	fa 94       	dec	r15
    402e:	c8 18       	sub	r12, r8
    4030:	d9 08       	sbc	r13, r9
    4032:	ea 08       	sbc	r14, r10
    4034:	fb 08       	sbc	r15, r11
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:424
  int32_t adc_T = read24(BME280_REGISTER_TEMPDATA);
  if (adc_T == 0x800000) // value in case temp measurement was disabled
    return NAN;
  adc_T >>= 4;

  var1 = ((((adc_T >> 3) - ((int32_t)_bme280_calib.dig_T1 << 1))) *
    4036:	37 e0       	ldi	r19, 0x07	; 7
    4038:	95 95       	asr	r25
    403a:	87 95       	ror	r24
    403c:	77 95       	ror	r23
    403e:	67 95       	ror	r22
    4040:	3a 95       	dec	r19
    4042:	d1 f7       	brne	.-12     	; 0x4038 <Adafruit_BME280::readTemperature() [clone .constprop.87]+0x46>
    4044:	88 0c       	add	r8, r8
    4046:	99 1c       	adc	r9, r9
    4048:	aa 1c       	adc	r10, r10
    404a:	bb 1c       	adc	r11, r11
    404c:	9b 01       	movw	r18, r22
    404e:	ac 01       	movw	r20, r24
    4050:	28 19       	sub	r18, r8
    4052:	39 09       	sbc	r19, r9
    4054:	4a 09       	sbc	r20, r10
    4056:	5b 09       	sbc	r21, r11
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:425
          ((int32_t)_bme280_calib.dig_T2)) >>
    4058:	a0 91 e4 10 	lds	r26, 0x10E4	; 0x8010e4 <bme280+0x1d>
    405c:	b0 91 e5 10 	lds	r27, 0x10E5	; 0x8010e5 <bme280+0x1e>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:424
  int32_t adc_T = read24(BME280_REGISTER_TEMPDATA);
  if (adc_T == 0x800000) // value in case temp measurement was disabled
    return NAN;
  adc_T >>= 4;

  var1 = ((((adc_T >> 3) - ((int32_t)_bme280_calib.dig_T1 << 1))) *
    4060:	0e 94 3b 6a 	call	0xd476	; 0xd476 <__mulshisi3>
    4064:	4b 01       	movw	r8, r22
    4066:	5c 01       	movw	r10, r24
    4068:	5b e0       	ldi	r21, 0x0B	; 11
    406a:	b5 94       	asr	r11
    406c:	a7 94       	ror	r10
    406e:	97 94       	ror	r9
    4070:	87 94       	ror	r8
    4072:	5a 95       	dec	r21
    4074:	d1 f7       	brne	.-12     	; 0x406a <Adafruit_BME280::readTemperature() [clone .constprop.87]+0x78>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:428
          ((int32_t)_bme280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bme280_calib.dig_T1)) *
    4076:	a7 01       	movw	r20, r14
    4078:	96 01       	movw	r18, r12
    407a:	c7 01       	movw	r24, r14
    407c:	b6 01       	movw	r22, r12
    407e:	0e 94 e7 6b 	call	0xd7ce	; 0xd7ce <__mulsi3>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:429
            ((adc_T >> 4) - ((int32_t)_bme280_calib.dig_T1))) >>
    4082:	9b 01       	movw	r18, r22
    4084:	ac 01       	movw	r20, r24
    4086:	6c e0       	ldi	r22, 0x0C	; 12
    4088:	55 95       	asr	r21
    408a:	47 95       	ror	r20
    408c:	37 95       	ror	r19
    408e:	27 95       	ror	r18
    4090:	6a 95       	dec	r22
    4092:	d1 f7       	brne	.-12     	; 0x4088 <Adafruit_BME280::readTemperature() [clone .constprop.87]+0x96>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:431
           12) *
          ((int32_t)_bme280_calib.dig_T3)) >>
    4094:	a0 91 e6 10 	lds	r26, 0x10E6	; 0x8010e6 <bme280+0x1f>
    4098:	b0 91 e7 10 	lds	r27, 0x10E7	; 0x8010e7 <bme280+0x20>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:430
          ((int32_t)_bme280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bme280_calib.dig_T1)) *
            ((adc_T >> 4) - ((int32_t)_bme280_calib.dig_T1))) >>
           12) *
    409c:	0e 94 3b 6a 	call	0xd476	; 0xd476 <__mulshisi3>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:428

  var1 = ((((adc_T >> 3) - ((int32_t)_bme280_calib.dig_T1 << 1))) *
          ((int32_t)_bme280_calib.dig_T2)) >>
         11;

  var2 = (((((adc_T >> 4) - ((int32_t)_bme280_calib.dig_T1)) *
    40a0:	9b 01       	movw	r18, r22
    40a2:	ac 01       	movw	r20, r24
    40a4:	7e e0       	ldi	r23, 0x0E	; 14
    40a6:	55 95       	asr	r21
    40a8:	47 95       	ror	r20
    40aa:	37 95       	ror	r19
    40ac:	27 95       	ror	r18
    40ae:	7a 95       	dec	r23
    40b0:	d1 f7       	brne	.-12     	; 0x40a6 <Adafruit_BME280::readTemperature() [clone .constprop.87]+0xb4>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:434
            ((adc_T >> 4) - ((int32_t)_bme280_calib.dig_T1))) >>
           12) *
          ((int32_t)_bme280_calib.dig_T3)) >>
         14;

  t_fine = var1 + var2 + t_fine_adjust;
    40b2:	28 0d       	add	r18, r8
    40b4:	39 1d       	adc	r19, r9
    40b6:	4a 1d       	adc	r20, r10
    40b8:	5b 1d       	adc	r21, r11
    40ba:	80 91 de 10 	lds	r24, 0x10DE	; 0x8010de <bme280+0x17>
    40be:	90 91 df 10 	lds	r25, 0x10DF	; 0x8010df <bme280+0x18>
    40c2:	a0 91 e0 10 	lds	r26, 0x10E0	; 0x8010e0 <bme280+0x19>
    40c6:	b0 91 e1 10 	lds	r27, 0x10E1	; 0x8010e1 <bme280+0x1a>
    40ca:	28 0f       	add	r18, r24
    40cc:	39 1f       	adc	r19, r25
    40ce:	4a 1f       	adc	r20, r26
    40d0:	5b 1f       	adc	r21, r27
    40d2:	20 93 d6 10 	sts	0x10D6, r18	; 0x8010d6 <bme280+0xf>
    40d6:	30 93 d7 10 	sts	0x10D7, r19	; 0x8010d7 <bme280+0x10>
    40da:	40 93 d8 10 	sts	0x10D8, r20	; 0x8010d8 <bme280+0x11>
    40de:	50 93 d9 10 	sts	0x10D9, r21	; 0x8010d9 <bme280+0x12>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:436

  float T = (t_fine * 5 + 128) >> 8;
    40e2:	a5 e0       	ldi	r26, 0x05	; 5
    40e4:	b0 e0       	ldi	r27, 0x00	; 0
    40e6:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
    40ea:	60 58       	subi	r22, 0x80	; 128
    40ec:	7f 4f       	sbci	r23, 0xFF	; 255
    40ee:	8f 4f       	sbci	r24, 0xFF	; 255
    40f0:	9f 4f       	sbci	r25, 0xFF	; 255
    40f2:	67 2f       	mov	r22, r23
    40f4:	78 2f       	mov	r23, r24
    40f6:	89 2f       	mov	r24, r25
    40f8:	99 27       	eor	r25, r25
    40fa:	87 fd       	sbrc	r24, 7
    40fc:	9a 95       	dec	r25
    40fe:	0e 94 db 68 	call	0xd1b6	; 0xd1b6 <__floatsisf>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:437
  return T / 100;
    4102:	20 e0       	ldi	r18, 0x00	; 0
    4104:	30 e0       	ldi	r19, 0x00	; 0
    4106:	48 ec       	ldi	r20, 0xC8	; 200
    4108:	52 e4       	ldi	r21, 0x42	; 66
    410a:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:438
}
    410e:	ff 90       	pop	r15
    4110:	ef 90       	pop	r14
    4112:	df 90       	pop	r13
    4114:	cf 90       	pop	r12
    4116:	bf 90       	pop	r11
    4118:	af 90       	pop	r10
    411a:	9f 90       	pop	r9
    411c:	8f 90       	pop	r8
    411e:	08 95       	ret
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:421
float Adafruit_BME280::readTemperature(void) {
  int32_t var1, var2;

  int32_t adc_T = read24(BME280_REGISTER_TEMPDATA);
  if (adc_T == 0x800000) // value in case temp measurement was disabled
    return NAN;
    4120:	60 e0       	ldi	r22, 0x00	; 0
    4122:	70 e0       	ldi	r23, 0x00	; 0
    4124:	80 ec       	ldi	r24, 0xC0	; 192
    4126:	9f e7       	ldi	r25, 0x7F	; 127
    4128:	f2 cf       	rjmp	.-28     	; 0x410e <Adafruit_BME280::readTemperature() [clone .constprop.87]+0x11c>

0000412a <Adafruit_BME280::read16(unsigned char) [clone .constprop.85]>:
read16():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:256
/*!
 *   @brief  Reads a 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
uint16_t Adafruit_BME280::read16(byte reg) {
    412a:	cf 93       	push	r28
    412c:	df 93       	push	r29
    412e:	c8 2f       	mov	r28, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:259
  uint16_t value;

  if (_cs == -1) {
    4130:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    4134:	8f 3f       	cpi	r24, 0xFF	; 255
    4136:	09 f0       	breq	.+2      	; 0x413a <Adafruit_BME280::read16(unsigned char) [clone .constprop.85]+0x10>
    4138:	3f c0       	rjmp	.+126    	; 0x41b8 <Adafruit_BME280::read16(unsigned char) [clone .constprop.85]+0x8e>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:260
    _wire->beginTransmission((uint8_t)_i2caddr);
    413a:	80 91 d1 10 	lds	r24, 0x10D1	; 0x8010d1 <bme280+0xa>
    413e:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:261
    _wire->write((uint8_t)reg);
    4142:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    4146:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    414a:	dc 01       	movw	r26, r24
    414c:	ed 91       	ld	r30, X+
    414e:	fc 91       	ld	r31, X
    4150:	01 90       	ld	r0, Z+
    4152:	f0 81       	ld	r31, Z
    4154:	e0 2d       	mov	r30, r0
    4156:	6c 2f       	mov	r22, r28
    4158:	19 95       	eicall
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:262
    _wire->endTransmission();
    415a:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    415e:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    4162:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:263
    _wire->requestFrom((uint8_t)_i2caddr, (byte)2);
    4166:	42 e0       	ldi	r20, 0x02	; 2
    4168:	60 91 d1 10 	lds	r22, 0x10D1	; 0x8010d1 <bme280+0xa>
    416c:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    4170:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    4174:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <TwoWire::requestFrom(unsigned char, unsigned char)>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:264
    value = (_wire->read() << 8) | _wire->read();
    4178:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    417c:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    4180:	dc 01       	movw	r26, r24
    4182:	ed 91       	ld	r30, X+
    4184:	fc 91       	ld	r31, X
    4186:	02 84       	ldd	r0, Z+10	; 0x0a
    4188:	f3 85       	ldd	r31, Z+11	; 0x0b
    418a:	e0 2d       	mov	r30, r0
    418c:	19 95       	eicall
    418e:	c8 2f       	mov	r28, r24
    4190:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    4194:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    4198:	dc 01       	movw	r26, r24
    419a:	ed 91       	ld	r30, X+
    419c:	fc 91       	ld	r31, X
    419e:	02 84       	ldd	r0, Z+10	; 0x0a
    41a0:	f3 85       	ldd	r31, Z+11	; 0x0b
    41a2:	e0 2d       	mov	r30, r0
    41a4:	19 95       	eicall
    41a6:	20 e0       	ldi	r18, 0x00	; 0
    41a8:	3c 2f       	mov	r19, r28
    41aa:	e9 01       	movw	r28, r18
    41ac:	c8 2b       	or	r28, r24
    41ae:	d9 2b       	or	r29, r25
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:277
    if (_sck == -1)
      _spi->endTransaction(); // release the SPI bus
  }

  return value;
}
    41b0:	ce 01       	movw	r24, r28
    41b2:	df 91       	pop	r29
    41b4:	cf 91       	pop	r28
    41b6:	08 95       	ret
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:266
    _wire->write((uint8_t)reg);
    _wire->endTransmission();
    _wire->requestFrom((uint8_t)_i2caddr, (byte)2);
    value = (_wire->read() << 8) | _wire->read();
  } else {
    if (_sck == -1)
    41b8:	80 91 dd 10 	lds	r24, 0x10DD	; 0x8010dd <bme280+0x16>
    41bc:	8f 3f       	cpi	r24, 0xFF	; 255
    41be:	21 f4       	brne	.+8      	; 0x41c8 <Adafruit_BME280::read16(unsigned char) [clone .constprop.85]+0x9e>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:267
      _spi->beginTransaction(SPISettings(500000, MSBFIRST, SPI_MODE0));
    41c0:	82 e5       	ldi	r24, 0x52	; 82
    41c2:	91 e0       	ldi	r25, 0x01	; 1
    41c4:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <SPIClass::beginTransaction(SPISettings)>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:268
    digitalWrite(_cs, LOW);
    41c8:	60 e0       	ldi	r22, 0x00	; 0
    41ca:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    41ce:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:269
    spixfer(reg | 0x80); // read, bit 7 high
    41d2:	8c 2f       	mov	r24, r28
    41d4:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:270
    value = (spixfer(0) << 8) | spixfer(0);
    41d8:	80 e0       	ldi	r24, 0x00	; 0
    41da:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>
    41de:	c8 2f       	mov	r28, r24
    41e0:	80 e0       	ldi	r24, 0x00	; 0
    41e2:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>
    41e6:	dc 2f       	mov	r29, r28
    41e8:	c8 2f       	mov	r28, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:271
    digitalWrite(_cs, HIGH);
    41ea:	61 e0       	ldi	r22, 0x01	; 1
    41ec:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    41f0:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
    41f4:	dd cf       	rjmp	.-70     	; 0x41b0 <Adafruit_BME280::read16(unsigned char) [clone .constprop.85]+0x86>

000041f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>:
read16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:285
 *   @brief  Reads a signed 16 bit little endian value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
uint16_t Adafruit_BME280::read16_LE(byte reg) {
  uint16_t temp = read16(reg);
    41f6:	0e 94 95 20 	call	0x412a	; 0x412a <Adafruit_BME280::read16(unsigned char) [clone .constprop.85]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:287
  return (temp >> 8) | (temp << 8);
}
    41fa:	98 27       	eor	r25, r24
    41fc:	89 27       	eor	r24, r25
    41fe:	98 27       	eor	r25, r24
    4200:	08 95       	ret

00004202 <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]>:
read8():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:229
/*!
 *   @brief  Reads an 8 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the data byte read from the device
 */
uint8_t Adafruit_BME280::read8(byte reg) {
    4202:	cf 93       	push	r28
    4204:	c8 2f       	mov	r28, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:232
  uint8_t value;

  if (_cs == -1) {
    4206:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    420a:	8f 3f       	cpi	r24, 0xFF	; 255
    420c:	71 f5       	brne	.+92     	; 0x426a <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]+0x68>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:233
    _wire->beginTransmission((uint8_t)_i2caddr);
    420e:	80 91 d1 10 	lds	r24, 0x10D1	; 0x8010d1 <bme280+0xa>
    4212:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:234
    _wire->write((uint8_t)reg);
    4216:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    421a:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    421e:	dc 01       	movw	r26, r24
    4220:	ed 91       	ld	r30, X+
    4222:	fc 91       	ld	r31, X
    4224:	01 90       	ld	r0, Z+
    4226:	f0 81       	ld	r31, Z
    4228:	e0 2d       	mov	r30, r0
    422a:	6c 2f       	mov	r22, r28
    422c:	19 95       	eicall
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:235
    _wire->endTransmission();
    422e:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    4232:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    4236:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:236
    _wire->requestFrom((uint8_t)_i2caddr, (byte)1);
    423a:	41 e0       	ldi	r20, 0x01	; 1
    423c:	60 91 d1 10 	lds	r22, 0x10D1	; 0x8010d1 <bme280+0xa>
    4240:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    4244:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    4248:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <TwoWire::requestFrom(unsigned char, unsigned char)>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:237
    value = _wire->read();
    424c:	80 91 c7 10 	lds	r24, 0x10C7	; 0x8010c7 <bme280>
    4250:	90 91 c8 10 	lds	r25, 0x10C8	; 0x8010c8 <bme280+0x1>
    4254:	dc 01       	movw	r26, r24
    4256:	ed 91       	ld	r30, X+
    4258:	fc 91       	ld	r31, X
    425a:	02 84       	ldd	r0, Z+10	; 0x0a
    425c:	f3 85       	ldd	r31, Z+11	; 0x0b
    425e:	e0 2d       	mov	r30, r0
    4260:	19 95       	eicall
    4262:	c8 2f       	mov	r28, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:249
    digitalWrite(_cs, HIGH);
    if (_sck == -1)
      _spi->endTransaction(); // release the SPI bus
  }
  return value;
}
    4264:	8c 2f       	mov	r24, r28
    4266:	cf 91       	pop	r28
    4268:	08 95       	ret
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:239
    _wire->write((uint8_t)reg);
    _wire->endTransmission();
    _wire->requestFrom((uint8_t)_i2caddr, (byte)1);
    value = _wire->read();
  } else {
    if (_sck == -1)
    426a:	80 91 dd 10 	lds	r24, 0x10DD	; 0x8010dd <bme280+0x16>
    426e:	8f 3f       	cpi	r24, 0xFF	; 255
    4270:	21 f4       	brne	.+8      	; 0x427a <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]+0x78>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:240
      _spi->beginTransaction(SPISettings(500000, MSBFIRST, SPI_MODE0));
    4272:	82 e5       	ldi	r24, 0x52	; 82
    4274:	91 e0       	ldi	r25, 0x01	; 1
    4276:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <SPIClass::beginTransaction(SPISettings)>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:241
    digitalWrite(_cs, LOW);
    427a:	60 e0       	ldi	r22, 0x00	; 0
    427c:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    4280:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:242
    spixfer(reg | 0x80); // read, bit 7 high
    4284:	8c 2f       	mov	r24, r28
    4286:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:243
    value = spixfer(0);
    428a:	80 e0       	ldi	r24, 0x00	; 0
    428c:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <Adafruit_BME280::spixfer(unsigned char) [clone .constprop.89]>
    4290:	c8 2f       	mov	r28, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:244
    digitalWrite(_cs, HIGH);
    4292:	61 e0       	ldi	r22, 0x01	; 1
    4294:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    4298:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
    429c:	e3 cf       	rjmp	.-58     	; 0x4264 <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]+0x62>

0000429e <Adafruit_BME280::init() [clone .constprop.73]>:
init():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:95

/*!
 *   @brief  Initialise sensor with given parameters / settings
 *   @returns true on success, false otherwise
 */
bool Adafruit_BME280::init() {
    429e:	cf 93       	push	r28
    42a0:	df 93       	push	r29
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:97
  // init I2C or SPI sensor interface
  if (_cs == -1) {
    42a2:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    42a6:	8f 3f       	cpi	r24, 0xFF	; 255
    42a8:	09 f0       	breq	.+2      	; 0x42ac <Adafruit_BME280::init() [clone .constprop.73]+0xe>
    42aa:	0e c1       	rjmp	.+540    	; 0x44c8 <Adafruit_BME280::init() [clone .constprop.73]+0x22a>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:99
    // I2C
    _wire->begin();
    42ac:	0e 94 a5 1a 	call	0x354a	; 0x354a <TwoWire::begin() [clone .constprop.113]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:115
      pinMode(_miso, INPUT);
    }
  }

  // check if sensor, i.e. the chip ID is correct
  _sensorID = read8(BME280_REGISTER_CHIPID);
    42b0:	80 ed       	ldi	r24, 0xD0	; 208
    42b2:	0e 94 01 21 	call	0x4202	; 0x4202 <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]>
    42b6:	90 e0       	ldi	r25, 0x00	; 0
    42b8:	b0 e0       	ldi	r27, 0x00	; 0
    42ba:	a0 e0       	ldi	r26, 0x00	; 0
    42bc:	80 93 d2 10 	sts	0x10D2, r24	; 0x8010d2 <bme280+0xb>
    42c0:	90 93 d3 10 	sts	0x10D3, r25	; 0x8010d3 <bme280+0xc>
    42c4:	a0 93 d4 10 	sts	0x10D4, r26	; 0x8010d4 <bme280+0xd>
    42c8:	b0 93 d5 10 	sts	0x10D5, r27	; 0x8010d5 <bme280+0xe>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:116
  if (_sensorID != 0x60)
    42cc:	80 36       	cpi	r24, 0x60	; 96
    42ce:	91 05       	cpc	r25, r1
    42d0:	a1 05       	cpc	r26, r1
    42d2:	b1 05       	cpc	r27, r1
    42d4:	09 f0       	breq	.+2      	; 0x42d8 <Adafruit_BME280::init() [clone .constprop.73]+0x3a>
    42d6:	15 c1       	rjmp	.+554    	; 0x4502 <Adafruit_BME280::init() [clone .constprop.73]+0x264>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:121
    return false;

  // reset the device using soft-reset
  // this makes sure the IIR is off, etc.
  write8(BME280_REGISTER_SOFTRESET, 0xB6);
    42d8:	66 eb       	ldi	r22, 0xB6	; 182
    42da:	80 ee       	ldi	r24, 0xE0	; 224
    42dc:	0e 94 ff 1c 	call	0x39fe	; 0x39fe <Adafruit_BME280::write8(unsigned char, unsigned char) [clone .constprop.82]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:124

  // wait for chip to wake up.
  delay(10);
    42e0:	6a e0       	ldi	r22, 0x0A	; 10
    42e2:	70 e0       	ldi	r23, 0x00	; 0
    42e4:	80 e0       	ldi	r24, 0x00	; 0
    42e6:	90 e0       	ldi	r25, 0x00	; 0
    42e8:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
isReadingCalibration():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:407
/*!
 *   @brief return true if chip is busy reading cal data
 *   @returns true if reading calibration, false otherwise
 */
bool Adafruit_BME280::isReadingCalibration(void) {
  uint8_t const rStatus = read8(BME280_REGISTER_STATUS);
    42ec:	83 ef       	ldi	r24, 0xF3	; 243
    42ee:	0e 94 01 21 	call	0x4202	; 0x4202 <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]>
init():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:127

  // wait for chip to wake up.
  delay(10);

  // if chip is still reading calibration, delay
  while (isReadingCalibration())
    42f2:	80 fd       	sbrc	r24, 0
    42f4:	f5 cf       	rjmp	.-22     	; 0x42e0 <Adafruit_BME280::init() [clone .constprop.73]+0x42>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:378

/*!
 *   @brief  Reads the factory-set coefficients
 */
void Adafruit_BME280::readCoefficients(void) {
  _bme280_calib.dig_T1 = read16_LE(BME280_REGISTER_DIG_T1);
    42f6:	88 e8       	ldi	r24, 0x88	; 136
    42f8:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
    42fc:	90 93 e3 10 	sts	0x10E3, r25	; 0x8010e3 <bme280+0x1c>
    4300:	80 93 e2 10 	sts	0x10E2, r24	; 0x8010e2 <bme280+0x1b>
readS16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:302
 *   @brief  Reads a signed little endian 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
int16_t Adafruit_BME280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    4304:	8a e8       	ldi	r24, 0x8A	; 138
    4306:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:379
/*!
 *   @brief  Reads the factory-set coefficients
 */
void Adafruit_BME280::readCoefficients(void) {
  _bme280_calib.dig_T1 = read16_LE(BME280_REGISTER_DIG_T1);
  _bme280_calib.dig_T2 = readS16_LE(BME280_REGISTER_DIG_T2);
    430a:	90 93 e5 10 	sts	0x10E5, r25	; 0x8010e5 <bme280+0x1e>
    430e:	80 93 e4 10 	sts	0x10E4, r24	; 0x8010e4 <bme280+0x1d>
readS16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:302
 *   @brief  Reads a signed little endian 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
int16_t Adafruit_BME280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    4312:	8c e8       	ldi	r24, 0x8C	; 140
    4314:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:380
 *   @brief  Reads the factory-set coefficients
 */
void Adafruit_BME280::readCoefficients(void) {
  _bme280_calib.dig_T1 = read16_LE(BME280_REGISTER_DIG_T1);
  _bme280_calib.dig_T2 = readS16_LE(BME280_REGISTER_DIG_T2);
  _bme280_calib.dig_T3 = readS16_LE(BME280_REGISTER_DIG_T3);
    4318:	90 93 e7 10 	sts	0x10E7, r25	; 0x8010e7 <bme280+0x20>
    431c:	80 93 e6 10 	sts	0x10E6, r24	; 0x8010e6 <bme280+0x1f>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:382

  _bme280_calib.dig_P1 = read16_LE(BME280_REGISTER_DIG_P1);
    4320:	8e e8       	ldi	r24, 0x8E	; 142
    4322:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
    4326:	90 93 e9 10 	sts	0x10E9, r25	; 0x8010e9 <bme280+0x22>
    432a:	80 93 e8 10 	sts	0x10E8, r24	; 0x8010e8 <bme280+0x21>
readS16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:302
 *   @brief  Reads a signed little endian 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
int16_t Adafruit_BME280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    432e:	80 e9       	ldi	r24, 0x90	; 144
    4330:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:383
  _bme280_calib.dig_T1 = read16_LE(BME280_REGISTER_DIG_T1);
  _bme280_calib.dig_T2 = readS16_LE(BME280_REGISTER_DIG_T2);
  _bme280_calib.dig_T3 = readS16_LE(BME280_REGISTER_DIG_T3);

  _bme280_calib.dig_P1 = read16_LE(BME280_REGISTER_DIG_P1);
  _bme280_calib.dig_P2 = readS16_LE(BME280_REGISTER_DIG_P2);
    4334:	90 93 eb 10 	sts	0x10EB, r25	; 0x8010eb <bme280+0x24>
    4338:	80 93 ea 10 	sts	0x10EA, r24	; 0x8010ea <bme280+0x23>
readS16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:302
 *   @brief  Reads a signed little endian 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
int16_t Adafruit_BME280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    433c:	82 e9       	ldi	r24, 0x92	; 146
    433e:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:384
  _bme280_calib.dig_T2 = readS16_LE(BME280_REGISTER_DIG_T2);
  _bme280_calib.dig_T3 = readS16_LE(BME280_REGISTER_DIG_T3);

  _bme280_calib.dig_P1 = read16_LE(BME280_REGISTER_DIG_P1);
  _bme280_calib.dig_P2 = readS16_LE(BME280_REGISTER_DIG_P2);
  _bme280_calib.dig_P3 = readS16_LE(BME280_REGISTER_DIG_P3);
    4342:	90 93 ed 10 	sts	0x10ED, r25	; 0x8010ed <bme280+0x26>
    4346:	80 93 ec 10 	sts	0x10EC, r24	; 0x8010ec <bme280+0x25>
readS16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:302
 *   @brief  Reads a signed little endian 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
int16_t Adafruit_BME280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    434a:	84 e9       	ldi	r24, 0x94	; 148
    434c:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:385
  _bme280_calib.dig_T3 = readS16_LE(BME280_REGISTER_DIG_T3);

  _bme280_calib.dig_P1 = read16_LE(BME280_REGISTER_DIG_P1);
  _bme280_calib.dig_P2 = readS16_LE(BME280_REGISTER_DIG_P2);
  _bme280_calib.dig_P3 = readS16_LE(BME280_REGISTER_DIG_P3);
  _bme280_calib.dig_P4 = readS16_LE(BME280_REGISTER_DIG_P4);
    4350:	90 93 ef 10 	sts	0x10EF, r25	; 0x8010ef <bme280+0x28>
    4354:	80 93 ee 10 	sts	0x10EE, r24	; 0x8010ee <bme280+0x27>
readS16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:302
 *   @brief  Reads a signed little endian 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
int16_t Adafruit_BME280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    4358:	86 e9       	ldi	r24, 0x96	; 150
    435a:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:386

  _bme280_calib.dig_P1 = read16_LE(BME280_REGISTER_DIG_P1);
  _bme280_calib.dig_P2 = readS16_LE(BME280_REGISTER_DIG_P2);
  _bme280_calib.dig_P3 = readS16_LE(BME280_REGISTER_DIG_P3);
  _bme280_calib.dig_P4 = readS16_LE(BME280_REGISTER_DIG_P4);
  _bme280_calib.dig_P5 = readS16_LE(BME280_REGISTER_DIG_P5);
    435e:	90 93 f1 10 	sts	0x10F1, r25	; 0x8010f1 <bme280+0x2a>
    4362:	80 93 f0 10 	sts	0x10F0, r24	; 0x8010f0 <bme280+0x29>
readS16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:302
 *   @brief  Reads a signed little endian 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
int16_t Adafruit_BME280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    4366:	88 e9       	ldi	r24, 0x98	; 152
    4368:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:387
  _bme280_calib.dig_P1 = read16_LE(BME280_REGISTER_DIG_P1);
  _bme280_calib.dig_P2 = readS16_LE(BME280_REGISTER_DIG_P2);
  _bme280_calib.dig_P3 = readS16_LE(BME280_REGISTER_DIG_P3);
  _bme280_calib.dig_P4 = readS16_LE(BME280_REGISTER_DIG_P4);
  _bme280_calib.dig_P5 = readS16_LE(BME280_REGISTER_DIG_P5);
  _bme280_calib.dig_P6 = readS16_LE(BME280_REGISTER_DIG_P6);
    436c:	90 93 f3 10 	sts	0x10F3, r25	; 0x8010f3 <bme280+0x2c>
    4370:	80 93 f2 10 	sts	0x10F2, r24	; 0x8010f2 <bme280+0x2b>
readS16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:302
 *   @brief  Reads a signed little endian 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
int16_t Adafruit_BME280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    4374:	8a e9       	ldi	r24, 0x9A	; 154
    4376:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:388
  _bme280_calib.dig_P2 = readS16_LE(BME280_REGISTER_DIG_P2);
  _bme280_calib.dig_P3 = readS16_LE(BME280_REGISTER_DIG_P3);
  _bme280_calib.dig_P4 = readS16_LE(BME280_REGISTER_DIG_P4);
  _bme280_calib.dig_P5 = readS16_LE(BME280_REGISTER_DIG_P5);
  _bme280_calib.dig_P6 = readS16_LE(BME280_REGISTER_DIG_P6);
  _bme280_calib.dig_P7 = readS16_LE(BME280_REGISTER_DIG_P7);
    437a:	90 93 f5 10 	sts	0x10F5, r25	; 0x8010f5 <bme280+0x2e>
    437e:	80 93 f4 10 	sts	0x10F4, r24	; 0x8010f4 <bme280+0x2d>
readS16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:302
 *   @brief  Reads a signed little endian 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
int16_t Adafruit_BME280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    4382:	8c e9       	ldi	r24, 0x9C	; 156
    4384:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:389
  _bme280_calib.dig_P3 = readS16_LE(BME280_REGISTER_DIG_P3);
  _bme280_calib.dig_P4 = readS16_LE(BME280_REGISTER_DIG_P4);
  _bme280_calib.dig_P5 = readS16_LE(BME280_REGISTER_DIG_P5);
  _bme280_calib.dig_P6 = readS16_LE(BME280_REGISTER_DIG_P6);
  _bme280_calib.dig_P7 = readS16_LE(BME280_REGISTER_DIG_P7);
  _bme280_calib.dig_P8 = readS16_LE(BME280_REGISTER_DIG_P8);
    4388:	90 93 f7 10 	sts	0x10F7, r25	; 0x8010f7 <bme280+0x30>
    438c:	80 93 f6 10 	sts	0x10F6, r24	; 0x8010f6 <bme280+0x2f>
readS16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:302
 *   @brief  Reads a signed little endian 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
int16_t Adafruit_BME280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    4390:	8e e9       	ldi	r24, 0x9E	; 158
    4392:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:390
  _bme280_calib.dig_P4 = readS16_LE(BME280_REGISTER_DIG_P4);
  _bme280_calib.dig_P5 = readS16_LE(BME280_REGISTER_DIG_P5);
  _bme280_calib.dig_P6 = readS16_LE(BME280_REGISTER_DIG_P6);
  _bme280_calib.dig_P7 = readS16_LE(BME280_REGISTER_DIG_P7);
  _bme280_calib.dig_P8 = readS16_LE(BME280_REGISTER_DIG_P8);
  _bme280_calib.dig_P9 = readS16_LE(BME280_REGISTER_DIG_P9);
    4396:	90 93 f9 10 	sts	0x10F9, r25	; 0x8010f9 <bme280+0x32>
    439a:	80 93 f8 10 	sts	0x10F8, r24	; 0x8010f8 <bme280+0x31>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:392

  _bme280_calib.dig_H1 = read8(BME280_REGISTER_DIG_H1);
    439e:	81 ea       	ldi	r24, 0xA1	; 161
    43a0:	0e 94 01 21 	call	0x4202	; 0x4202 <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]>
    43a4:	80 93 fa 10 	sts	0x10FA, r24	; 0x8010fa <bme280+0x33>
readS16_LE():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:302
 *   @brief  Reads a signed little endian 16 bit value over I2C or SPI
 *   @param reg the register address to read from
 *   @returns the 16 bit data value read from the device
 */
int16_t Adafruit_BME280::readS16_LE(byte reg) {
  return (int16_t)read16_LE(reg);
    43a8:	81 ee       	ldi	r24, 0xE1	; 225
    43aa:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <Adafruit_BME280::read16_LE(unsigned char) [clone .constprop.76]>
readCoefficients():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:393
  _bme280_calib.dig_P7 = readS16_LE(BME280_REGISTER_DIG_P7);
  _bme280_calib.dig_P8 = readS16_LE(BME280_REGISTER_DIG_P8);
  _bme280_calib.dig_P9 = readS16_LE(BME280_REGISTER_DIG_P9);

  _bme280_calib.dig_H1 = read8(BME280_REGISTER_DIG_H1);
  _bme280_calib.dig_H2 = readS16_LE(BME280_REGISTER_DIG_H2);
    43ae:	90 93 fc 10 	sts	0x10FC, r25	; 0x8010fc <bme280+0x35>
    43b2:	80 93 fb 10 	sts	0x10FB, r24	; 0x8010fb <bme280+0x34>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:394
  _bme280_calib.dig_H3 = read8(BME280_REGISTER_DIG_H3);
    43b6:	83 ee       	ldi	r24, 0xE3	; 227
    43b8:	0e 94 01 21 	call	0x4202	; 0x4202 <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]>
    43bc:	80 93 fd 10 	sts	0x10FD, r24	; 0x8010fd <bme280+0x36>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:395
  _bme280_calib.dig_H4 = ((int8_t)read8(BME280_REGISTER_DIG_H4) << 4) |
    43c0:	84 ee       	ldi	r24, 0xE4	; 228
    43c2:	0e 94 01 21 	call	0x4202	; 0x4202 <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]>
    43c6:	c8 2f       	mov	r28, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:396
                         (read8(BME280_REGISTER_DIG_H4 + 1) & 0xF);
    43c8:	85 ee       	ldi	r24, 0xE5	; 229
    43ca:	0e 94 01 21 	call	0x4202	; 0x4202 <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:395
  _bme280_calib.dig_P9 = readS16_LE(BME280_REGISTER_DIG_P9);

  _bme280_calib.dig_H1 = read8(BME280_REGISTER_DIG_H1);
  _bme280_calib.dig_H2 = readS16_LE(BME280_REGISTER_DIG_H2);
  _bme280_calib.dig_H3 = read8(BME280_REGISTER_DIG_H3);
  _bme280_calib.dig_H4 = ((int8_t)read8(BME280_REGISTER_DIG_H4) << 4) |
    43ce:	90 e1       	ldi	r25, 0x10	; 16
    43d0:	c9 02       	muls	r28, r25
    43d2:	90 01       	movw	r18, r0
    43d4:	11 24       	eor	r1, r1
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:396
                         (read8(BME280_REGISTER_DIG_H4 + 1) & 0xF);
    43d6:	8f 70       	andi	r24, 0x0F	; 15
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:395
  _bme280_calib.dig_P9 = readS16_LE(BME280_REGISTER_DIG_P9);

  _bme280_calib.dig_H1 = read8(BME280_REGISTER_DIG_H1);
  _bme280_calib.dig_H2 = readS16_LE(BME280_REGISTER_DIG_H2);
  _bme280_calib.dig_H3 = read8(BME280_REGISTER_DIG_H3);
  _bme280_calib.dig_H4 = ((int8_t)read8(BME280_REGISTER_DIG_H4) << 4) |
    43d8:	28 2b       	or	r18, r24
    43da:	30 93 ff 10 	sts	0x10FF, r19	; 0x8010ff <bme280+0x38>
    43de:	20 93 fe 10 	sts	0x10FE, r18	; 0x8010fe <bme280+0x37>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:397
                         (read8(BME280_REGISTER_DIG_H4 + 1) & 0xF);
  _bme280_calib.dig_H5 = ((int8_t)read8(BME280_REGISTER_DIG_H5 + 1) << 4) |
    43e2:	86 ee       	ldi	r24, 0xE6	; 230
    43e4:	0e 94 01 21 	call	0x4202	; 0x4202 <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]>
    43e8:	c8 2f       	mov	r28, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:398
                         (read8(BME280_REGISTER_DIG_H5) >> 4);
    43ea:	85 ee       	ldi	r24, 0xE5	; 229
    43ec:	0e 94 01 21 	call	0x4202	; 0x4202 <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:397
  _bme280_calib.dig_H1 = read8(BME280_REGISTER_DIG_H1);
  _bme280_calib.dig_H2 = readS16_LE(BME280_REGISTER_DIG_H2);
  _bme280_calib.dig_H3 = read8(BME280_REGISTER_DIG_H3);
  _bme280_calib.dig_H4 = ((int8_t)read8(BME280_REGISTER_DIG_H4) << 4) |
                         (read8(BME280_REGISTER_DIG_H4 + 1) & 0xF);
  _bme280_calib.dig_H5 = ((int8_t)read8(BME280_REGISTER_DIG_H5 + 1) << 4) |
    43f0:	90 e1       	ldi	r25, 0x10	; 16
    43f2:	c9 02       	muls	r28, r25
    43f4:	e0 01       	movw	r28, r0
    43f6:	11 24       	eor	r1, r1
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:398
                         (read8(BME280_REGISTER_DIG_H5) >> 4);
    43f8:	90 e0       	ldi	r25, 0x00	; 0
    43fa:	24 e0       	ldi	r18, 0x04	; 4
    43fc:	95 95       	asr	r25
    43fe:	87 95       	ror	r24
    4400:	2a 95       	dec	r18
    4402:	e1 f7       	brne	.-8      	; 0x43fc <Adafruit_BME280::init() [clone .constprop.73]+0x15e>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:397
  _bme280_calib.dig_H1 = read8(BME280_REGISTER_DIG_H1);
  _bme280_calib.dig_H2 = readS16_LE(BME280_REGISTER_DIG_H2);
  _bme280_calib.dig_H3 = read8(BME280_REGISTER_DIG_H3);
  _bme280_calib.dig_H4 = ((int8_t)read8(BME280_REGISTER_DIG_H4) << 4) |
                         (read8(BME280_REGISTER_DIG_H4 + 1) & 0xF);
  _bme280_calib.dig_H5 = ((int8_t)read8(BME280_REGISTER_DIG_H5 + 1) << 4) |
    4404:	8c 2b       	or	r24, r28
    4406:	9d 2b       	or	r25, r29
    4408:	90 93 01 11 	sts	0x1101, r25	; 0x801101 <bme280+0x3a>
    440c:	80 93 00 11 	sts	0x1100, r24	; 0x801100 <bme280+0x39>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:399
                         (read8(BME280_REGISTER_DIG_H5) >> 4);
  _bme280_calib.dig_H6 = (int8_t)read8(BME280_REGISTER_DIG_H6);
    4410:	87 ee       	ldi	r24, 0xE7	; 231
    4412:	0e 94 01 21 	call	0x4202	; 0x4202 <Adafruit_BME280::read8(unsigned char) [clone .constprop.77]>
    4416:	80 93 02 11 	sts	0x1102, r24	; 0x801102 <bme280+0x3b>
setSampling():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:158
                                  sensor_sampling pressSampling,
                                  sensor_sampling humSampling,
                                  sensor_filter filter,
                                  standby_duration duration) {
  _measReg.mode = mode;
  _measReg.osrs_t = tempSampling;
    441a:	8d ee       	ldi	r24, 0xED	; 237
    441c:	80 93 04 11 	sts	0x1104, r24	; 0x801104 <bme280+0x3d>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:161
  _measReg.osrs_p = pressSampling;

  _humReg.osrs_h = humSampling;
    4420:	80 91 05 11 	lds	r24, 0x1105	; 0x801105 <bme280+0x3e>
    4424:	8f 71       	andi	r24, 0x1F	; 31
    4426:	80 6a       	ori	r24, 0xA0	; 160
    4428:	80 93 05 11 	sts	0x1105, r24	; 0x801105 <bme280+0x3e>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:162
  _configReg.filter = filter;
    442c:	80 91 03 11 	lds	r24, 0x1103	; 0x801103 <bme280+0x3c>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:163
  _configReg.t_sb = duration;
    4430:	80 7c       	andi	r24, 0xC0	; 192
    4432:	80 93 03 11 	sts	0x1103, r24	; 0x801103 <bme280+0x3c>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:167

  // making sure sensor is in sleep mode before setting configuration
  // as it otherwise may be ignored
  write8(BME280_REGISTER_CONTROL, MODE_SLEEP);
    4436:	60 e0       	ldi	r22, 0x00	; 0
    4438:	84 ef       	ldi	r24, 0xF4	; 244
    443a:	0e 94 ff 1c 	call	0x39fe	; 0x39fe <Adafruit_BME280::write8(unsigned char, unsigned char) [clone .constprop.82]>
_ZN15Adafruit_BME2808ctrl_hum3getEv():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.h:373
    // 100 = x8
    // 101 and above = x16
    unsigned int osrs_h : 3; ///< pressure oversampling

    /// @return combined ctrl hum register
    unsigned int get() { return (osrs_h); }
    443e:	60 91 05 11 	lds	r22, 0x1105	; 0x801105 <bme280+0x3e>
    4442:	62 95       	swap	r22
    4444:	66 95       	lsr	r22
    4446:	67 70       	andi	r22, 0x07	; 7
setSampling():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:172

  // you must make sure to also set REGISTER_CONTROL after setting the
  // CONTROLHUMID register, otherwise the values won't be applied (see
  // DS 5.4.3)
  write8(BME280_REGISTER_CONTROLHUMID, _humReg.get());
    4448:	82 ef       	ldi	r24, 0xF2	; 242
    444a:	0e 94 ff 1c 	call	0x39fe	; 0x39fe <Adafruit_BME280::write8(unsigned char, unsigned char) [clone .constprop.82]>
get():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.h:315
    // unused - don't set
    unsigned int none : 1;     ///< unused - don't set
    unsigned int spi3w_en : 1; ///< unused - don't set

    /// @return combined config register
    unsigned int get() { return (t_sb << 5) | (filter << 2) | spi3w_en; }
    444e:	80 91 03 11 	lds	r24, 0x1103	; 0x801103 <bme280+0x3c>
    4452:	68 2f       	mov	r22, r24
    4454:	67 70       	andi	r22, 0x07	; 7
    4456:	90 e2       	ldi	r25, 0x20	; 32
    4458:	69 9f       	mul	r22, r25
    445a:	b0 01       	movw	r22, r0
    445c:	11 24       	eor	r1, r1
    445e:	28 2f       	mov	r18, r24
    4460:	26 95       	lsr	r18
    4462:	26 95       	lsr	r18
    4464:	26 95       	lsr	r18
    4466:	27 70       	andi	r18, 0x07	; 7
    4468:	94 e0       	ldi	r25, 0x04	; 4
    446a:	29 9f       	mul	r18, r25
    446c:	90 01       	movw	r18, r0
    446e:	11 24       	eor	r1, r1
    4470:	62 2b       	or	r22, r18
    4472:	87 fb       	bst	r24, 7
    4474:	88 27       	eor	r24, r24
    4476:	80 f9       	bld	r24, 0
    4478:	68 2b       	or	r22, r24
setSampling():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:173
  write8(BME280_REGISTER_CONFIG, _configReg.get());
    447a:	85 ef       	ldi	r24, 0xF5	; 245
    447c:	0e 94 ff 1c 	call	0x39fe	; 0x39fe <Adafruit_BME280::write8(unsigned char, unsigned char) [clone .constprop.82]>
get():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.h:350
    // 01 or 10 = forced
    // 11       = normal
    unsigned int mode : 2; ///< device mode

    /// @return combined ctrl register
    unsigned int get() { return (osrs_t << 5) | (osrs_p << 2) | mode; }
    4480:	80 91 04 11 	lds	r24, 0x1104	; 0x801104 <bme280+0x3d>
    4484:	68 2f       	mov	r22, r24
    4486:	67 70       	andi	r22, 0x07	; 7
    4488:	90 e2       	ldi	r25, 0x20	; 32
    448a:	69 9f       	mul	r22, r25
    448c:	b0 01       	movw	r22, r0
    448e:	11 24       	eor	r1, r1
    4490:	28 2f       	mov	r18, r24
    4492:	26 95       	lsr	r18
    4494:	26 95       	lsr	r18
    4496:	26 95       	lsr	r18
    4498:	27 70       	andi	r18, 0x07	; 7
    449a:	94 e0       	ldi	r25, 0x04	; 4
    449c:	29 9f       	mul	r18, r25
    449e:	90 01       	movw	r18, r0
    44a0:	11 24       	eor	r1, r1
    44a2:	62 2b       	or	r22, r18
    44a4:	82 95       	swap	r24
    44a6:	86 95       	lsr	r24
    44a8:	86 95       	lsr	r24
    44aa:	83 70       	andi	r24, 0x03	; 3
    44ac:	68 2b       	or	r22, r24
setSampling():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:174
  write8(BME280_REGISTER_CONTROL, _measReg.get());
    44ae:	84 ef       	ldi	r24, 0xF4	; 244
    44b0:	0e 94 ff 1c 	call	0x39fe	; 0x39fe <Adafruit_BME280::write8(unsigned char, unsigned char) [clone .constprop.82]>
init():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:134

  readCoefficients(); // read trimming parameters, see DS 4.2.2

  setSampling(); // use defaults

  delay(100);
    44b4:	64 e6       	ldi	r22, 0x64	; 100
    44b6:	70 e0       	ldi	r23, 0x00	; 0
    44b8:	80 e0       	ldi	r24, 0x00	; 0
    44ba:	90 e0       	ldi	r25, 0x00	; 0
    44bc:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:136

  return true;
    44c0:	81 e0       	ldi	r24, 0x01	; 1
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:137
}
    44c2:	df 91       	pop	r29
    44c4:	cf 91       	pop	r28
    44c6:	08 95       	ret
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:101
  // init I2C or SPI sensor interface
  if (_cs == -1) {
    // I2C
    _wire->begin();
  } else {
    digitalWrite(_cs, HIGH);
    44c8:	61 e0       	ldi	r22, 0x01	; 1
    44ca:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:102
    pinMode(_cs, OUTPUT);
    44ce:	61 e0       	ldi	r22, 0x01	; 1
    44d0:	80 91 da 10 	lds	r24, 0x10DA	; 0x8010da <bme280+0x13>
    44d4:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:103
    if (_sck == -1) {
    44d8:	80 91 dd 10 	lds	r24, 0x10DD	; 0x8010dd <bme280+0x16>
    44dc:	8f 3f       	cpi	r24, 0xFF	; 255
    44de:	19 f4       	brne	.+6      	; 0x44e6 <Adafruit_BME280::init() [clone .constprop.73]+0x248>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:105
      // hardware SPI
      _spi->begin();
    44e0:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <SPIClass::begin()>
    44e4:	e5 ce       	rjmp	.-566    	; 0x42b0 <Adafruit_BME280::init() [clone .constprop.73]+0x12>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:108
    } else {
      // software SPI
      pinMode(_sck, OUTPUT);
    44e6:	61 e0       	ldi	r22, 0x01	; 1
    44e8:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:109
      pinMode(_mosi, OUTPUT);
    44ec:	61 e0       	ldi	r22, 0x01	; 1
    44ee:	80 91 db 10 	lds	r24, 0x10DB	; 0x8010db <bme280+0x14>
    44f2:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:110
      pinMode(_miso, INPUT);
    44f6:	60 e0       	ldi	r22, 0x00	; 0
    44f8:	80 91 dc 10 	lds	r24, 0x10DC	; 0x8010dc <bme280+0x15>
    44fc:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
    4500:	d7 ce       	rjmp	.-594    	; 0x42b0 <Adafruit_BME280::init() [clone .constprop.73]+0x12>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:117
  }

  // check if sensor, i.e. the chip ID is correct
  _sensorID = read8(BME280_REGISTER_CHIPID);
  if (_sensorID != 0x60)
    return false;
    4502:	80 e0       	ldi	r24, 0x00	; 0
    4504:	de cf       	rjmp	.-68     	; 0x44c2 <Adafruit_BME280::init() [clone .constprop.73]+0x224>

00004506 <LiquidCrystal_I2C::write4bits(unsigned char)>:
write4bits():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:247
	uint8_t lownib=(value<<4)&0xf0;
       write4bits((highnib)|mode);
	write4bits((lownib)|mode); 
}

void LiquidCrystal_I2C::write4bits(uint8_t value) {
    4506:	0f 93       	push	r16
    4508:	1f 93       	push	r17
    450a:	cf 93       	push	r28
    450c:	8c 01       	movw	r16, r24
    450e:	c6 2f       	mov	r28, r22
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:248
	expanderWrite(value);
    4510:	0e 94 46 1d 	call	0x3a8c	; 0x3a8c <LiquidCrystal_I2C::expanderWrite(unsigned char)>
pulseEnable():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:259
	printIIC((int)(_data) | _backlightval);
	Wire.endTransmission();   
}

void LiquidCrystal_I2C::pulseEnable(uint8_t _data){
	expanderWrite(_data | En);	// En high
    4514:	6c 2f       	mov	r22, r28
    4516:	64 60       	ori	r22, 0x04	; 4
    4518:	c8 01       	movw	r24, r16
    451a:	0e 94 46 1d 	call	0x3a8c	; 0x3a8c <LiquidCrystal_I2C::expanderWrite(unsigned char)>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:262
	delayMicroseconds(1);		// enable pulse must be >450ns
	
	expanderWrite(_data & ~En);	// En low
    451e:	6c 2f       	mov	r22, r28
    4520:	6b 7f       	andi	r22, 0xFB	; 251
    4522:	c8 01       	movw	r24, r16
    4524:	0e 94 46 1d 	call	0x3a8c	; 0x3a8c <LiquidCrystal_I2C::expanderWrite(unsigned char)>
delayMicroseconds():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:234
	

#endif

	// busy wait
	__asm__ __volatile__ (
    4528:	83 ec       	ldi	r24, 0xC3	; 195
    452a:	90 e0       	ldi	r25, 0x00	; 0
    452c:	01 97       	sbiw	r24, 0x01	; 1
    452e:	f1 f7       	brne	.-4      	; 0x452c <LiquidCrystal_I2C::write4bits(unsigned char)+0x26>
write4bits():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:250
}

void LiquidCrystal_I2C::write4bits(uint8_t value) {
	expanderWrite(value);
	pulseEnable(value);
}
    4530:	cf 91       	pop	r28
    4532:	1f 91       	pop	r17
    4534:	0f 91       	pop	r16
    4536:	08 95       	ret

00004538 <LiquidCrystal_I2C::send(unsigned char, unsigned char)>:
send():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:240


/************ low level data pushing commands **********/

// write either command or data
void LiquidCrystal_I2C::send(uint8_t value, uint8_t mode) {
    4538:	0f 93       	push	r16
    453a:	1f 93       	push	r17
    453c:	cf 93       	push	r28
    453e:	df 93       	push	r29
    4540:	8c 01       	movw	r16, r24
    4542:	d6 2f       	mov	r29, r22
    4544:	c4 2f       	mov	r28, r20
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:241
	uint8_t highnib=value&0xf0;
    4546:	60 7f       	andi	r22, 0xF0	; 240
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:243
	uint8_t lownib=(value<<4)&0xf0;
       write4bits((highnib)|mode);
    4548:	64 2b       	or	r22, r20
    454a:	0e 94 83 22 	call	0x4506	; 0x4506 <LiquidCrystal_I2C::write4bits(unsigned char)>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:242
/************ low level data pushing commands **********/

// write either command or data
void LiquidCrystal_I2C::send(uint8_t value, uint8_t mode) {
	uint8_t highnib=value&0xf0;
	uint8_t lownib=(value<<4)&0xf0;
    454e:	80 e1       	ldi	r24, 0x10	; 16
    4550:	d8 9f       	mul	r29, r24
    4552:	b0 01       	movw	r22, r0
    4554:	11 24       	eor	r1, r1
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:244
       write4bits((highnib)|mode);
	write4bits((lownib)|mode); 
    4556:	6c 2b       	or	r22, r28
    4558:	c8 01       	movw	r24, r16
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:245
}
    455a:	df 91       	pop	r29
    455c:	cf 91       	pop	r28
    455e:	1f 91       	pop	r17
    4560:	0f 91       	pop	r16
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:244
// write either command or data
void LiquidCrystal_I2C::send(uint8_t value, uint8_t mode) {
	uint8_t highnib=value&0xf0;
	uint8_t lownib=(value<<4)&0xf0;
       write4bits((highnib)|mode);
	write4bits((lownib)|mode); 
    4562:	0c 94 83 22 	jmp	0x4506	; 0x4506 <LiquidCrystal_I2C::write4bits(unsigned char)>

00004566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>:
setCursor():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:137
void LiquidCrystal_I2C::home(){
	command(LCD_RETURNHOME);  // set cursor position to zero
	delayMicroseconds(2000);  // this command takes a long time!
}

void LiquidCrystal_I2C::setCursor(uint8_t col, uint8_t row){
    4566:	cf 93       	push	r28
    4568:	df 93       	push	r29
    456a:	00 d0       	rcall	.+0      	; 0x456c <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]+0x6>
    456c:	00 d0       	rcall	.+0      	; 0x456e <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]+0x8>
    456e:	1f 92       	push	r1
    4570:	1f 92       	push	r1
    4572:	cd b7       	in	r28, 0x3d	; 61
    4574:	de b7       	in	r29, 0x3e	; 62
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:138
	int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
    4576:	98 e0       	ldi	r25, 0x08	; 8
    4578:	e5 ed       	ldi	r30, 0xD5	; 213
    457a:	f2 e0       	ldi	r31, 0x02	; 2
    457c:	de 01       	movw	r26, r28
    457e:	11 96       	adiw	r26, 0x01	; 1
    4580:	01 90       	ld	r0, Z+
    4582:	0d 92       	st	X+, r0
    4584:	9a 95       	dec	r25
    4586:	e1 f7       	brne	.-8      	; 0x4580 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]+0x1a>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:139
	if ( row > _numlines ) {
    4588:	90 91 c3 10 	lds	r25, 0x10C3	; 0x8010c3 <lcd+0x8>
    458c:	96 17       	cp	r25, r22
    458e:	10 f4       	brcc	.+4      	; 0x4594 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]+0x2e>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:140
		row = _numlines-1;    // we count rows starting w/0
    4590:	6f ef       	ldi	r22, 0xFF	; 255
    4592:	69 0f       	add	r22, r25
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:142
	}
	command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
    4594:	26 2f       	mov	r18, r22
    4596:	30 e0       	ldi	r19, 0x00	; 0
    4598:	22 0f       	add	r18, r18
    459a:	33 1f       	adc	r19, r19
    459c:	41 e0       	ldi	r20, 0x01	; 1
    459e:	50 e0       	ldi	r21, 0x00	; 0
    45a0:	4c 0f       	add	r20, r28
    45a2:	5d 1f       	adc	r21, r29
    45a4:	24 0f       	add	r18, r20
    45a6:	35 1f       	adc	r19, r21
    45a8:	f9 01       	movw	r30, r18
    45aa:	60 81       	ld	r22, Z
    45ac:	68 0f       	add	r22, r24
    45ae:	60 68       	ori	r22, 0x80	; 128
command():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:233


/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
    45b0:	40 e0       	ldi	r20, 0x00	; 0
    45b2:	8b eb       	ldi	r24, 0xBB	; 187
    45b4:	90 e1       	ldi	r25, 0x10	; 16
setCursor():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:143
	int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
	if ( row > _numlines ) {
		row = _numlines-1;    // we count rows starting w/0
	}
	command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
}
    45b6:	28 96       	adiw	r28, 0x08	; 8
    45b8:	0f b6       	in	r0, 0x3f	; 63
    45ba:	f8 94       	cli
    45bc:	de bf       	out	0x3e, r29	; 62
    45be:	0f be       	out	0x3f, r0	; 63
    45c0:	cd bf       	out	0x3d, r28	; 61
    45c2:	df 91       	pop	r29
    45c4:	cf 91       	pop	r28
command():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:233


/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
    45c6:	0c 94 9c 22 	jmp	0x4538	; 0x4538 <LiquidCrystal_I2C::send(unsigned char, unsigned char)>

000045ca <LiquidCrystal_I2C::clear() [clone .constprop.143]>:
    45ca:	40 e0       	ldi	r20, 0x00	; 0
    45cc:	61 e0       	ldi	r22, 0x01	; 1
    45ce:	8b eb       	ldi	r24, 0xBB	; 187
    45d0:	90 e1       	ldi	r25, 0x10	; 16
    45d2:	0e 94 9c 22 	call	0x4538	; 0x4538 <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
delayMicroseconds():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:234
    45d6:	8b e3       	ldi	r24, 0x3B	; 59
    45d8:	9f e1       	ldi	r25, 0x1F	; 31
    45da:	01 97       	sbiw	r24, 0x01	; 1
    45dc:	f1 f7       	brne	.-4      	; 0x45da <LiquidCrystal_I2C::clear() [clone .constprop.143]+0x10>
clear():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:130

/********** high level commands, for the user! */
void LiquidCrystal_I2C::clear(){
	command(LCD_CLEARDISPLAY);// clear display, set cursor position to zero
	delayMicroseconds(2000);  // this command takes a long time!
}
    45de:	08 95       	ret

000045e0 <LiquidCrystal_I2C::write(unsigned char)>:
write():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:11

#include "Arduino.h"

#define printIIC(args)	Wire.write(args)
inline size_t LiquidCrystal_I2C::write(uint8_t value) {
	send(value, Rs);
    45e0:	41 e0       	ldi	r20, 0x01	; 1
    45e2:	0e 94 9c 22 	call	0x4538	; 0x4538 <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:13
	return 1;
}
    45e6:	81 e0       	ldi	r24, 0x01	; 1
    45e8:	90 e0       	ldi	r25, 0x00	; 0
    45ea:	08 95       	ret

000045ec <LiquidCrystal_I2C::createChar(unsigned char, unsigned char*) [clone .constprop.164]>:
createChar():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:209
	command(LCD_ENTRYMODESET | _displaymode);
}

// Allows us to fill the first 8 CGRAM locations
// with custom characters
void LiquidCrystal_I2C::createChar(uint8_t location, uint8_t charmap[]) {
    45ec:	0f 93       	push	r16
    45ee:	1f 93       	push	r17
    45f0:	cf 93       	push	r28
    45f2:	df 93       	push	r29
    45f4:	8b 01       	movw	r16, r22
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:211
	location &= 0x7; // we only have 8 locations 0-7
	command(LCD_SETCGRAMADDR | (location << 3));
    45f6:	98 e0       	ldi	r25, 0x08	; 8
    45f8:	89 9f       	mul	r24, r25
    45fa:	b0 01       	movw	r22, r0
    45fc:	11 24       	eor	r1, r1
    45fe:	60 64       	ori	r22, 0x40	; 64
command():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:233


/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
    4600:	40 e0       	ldi	r20, 0x00	; 0
    4602:	8b eb       	ldi	r24, 0xBB	; 187
    4604:	90 e1       	ldi	r25, 0x10	; 16
    4606:	0e 94 9c 22 	call	0x4538	; 0x4538 <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
    460a:	e8 01       	movw	r28, r16
    460c:	08 5f       	subi	r16, 0xF8	; 248
    460e:	1f 4f       	sbci	r17, 0xFF	; 255
createChar():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:213
// with custom characters
void LiquidCrystal_I2C::createChar(uint8_t location, uint8_t charmap[]) {
	location &= 0x7; // we only have 8 locations 0-7
	command(LCD_SETCGRAMADDR | (location << 3));
	for (int i=0; i<8; i++) {
		write(charmap[i]);
    4610:	69 91       	ld	r22, Y+
    4612:	8b eb       	ldi	r24, 0xBB	; 187
    4614:	90 e1       	ldi	r25, 0x10	; 16
    4616:	0e 94 f0 22 	call	0x45e0	; 0x45e0 <LiquidCrystal_I2C::write(unsigned char)>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:212
// Allows us to fill the first 8 CGRAM locations
// with custom characters
void LiquidCrystal_I2C::createChar(uint8_t location, uint8_t charmap[]) {
	location &= 0x7; // we only have 8 locations 0-7
	command(LCD_SETCGRAMADDR | (location << 3));
	for (int i=0; i<8; i++) {
    461a:	c0 17       	cp	r28, r16
    461c:	d1 07       	cpc	r29, r17
    461e:	c1 f7       	brne	.-16     	; 0x4610 <LiquidCrystal_I2C::createChar(unsigned char, unsigned char*) [clone .constprop.164]+0x24>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:215
		write(charmap[i]);
	}
}
    4620:	df 91       	pop	r29
    4622:	cf 91       	pop	r28
    4624:	1f 91       	pop	r17
    4626:	0f 91       	pop	r16
    4628:	08 95       	ret

0000462a <Shifty::writeAllBits()>:
writeAllBits():
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:96
void Shifty::writeBitHard(int bitnum, bool value) {
  writeBitSoft(bitnum, value);
  writeAllBits();
}

void Shifty::writeAllBits() {
    462a:	cf 92       	push	r12
    462c:	df 92       	push	r13
    462e:	ef 92       	push	r14
    4630:	ff 92       	push	r15
    4632:	0f 93       	push	r16
    4634:	1f 93       	push	r17
    4636:	cf 93       	push	r28
    4638:	df 93       	push	r29
    463a:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:97
  digitalWrite(latchPin, LOW);
    463c:	60 e0       	ldi	r22, 0x00	; 0
    463e:	8e 81       	ldd	r24, Y+6	; 0x06
    4640:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:98
  digitalWrite(clockPin, LOW);
    4644:	60 e0       	ldi	r22, 0x00	; 0
    4646:	8a 81       	ldd	r24, Y+2	; 0x02
    4648:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
    464c:	8e 01       	movw	r16, r28
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:99
  for(int i = 0; i < this->byteCount; i++) {
    464e:	2a 85       	ldd	r18, Y+10	; 0x0a
    4650:	3b 85       	ldd	r19, Y+11	; 0x0b
    4652:	c8 01       	movw	r24, r16
    4654:	8c 1b       	sub	r24, r28
    4656:	9d 0b       	sbc	r25, r29
    4658:	82 17       	cp	r24, r18
    465a:	93 07       	cpc	r25, r19
    465c:	e4 f4       	brge	.+56     	; 0x4696 <Shifty::writeAllBits()+0x6c>
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:100
    shiftOut(dataPin, clockPin, MSBFIRST, this->writeBuffer[i]);
    465e:	f8 01       	movw	r30, r16
    4660:	e4 84       	ldd	r14, Z+12	; 0x0c
    4662:	da 80       	ldd	r13, Y+2	; 0x02
    4664:	c8 80       	ld	r12, Y
    4666:	88 e0       	ldi	r24, 0x08	; 8
    4668:	f8 2e       	mov	r15, r24
shiftOut():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_shift.c:49
	for (i = 0; i < 8; i++)  {
		if (bitOrder == LSBFIRST) {
			digitalWrite(dataPin, val & 1);
			val >>= 1;
		} else {	
			digitalWrite(dataPin, (val & 128) != 0);
    466a:	6e 2d       	mov	r22, r14
    466c:	66 1f       	adc	r22, r22
    466e:	66 27       	eor	r22, r22
    4670:	66 1f       	adc	r22, r22
    4672:	8c 2d       	mov	r24, r12
    4674:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_shift.c:50
			val <<= 1;
    4678:	ee 0c       	add	r14, r14
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_shift.c:53
		}
			
		digitalWrite(clockPin, HIGH);
    467a:	61 e0       	ldi	r22, 0x01	; 1
    467c:	8d 2d       	mov	r24, r13
    467e:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_shift.c:54
		digitalWrite(clockPin, LOW);		
    4682:	60 e0       	ldi	r22, 0x00	; 0
    4684:	8d 2d       	mov	r24, r13
    4686:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
    468a:	fa 94       	dec	r15
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_shift.c:44

void shiftOut(uint8_t dataPin, uint8_t clockPin, uint8_t bitOrder, uint8_t val)
{
	uint8_t i;

	for (i = 0; i < 8; i++)  {
    468c:	f1 10       	cpse	r15, r1
    468e:	ed cf       	rjmp	.-38     	; 0x466a <Shifty::writeAllBits()+0x40>
    4690:	0f 5f       	subi	r16, 0xFF	; 255
    4692:	1f 4f       	sbci	r17, 0xFF	; 255
    4694:	dc cf       	rjmp	.-72     	; 0x464e <Shifty::writeAllBits()+0x24>
writeAllBits():
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:102
  }
  digitalWrite(latchPin, HIGH);
    4696:	61 e0       	ldi	r22, 0x01	; 1
    4698:	8e 81       	ldd	r24, Y+6	; 0x06
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:103
}
    469a:	df 91       	pop	r29
    469c:	cf 91       	pop	r28
    469e:	1f 91       	pop	r17
    46a0:	0f 91       	pop	r16
    46a2:	ff 90       	pop	r15
    46a4:	ef 90       	pop	r14
    46a6:	df 90       	pop	r13
    46a8:	cf 90       	pop	r12
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:102
  digitalWrite(latchPin, LOW);
  digitalWrite(clockPin, LOW);
  for(int i = 0; i < this->byteCount; i++) {
    shiftOut(dataPin, clockPin, MSBFIRST, this->writeBuffer[i]);
  }
  digitalWrite(latchPin, HIGH);
    46aa:	0c 94 3f 08 	jmp	0x107e	; 0x107e <digitalWrite>

000046ae <BlinkControl::_onOne(bool) [clone .constprop.45]>:
_onOne():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:129
    analogWrite(this->_pin, this->_dutyCycle);
    #endif
  }
}

void BlinkControl::_onOne(bool shiftRegOffOthers) {
    46ae:	cf 93       	push	r28
    46b0:	df 93       	push	r29
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:133
  #if defined(ESP32)
  this->_pwmDetachPin();
  #endif
  if (this->_shiftReg == NULL) {
    46b2:	fc 01       	movw	r30, r24
    46b4:	c6 81       	ldd	r28, Z+6	; 0x06
    46b6:	d7 81       	ldd	r29, Z+7	; 0x07
    46b8:	84 81       	ldd	r24, Z+4	; 0x04
    46ba:	95 81       	ldd	r25, Z+5	; 0x05
    46bc:	20 97       	sbiw	r28, 0x00	; 0
    46be:	29 f4       	brne	.+10     	; 0x46ca <BlinkControl::_onOne(bool) [clone .constprop.45]+0x1c>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:134
    digitalWrite(this->_pin, HIGH);
    46c0:	61 e0       	ldi	r22, 0x01	; 1
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:142
      this->_shiftReg->writeBit(this->_pin, HIGH);
    } else {
      this->_shiftRegOnePinOnOnly(this->_pin, HIGH);
    }
  }
}
    46c2:	df 91       	pop	r29
    46c4:	cf 91       	pop	r28
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:134
void BlinkControl::_onOne(bool shiftRegOffOthers) {
  #if defined(ESP32)
  this->_pwmDetachPin();
  #endif
  if (this->_shiftReg == NULL) {
    digitalWrite(this->_pin, HIGH);
    46c6:	0c 94 3f 08 	jmp	0x107e	; 0x107e <digitalWrite>
    46ca:	fc 01       	movw	r30, r24
    46cc:	97 fd       	sbrc	r25, 7
    46ce:	37 96       	adiw	r30, 0x07	; 7
    46d0:	23 e0       	ldi	r18, 0x03	; 3
    46d2:	f5 95       	asr	r31
    46d4:	e7 95       	ror	r30
    46d6:	2a 95       	dec	r18
    46d8:	e1 f7       	brne	.-8      	; 0x46d2 <BlinkControl::_onOne(bool) [clone .constprop.45]+0x24>
    46da:	68 e0       	ldi	r22, 0x08	; 8
    46dc:	70 e0       	ldi	r23, 0x00	; 0
    46de:	0e 94 17 6c 	call	0xd82e	; 0xd82e <__divmodhi4>
    46e2:	28 2f       	mov	r18, r24
    46e4:	81 e0       	ldi	r24, 0x01	; 1
    46e6:	90 e0       	ldi	r25, 0x00	; 0
    46e8:	a0 e0       	ldi	r26, 0x00	; 0
    46ea:	b0 e0       	ldi	r27, 0x00	; 0
    46ec:	04 c0       	rjmp	.+8      	; 0x46f6 <BlinkControl::_onOne(bool) [clone .constprop.45]+0x48>
    46ee:	88 0f       	add	r24, r24
    46f0:	99 1f       	adc	r25, r25
    46f2:	aa 1f       	adc	r26, r26
    46f4:	bb 1f       	adc	r27, r27
    46f6:	2a 95       	dec	r18
    46f8:	d2 f7       	brpl	.-12     	; 0x46ee <BlinkControl::_onOne(bool) [clone .constprop.45]+0x40>
    46fa:	ec 0f       	add	r30, r28
    46fc:	fd 1f       	adc	r31, r29
    46fe:	24 85       	ldd	r18, Z+12	; 0x0c
    4700:	82 2b       	or	r24, r18
writeBit():
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:39
void Shifty::batchWriteBegin() {
  batchWriteMode = true;
}

void Shifty::writeBit(int bitnum, bool value) {
  if(batchWriteMode) {
    4702:	9c ad       	ldd	r25, Y+60	; 0x3c
writeBitSoft():
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:88
void Shifty::writeBitSoft(int bitnum, bool value) {
  int bytenum = bitnum / 8;
  int offset = bitnum % 8;
  byte b = this->writeBuffer[bytenum];
  bitWrite(b, offset, value);
  this->writeBuffer[bytenum] = b;
    4704:	84 87       	std	Z+12, r24	; 0x0c
writeBit():
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:39
void Shifty::batchWriteBegin() {
  batchWriteMode = true;
}

void Shifty::writeBit(int bitnum, bool value) {
  if(batchWriteMode) {
    4706:	99 23       	and	r25, r25
    4708:	19 f0       	breq	.+6      	; 0x4710 <BlinkControl::_onOne(bool) [clone .constprop.45]+0x62>
_onOne():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:142
      this->_shiftReg->writeBit(this->_pin, HIGH);
    } else {
      this->_shiftRegOnePinOnOnly(this->_pin, HIGH);
    }
  }
}
    470a:	df 91       	pop	r29
    470c:	cf 91       	pop	r28
    470e:	08 95       	ret
writeBitHard():
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:93
  this->writeBuffer[bytenum] = b;
}

void Shifty::writeBitHard(int bitnum, bool value) {
  writeBitSoft(bitnum, value);
  writeAllBits();
    4710:	ce 01       	movw	r24, r28
_onOne():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:142
    4712:	df 91       	pop	r29
    4714:	cf 91       	pop	r28
writeBitHard():
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:93
    4716:	0c 94 15 23 	jmp	0x462a	; 0x462a <Shifty::writeAllBits()>

0000471a <BlinkControl::_offOne()>:
_offOne():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:156

void BlinkControl::_offOne() {
  #if defined(ESP32)
  this->_pwmDetachPin();
  #endif
  if (this->_shiftReg == NULL) {
    471a:	dc 01       	movw	r26, r24
    471c:	16 96       	adiw	r26, 0x06	; 6
    471e:	ed 91       	ld	r30, X+
    4720:	fc 91       	ld	r31, X
    4722:	17 97       	sbiw	r26, 0x07	; 7
    4724:	14 96       	adiw	r26, 0x04	; 4
    4726:	8d 91       	ld	r24, X+
    4728:	9c 91       	ld	r25, X
    472a:	30 97       	sbiw	r30, 0x00	; 0
    472c:	19 f4       	brne	.+6      	; 0x4734 <BlinkControl::_offOne()+0x1a>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:157
    digitalWrite(this->_pin, LOW);
    472e:	60 e0       	ldi	r22, 0x00	; 0
    4730:	0c 94 3f 08 	jmp	0x107e	; 0x107e <digitalWrite>
    4734:	9c 01       	movw	r18, r24
    4736:	97 ff       	sbrs	r25, 7
    4738:	02 c0       	rjmp	.+4      	; 0x473e <BlinkControl::_offOne()+0x24>
    473a:	29 5f       	subi	r18, 0xF9	; 249
    473c:	3f 4f       	sbci	r19, 0xFF	; 255
    473e:	43 e0       	ldi	r20, 0x03	; 3
    4740:	35 95       	asr	r19
    4742:	27 95       	ror	r18
    4744:	4a 95       	dec	r20
    4746:	e1 f7       	brne	.-8      	; 0x4740 <BlinkControl::_offOne()+0x26>
    4748:	68 e0       	ldi	r22, 0x08	; 8
    474a:	70 e0       	ldi	r23, 0x00	; 0
    474c:	0e 94 17 6c 	call	0xd82e	; 0xd82e <__divmodhi4>
    4750:	48 2f       	mov	r20, r24
    4752:	81 e0       	ldi	r24, 0x01	; 1
    4754:	90 e0       	ldi	r25, 0x00	; 0
    4756:	a0 e0       	ldi	r26, 0x00	; 0
    4758:	b0 e0       	ldi	r27, 0x00	; 0
    475a:	04 c0       	rjmp	.+8      	; 0x4764 <BlinkControl::_offOne()+0x4a>
    475c:	88 0f       	add	r24, r24
    475e:	99 1f       	adc	r25, r25
    4760:	aa 1f       	adc	r26, r26
    4762:	bb 1f       	adc	r27, r27
    4764:	4a 95       	dec	r20
    4766:	d2 f7       	brpl	.-12     	; 0x475c <BlinkControl::_offOne()+0x42>
    4768:	80 95       	com	r24
    476a:	df 01       	movw	r26, r30
    476c:	a2 0f       	add	r26, r18
    476e:	b3 1f       	adc	r27, r19
    4770:	1c 96       	adiw	r26, 0x0c	; 12
    4772:	9c 91       	ld	r25, X
    4774:	1c 97       	sbiw	r26, 0x0c	; 12
    4776:	89 23       	and	r24, r25
writeBit():
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:39
void Shifty::batchWriteBegin() {
  batchWriteMode = true;
}

void Shifty::writeBit(int bitnum, bool value) {
  if(batchWriteMode) {
    4778:	94 ad       	ldd	r25, Z+60	; 0x3c
writeBitSoft():
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:88
void Shifty::writeBitSoft(int bitnum, bool value) {
  int bytenum = bitnum / 8;
  int offset = bitnum % 8;
  byte b = this->writeBuffer[bytenum];
  bitWrite(b, offset, value);
  this->writeBuffer[bytenum] = b;
    477a:	1c 96       	adiw	r26, 0x0c	; 12
    477c:	8c 93       	st	X, r24
writeBit():
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:39
void Shifty::batchWriteBegin() {
  batchWriteMode = true;
}

void Shifty::writeBit(int bitnum, bool value) {
  if(batchWriteMode) {
    477e:	91 11       	cpse	r25, r1
_offOne():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:161
  } else {
    this->_shiftReg->writeBit(this->_pin, LOW);
  }
}
    4780:	08 95       	ret
writeBitHard():
D:\USER\Documents\Arduino\libraries\arduino_477413\src/Shifty.cpp:93
  this->writeBuffer[bytenum] = b;
}

void Shifty::writeBitHard(int bitnum, bool value) {
  writeBitSoft(bitnum, value);
  writeAllBits();
    4782:	cf 01       	movw	r24, r30
    4784:	0c 94 15 23 	jmp	0x462a	; 0x462a <Shifty::writeAllBits()>

00004788 <BlinkControl::pause()>:
pause():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:177
  this->_state = BC_STATE_OFF;
}

// set state to off only, not to touch the timings array
// so that it can be restart again
void BlinkControl::pause() {
    4788:	cf 93       	push	r28
    478a:	df 93       	push	r29
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:178
  if (this->_state != BC_STATE_BLINK && this->_state != BC_STATE_BREATHE && this->_state != BC_STATE_PULSE) {
    478c:	fc 01       	movw	r30, r24
    478e:	20 81       	ld	r18, Z
    4790:	31 81       	ldd	r19, Z+1	; 0x01
    4792:	22 50       	subi	r18, 0x02	; 2
    4794:	31 09       	sbc	r19, r1
    4796:	23 30       	cpi	r18, 0x03	; 3
    4798:	31 05       	cpc	r19, r1
    479a:	98 f4       	brcc	.+38     	; 0x47c2 <BlinkControl::pause()+0x3a>
    479c:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:181
    return;
  }
  this->_offOne();
    479e:	0e 94 8d 23 	call	0x471a	; 0x471a <BlinkControl::_offOne()>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:182
  this->_timingCursor = 0;
    47a2:	1b ae       	std	Y+59, r1	; 0x3b
    47a4:	1a ae       	std	Y+58, r1	; 0x3a
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:183
  this->_pinOn = false;
    47a6:	fe 01       	movw	r30, r28
    47a8:	e0 5c       	subi	r30, 0xC0	; 192
    47aa:	ff 4f       	sbci	r31, 0xFF	; 255
    47ac:	10 82       	st	Z, r1
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:184
  this->_prevState = this->_state;
    47ae:	88 81       	ld	r24, Y
    47b0:	99 81       	ldd	r25, Y+1	; 0x01
    47b2:	9b 83       	std	Y+3, r25	; 0x03
    47b4:	8a 83       	std	Y+2, r24	; 0x02
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:185
  this->_state = BC_STATE_OFF;
    47b6:	19 82       	std	Y+1, r1	; 0x01
    47b8:	18 82       	st	Y, r1
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:186
  this->_lastAction = 0;
    47ba:	1c ae       	std	Y+60, r1	; 0x3c
    47bc:	1d ae       	std	Y+61, r1	; 0x3d
    47be:	1e ae       	std	Y+62, r1	; 0x3e
    47c0:	1f ae       	std	Y+63, r1	; 0x3f
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:187
}
    47c2:	df 91       	pop	r29
    47c4:	cf 91       	pop	r28
    47c6:	08 95       	ret

000047c8 <BlinkControl::on(bool) [clone .constprop.44]>:
on():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:144
      this->_shiftRegOnePinOnOnly(this->_pin, HIGH);
    }
  }
}

void BlinkControl::on(bool shiftRegOffOthers) {
    47c8:	cf 93       	push	r28
    47ca:	df 93       	push	r29
    47cc:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:145
  if (this->_state != BC_STATE_ON && this->_state != BC_STATE_OFF) {
    47ce:	88 81       	ld	r24, Y
    47d0:	99 81       	ldd	r25, Y+1	; 0x01
    47d2:	02 97       	sbiw	r24, 0x02	; 2
    47d4:	18 f0       	brcs	.+6      	; 0x47dc <BlinkControl::on(bool) [clone .constprop.44]+0x14>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:146
    this->pause();
    47d6:	ce 01       	movw	r24, r28
    47d8:	0e 94 c4 23 	call	0x4788	; 0x4788 <BlinkControl::pause()>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:148
  }
  this->_onOne(shiftRegOffOthers);
    47dc:	ce 01       	movw	r24, r28
    47de:	0e 94 57 23 	call	0x46ae	; 0x46ae <BlinkControl::_onOne(bool) [clone .constprop.45]>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:149
  this->_state = BC_STATE_ON;
    47e2:	81 e0       	ldi	r24, 0x01	; 1
    47e4:	90 e0       	ldi	r25, 0x00	; 0
    47e6:	99 83       	std	Y+1, r25	; 0x01
    47e8:	88 83       	st	Y, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:150
}
    47ea:	df 91       	pop	r29
    47ec:	cf 91       	pop	r28
    47ee:	08 95       	ret

000047f0 <BlinkControl::off()>:
off():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:169
  this->_shiftRegAllPinOff();
  this->_prevState = this->_state;
  this->_state = BC_STATE_OFF;
}

void BlinkControl::off() {
    47f0:	cf 93       	push	r28
    47f2:	df 93       	push	r29
    47f4:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:170
  this->_offOne();
    47f6:	0e 94 8d 23 	call	0x471a	; 0x471a <BlinkControl::_offOne()>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:171
  this->_prevState = this->_state;
    47fa:	88 81       	ld	r24, Y
    47fc:	99 81       	ldd	r25, Y+1	; 0x01
    47fe:	9b 83       	std	Y+3, r25	; 0x03
    4800:	8a 83       	std	Y+2, r24	; 0x02
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:172
  this->_state = BC_STATE_OFF;
    4802:	19 82       	std	Y+1, r1	; 0x01
    4804:	18 82       	st	Y, r1
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:173
}
    4806:	df 91       	pop	r29
    4808:	cf 91       	pop	r28
    480a:	08 95       	ret

0000480c <BlinkControl::loop()>:
loop():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:65
  this->_pinOn = false;
  this->_state = BC_STATE_OFF;
  this->_lastAction = 0;
}

void BlinkControl::loop() {
    480c:	cf 92       	push	r12
    480e:	df 92       	push	r13
    4810:	ef 92       	push	r14
    4812:	ff 92       	push	r15
    4814:	0f 93       	push	r16
    4816:	1f 93       	push	r17
    4818:	cf 93       	push	r28
    481a:	df 93       	push	r29
    481c:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:66
  if (this->_state == BC_STATE_BLINK) {
    481e:	88 81       	ld	r24, Y
    4820:	99 81       	ldd	r25, Y+1	; 0x01
    4822:	82 30       	cpi	r24, 0x02	; 2
    4824:	91 05       	cpc	r25, r1
    4826:	09 f0       	breq	.+2      	; 0x482a <BlinkControl::loop()+0x1e>
    4828:	57 c0       	rjmp	.+174    	; 0x48d8 <BlinkControl::loop()+0xcc>
_blinkLoop():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:76
    this->_pulseLoop();
  }
}

void BlinkControl::_blinkLoop() {
  unsigned long curtime = millis();
    482a:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    482e:	6b 01       	movw	r12, r22
    4830:	7c 01       	movw	r14, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:77
  if (this->_lastAction == 0) {
    4832:	8c ad       	ldd	r24, Y+60	; 0x3c
    4834:	9d ad       	ldd	r25, Y+61	; 0x3d
    4836:	ae ad       	ldd	r26, Y+62	; 0x3e
    4838:	bf ad       	ldd	r27, Y+63	; 0x3f
    483a:	00 97       	sbiw	r24, 0x00	; 0
    483c:	a1 05       	cpc	r26, r1
    483e:	b1 05       	cpc	r27, r1
    4840:	a9 f4       	brne	.+42     	; 0x486c <BlinkControl::loop()+0x60>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:78
    this->_pinOn = true;
    4842:	fe 01       	movw	r30, r28
    4844:	e0 5c       	subi	r30, 0xC0	; 192
    4846:	ff 4f       	sbci	r31, 0xFF	; 255
    4848:	81 e0       	ldi	r24, 0x01	; 1
    484a:	80 83       	st	Z, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:79
    this->_onOne(false);
    484c:	ce 01       	movw	r24, r28
    484e:	0e 94 57 23 	call	0x46ae	; 0x46ae <BlinkControl::_onOne(bool) [clone .constprop.45]>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:92
    }
    this->_timingCursor++;
    if (this->_timingCursor >= this->_timingCount) {
      this->_timingCursor = 0;
    }
    this->_lastAction = curtime;
    4852:	cc ae       	std	Y+60, r12	; 0x3c
    4854:	dd ae       	std	Y+61, r13	; 0x3d
    4856:	ee ae       	std	Y+62, r14	; 0x3e
    4858:	ff ae       	std	Y+63, r15	; 0x3f
loop():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:73
  } else if (this->_state == BC_STATE_BREATHE) {
    this->_breatheLoop();
  } else if (this->_state == BC_STATE_PULSE) {
    this->_pulseLoop();
  }
}
    485a:	df 91       	pop	r29
    485c:	cf 91       	pop	r28
    485e:	1f 91       	pop	r17
    4860:	0f 91       	pop	r16
    4862:	ff 90       	pop	r15
    4864:	ef 90       	pop	r14
    4866:	df 90       	pop	r13
    4868:	cf 90       	pop	r12
    486a:	08 95       	ret
_blinkLoop():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:81
  unsigned long curtime = millis();
  if (this->_lastAction == 0) {
    this->_pinOn = true;
    this->_onOne(false);
    this->_lastAction = curtime;
  } else if (curtime - this->_lastAction > this->_blinkTiming[this->_timingCursor]) {
    486c:	b7 01       	movw	r22, r14
    486e:	a6 01       	movw	r20, r12
    4870:	48 1b       	sub	r20, r24
    4872:	59 0b       	sbc	r21, r25
    4874:	6a 0b       	sbc	r22, r26
    4876:	7b 0b       	sbc	r23, r27
    4878:	8a ad       	ldd	r24, Y+58	; 0x3a
    487a:	9b ad       	ldd	r25, Y+59	; 0x3b
    487c:	88 0f       	add	r24, r24
    487e:	99 1f       	adc	r25, r25
    4880:	ee a9       	ldd	r30, Y+54	; 0x36
    4882:	ff a9       	ldd	r31, Y+55	; 0x37
    4884:	e8 0f       	add	r30, r24
    4886:	f9 1f       	adc	r31, r25
    4888:	80 81       	ld	r24, Z
    488a:	91 81       	ldd	r25, Z+1	; 0x01
    488c:	09 2e       	mov	r0, r25
    488e:	00 0c       	add	r0, r0
    4890:	aa 0b       	sbc	r26, r26
    4892:	bb 0b       	sbc	r27, r27
    4894:	84 17       	cp	r24, r20
    4896:	95 07       	cpc	r25, r21
    4898:	a6 07       	cpc	r26, r22
    489a:	b7 07       	cpc	r27, r23
    489c:	f0 f6       	brcc	.-68     	; 0x485a <BlinkControl::loop()+0x4e>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:82
    this->_pinOn = !this->_pinOn;
    489e:	fe 01       	movw	r30, r28
    48a0:	e0 5c       	subi	r30, 0xC0	; 192
    48a2:	ff 4f       	sbci	r31, 0xFF	; 255
    48a4:	80 81       	ld	r24, Z
    48a6:	91 e0       	ldi	r25, 0x01	; 1
    48a8:	89 27       	eor	r24, r25
    48aa:	80 83       	st	Z, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:83
    if (this->_pinOn) {
    48ac:	88 23       	and	r24, r24
    48ae:	81 f0       	breq	.+32     	; 0x48d0 <BlinkControl::loop()+0xc4>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:84
      this->_onOne(false);
    48b0:	ce 01       	movw	r24, r28
    48b2:	0e 94 57 23 	call	0x46ae	; 0x46ae <BlinkControl::_onOne(bool) [clone .constprop.45]>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:88
    } else {
      this->_offOne();
    }
    this->_timingCursor++;
    48b6:	8a ad       	ldd	r24, Y+58	; 0x3a
    48b8:	9b ad       	ldd	r25, Y+59	; 0x3b
    48ba:	01 96       	adiw	r24, 0x01	; 1
    48bc:	9b af       	std	Y+59, r25	; 0x3b
    48be:	8a af       	std	Y+58, r24	; 0x3a
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:89
    if (this->_timingCursor >= this->_timingCount) {
    48c0:	28 ad       	ldd	r18, Y+56	; 0x38
    48c2:	39 ad       	ldd	r19, Y+57	; 0x39
    48c4:	82 17       	cp	r24, r18
    48c6:	93 07       	cpc	r25, r19
    48c8:	24 f2       	brlt	.-120    	; 0x4852 <BlinkControl::loop()+0x46>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:90
      this->_timingCursor = 0;
    48ca:	1b ae       	std	Y+59, r1	; 0x3b
    48cc:	1a ae       	std	Y+58, r1	; 0x3a
    48ce:	c1 cf       	rjmp	.-126    	; 0x4852 <BlinkControl::loop()+0x46>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:86
  } else if (curtime - this->_lastAction > this->_blinkTiming[this->_timingCursor]) {
    this->_pinOn = !this->_pinOn;
    if (this->_pinOn) {
      this->_onOne(false);
    } else {
      this->_offOne();
    48d0:	ce 01       	movw	r24, r28
    48d2:	0e 94 8d 23 	call	0x471a	; 0x471a <BlinkControl::_offOne()>
    48d6:	ef cf       	rjmp	.-34     	; 0x48b6 <BlinkControl::loop()+0xaa>
loop():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:68
}

void BlinkControl::loop() {
  if (this->_state == BC_STATE_BLINK) {
    this->_blinkLoop();
  } else if (this->_state == BC_STATE_BREATHE) {
    48d8:	83 30       	cpi	r24, 0x03	; 3
    48da:	91 05       	cpc	r25, r1
    48dc:	09 f0       	breq	.+2      	; 0x48e0 <BlinkControl::loop()+0xd4>
    48de:	47 c0       	rjmp	.+142    	; 0x496e <BlinkControl::loop()+0x162>
_breatheLoop():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:97
    this->_lastAction = curtime;
  }
}

void BlinkControl::_breatheLoop() {
  unsigned long curtime = millis();
    48e0:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:98
  if (curtime - this->_lastAction > this->_breatheInterval) {
    48e4:	0c ad       	ldd	r16, Y+60	; 0x3c
    48e6:	1d ad       	ldd	r17, Y+61	; 0x3d
    48e8:	2e ad       	ldd	r18, Y+62	; 0x3e
    48ea:	3f ad       	ldd	r19, Y+63	; 0x3f
    48ec:	6b 01       	movw	r12, r22
    48ee:	7c 01       	movw	r14, r24
    48f0:	c0 1a       	sub	r12, r16
    48f2:	d1 0a       	sbc	r13, r17
    48f4:	e2 0a       	sbc	r14, r18
    48f6:	f3 0a       	sbc	r15, r19
    48f8:	97 01       	movw	r18, r14
    48fa:	86 01       	movw	r16, r12
    48fc:	fe 01       	movw	r30, r28
    48fe:	ef 5b       	subi	r30, 0xBF	; 191
    4900:	ff 4f       	sbci	r31, 0xFF	; 255
    4902:	40 81       	ld	r20, Z
    4904:	51 81       	ldd	r21, Z+1	; 0x01
    4906:	6a 01       	movw	r12, r20
    4908:	f1 2c       	mov	r15, r1
    490a:	e1 2c       	mov	r14, r1
    490c:	c0 16       	cp	r12, r16
    490e:	d1 06       	cpc	r13, r17
    4910:	e2 06       	cpc	r14, r18
    4912:	f3 06       	cpc	r15, r19
    4914:	08 f0       	brcs	.+2      	; 0x4918 <BlinkControl::loop()+0x10c>
    4916:	a1 cf       	rjmp	.-190    	; 0x485a <BlinkControl::loop()+0x4e>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:99
    this->_lastAction = curtime;
    4918:	6c af       	std	Y+60, r22	; 0x3c
    491a:	7d af       	std	Y+61, r23	; 0x3d
    491c:	8e af       	std	Y+62, r24	; 0x3e
    491e:	9f af       	std	Y+63, r25	; 0x3f
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:100
    this->_dutyCycle += this->_brightStep;
    4920:	32 96       	adiw	r30, 0x02	; 2
    4922:	80 81       	ld	r24, Z
    4924:	91 81       	ldd	r25, Z+1	; 0x01
    4926:	de 01       	movw	r26, r28
    4928:	ab 5b       	subi	r26, 0xBB	; 187
    492a:	bf 4f       	sbci	r27, 0xFF	; 255
    492c:	6d 91       	ld	r22, X+
    492e:	7c 91       	ld	r23, X
    4930:	11 97       	sbiw	r26, 0x01	; 1
    4932:	68 0f       	add	r22, r24
    4934:	79 1f       	adc	r23, r25
    4936:	11 96       	adiw	r26, 0x01	; 1
    4938:	7c 93       	st	X, r23
    493a:	6e 93       	st	-X, r22
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:101
    if (this->_dutyCycle <= 0 || this->_dutyCycle >= this->_brightStepMax) {
    493c:	16 16       	cp	r1, r22
    493e:	17 06       	cpc	r1, r23
    4940:	34 f4       	brge	.+12     	; 0x494e <BlinkControl::loop()+0x142>
    4942:	12 96       	adiw	r26, 0x02	; 2
    4944:	2d 91       	ld	r18, X+
    4946:	3c 91       	ld	r19, X
    4948:	62 17       	cp	r22, r18
    494a:	73 07       	cpc	r23, r19
    494c:	2c f0       	brlt	.+10     	; 0x4958 <BlinkControl::loop()+0x14c>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:102
      this->_brightStep = -this->_brightStep;
    494e:	91 95       	neg	r25
    4950:	81 95       	neg	r24
    4952:	91 09       	sbc	r25, r1
    4954:	91 83       	std	Z+1, r25	; 0x01
    4956:	80 83       	st	Z, r24
_pulseLoop():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:124
      this->_lastAction += 500;
    }
    #if defined(ESP32)
    ledcWrite(this->_pwmChannel, this->_dutyCycle);
    #else
    analogWrite(this->_pin, this->_dutyCycle);
    4958:	8c 81       	ldd	r24, Y+4	; 0x04
loop():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:73
  } else if (this->_state == BC_STATE_BREATHE) {
    this->_breatheLoop();
  } else if (this->_state == BC_STATE_PULSE) {
    this->_pulseLoop();
  }
}
    495a:	df 91       	pop	r29
    495c:	cf 91       	pop	r28
    495e:	1f 91       	pop	r17
    4960:	0f 91       	pop	r16
    4962:	ff 90       	pop	r15
    4964:	ef 90       	pop	r14
    4966:	df 90       	pop	r13
    4968:	cf 90       	pop	r12
_pulseLoop():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:124
      this->_lastAction += 500;
    }
    #if defined(ESP32)
    ledcWrite(this->_pwmChannel, this->_dutyCycle);
    #else
    analogWrite(this->_pin, this->_dutyCycle);
    496a:	0c 94 38 0c 	jmp	0x1870	; 0x1870 <analogWrite>
loop():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:70
void BlinkControl::loop() {
  if (this->_state == BC_STATE_BLINK) {
    this->_blinkLoop();
  } else if (this->_state == BC_STATE_BREATHE) {
    this->_breatheLoop();
  } else if (this->_state == BC_STATE_PULSE) {
    496e:	04 97       	sbiw	r24, 0x04	; 4
    4970:	09 f0       	breq	.+2      	; 0x4974 <BlinkControl::loop()+0x168>
    4972:	73 cf       	rjmp	.-282    	; 0x485a <BlinkControl::loop()+0x4e>
_pulseLoop():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:113
    #endif
  }
}

void BlinkControl::_pulseLoop() {
  unsigned long curtime = millis();
    4974:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:114
  if (curtime - this->_lastAction > this->_breatheInterval) {
    4978:	0c ad       	ldd	r16, Y+60	; 0x3c
    497a:	1d ad       	ldd	r17, Y+61	; 0x3d
    497c:	2e ad       	ldd	r18, Y+62	; 0x3e
    497e:	3f ad       	ldd	r19, Y+63	; 0x3f
    4980:	6b 01       	movw	r12, r22
    4982:	7c 01       	movw	r14, r24
    4984:	c0 1a       	sub	r12, r16
    4986:	d1 0a       	sbc	r13, r17
    4988:	e2 0a       	sbc	r14, r18
    498a:	f3 0a       	sbc	r15, r19
    498c:	fe 01       	movw	r30, r28
    498e:	ef 5b       	subi	r30, 0xBF	; 191
    4990:	ff 4f       	sbci	r31, 0xFF	; 255
    4992:	00 81       	ld	r16, Z
    4994:	11 81       	ldd	r17, Z+1	; 0x01
    4996:	30 e0       	ldi	r19, 0x00	; 0
    4998:	20 e0       	ldi	r18, 0x00	; 0
    499a:	0c 15       	cp	r16, r12
    499c:	1d 05       	cpc	r17, r13
    499e:	2e 05       	cpc	r18, r14
    49a0:	3f 05       	cpc	r19, r15
    49a2:	08 f0       	brcs	.+2      	; 0x49a6 <BlinkControl::loop()+0x19a>
    49a4:	5a cf       	rjmp	.-332    	; 0x485a <BlinkControl::loop()+0x4e>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:115
    this->_lastAction = curtime;
    49a6:	6c af       	std	Y+60, r22	; 0x3c
    49a8:	7d af       	std	Y+61, r23	; 0x3d
    49aa:	8e af       	std	Y+62, r24	; 0x3e
    49ac:	9f af       	std	Y+63, r25	; 0x3f
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:116
    this->_dutyCycle -= this->_brightStep;
    49ae:	34 96       	adiw	r30, 0x04	; 4
    49b0:	20 81       	ld	r18, Z
    49b2:	31 81       	ldd	r19, Z+1	; 0x01
    49b4:	de 01       	movw	r26, r28
    49b6:	ad 5b       	subi	r26, 0xBD	; 189
    49b8:	bf 4f       	sbci	r27, 0xFF	; 255
    49ba:	4d 91       	ld	r20, X+
    49bc:	5c 91       	ld	r21, X
    49be:	11 97       	sbiw	r26, 0x01	; 1
    49c0:	24 1b       	sub	r18, r20
    49c2:	35 0b       	sbc	r19, r21
    49c4:	31 83       	std	Z+1, r19	; 0x01
    49c6:	20 83       	st	Z, r18
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:117
    if (this->_dutyCycle < 0) {
    49c8:	37 ff       	sbrs	r19, 7
    49ca:	0d c0       	rjmp	.+26     	; 0x49e6 <BlinkControl::loop()+0x1da>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:118
      this->_dutyCycle = this->_brightStepMax;
    49cc:	14 96       	adiw	r26, 0x04	; 4
    49ce:	2d 91       	ld	r18, X+
    49d0:	3c 91       	ld	r19, X
    49d2:	31 83       	std	Z+1, r19	; 0x01
    49d4:	20 83       	st	Z, r18
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:119
      this->_lastAction += 500;
    49d6:	6c 50       	subi	r22, 0x0C	; 12
    49d8:	7e 4f       	sbci	r23, 0xFE	; 254
    49da:	8f 4f       	sbci	r24, 0xFF	; 255
    49dc:	9f 4f       	sbci	r25, 0xFF	; 255
    49de:	6c af       	std	Y+60, r22	; 0x3c
    49e0:	7d af       	std	Y+61, r23	; 0x3d
    49e2:	8e af       	std	Y+62, r24	; 0x3e
    49e4:	9f af       	std	Y+63, r25	; 0x3f
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:124
    }
    #if defined(ESP32)
    ledcWrite(this->_pwmChannel, this->_dutyCycle);
    #else
    analogWrite(this->_pin, this->_dutyCycle);
    49e6:	60 81       	ld	r22, Z
    49e8:	71 81       	ldd	r23, Z+1	; 0x01
    49ea:	b6 cf       	rjmp	.-148    	; 0x4958 <BlinkControl::loop()+0x14c>

000049ec <BlinkControl::begin()>:
begin():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:57

BlinkControl::~BlinkControl() {
  delete[] this->_blinkTiming;
}

void BlinkControl::begin() {
    49ec:	cf 93       	push	r28
    49ee:	df 93       	push	r29
    49f0:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:58
  this->_offOne();
    49f2:	0e 94 8d 23 	call	0x471a	; 0x471a <BlinkControl::_offOne()>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:59
  this->_timingCursor = 0;
    49f6:	1b ae       	std	Y+59, r1	; 0x3b
    49f8:	1a ae       	std	Y+58, r1	; 0x3a
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:60
  this->_pinOn = false;
    49fa:	fe 01       	movw	r30, r28
    49fc:	e0 5c       	subi	r30, 0xC0	; 192
    49fe:	ff 4f       	sbci	r31, 0xFF	; 255
    4a00:	10 82       	st	Z, r1
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:61
  this->_state = BC_STATE_OFF;
    4a02:	19 82       	std	Y+1, r1	; 0x01
    4a04:	18 82       	st	Y, r1
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:62
  this->_lastAction = 0;
    4a06:	1c ae       	std	Y+60, r1	; 0x3c
    4a08:	1d ae       	std	Y+61, r1	; 0x3d
    4a0a:	1e ae       	std	Y+62, r1	; 0x3e
    4a0c:	1f ae       	std	Y+63, r1	; 0x3f
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:63
}
    4a0e:	df 91       	pop	r29
    4a10:	cf 91       	pop	r28
    4a12:	08 95       	ret

00004a14 <BlinkControl::blink(int*, int)>:
blink():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:210
  
  this->_state = this->_prevState;
  this->_prevState = BC_STATE_OFF;
}

void BlinkControl::blink(int timings[], int timingCount) {
    4a14:	ef 92       	push	r14
    4a16:	ff 92       	push	r15
    4a18:	0f 93       	push	r16
    4a1a:	1f 93       	push	r17
    4a1c:	cf 93       	push	r28
    4a1e:	df 93       	push	r29
    4a20:	ec 01       	movw	r28, r24
    4a22:	7b 01       	movw	r14, r22
    4a24:	8a 01       	movw	r16, r20
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:211
  if (this->_state != BC_STATE_BLINK && this->_state != BC_STATE_OFF) {
    4a26:	88 81       	ld	r24, Y
    4a28:	99 81       	ldd	r25, Y+1	; 0x01
    4a2a:	8d 7f       	andi	r24, 0xFD	; 253
    4a2c:	89 2b       	or	r24, r25
    4a2e:	19 f0       	breq	.+6      	; 0x4a36 <BlinkControl::blink(int*, int)+0x22>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:212
    this->off();
    4a30:	ce 01       	movw	r24, r28
    4a32:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:215
  }
  
  this->_timingCount = timingCount;
    4a36:	19 af       	std	Y+57, r17	; 0x39
    4a38:	08 af       	std	Y+56, r16	; 0x38
operator new():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/new.cpp:22
*/

#include <stdlib.h>

void *operator new(size_t size) {
  return malloc(size);
    4a3a:	c8 01       	movw	r24, r16
    4a3c:	88 0f       	add	r24, r24
    4a3e:	99 1f       	adc	r25, r25
    4a40:	0e 94 d8 62 	call	0xc5b0	; 0xc5b0 <malloc>
blink():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:216
  this->_blinkTiming = new int[this->_timingCount];
    4a44:	8e ab       	std	Y+54, r24	; 0x36
    4a46:	9f ab       	std	Y+55, r25	; 0x37
    4a48:	d7 01       	movw	r26, r14
    4a4a:	fc 01       	movw	r30, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:217
  for (int i = 0; i < this->_timingCount; i++) {
    4a4c:	90 e0       	ldi	r25, 0x00	; 0
    4a4e:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:218
    this->_blinkTiming[i] = timings[i];
    4a50:	2d 91       	ld	r18, X+
    4a52:	3d 91       	ld	r19, X+
    4a54:	21 93       	st	Z+, r18
    4a56:	31 93       	st	Z+, r19
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:217
    this->off();
  }
  
  this->_timingCount = timingCount;
  this->_blinkTiming = new int[this->_timingCount];
  for (int i = 0; i < this->_timingCount; i++) {
    4a58:	01 96       	adiw	r24, 0x01	; 1
    4a5a:	08 17       	cp	r16, r24
    4a5c:	19 07       	cpc	r17, r25
    4a5e:	c1 f7       	brne	.-16     	; 0x4a50 <BlinkControl::blink(int*, int)+0x3c>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:221
    this->_blinkTiming[i] = timings[i];
  }
  
  this->_timingCursor = 0;
    4a60:	1b ae       	std	Y+59, r1	; 0x3b
    4a62:	1a ae       	std	Y+58, r1	; 0x3a
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:222
  this->_state = BC_STATE_BLINK;
    4a64:	82 e0       	ldi	r24, 0x02	; 2
    4a66:	90 e0       	ldi	r25, 0x00	; 0
    4a68:	99 83       	std	Y+1, r25	; 0x01
    4a6a:	88 83       	st	Y, r24
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:223
  this->_lastAction = 0;
    4a6c:	1c ae       	std	Y+60, r1	; 0x3c
    4a6e:	1d ae       	std	Y+61, r1	; 0x3d
    4a70:	1e ae       	std	Y+62, r1	; 0x3e
    4a72:	1f ae       	std	Y+63, r1	; 0x3f
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:224
}
    4a74:	df 91       	pop	r29
    4a76:	cf 91       	pop	r28
    4a78:	1f 91       	pop	r17
    4a7a:	0f 91       	pop	r16
    4a7c:	ff 90       	pop	r15
    4a7e:	ef 90       	pop	r14
    4a80:	08 95       	ret

00004a82 <BlinkControl::fastBlinking()>:
fastBlinking():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:243
void BlinkControl::blink4() {
  this->blink(this->blinkTiming4, 8);
}

void BlinkControl::fastBlinking() {
  this->blink(this->blinkTiming625, 2);
    4a82:	bc 01       	movw	r22, r24
    4a84:	6e 5c       	subi	r22, 0xCE	; 206
    4a86:	7f 4f       	sbci	r23, 0xFF	; 255
    4a88:	42 e0       	ldi	r20, 0x02	; 2
    4a8a:	50 e0       	ldi	r21, 0x00	; 0
    4a8c:	0c 94 0a 25 	jmp	0x4a14	; 0x4a14 <BlinkControl::blink(int*, int)>

00004a90 <String::getBytes(unsigned char*, unsigned int, unsigned int) const [clone .part.9] [clone .constprop.178]>:
_ZNK6String8getBytesEPhjj.part.9():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:537
{
	if (index >= len || !buffer) return 0;
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
    4a90:	0f 93       	push	r16
    4a92:	1f 93       	push	r17
    4a94:	cf 93       	push	r28
    4a96:	df 93       	push	r29
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:540
{
	if (!bufsize || !buf) return;
	if (index >= len) {
    4a98:	fc 01       	movw	r30, r24
    4a9a:	04 81       	ldd	r16, Z+4	; 0x04
    4a9c:	15 81       	ldd	r17, Z+5	; 0x05
    4a9e:	01 15       	cp	r16, r1
    4aa0:	11 05       	cpc	r17, r1
    4aa2:	39 f4       	brne	.+14     	; 0x4ab2 <String::getBytes(unsigned char*, unsigned int, unsigned int) const [clone .part.9] [clone .constprop.178]+0x22>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:541
		buf[0] = 0;
    4aa4:	fb 01       	movw	r30, r22
    4aa6:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:548
	}
	unsigned int n = bufsize - 1;
	if (n > len - index) n = len - index;
	strncpy((char *)buf, buffer + index, n);
	buf[n] = 0;
}
    4aa8:	df 91       	pop	r29
    4aaa:	cf 91       	pop	r28
    4aac:	1f 91       	pop	r17
    4aae:	0f 91       	pop	r16
    4ab0:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:544
	if (!bufsize || !buf) return;
	if (index >= len) {
		buf[0] = 0;
		return;
	}
	unsigned int n = bufsize - 1;
    4ab2:	41 50       	subi	r20, 0x01	; 1
    4ab4:	51 09       	sbc	r21, r1
    4ab6:	40 17       	cp	r20, r16
    4ab8:	51 07       	cpc	r21, r17
    4aba:	08 f4       	brcc	.+2      	; 0x4abe <String::getBytes(unsigned char*, unsigned int, unsigned int) const [clone .part.9] [clone .constprop.178]+0x2e>
    4abc:	8a 01       	movw	r16, r20
    4abe:	eb 01       	movw	r28, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:546
	if (n > len - index) n = len - index;
	strncpy((char *)buf, buffer + index, n);
    4ac0:	fc 01       	movw	r30, r24
    4ac2:	60 81       	ld	r22, Z
    4ac4:	71 81       	ldd	r23, Z+1	; 0x01
    4ac6:	a8 01       	movw	r20, r16
    4ac8:	ce 01       	movw	r24, r28
    4aca:	0e 94 cf 6e 	call	0xdd9e	; 0xdd9e <strncpy>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:547
	buf[n] = 0;
    4ace:	c0 0f       	add	r28, r16
    4ad0:	d1 1f       	adc	r29, r17
    4ad2:	18 82       	st	Y, r1
    4ad4:	e9 cf       	rjmp	.-46     	; 0x4aa8 <String::getBytes(unsigned char*, unsigned int, unsigned int) const [clone .part.9] [clone .constprop.178]+0x18>

00004ad6 <getFilename(char*) [clone .constprop.135]>:
getFilename():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:78
		SDIO.clearBlink();
		SDIO.fastBlinking();
	}
}
void getFilename(char *filename) {      //File Name Set As : IDYYMMDD.csv !!Warning!! Filename should alway be "8digits".csv
	sprintf(filename, "%02X%02d%02d%02d.csv", device_ID, year % 100, month, day);
    4ad6:	80 91 28 0c 	lds	r24, 0x0C28	; 0x800c28 <day+0x1>
    4ada:	8f 93       	push	r24
    4adc:	80 91 27 0c 	lds	r24, 0x0C27	; 0x800c27 <day>
    4ae0:	8f 93       	push	r24
    4ae2:	80 91 26 0c 	lds	r24, 0x0C26	; 0x800c26 <month+0x1>
    4ae6:	8f 93       	push	r24
    4ae8:	80 91 25 0c 	lds	r24, 0x0C25	; 0x800c25 <month>
    4aec:	8f 93       	push	r24
    4aee:	80 91 23 0c 	lds	r24, 0x0C23	; 0x800c23 <year>
    4af2:	90 91 24 0c 	lds	r25, 0x0C24	; 0x800c24 <year+0x1>
    4af6:	64 e6       	ldi	r22, 0x64	; 100
    4af8:	70 e0       	ldi	r23, 0x00	; 0
    4afa:	0e 94 17 6c 	call	0xd82e	; 0xd82e <__divmodhi4>
    4afe:	9f 93       	push	r25
    4b00:	8f 93       	push	r24
    4b02:	80 91 22 0c 	lds	r24, 0x0C22	; 0x800c22 <device_ID+0x1>
    4b06:	8f 93       	push	r24
    4b08:	80 91 21 0c 	lds	r24, 0x0C21	; 0x800c21 <device_ID>
    4b0c:	8f 93       	push	r24
    4b0e:	85 e5       	ldi	r24, 0x55	; 85
    4b10:	93 e0       	ldi	r25, 0x03	; 3
    4b12:	9f 93       	push	r25
    4b14:	8f 93       	push	r24
    4b16:	8e e8       	ldi	r24, 0x8E	; 142
    4b18:	92 e0       	ldi	r25, 0x02	; 2
    4b1a:	9f 93       	push	r25
    4b1c:	8f 93       	push	r24
    4b1e:	0e 94 de 6e 	call	0xddbc	; 0xddbc <sprintf>
    4b22:	8d b7       	in	r24, 0x3d	; 61
    4b24:	9e b7       	in	r25, 0x3e	; 62
    4b26:	0c 96       	adiw	r24, 0x0c	; 12
    4b28:	0f b6       	in	r0, 0x3f	; 63
    4b2a:	f8 94       	cli
    4b2c:	9e bf       	out	0x3e, r25	; 62
    4b2e:	0f be       	out	0x3f, r0	; 63
    4b30:	8d bf       	out	0x3d, r24	; 61
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:80
	return;
}
    4b32:	08 95       	ret

00004b34 <String::invalidate()>:
invalidate():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:139
	capacity = 0;
	len = 0;
}

void String::invalidate(void)
{
    4b34:	cf 93       	push	r28
    4b36:	df 93       	push	r29
    4b38:	ec 01       	movw	r28, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:140
	if (buffer) free(buffer);
    4b3a:	88 81       	ld	r24, Y
    4b3c:	99 81       	ldd	r25, Y+1	; 0x01
    4b3e:	00 97       	sbiw	r24, 0x00	; 0
    4b40:	11 f0       	breq	.+4      	; 0x4b46 <String::invalidate()+0x12>
    4b42:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:141
	buffer = NULL;
    4b46:	19 82       	std	Y+1, r1	; 0x01
    4b48:	18 82       	st	Y, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:142
	capacity = len = 0;
    4b4a:	1d 82       	std	Y+5, r1	; 0x05
    4b4c:	1c 82       	std	Y+4, r1	; 0x04
    4b4e:	1b 82       	std	Y+3, r1	; 0x03
    4b50:	1a 82       	std	Y+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:143
}
    4b52:	df 91       	pop	r29
    4b54:	cf 91       	pop	r28
    4b56:	08 95       	ret

00004b58 <String::~String()>:
__base_dtor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:124
	*this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}

String::~String()
{
	if (buffer) free(buffer);
    4b58:	fc 01       	movw	r30, r24
    4b5a:	80 81       	ld	r24, Z
    4b5c:	91 81       	ldd	r25, Z+1	; 0x01
    4b5e:	00 97       	sbiw	r24, 0x00	; 0
    4b60:	11 f0       	breq	.+4      	; 0x4b66 <String::~String()+0xe>
    4b62:	0c 94 74 63 	jmp	0xc6e8	; 0xc6e8 <free>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:125
}
    4b66:	08 95       	ret

00004b68 <Print::write(char const*) [clone .part.2]>:
_ZN5Print5writeEPKc.part.2():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:54
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
    4b68:	fb 01       	movw	r30, r22
    4b6a:	01 90       	ld	r0, Z+
    4b6c:	00 20       	and	r0, r0
    4b6e:	e9 f7       	brne	.-6      	; 0x4b6a <Print::write(char const*) [clone .part.2]+0x2>
    4b70:	31 97       	sbiw	r30, 0x01	; 1
    4b72:	af 01       	movw	r20, r30
    4b74:	46 1b       	sub	r20, r22
    4b76:	57 0b       	sbc	r21, r23
    4b78:	dc 01       	movw	r26, r24
    4b7a:	ed 91       	ld	r30, X+
    4b7c:	fc 91       	ld	r31, X
    4b7e:	02 80       	ldd	r0, Z+2	; 0x02
    4b80:	f3 81       	ldd	r31, Z+3	; 0x03
    4b82:	e0 2d       	mov	r30, r0
    4b84:	19 94       	eijmp

00004b86 <Print::println(__FlashStringHelper const*) [clone .constprop.71]>:
println():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:114
size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
}

size_t Print::println(const __FlashStringHelper *ifsh)
    4b86:	cf 93       	push	r28
    4b88:	df 93       	push	r29
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:116
{
  size_t n = print(ifsh);
    4b8a:	bc 01       	movw	r22, r24
    4b8c:	82 e5       	ldi	r24, 0x52	; 82
    4b8e:	9e e0       	ldi	r25, 0x0E	; 14
    4b90:	0e 94 51 06 	call	0xca2	; 0xca2 <Print::print(__FlashStringHelper const*)>
    4b94:	ec 01       	movw	r28, r24
write():
    4b96:	6a e6       	ldi	r22, 0x6A	; 106
    4b98:	73 e0       	ldi	r23, 0x03	; 3
    4b9a:	82 e5       	ldi	r24, 0x52	; 82
    4b9c:	9e e0       	ldi	r25, 0x0E	; 14
    4b9e:	0e 94 b4 25 	call	0x4b68	; 0x4b68 <Print::write(char const*) [clone .part.2]>
println():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:119
  n += println();
  return n;
}
    4ba2:	8c 0f       	add	r24, r28
    4ba4:	9d 1f       	adc	r25, r29
    4ba6:	df 91       	pop	r29
    4ba8:	cf 91       	pop	r28
    4baa:	08 95       	ret

00004bac <Print::printNumber(unsigned long, unsigned char)>:
printNumber():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:204
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
{
    4bac:	8f 92       	push	r8
    4bae:	9f 92       	push	r9
    4bb0:	af 92       	push	r10
    4bb2:	bf 92       	push	r11
    4bb4:	ef 92       	push	r14
    4bb6:	ff 92       	push	r15
    4bb8:	0f 93       	push	r16
    4bba:	1f 93       	push	r17
    4bbc:	cf 93       	push	r28
    4bbe:	df 93       	push	r29
    4bc0:	cd b7       	in	r28, 0x3d	; 61
    4bc2:	de b7       	in	r29, 0x3e	; 62
    4bc4:	a1 97       	sbiw	r28, 0x21	; 33
    4bc6:	0f b6       	in	r0, 0x3f	; 63
    4bc8:	f8 94       	cli
    4bca:	de bf       	out	0x3e, r29	; 62
    4bcc:	0f be       	out	0x3f, r0	; 63
    4bce:	cd bf       	out	0x3d, r28	; 61
    4bd0:	7c 01       	movw	r14, r24
    4bd2:	fa 01       	movw	r30, r20
    4bd4:	cb 01       	movw	r24, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:208
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    4bd6:	19 a2       	std	Y+33, r1	; 0x21
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:211

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
    4bd8:	22 30       	cpi	r18, 0x02	; 2
    4bda:	08 f4       	brcc	.+2      	; 0x4bde <Print::printNumber(unsigned long, unsigned char)+0x32>
    4bdc:	2a e0       	ldi	r18, 0x0A	; 10
    4bde:	8e 01       	movw	r16, r28
    4be0:	0f 5d       	subi	r16, 0xDF	; 223
    4be2:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:214

  do {
    char c = n % base;
    4be4:	82 2e       	mov	r8, r18
    4be6:	91 2c       	mov	r9, r1
    4be8:	b1 2c       	mov	r11, r1
    4bea:	a1 2c       	mov	r10, r1
    4bec:	bf 01       	movw	r22, r30
    4bee:	a5 01       	movw	r20, r10
    4bf0:	94 01       	movw	r18, r8
    4bf2:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:215
    n /= base;
    4bf6:	f9 01       	movw	r30, r18
    4bf8:	ca 01       	movw	r24, r20
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:217

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    4bfa:	6a 30       	cpi	r22, 0x0A	; 10
    4bfc:	0c f5       	brge	.+66     	; 0x4c40 <Print::printNumber(unsigned long, unsigned char)+0x94>
    4bfe:	60 5d       	subi	r22, 0xD0	; 208
    4c00:	d8 01       	movw	r26, r16
    4c02:	6e 93       	st	-X, r22
    4c04:	8d 01       	movw	r16, r26
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:218
  } while(n);
    4c06:	23 2b       	or	r18, r19
    4c08:	24 2b       	or	r18, r20
    4c0a:	25 2b       	or	r18, r21
    4c0c:	79 f7       	brne	.-34     	; 0x4bec <Print::printNumber(unsigned long, unsigned char)+0x40>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:53
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    4c0e:	90 e0       	ldi	r25, 0x00	; 0
    4c10:	80 e0       	ldi	r24, 0x00	; 0
write():
    4c12:	10 97       	sbiw	r26, 0x00	; 0
    4c14:	21 f0       	breq	.+8      	; 0x4c1e <Print::printNumber(unsigned long, unsigned char)+0x72>
    4c16:	bd 01       	movw	r22, r26
    4c18:	c7 01       	movw	r24, r14
    4c1a:	0e 94 b4 25 	call	0x4b68	; 0x4b68 <Print::write(char const*) [clone .part.2]>
printNumber():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:221

  return write(str);
}
    4c1e:	a1 96       	adiw	r28, 0x21	; 33
    4c20:	0f b6       	in	r0, 0x3f	; 63
    4c22:	f8 94       	cli
    4c24:	de bf       	out	0x3e, r29	; 62
    4c26:	0f be       	out	0x3f, r0	; 63
    4c28:	cd bf       	out	0x3d, r28	; 61
    4c2a:	df 91       	pop	r29
    4c2c:	cf 91       	pop	r28
    4c2e:	1f 91       	pop	r17
    4c30:	0f 91       	pop	r16
    4c32:	ff 90       	pop	r15
    4c34:	ef 90       	pop	r14
    4c36:	bf 90       	pop	r11
    4c38:	af 90       	pop	r10
    4c3a:	9f 90       	pop	r9
    4c3c:	8f 90       	pop	r8
    4c3e:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:217

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    4c40:	69 5c       	subi	r22, 0xC9	; 201
    4c42:	de cf       	rjmp	.-68     	; 0x4c00 <Print::printNumber(unsigned long, unsigned char)+0x54>

00004c44 <Print::print(int, int) [clone .constprop.175]>:
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:77
size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
    4c44:	cf 92       	push	r12
    4c46:	df 92       	push	r13
    4c48:	ef 92       	push	r14
    4c4a:	ff 92       	push	r15
    4c4c:	0f 93       	push	r16
    4c4e:	1f 93       	push	r17
    4c50:	cf 93       	push	r28
    4c52:	df 93       	push	r29
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:79
{
  return print((long) n, base);
    4c54:	6b 01       	movw	r12, r22
    4c56:	77 0f       	add	r23, r23
    4c58:	ee 08       	sbc	r14, r14
    4c5a:	ff 08       	sbc	r15, r15
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:92
size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
    4c5c:	f7 fe       	sbrs	r15, 7
    4c5e:	1b c0       	rjmp	.+54     	; 0x4c96 <Print::print(int, int) [clone .constprop.175]+0x52>
    4c60:	ec 01       	movw	r28, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:93
      int t = print('-');
    4c62:	6d e2       	ldi	r22, 0x2D	; 45
    4c64:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
    4c68:	8c 01       	movw	r16, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:94
      n = -n;
    4c6a:	44 27       	eor	r20, r20
    4c6c:	55 27       	eor	r21, r21
    4c6e:	ba 01       	movw	r22, r20
    4c70:	4c 19       	sub	r20, r12
    4c72:	5d 09       	sbc	r21, r13
    4c74:	6e 09       	sbc	r22, r14
    4c76:	7f 09       	sbc	r23, r15
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:95
      return printNumber(n, 10) + t;
    4c78:	2a e0       	ldi	r18, 0x0A	; 10
    4c7a:	ce 01       	movw	r24, r28
    4c7c:	0e 94 d6 25 	call	0x4bac	; 0x4bac <Print::printNumber(unsigned long, unsigned char)>
    4c80:	80 0f       	add	r24, r16
    4c82:	91 1f       	adc	r25, r17
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:80
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
}
    4c84:	df 91       	pop	r29
    4c86:	cf 91       	pop	r28
    4c88:	1f 91       	pop	r17
    4c8a:	0f 91       	pop	r16
    4c8c:	ff 90       	pop	r15
    4c8e:	ef 90       	pop	r14
    4c90:	df 90       	pop	r13
    4c92:	cf 90       	pop	r12
    4c94:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:97
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    4c96:	2a e0       	ldi	r18, 0x0A	; 10
    4c98:	b7 01       	movw	r22, r14
    4c9a:	a6 01       	movw	r20, r12
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:80
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
}
    4c9c:	df 91       	pop	r29
    4c9e:	cf 91       	pop	r28
    4ca0:	1f 91       	pop	r17
    4ca2:	0f 91       	pop	r16
    4ca4:	ff 90       	pop	r15
    4ca6:	ef 90       	pop	r14
    4ca8:	df 90       	pop	r13
    4caa:	cf 90       	pop	r12
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:97
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    4cac:	0c 94 d6 25 	jmp	0x4bac	; 0x4bac <Print::printNumber(unsigned long, unsigned char)>

00004cb0 <Print::printFloat(double, unsigned char)>:
printFloat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:224

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits) 
{ 
    4cb0:	2f 92       	push	r2
    4cb2:	3f 92       	push	r3
    4cb4:	4f 92       	push	r4
    4cb6:	5f 92       	push	r5
    4cb8:	6f 92       	push	r6
    4cba:	7f 92       	push	r7
    4cbc:	8f 92       	push	r8
    4cbe:	9f 92       	push	r9
    4cc0:	af 92       	push	r10
    4cc2:	bf 92       	push	r11
    4cc4:	cf 92       	push	r12
    4cc6:	df 92       	push	r13
    4cc8:	ef 92       	push	r14
    4cca:	ff 92       	push	r15
    4ccc:	1f 93       	push	r17
    4cce:	cf 93       	push	r28
    4cd0:	df 93       	push	r29
    4cd2:	ec 01       	movw	r28, r24
    4cd4:	6a 01       	movw	r12, r20
    4cd6:	7b 01       	movw	r14, r22
    4cd8:	72 2e       	mov	r7, r18
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:227
  size_t n = 0;
  
  if (isnan(number)) return print("nan");
    4cda:	ab 01       	movw	r20, r22
    4cdc:	96 01       	movw	r18, r12
    4cde:	cb 01       	movw	r24, r22
    4ce0:	b6 01       	movw	r22, r12
    4ce2:	0e 94 e2 6b 	call	0xd7c4	; 0xd7c4 <__unordsf2>
write():
    4ce6:	6d e6       	ldi	r22, 0x6D	; 109
    4ce8:	73 e0       	ldi	r23, 0x03	; 3
printFloat():
    4cea:	81 11       	cpse	r24, r1
    4cec:	26 c0       	rjmp	.+76     	; 0x4d3a <Print::printFloat(double, unsigned char)+0x8a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:228
  if (isinf(number)) return print("inf");
    4cee:	46 01       	movw	r8, r12
    4cf0:	57 01       	movw	r10, r14
    4cf2:	e8 94       	clt
    4cf4:	b7 f8       	bld	r11, 7
    4cf6:	2f ef       	ldi	r18, 0xFF	; 255
    4cf8:	3f ef       	ldi	r19, 0xFF	; 255
    4cfa:	4f e7       	ldi	r20, 0x7F	; 127
    4cfc:	5f e7       	ldi	r21, 0x7F	; 127
    4cfe:	c5 01       	movw	r24, r10
    4d00:	b4 01       	movw	r22, r8
    4d02:	0e 94 e2 6b 	call	0xd7c4	; 0xd7c4 <__unordsf2>
    4d06:	81 11       	cpse	r24, r1
    4d08:	0c c0       	rjmp	.+24     	; 0x4d22 <Print::printFloat(double, unsigned char)+0x72>
    4d0a:	2f ef       	ldi	r18, 0xFF	; 255
    4d0c:	3f ef       	ldi	r19, 0xFF	; 255
    4d0e:	4f e7       	ldi	r20, 0x7F	; 127
    4d10:	5f e7       	ldi	r21, 0x7F	; 127
    4d12:	c5 01       	movw	r24, r10
    4d14:	b4 01       	movw	r22, r8
    4d16:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
write():
    4d1a:	61 e7       	ldi	r22, 0x71	; 113
    4d1c:	73 e0       	ldi	r23, 0x03	; 3
printFloat():
    4d1e:	18 16       	cp	r1, r24
    4d20:	64 f0       	brlt	.+24     	; 0x4d3a <Print::printFloat(double, unsigned char)+0x8a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:229
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
    4d22:	2f ef       	ldi	r18, 0xFF	; 255
    4d24:	3f ef       	ldi	r19, 0xFF	; 255
    4d26:	4f e7       	ldi	r20, 0x7F	; 127
    4d28:	5f e4       	ldi	r21, 0x4F	; 79
    4d2a:	c7 01       	movw	r24, r14
    4d2c:	b6 01       	movw	r22, r12
    4d2e:	0e 94 dd 6b 	call	0xd7ba	; 0xd7ba <__gesf2>
    4d32:	18 16       	cp	r1, r24
    4d34:	b4 f4       	brge	.+44     	; 0x4d62 <Print::printFloat(double, unsigned char)+0xb2>
write():
    4d36:	68 e9       	ldi	r22, 0x98	; 152
    4d38:	73 e0       	ldi	r23, 0x03	; 3
    4d3a:	ce 01       	movw	r24, r28
printFloat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:266
    n += print(toPrint);
    remainder -= toPrint; 
  } 
  
  return n;
}
    4d3c:	df 91       	pop	r29
    4d3e:	cf 91       	pop	r28
    4d40:	1f 91       	pop	r17
    4d42:	ff 90       	pop	r15
    4d44:	ef 90       	pop	r14
    4d46:	df 90       	pop	r13
    4d48:	cf 90       	pop	r12
    4d4a:	bf 90       	pop	r11
    4d4c:	af 90       	pop	r10
    4d4e:	9f 90       	pop	r9
    4d50:	8f 90       	pop	r8
    4d52:	7f 90       	pop	r7
    4d54:	6f 90       	pop	r6
    4d56:	5f 90       	pop	r5
    4d58:	4f 90       	pop	r4
    4d5a:	3f 90       	pop	r3
    4d5c:	2f 90       	pop	r2
write():
    4d5e:	0c 94 b4 25 	jmp	0x4b68	; 0x4b68 <Print::write(char const*) [clone .part.2]>
printFloat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:230
  size_t n = 0;
  
  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
    4d62:	2f ef       	ldi	r18, 0xFF	; 255
    4d64:	3f ef       	ldi	r19, 0xFF	; 255
    4d66:	4f e7       	ldi	r20, 0x7F	; 127
    4d68:	5f ec       	ldi	r21, 0xCF	; 207
    4d6a:	c7 01       	movw	r24, r14
    4d6c:	b6 01       	movw	r22, r12
    4d6e:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
    4d72:	87 fd       	sbrc	r24, 7
    4d74:	e0 cf       	rjmp	.-64     	; 0x4d36 <Print::printFloat(double, unsigned char)+0x86>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:233
  
  // Handle negative numbers
  if (number < 0.0)
    4d76:	20 e0       	ldi	r18, 0x00	; 0
    4d78:	30 e0       	ldi	r19, 0x00	; 0
    4d7a:	a9 01       	movw	r20, r18
    4d7c:	c7 01       	movw	r24, r14
    4d7e:	b6 01       	movw	r22, r12
    4d80:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:225
  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits) 
{ 
  size_t n = 0;
    4d84:	31 2c       	mov	r3, r1
    4d86:	21 2c       	mov	r2, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:233
  if (isinf(number)) return print("inf");
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
  
  // Handle negative numbers
  if (number < 0.0)
    4d88:	87 ff       	sbrs	r24, 7
    4d8a:	09 c0       	rjmp	.+18     	; 0x4d9e <Print::printFloat(double, unsigned char)+0xee>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:235
  {
     n += print('-');
    4d8c:	6d e2       	ldi	r22, 0x2D	; 45
    4d8e:	ce 01       	movw	r24, r28
    4d90:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
    4d94:	1c 01       	movw	r2, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:236
     number = -number;
    4d96:	f7 fa       	bst	r15, 7
    4d98:	f0 94       	com	r15
    4d9a:	f7 f8       	bld	r15, 7
    4d9c:	f0 94       	com	r15
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:241
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    4d9e:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:240
     n += print('-');
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
    4da0:	60 e0       	ldi	r22, 0x00	; 0
    4da2:	70 e0       	ldi	r23, 0x00	; 0
    4da4:	80 e0       	ldi	r24, 0x00	; 0
    4da6:	9f e3       	ldi	r25, 0x3F	; 63
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:241
  for (uint8_t i=0; i<digits; ++i)
    4da8:	71 16       	cp	r7, r17
    4daa:	41 f0       	breq	.+16     	; 0x4dbc <Print::printFloat(double, unsigned char)+0x10c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:242
    rounding /= 10.0;
    4dac:	20 e0       	ldi	r18, 0x00	; 0
    4dae:	30 e0       	ldi	r19, 0x00	; 0
    4db0:	40 e2       	ldi	r20, 0x20	; 32
    4db2:	51 e4       	ldi	r21, 0x41	; 65
    4db4:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:241
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    4db8:	1f 5f       	subi	r17, 0xFF	; 255
    4dba:	f6 cf       	rjmp	.-20     	; 0x4da8 <Print::printFloat(double, unsigned char)+0xf8>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:244
    rounding /= 10.0;
  
  number += rounding;
    4dbc:	a7 01       	movw	r20, r14
    4dbe:	96 01       	movw	r18, r12
    4dc0:	0e 94 75 6a 	call	0xd4ea	; 0xd4ea <__addsf3>
    4dc4:	2b 01       	movw	r4, r22
    4dc6:	3c 01       	movw	r6, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:247

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
    4dc8:	0e 94 5a 6b 	call	0xd6b4	; 0xd6b4 <__fixunssfsi>
    4dcc:	4b 01       	movw	r8, r22
    4dce:	5c 01       	movw	r10, r24
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    4dd0:	2a e0       	ldi	r18, 0x0A	; 10
    4dd2:	bc 01       	movw	r22, r24
    4dd4:	a4 01       	movw	r20, r8
    4dd6:	ce 01       	movw	r24, r28
    4dd8:	0e 94 d6 25 	call	0x4bac	; 0x4bac <Print::printNumber(unsigned long, unsigned char)>
printFloat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:249
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
    4ddc:	7c 01       	movw	r14, r24
    4dde:	e2 0c       	add	r14, r2
    4de0:	f3 1c       	adc	r15, r3
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:252

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    4de2:	11 23       	and	r17, r17
    4de4:	c1 f1       	breq	.+112    	; 0x4e56 <Print::printFloat(double, unsigned char)+0x1a6>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:248
  
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
    4de6:	c5 01       	movw	r24, r10
    4de8:	b4 01       	movw	r22, r8
    4dea:	0e 94 d9 68 	call	0xd1b2	; 0xd1b2 <__floatunsisf>
    4dee:	9b 01       	movw	r18, r22
    4df0:	ac 01       	movw	r20, r24
    4df2:	c3 01       	movw	r24, r6
    4df4:	b2 01       	movw	r22, r4
    4df6:	0e 94 74 6a 	call	0xd4e8	; 0xd4e8 <__subsf3>
    4dfa:	4b 01       	movw	r8, r22
    4dfc:	5c 01       	movw	r10, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:253
  n += print(int_part);

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    n += print('.'); 
    4dfe:	6e e2       	ldi	r22, 0x2E	; 46
    4e00:	ce 01       	movw	r24, r28
    4e02:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
    4e06:	e8 0e       	add	r14, r24
    4e08:	f9 1e       	adc	r15, r25
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:257
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
    4e0a:	11 50       	subi	r17, 0x01	; 1
    4e0c:	20 f1       	brcs	.+72     	; 0x4e56 <Print::printFloat(double, unsigned char)+0x1a6>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:259
  {
    remainder *= 10.0;
    4e0e:	20 e0       	ldi	r18, 0x00	; 0
    4e10:	30 e0       	ldi	r19, 0x00	; 0
    4e12:	40 e2       	ldi	r20, 0x20	; 32
    4e14:	51 e4       	ldi	r21, 0x41	; 65
    4e16:	c5 01       	movw	r24, r10
    4e18:	b4 01       	movw	r22, r8
    4e1a:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
    4e1e:	2b 01       	movw	r4, r22
    4e20:	3c 01       	movw	r6, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:260
    unsigned int toPrint = (unsigned int)(remainder);
    4e22:	0e 94 5a 6b 	call	0xd6b4	; 0xd6b4 <__fixunssfsi>
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:84
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base)
{
  return print((unsigned long) n, base);
    4e26:	4b 01       	movw	r8, r22
    4e28:	b1 2c       	mov	r11, r1
    4e2a:	a1 2c       	mov	r10, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    4e2c:	2a e0       	ldi	r18, 0x0A	; 10
    4e2e:	b5 01       	movw	r22, r10
    4e30:	a4 01       	movw	r20, r8
    4e32:	ce 01       	movw	r24, r28
    4e34:	0e 94 d6 25 	call	0x4bac	; 0x4bac <Print::printNumber(unsigned long, unsigned char)>
printFloat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:261
  // Extract digits from the remainder one at a time
  while (digits-- > 0)
  {
    remainder *= 10.0;
    unsigned int toPrint = (unsigned int)(remainder);
    n += print(toPrint);
    4e38:	e8 0e       	add	r14, r24
    4e3a:	f9 1e       	adc	r15, r25
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:262
    remainder -= toPrint; 
    4e3c:	c5 01       	movw	r24, r10
    4e3e:	b4 01       	movw	r22, r8
    4e40:	0e 94 d9 68 	call	0xd1b2	; 0xd1b2 <__floatunsisf>
    4e44:	9b 01       	movw	r18, r22
    4e46:	ac 01       	movw	r20, r24
    4e48:	c3 01       	movw	r24, r6
    4e4a:	b2 01       	movw	r22, r4
    4e4c:	0e 94 74 6a 	call	0xd4e8	; 0xd4e8 <__subsf3>
    4e50:	4b 01       	movw	r8, r22
    4e52:	5c 01       	movw	r10, r24
    4e54:	da cf       	rjmp	.-76     	; 0x4e0a <Print::printFloat(double, unsigned char)+0x15a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:266
  } 
  
  return n;
}
    4e56:	c7 01       	movw	r24, r14
    4e58:	df 91       	pop	r29
    4e5a:	cf 91       	pop	r28
    4e5c:	1f 91       	pop	r17
    4e5e:	ff 90       	pop	r15
    4e60:	ef 90       	pop	r14
    4e62:	df 90       	pop	r13
    4e64:	cf 90       	pop	r12
    4e66:	bf 90       	pop	r11
    4e68:	af 90       	pop	r10
    4e6a:	9f 90       	pop	r9
    4e6c:	8f 90       	pop	r8
    4e6e:	7f 90       	pop	r7
    4e70:	6f 90       	pop	r6
    4e72:	5f 90       	pop	r5
    4e74:	4f 90       	pop	r4
    4e76:	3f 90       	pop	r3
    4e78:	2f 90       	pop	r2
    4e7a:	08 95       	ret

00004e7c <Print::println(char const*)>:
println():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:139
  n += println();
  return n;
}

size_t Print::println(const char c[])
{
    4e7c:	0f 93       	push	r16
    4e7e:	1f 93       	push	r17
    4e80:	cf 93       	push	r28
    4e82:	df 93       	push	r29
    4e84:	8c 01       	movw	r16, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:53
    4e86:	d0 e0       	ldi	r29, 0x00	; 0
    4e88:	c0 e0       	ldi	r28, 0x00	; 0
write():
    4e8a:	61 15       	cp	r22, r1
    4e8c:	71 05       	cpc	r23, r1
    4e8e:	19 f0       	breq	.+6      	; 0x4e96 <Print::println(char const*)+0x1a>
    4e90:	0e 94 b4 25 	call	0x4b68	; 0x4b68 <Print::write(char const*) [clone .part.2]>
    4e94:	ec 01       	movw	r28, r24
    4e96:	6a e6       	ldi	r22, 0x6A	; 106
    4e98:	73 e0       	ldi	r23, 0x03	; 3
    4e9a:	c8 01       	movw	r24, r16
    4e9c:	0e 94 b4 25 	call	0x4b68	; 0x4b68 <Print::write(char const*) [clone .part.2]>
println():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:143
  size_t n = print(c);
  n += println();
  return n;
}
    4ea0:	8c 0f       	add	r24, r28
    4ea2:	9d 1f       	adc	r25, r29
    4ea4:	df 91       	pop	r29
    4ea6:	cf 91       	pop	r28
    4ea8:	1f 91       	pop	r17
    4eaa:	0f 91       	pop	r16
    4eac:	08 95       	ret

00004eae <SD_checking()>:
SD_checking():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:1
void SD_checking() {
    4eae:	cf 92       	push	r12
    4eb0:	df 92       	push	r13
    4eb2:	ef 92       	push	r14
    4eb4:	ff 92       	push	r15
    4eb6:	1f 93       	push	r17
    4eb8:	cf 93       	push	r28
    4eba:	df 93       	push	r29
begin():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:340
  /* Implementation of class used to create `SDCard` object. */



  boolean SDClass::begin(uint8_t csPin) {
    if (root.isOpen()) {
    4ebc:	80 91 22 0f 	lds	r24, 0x0F22	; 0x800f22 <SDLib::SD+0x2f>
    4ec0:	88 23       	and	r24, r24
    4ec2:	21 f0       	breq	.+8      	; 0x4ecc <SD_checking()+0x1e>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:341
      root.close();
    4ec4:	8d e1       	ldi	r24, 0x1D	; 29
    4ec6:	9f e0       	ldi	r25, 0x0F	; 15
    4ec8:	0e 94 9e 16 	call	0x2d3c	; 0x2d3c <SdFile::close()>
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:258
   \return The value one, true, is returned for success and
   the value zero, false, is returned for failure.  The reason for failure
   can be determined by calling errorCode() and errorData().
*/
uint8_t Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
  errorCode_ = inBlock_ = partialBlockRead_ = type_ = 0;
    4ecc:	10 92 fe 0e 	sts	0x0EFE, r1	; 0x800efe <SDLib::SD+0xb>
    4ed0:	10 92 fc 0e 	sts	0x0EFC, r1	; 0x800efc <SDLib::SD+0x9>
    4ed4:	10 92 f9 0e 	sts	0x0EF9, r1	; 0x800ef9 <SDLib::SD+0x6>
    4ed8:	10 92 f8 0e 	sts	0x0EF8, r1	; 0x800ef8 <SDLib::SD+0x5>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:259
  chipSelectPin_ = chipSelectPin;
    4edc:	84 e0       	ldi	r24, 0x04	; 4
    4ede:	80 93 f7 0e 	sts	0x0EF7, r24	; 0x800ef7 <SDLib::SD+0x4>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:261
  // 16-bit init start time allows over a minute
  unsigned int t0 = millis();
    4ee2:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    4ee6:	eb 01       	movw	r28, r22
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:265
  uint32_t arg;

  // set pin modes
  pinMode(chipSelectPin_, OUTPUT);
    4ee8:	61 e0       	ldi	r22, 0x01	; 1
    4eea:	80 91 f7 0e 	lds	r24, 0x0EF7	; 0x800ef7 <SDLib::SD+0x4>
    4eee:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:266
  digitalWrite(chipSelectPin_, HIGH);
    4ef2:	61 e0       	ldi	r22, 0x01	; 1
    4ef4:	80 91 f7 0e 	lds	r24, 0x0EF7	; 0x800ef7 <SDLib::SD+0x4>
    4ef8:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:283
  // Enable SPI, Master, clock rate f_osc/128
  SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1) | (1 << SPR0);
  // clear double speed
  SPSR &= ~(1 << SPI2X);
  #else // USE_SPI_LIB
  SDCARD_SPI.begin();
    4efc:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <SPIClass::begin()>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:284
  settings = SPISettings(250000, MSBFIRST, SPI_MODE0);
    4f00:	82 e5       	ldi	r24, 0x52	; 82
    4f02:	80 93 f1 0e 	sts	0x0EF1, r24	; 0x800ef1 <settings>
    4f06:	10 92 f2 0e 	sts	0x0EF2, r1	; 0x800ef2 <settings+0x1>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:290
  #endif // USE_SPI_LIB
  #endif // SOFTWARE_SPI

  // must supply min of 74 clock cycles with CS high.
  #ifdef USE_SPI_LIB
  SDCARD_SPI.beginTransaction(settings);
    4f0a:	80 91 f1 0e 	lds	r24, 0x0EF1	; 0x800ef1 <settings>
    4f0e:	90 91 f2 0e 	lds	r25, 0x0EF2	; 0x800ef2 <settings+0x1>
    4f12:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <SPIClass::beginTransaction(SPISettings)>
    4f16:	1a e0       	ldi	r17, 0x0A	; 10
spiSend():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:42
  #ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
  #else
  SDCARD_SPI.transfer(b);
    4f18:	8f ef       	ldi	r24, 0xFF	; 255
    4f1a:	0e 94 e0 0d 	call	0x1bc0	; 0x1bc0 <SPIClass::transfer(unsigned char)>
    4f1e:	11 50       	subi	r17, 0x01	; 1
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:292

  // must supply min of 74 clock cycles with CS high.
  #ifdef USE_SPI_LIB
  SDCARD_SPI.beginTransaction(settings);
  #endif
  for (uint8_t i = 0; i < 10; i++) {
    4f20:	d9 f7       	brne	.-10     	; 0x4f18 <SD_checking()+0x6a>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:299
  }
  #ifdef USE_SPI_LIB
  SDCARD_SPI.endTransaction();
  #endif

  chipSelectLow();
    4f22:	83 ef       	ldi	r24, 0xF3	; 243
    4f24:	9e e0       	ldi	r25, 0x0E	; 14
    4f26:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <Sd2Card::chipSelectLow()>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:302

  // command to go idle in SPI mode
  while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
    4f2a:	20 e0       	ldi	r18, 0x00	; 0
    4f2c:	30 e0       	ldi	r19, 0x00	; 0
    4f2e:	a9 01       	movw	r20, r18
    4f30:	60 e0       	ldi	r22, 0x00	; 0
    4f32:	83 ef       	ldi	r24, 0xF3	; 243
    4f34:	9e e0       	ldi	r25, 0x0E	; 14
    4f36:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <Sd2Card::cardCommand(unsigned char, unsigned long)>
    4f3a:	18 2f       	mov	r17, r24
    4f3c:	80 93 fd 0e 	sts	0x0EFD, r24	; 0x800efd <SDLib::SD+0xa>
    4f40:	81 30       	cpi	r24, 0x01	; 1
    4f42:	19 f1       	breq	.+70     	; 0x4f8a <SD_checking()+0xdc>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:303
    unsigned int d = millis() - t0;
    4f44:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    4f48:	6c 1b       	sub	r22, r28
    4f4a:	7d 0b       	sbc	r23, r29
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:304
    if (d > SD_INIT_TIMEOUT) {
    4f4c:	61 3d       	cpi	r22, 0xD1	; 209
    4f4e:	77 40       	sbci	r23, 0x07	; 7
    4f50:	60 f3       	brcs	.-40     	; 0x4f2a <SD_checking()+0x7c>
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
    4f52:	81 e0       	ldi	r24, 0x01	; 1
    4f54:	80 93 f8 0e 	sts	0x0EF8, r24	; 0x800ef8 <SDLib::SD+0x5>
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:357
  #else  // SOFTWARE_SPI
  return true;
  #endif  // SOFTWARE_SPI

fail:
  chipSelectHigh();
    4f58:	83 ef       	ldi	r24, 0xF3	; 243
    4f5a:	9e e0       	ldi	r25, 0x0E	; 14
    4f5c:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <Sd2Card::chipSelectHigh()>
SD_checking():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:4
	//lcd_qSprint("SD.....", 0, 1);
	if (!SD.begin(chipSelect)) {
		Serial.println("SD Devive error");
    4f60:	65 e7       	ldi	r22, 0x75	; 117
    4f62:	73 e0       	ldi	r23, 0x03	; 3
    4f64:	82 e5       	ldi	r24, 0x52	; 82
    4f66:	9e e0       	ldi	r25, 0x0E	; 14
    4f68:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:5
		SD_alive = false;
    4f6c:	10 92 19 02 	sts	0x0219, r1	; 0x800219 <SD_alive>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:6
		SDIO.resume();
    4f70:	89 e2       	ldi	r24, 0x29	; 41
    4f72:	90 e1       	ldi	r25, 0x10	; 16
    4f74:	0e 94 60 1d 	call	0x3ac0	; 0x3ac0 <BlinkControl::resume()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:11
		waring();
	}
	else SD_alive = true;
	//lcd_qSprint(SD_alive ? "OK >w<" : "**FAIL**", 7, 1);
}
    4f78:	df 91       	pop	r29
    4f7a:	cf 91       	pop	r28
    4f7c:	1f 91       	pop	r17
    4f7e:	ff 90       	pop	r15
    4f80:	ef 90       	pop	r14
    4f82:	df 90       	pop	r13
    4f84:	cf 90       	pop	r12
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:7
	//lcd_qSprint("SD.....", 0, 1);
	if (!SD.begin(chipSelect)) {
		Serial.println("SD Devive error");
		SD_alive = false;
		SDIO.resume();
		waring();
    4f86:	0c 94 b1 1d 	jmp	0x3b62	; 0x3b62 <waring()>
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:310
      error(SD_CARD_ERROR_CMD0);
      goto fail;
    }
  }
  // check SD version
  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    4f8a:	2a ea       	ldi	r18, 0xAA	; 170
    4f8c:	31 e0       	ldi	r19, 0x01	; 1
    4f8e:	40 e0       	ldi	r20, 0x00	; 0
    4f90:	50 e0       	ldi	r21, 0x00	; 0
    4f92:	68 e0       	ldi	r22, 0x08	; 8
    4f94:	83 ef       	ldi	r24, 0xF3	; 243
    4f96:	9e e0       	ldi	r25, 0x0E	; 14
    4f98:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <Sd2Card::cardCommand(unsigned char, unsigned long)>
    4f9c:	82 ff       	sbrs	r24, 2
    4f9e:	2a c0       	rjmp	.+84     	; 0x4ff4 <SD_checking()+0x146>
_ZN7Sd2Card4typeEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:267
    uint8_t readRegister(uint8_t cmd, void* buf);
    uint8_t sendWriteCommand(uint32_t blockNumber, uint32_t eraseCount);
    void chipSelectHigh(void);
    void chipSelectLow(void);
    void type(uint8_t value) {
      type_ = value;
    4fa0:	10 93 fe 0e 	sts	0x0EFE, r17	; 0x800efe <SDLib::SD+0xb>
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:324
      goto fail;
    }
    type(SD_CARD_TYPE_SD2);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    4fa4:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <SDLib::SD+0xb>
SD_checking():
    4fa8:	c1 2c       	mov	r12, r1
    4faa:	d1 2c       	mov	r13, r1
    4fac:	76 01       	movw	r14, r12
init():
    4fae:	82 30       	cpi	r24, 0x02	; 2
    4fb0:	29 f4       	brne	.+10     	; 0x4fbc <SD_checking()+0x10e>
SD_checking():
    4fb2:	c1 2c       	mov	r12, r1
    4fb4:	d1 2c       	mov	r13, r1
    4fb6:	e1 2c       	mov	r14, r1
    4fb8:	80 e4       	ldi	r24, 0x40	; 64
    4fba:	f8 2e       	mov	r15, r24
cardAcmd():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:255
    uint8_t partialBlockRead_;
    uint8_t status_;
    uint8_t type_;
    // private functions
    uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
      cardCommand(CMD55, 0);
    4fbc:	20 e0       	ldi	r18, 0x00	; 0
    4fbe:	30 e0       	ldi	r19, 0x00	; 0
    4fc0:	a9 01       	movw	r20, r18
    4fc2:	67 e3       	ldi	r22, 0x37	; 55
    4fc4:	83 ef       	ldi	r24, 0xF3	; 243
    4fc6:	9e e0       	ldi	r25, 0x0E	; 14
    4fc8:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <Sd2Card::cardCommand(unsigned char, unsigned long)>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:256
      return cardCommand(cmd, arg);
    4fcc:	a7 01       	movw	r20, r14
    4fce:	96 01       	movw	r18, r12
    4fd0:	69 e2       	ldi	r22, 0x29	; 41
    4fd2:	83 ef       	ldi	r24, 0xF3	; 243
    4fd4:	9e e0       	ldi	r25, 0x0E	; 14
    4fd6:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <Sd2Card::cardCommand(unsigned char, unsigned long)>
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:326

  while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
    4fda:	80 93 fd 0e 	sts	0x0EFD, r24	; 0x800efd <SDLib::SD+0xa>
    4fde:	88 23       	and	r24, r24
    4fe0:	c1 f0       	breq	.+48     	; 0x5012 <SD_checking()+0x164>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:328
    // check for timeout
    unsigned int d = millis() - t0;
    4fe2:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    4fe6:	6c 1b       	sub	r22, r28
    4fe8:	7d 0b       	sbc	r23, r29
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:329
    if (d > SD_INIT_TIMEOUT) {
    4fea:	61 3d       	cpi	r22, 0xD1	; 209
    4fec:	77 40       	sbci	r23, 0x07	; 7
    4fee:	30 f3       	brcs	.-52     	; 0x4fbc <SD_checking()+0x10e>
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
    }
    uint8_t cardCommand(uint8_t cmd, uint32_t arg);
    void error(uint8_t code) {
      errorCode_ = code;
    4ff0:	88 e0       	ldi	r24, 0x08	; 8
    4ff2:	b0 cf       	rjmp	.-160    	; 0x4f54 <SD_checking()+0xa6>
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:310
      error(SD_CARD_ERROR_CMD0);
      goto fail;
    }
  }
  // check SD version
  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    4ff4:	14 e0       	ldi	r17, 0x04	; 4
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:315
    type(SD_CARD_TYPE_SD1);
  } else {
    // only need last byte of r7 response
    for (uint8_t i = 0; i < 4; i++) {
      status_ = spiRec();
    4ff6:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    4ffa:	80 93 fd 0e 	sts	0x0EFD, r24	; 0x800efd <SDLib::SD+0xa>
    4ffe:	11 50       	subi	r17, 0x01	; 1
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:314
  // check SD version
  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD1);
  } else {
    // only need last byte of r7 response
    for (uint8_t i = 0; i < 4; i++) {
    5000:	d1 f7       	brne	.-12     	; 0x4ff6 <SD_checking()+0x148>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:317
      status_ = spiRec();
    }
    if (status_ != 0XAA) {
    5002:	8a 3a       	cpi	r24, 0xAA	; 170
    5004:	11 f0       	breq	.+4      	; 0x500a <SD_checking()+0x15c>
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
    5006:	82 e0       	ldi	r24, 0x02	; 2
    5008:	a5 cf       	rjmp	.-182    	; 0x4f54 <SD_checking()+0xa6>
_ZN7Sd2Card4typeEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:267
    uint8_t readRegister(uint8_t cmd, void* buf);
    uint8_t sendWriteCommand(uint32_t blockNumber, uint32_t eraseCount);
    void chipSelectHigh(void);
    void chipSelectLow(void);
    void type(uint8_t value) {
      type_ = value;
    500a:	82 e0       	ldi	r24, 0x02	; 2
    500c:	80 93 fe 0e 	sts	0x0EFE, r24	; 0x800efe <SDLib::SD+0xb>
    5010:	c9 cf       	rjmp	.-110    	; 0x4fa4 <SD_checking()+0xf6>
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:335
      error(SD_CARD_ERROR_ACMD41);
      goto fail;
    }
  }
  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    5012:	80 91 fe 0e 	lds	r24, 0x0EFE	; 0x800efe <SDLib::SD+0xb>
    5016:	82 30       	cpi	r24, 0x02	; 2
    5018:	d1 f4       	brne	.+52     	; 0x504e <SD_checking()+0x1a0>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:336
    if (cardCommand(CMD58, 0)) {
    501a:	20 e0       	ldi	r18, 0x00	; 0
    501c:	30 e0       	ldi	r19, 0x00	; 0
    501e:	a9 01       	movw	r20, r18
    5020:	6a e3       	ldi	r22, 0x3A	; 58
    5022:	83 ef       	ldi	r24, 0xF3	; 243
    5024:	9e e0       	ldi	r25, 0x0E	; 14
    5026:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <Sd2Card::cardCommand(unsigned char, unsigned long)>
    502a:	88 23       	and	r24, r24
    502c:	11 f0       	breq	.+4      	; 0x5032 <SD_checking()+0x184>
_ZN7Sd2Card5errorEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:260
      cardCommand(CMD55, 0);
      return cardCommand(cmd, arg);
    }
    uint8_t cardCommand(uint8_t cmd, uint32_t arg);
    void error(uint8_t code) {
      errorCode_ = code;
    502e:	86 e0       	ldi	r24, 0x06	; 6
    5030:	91 cf       	rjmp	.-222    	; 0x4f54 <SD_checking()+0xa6>
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:340
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiRec() & 0XC0) == 0XC0) {
    5032:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    5036:	80 7c       	andi	r24, 0xC0	; 192
    5038:	80 3c       	cpi	r24, 0xC0	; 192
    503a:	19 f4       	brne	.+6      	; 0x5042 <SD_checking()+0x194>
_ZN7Sd2Card4typeEh():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.h:267
    uint8_t readRegister(uint8_t cmd, void* buf);
    uint8_t sendWriteCommand(uint32_t blockNumber, uint32_t eraseCount);
    void chipSelectHigh(void);
    void chipSelectLow(void);
    void type(uint8_t value) {
      type_ = value;
    503c:	83 e0       	ldi	r24, 0x03	; 3
    503e:	80 93 fe 0e 	sts	0x0EFE, r24	; 0x800efe <SDLib::SD+0xb>
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:345
      type(SD_CARD_TYPE_SDHC);
    }
    // discard rest of ocr - contains allowed voltage range
    for (uint8_t i = 0; i < 3; i++) {
      spiRec();
    5042:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    5046:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
    504a:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <spiRec()>
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:348
    }
  }
  chipSelectHigh();
    504e:	83 ef       	ldi	r24, 0xF3	; 243
    5050:	9e e0       	ldi	r25, 0x0E	; 14
    5052:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <Sd2Card::chipSelectHigh()>
setSckRate():
D:\USER\Documents\Arduino\libraries\SD\src\utility/Sd2Card.cpp:553
  SPCR |= (sckRateID & 4 ? (1 << SPR1) : 0)
          | (sckRateID & 2 ? (1 << SPR0) : 0);
  #else // USE_SPI_LIB
  switch (sckRateID) {
    case 0:  settings = SPISettings(25000000, MSBFIRST, SPI_MODE0); break;
    case 1:  settings = SPISettings(4000000, MSBFIRST, SPI_MODE0); break;
    5056:	80 e5       	ldi	r24, 0x50	; 80
    5058:	80 93 f1 0e 	sts	0x0EF1, r24	; 0x800ef1 <settings>
    505c:	10 92 f2 0e 	sts	0x0EF2, r1	; 0x800ef2 <settings+0x1>
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:506
       the value zero, false, is returned for failure.  Reasons for
       failure include not finding a valid partition, not finding a valid
       FAT file system or an I/O error.
    */
    uint8_t init(Sd2Card* dev) {
      return init(dev, 1) ? true : init(dev, 0);
    5060:	81 e0       	ldi	r24, 0x01	; 1
    5062:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]>
    5066:	88 23       	and	r24, r24
    5068:	91 f0       	breq	.+36     	; 0x508e <SD_checking()+0x1e0>
openRoot():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:395
    uint8_t open(SdFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT
      return open(&dirFile, index, oflag);
    }
    /** \deprecated Use: uint8_t SdFile::openRoot(SdVolume* vol); */
    uint8_t openRoot(SdVolume& vol) {
      return openRoot(&vol); // NOLINT
    506a:	8d e1       	ldi	r24, 0x1D	; 29
    506c:	9f e0       	ldi	r25, 0x0F	; 15
    506e:	0e 94 12 14 	call	0x2824	; 0x2824 <SdFile::openRoot(SdVolume*) [clone .constprop.152]>
begin():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:352

      Return true if initialization succeeds, false otherwise.

    */
    return card.init(SPI_HALF_SPEED, csPin) &&
           volume.init(card) &&
    5072:	88 23       	and	r24, r24
    5074:	09 f4       	brne	.+2      	; 0x5078 <SD_checking()+0x1ca>
    5076:	74 cf       	rjmp	.-280    	; 0x4f60 <SD_checking()+0xb2>
SD_checking():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:9
	}
	else SD_alive = true;
    5078:	81 e0       	ldi	r24, 0x01	; 1
    507a:	80 93 19 02 	sts	0x0219, r24	; 0x800219 <SD_alive>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:11
	//lcd_qSprint(SD_alive ? "OK >w<" : "**FAIL**", 7, 1);
}
    507e:	df 91       	pop	r29
    5080:	cf 91       	pop	r28
    5082:	1f 91       	pop	r17
    5084:	ff 90       	pop	r15
    5086:	ef 90       	pop	r14
    5088:	df 90       	pop	r13
    508a:	cf 90       	pop	r12
    508c:	08 95       	ret
init():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:506
       the value zero, false, is returned for failure.  Reasons for
       failure include not finding a valid partition, not finding a valid
       FAT file system or an I/O error.
    */
    uint8_t init(Sd2Card* dev) {
      return init(dev, 1) ? true : init(dev, 0);
    508e:	80 e0       	ldi	r24, 0x00	; 0
    5090:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <SdVolume::init(Sd2Card*, unsigned char) [clone .constprop.68]>
begin():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:351
      Performs the initialisation required by the sdfatlib library.

      Return true if initialization succeeds, false otherwise.

    */
    return card.init(SPI_HALF_SPEED, csPin) &&
    5094:	88 23       	and	r24, r24
    5096:	09 f4       	brne	.+2      	; 0x509a <SD_checking()+0x1ec>
    5098:	63 cf       	rjmp	.-314    	; 0x4f60 <SD_checking()+0xb2>
    509a:	e7 cf       	rjmp	.-50     	; 0x506a <SD_checking()+0x1bc>

0000509c <Print::println(String const&)>:
println():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:132
{
  return write("\r\n");
}

size_t Print::println(const String &s)
{
    509c:	0f 93       	push	r16
    509e:	1f 93       	push	r17
    50a0:	cf 93       	push	r28
    50a2:	df 93       	push	r29
    50a4:	ec 01       	movw	r28, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:133
  size_t n = print(s);
    50a6:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    50aa:	8c 01       	movw	r16, r24
write():
    50ac:	6a e6       	ldi	r22, 0x6A	; 106
    50ae:	73 e0       	ldi	r23, 0x03	; 3
    50b0:	ce 01       	movw	r24, r28
    50b2:	0e 94 b4 25 	call	0x4b68	; 0x4b68 <Print::write(char const*) [clone .part.2]>
println():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:136
  n += println();
  return n;
}
    50b6:	80 0f       	add	r24, r16
    50b8:	91 1f       	adc	r25, r17
    50ba:	df 91       	pop	r29
    50bc:	cf 91       	pop	r28
    50be:	1f 91       	pop	r17
    50c0:	0f 91       	pop	r16
    50c2:	08 95       	ret

000050c4 <LCDSerialPrint(String)>:
LCDSerialPrint():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:90
	lcd.setCursor(0, 1);
	for (int i = 0; i < 17; i++)lcd.print(" ");
	//row1cleared = true;
}

void LCDSerialPrint(String s) {
    50c4:	cf 93       	push	r28
    50c6:	df 93       	push	r29
    50c8:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:91
	lcd.clear();
    50ca:	0e 94 e5 22 	call	0x45ca	; 0x45ca <LiquidCrystal_I2C::clear() [clone .constprop.143]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:92
	lcd.setCursor(0, 0);
    50ce:	60 e0       	ldi	r22, 0x00	; 0
    50d0:	80 e0       	ldi	r24, 0x00	; 0
    50d2:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:93
	lcd.print(s);
    50d6:	be 01       	movw	r22, r28
    50d8:	8b eb       	ldi	r24, 0xBB	; 187
    50da:	90 e1       	ldi	r25, 0x10	; 16
    50dc:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:94
	Serial.println(s);
    50e0:	be 01       	movw	r22, r28
    50e2:	82 e5       	ldi	r24, 0x52	; 82
    50e4:	9e e0       	ldi	r25, 0x0E	; 14
    50e6:	0e 94 4e 28 	call	0x509c	; 0x509c <Print::println(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:95
	delay(50);
    50ea:	62 e3       	ldi	r22, 0x32	; 50
    50ec:	70 e0       	ldi	r23, 0x00	; 0
    50ee:	80 e0       	ldi	r24, 0x00	; 0
    50f0:	90 e0       	ldi	r25, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:96
}
    50f2:	df 91       	pop	r29
    50f4:	cf 91       	pop	r28
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:95
void LCDSerialPrint(String s) {
	lcd.clear();
	lcd.setCursor(0, 0);
	lcd.print(s);
	Serial.println(s);
	delay(50);
    50f6:	0c 94 34 0d 	jmp	0x1a68	; 0x1a68 <delay>

000050fa <Print::print(char const*)>:
write():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:63
{
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
    50fa:	0c 94 b4 25 	jmp	0x4b68	; 0x4b68 <Print::write(char const*) [clone .part.2]>

000050fe <RemoveBTNmessage()>:
RemoveBTNmessage():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:84
	lcd.setCursor(0, 1);
	for (int i = 0; i < 10; i++)	lcd.print(keypaddata[i] == '\0' ? " " : String(keypaddata[i]));
	//lcd.print(String(keypaddata));
}

void RemoveBTNmessage() {
    50fe:	cf 93       	push	r28
    5100:	df 93       	push	r29
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:85
	lcd.setCursor(0, 1);
    5102:	61 e0       	ldi	r22, 0x01	; 1
    5104:	80 e0       	ldi	r24, 0x00	; 0
    5106:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
    510a:	c1 e1       	ldi	r28, 0x11	; 17
    510c:	d0 e0       	ldi	r29, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:86
	for (int i = 0; i < 17; i++)lcd.print(" ");
    510e:	6c e8       	ldi	r22, 0x8C	; 140
    5110:	77 e0       	ldi	r23, 0x07	; 7
    5112:	8b eb       	ldi	r24, 0xBB	; 187
    5114:	90 e1       	ldi	r25, 0x10	; 16
    5116:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
    511a:	21 97       	sbiw	r28, 0x01	; 1
    511c:	c1 f7       	brne	.-16     	; 0x510e <RemoveBTNmessage()+0x10>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:88
	//row1cleared = true;
}
    511e:	df 91       	pop	r29
    5120:	cf 91       	pop	r28
    5122:	08 95       	ret

00005124 <SerialDebug(String, String)>:
SerialDebug():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:162
	}
	free(str_arr);
	return result;
}

void SerialDebug(String title, String value) {
    5124:	0f 93       	push	r16
    5126:	1f 93       	push	r17
    5128:	cf 93       	push	r28
    512a:	df 93       	push	r29
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:163
	if (DEBUG || debugMode)
    512c:	20 91 fa 09 	lds	r18, 0x09FA	; 0x8009fa <debugMode>
    5130:	22 23       	and	r18, r18
    5132:	b1 f0       	breq	.+44     	; 0x5160 <SerialDebug(String, String)+0x3c>
    5134:	eb 01       	movw	r28, r22
    5136:	8c 01       	movw	r16, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:165
	{
		Serial.print("$ ");
    5138:	65 e8       	ldi	r22, 0x85	; 133
    513a:	73 e0       	ldi	r23, 0x03	; 3
    513c:	82 e5       	ldi	r24, 0x52	; 82
    513e:	9e e0       	ldi	r25, 0x0E	; 14
    5140:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:166
		Serial.print(title);
    5144:	b8 01       	movw	r22, r16
    5146:	82 e5       	ldi	r24, 0x52	; 82
    5148:	9e e0       	ldi	r25, 0x0E	; 14
    514a:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:167
		Serial.println(value);
    514e:	be 01       	movw	r22, r28
    5150:	82 e5       	ldi	r24, 0x52	; 82
    5152:	9e e0       	ldi	r25, 0x0E	; 14
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:169
	}
    5154:	df 91       	pop	r29
    5156:	cf 91       	pop	r28
    5158:	1f 91       	pop	r17
    515a:	0f 91       	pop	r16
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:167
void SerialDebug(String title, String value) {
	if (DEBUG || debugMode)
	{
		Serial.print("$ ");
		Serial.print(title);
		Serial.println(value);
    515c:	0c 94 4e 28 	jmp	0x509c	; 0x509c <Print::println(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:169
	}
    5160:	df 91       	pop	r29
    5162:	cf 91       	pop	r28
    5164:	1f 91       	pop	r17
    5166:	0f 91       	pop	r16
    5168:	08 95       	ret

0000516a <String::toDouble() const>:
toDouble():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:748
	return float(toDouble());
}

double String::toDouble(void) const
{
	if (buffer) return atof(buffer);
    516a:	fc 01       	movw	r30, r24
    516c:	80 81       	ld	r24, Z
    516e:	91 81       	ldd	r25, Z+1	; 0x01
    5170:	00 97       	sbiw	r24, 0x00	; 0
    5172:	11 f0       	breq	.+4      	; 0x5178 <String::toDouble() const+0xe>
    5174:	0c 94 fd 63 	jmp	0xc7fa	; 0xc7fa <atof>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:750
	return 0;
}
    5178:	60 e0       	ldi	r22, 0x00	; 0
    517a:	70 e0       	ldi	r23, 0x00	; 0
    517c:	cb 01       	movw	r24, r22
    517e:	08 95       	ret

00005180 <String::toInt() const>:
toInt():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:737
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
	if (buffer) return atol(buffer);
    5180:	fc 01       	movw	r30, r24
    5182:	80 81       	ld	r24, Z
    5184:	91 81       	ldd	r25, Z+1	; 0x01
    5186:	00 97       	sbiw	r24, 0x00	; 0
    5188:	11 f0       	breq	.+4      	; 0x518e <String::toInt() const+0xe>
    518a:	0c 94 1f 64 	jmp	0xc83e	; 0xc83e <atol>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:739
	return 0;
}
    518e:	60 e0       	ldi	r22, 0x00	; 0
    5190:	70 e0       	ldi	r23, 0x00	; 0
    5192:	cb 01       	movw	r24, r22
    5194:	08 95       	ret

00005196 <TinyGPSPlus::parseDegrees(char const*, RawDegrees&)>:
parseDegrees():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:133
}

// static
// Parse degrees in that funny NMEA format DDMM.MMMM
void TinyGPSPlus::parseDegrees(const char *term, RawDegrees &deg)
{
    5196:	2f 92       	push	r2
    5198:	3f 92       	push	r3
    519a:	4f 92       	push	r4
    519c:	5f 92       	push	r5
    519e:	6f 92       	push	r6
    51a0:	7f 92       	push	r7
    51a2:	8f 92       	push	r8
    51a4:	9f 92       	push	r9
    51a6:	af 92       	push	r10
    51a8:	bf 92       	push	r11
    51aa:	cf 92       	push	r12
    51ac:	df 92       	push	r13
    51ae:	ef 92       	push	r14
    51b0:	ff 92       	push	r15
    51b2:	0f 93       	push	r16
    51b4:	1f 93       	push	r17
    51b6:	cf 93       	push	r28
    51b8:	df 93       	push	r29
    51ba:	d8 2f       	mov	r29, r24
    51bc:	c9 2f       	mov	r28, r25
    51be:	8b 01       	movw	r16, r22
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:134
  uint32_t leftOfDecimal = (uint32_t)atol(term);
    51c0:	0e 94 1f 64 	call	0xc83e	; 0xc83e <atol>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:135
  uint16_t minutes = (uint16_t)(leftOfDecimal % 100);
    51c4:	24 e6       	ldi	r18, 0x64	; 100
    51c6:	30 e0       	ldi	r19, 0x00	; 0
    51c8:	40 e0       	ldi	r20, 0x00	; 0
    51ca:	50 e0       	ldi	r21, 0x00	; 0
    51cc:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    51d0:	49 01       	movw	r8, r18
    51d2:	9b 01       	movw	r18, r22
    51d4:	ac 01       	movw	r20, r24
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:137
  uint32_t multiplier = 10000000UL;
  uint32_t tenMillionthsOfMinutes = minutes * multiplier;
    51d6:	60 e8       	ldi	r22, 0x80	; 128
    51d8:	76 e9       	ldi	r23, 0x96	; 150
    51da:	88 e9       	ldi	r24, 0x98	; 152
    51dc:	90 e0       	ldi	r25, 0x00	; 0
    51de:	0e 94 e7 6b 	call	0xd7ce	; 0xd7ce <__mulsi3>
    51e2:	6b 01       	movw	r12, r22
    51e4:	7c 01       	movw	r14, r24
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:139

  deg.deg = (int16_t)(leftOfDecimal / 100);
    51e6:	f8 01       	movw	r30, r16
    51e8:	91 82       	std	Z+1, r9	; 0x01
    51ea:	80 82       	st	Z, r8
    51ec:	ed 2f       	mov	r30, r29
    51ee:	fc 2f       	mov	r31, r28
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:141

  while (isdigit(*term))
    51f0:	21 91       	ld	r18, Z+
    51f2:	82 2f       	mov	r24, r18
    51f4:	02 2e       	mov	r0, r18
    51f6:	00 0c       	add	r0, r0
    51f8:	99 0b       	sbc	r25, r25
    51fa:	c0 97       	sbiw	r24, 0x30	; 48
    51fc:	0a 97       	sbiw	r24, 0x0a	; 10
    51fe:	c0 f3       	brcs	.-16     	; 0x51f0 <TinyGPSPlus::parseDegrees(char const*, RawDegrees&)+0x5a>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:144
    ++term;

  if (*term == '.')
    5200:	2e 32       	cpi	r18, 0x2E	; 46
    5202:	39 f5       	brne	.+78     	; 0x5252 <TinyGPSPlus::parseDegrees(char const*, RawDegrees&)+0xbc>
    5204:	1f 01       	movw	r2, r30
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:136
// Parse degrees in that funny NMEA format DDMM.MMMM
void TinyGPSPlus::parseDegrees(const char *term, RawDegrees &deg)
{
  uint32_t leftOfDecimal = (uint32_t)atol(term);
  uint16_t minutes = (uint16_t)(leftOfDecimal % 100);
  uint32_t multiplier = 10000000UL;
    5206:	80 e8       	ldi	r24, 0x80	; 128
    5208:	88 2e       	mov	r8, r24
    520a:	86 e9       	ldi	r24, 0x96	; 150
    520c:	98 2e       	mov	r9, r24
    520e:	88 e9       	ldi	r24, 0x98	; 152
    5210:	a8 2e       	mov	r10, r24
    5212:	b1 2c       	mov	r11, r1
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:147
    ++term;

  if (*term == '.')
    while (isdigit(*++term))
    {
      multiplier /= 10;
    5214:	9a e0       	ldi	r25, 0x0A	; 10
    5216:	49 2e       	mov	r4, r25
    5218:	51 2c       	mov	r5, r1
    521a:	61 2c       	mov	r6, r1
    521c:	71 2c       	mov	r7, r1
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:145

  while (isdigit(*term))
    ++term;

  if (*term == '.')
    while (isdigit(*++term))
    521e:	f1 01       	movw	r30, r2
    5220:	c1 91       	ld	r28, Z+
    5222:	1f 01       	movw	r2, r30
    5224:	0c 2e       	mov	r0, r28
    5226:	00 0c       	add	r0, r0
    5228:	dd 0b       	sbc	r29, r29
    522a:	e0 97       	sbiw	r28, 0x30	; 48
    522c:	ca 30       	cpi	r28, 0x0A	; 10
    522e:	d1 05       	cpc	r29, r1
    5230:	80 f4       	brcc	.+32     	; 0x5252 <TinyGPSPlus::parseDegrees(char const*, RawDegrees&)+0xbc>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:147
    {
      multiplier /= 10;
    5232:	c5 01       	movw	r24, r10
    5234:	b4 01       	movw	r22, r8
    5236:	a3 01       	movw	r20, r6
    5238:	92 01       	movw	r18, r4
    523a:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    523e:	49 01       	movw	r8, r18
    5240:	5a 01       	movw	r10, r20
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:148
      tenMillionthsOfMinutes += (*term - '0') * multiplier;
    5242:	de 01       	movw	r26, r28
    5244:	0e 94 3b 6a 	call	0xd476	; 0xd476 <__mulshisi3>
    5248:	c6 0e       	add	r12, r22
    524a:	d7 1e       	adc	r13, r23
    524c:	e8 1e       	adc	r14, r24
    524e:	f9 1e       	adc	r15, r25
    5250:	e6 cf       	rjmp	.-52     	; 0x521e <TinyGPSPlus::parseDegrees(char const*, RawDegrees&)+0x88>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:151
    }

  deg.billionths = (5 * tenMillionthsOfMinutes + 1) / 3;
    5252:	a5 e0       	ldi	r26, 0x05	; 5
    5254:	b0 e0       	ldi	r27, 0x00	; 0
    5256:	a7 01       	movw	r20, r14
    5258:	96 01       	movw	r18, r12
    525a:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
    525e:	6f 5f       	subi	r22, 0xFF	; 255
    5260:	7f 4f       	sbci	r23, 0xFF	; 255
    5262:	8f 4f       	sbci	r24, 0xFF	; 255
    5264:	9f 4f       	sbci	r25, 0xFF	; 255
    5266:	23 e0       	ldi	r18, 0x03	; 3
    5268:	30 e0       	ldi	r19, 0x00	; 0
    526a:	40 e0       	ldi	r20, 0x00	; 0
    526c:	50 e0       	ldi	r21, 0x00	; 0
    526e:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5272:	f8 01       	movw	r30, r16
    5274:	22 83       	std	Z+2, r18	; 0x02
    5276:	33 83       	std	Z+3, r19	; 0x03
    5278:	44 83       	std	Z+4, r20	; 0x04
    527a:	55 83       	std	Z+5, r21	; 0x05
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:152
  deg.negative = false;
    527c:	16 82       	std	Z+6, r1	; 0x06
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:153
}
    527e:	df 91       	pop	r29
    5280:	cf 91       	pop	r28
    5282:	1f 91       	pop	r17
    5284:	0f 91       	pop	r16
    5286:	ff 90       	pop	r15
    5288:	ef 90       	pop	r14
    528a:	df 90       	pop	r13
    528c:	cf 90       	pop	r12
    528e:	bf 90       	pop	r11
    5290:	af 90       	pop	r10
    5292:	9f 90       	pop	r9
    5294:	8f 90       	pop	r8
    5296:	7f 90       	pop	r7
    5298:	6f 90       	pop	r6
    529a:	5f 90       	pop	r5
    529c:	4f 90       	pop	r4
    529e:	3f 90       	pop	r3
    52a0:	2f 90       	pop	r2
    52a2:	08 95       	ret

000052a4 <TinyGPSPlus::parseDecimal(char const*)>:
parseDecimal():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:116
}

// static
// Parse a (potentially negative) number with up to 2 decimal digits -xxxx.yy
int32_t TinyGPSPlus::parseDecimal(const char *term)
{
    52a4:	1f 93       	push	r17
    52a6:	cf 93       	push	r28
    52a8:	df 93       	push	r29
    52aa:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:117
  bool negative = *term == '-';
    52ac:	18 81       	ld	r17, Y
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:118
  if (negative) ++term;
    52ae:	1d 32       	cpi	r17, 0x2D	; 45
    52b0:	09 f4       	brne	.+2      	; 0x52b4 <TinyGPSPlus::parseDecimal(char const*)+0x10>
    52b2:	21 96       	adiw	r28, 0x01	; 1
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:119
  int32_t ret = 100 * (int32_t)atol(term);
    52b4:	ce 01       	movw	r24, r28
    52b6:	0e 94 1f 64 	call	0xc83e	; 0xc83e <atol>
    52ba:	9b 01       	movw	r18, r22
    52bc:	ac 01       	movw	r20, r24
    52be:	a4 e6       	ldi	r26, 0x64	; 100
    52c0:	b0 e0       	ldi	r27, 0x00	; 0
    52c2:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
    52c6:	ab 01       	movw	r20, r22
    52c8:	bc 01       	movw	r22, r24
    52ca:	fe 01       	movw	r30, r28
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:120
  while (isdigit(*term)) ++term;
    52cc:	29 91       	ld	r18, Y+
    52ce:	82 2f       	mov	r24, r18
    52d0:	02 2e       	mov	r0, r18
    52d2:	00 0c       	add	r0, r0
    52d4:	99 0b       	sbc	r25, r25
    52d6:	c0 97       	sbiw	r24, 0x30	; 48
    52d8:	0a 97       	sbiw	r24, 0x0a	; 10
    52da:	b8 f3       	brcs	.-18     	; 0x52ca <TinyGPSPlus::parseDecimal(char const*)+0x26>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:121
  if (*term == '.' && isdigit(term[1]))
    52dc:	2e 32       	cpi	r18, 0x2E	; 46
    52de:	31 f5       	brne	.+76     	; 0x532c <TinyGPSPlus::parseDecimal(char const*)+0x88>
    52e0:	81 81       	ldd	r24, Z+1	; 0x01
    52e2:	08 2e       	mov	r0, r24
    52e4:	00 0c       	add	r0, r0
    52e6:	99 0b       	sbc	r25, r25
    52e8:	c0 97       	sbiw	r24, 0x30	; 48
    52ea:	8a 30       	cpi	r24, 0x0A	; 10
    52ec:	91 05       	cpc	r25, r1
    52ee:	f0 f4       	brcc	.+60     	; 0x532c <TinyGPSPlus::parseDecimal(char const*)+0x88>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:123
  {
    ret += 10 * (term[1] - '0');
    52f0:	aa e0       	ldi	r26, 0x0A	; 10
    52f2:	a8 9f       	mul	r26, r24
    52f4:	90 01       	movw	r18, r0
    52f6:	a9 9f       	mul	r26, r25
    52f8:	30 0d       	add	r19, r0
    52fa:	11 24       	eor	r1, r1
    52fc:	c9 01       	movw	r24, r18
    52fe:	33 0f       	add	r19, r19
    5300:	aa 0b       	sbc	r26, r26
    5302:	bb 0b       	sbc	r27, r27
    5304:	48 0f       	add	r20, r24
    5306:	59 1f       	adc	r21, r25
    5308:	6a 1f       	adc	r22, r26
    530a:	7b 1f       	adc	r23, r27
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:124
    if (isdigit(term[2]))
    530c:	82 81       	ldd	r24, Z+2	; 0x02
    530e:	08 2e       	mov	r0, r24
    5310:	00 0c       	add	r0, r0
    5312:	99 0b       	sbc	r25, r25
    5314:	c0 97       	sbiw	r24, 0x30	; 48
    5316:	8a 30       	cpi	r24, 0x0A	; 10
    5318:	91 05       	cpc	r25, r1
    531a:	40 f4       	brcc	.+16     	; 0x532c <TinyGPSPlus::parseDecimal(char const*)+0x88>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:125
      ret += term[2] - '0';
    531c:	09 2e       	mov	r0, r25
    531e:	00 0c       	add	r0, r0
    5320:	aa 0b       	sbc	r26, r26
    5322:	bb 0b       	sbc	r27, r27
    5324:	48 0f       	add	r20, r24
    5326:	59 1f       	adc	r21, r25
    5328:	6a 1f       	adc	r22, r26
    532a:	7b 1f       	adc	r23, r27
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:127
  }
  return negative ? -ret : ret;
    532c:	1d 32       	cpi	r17, 0x2D	; 45
    532e:	39 f4       	brne	.+14     	; 0x533e <TinyGPSPlus::parseDecimal(char const*)+0x9a>
    5330:	70 95       	com	r23
    5332:	60 95       	com	r22
    5334:	50 95       	com	r21
    5336:	41 95       	neg	r20
    5338:	5f 4f       	sbci	r21, 0xFF	; 255
    533a:	6f 4f       	sbci	r22, 0xFF	; 255
    533c:	7f 4f       	sbci	r23, 0xFF	; 255
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:128
}
    533e:	cb 01       	movw	r24, r22
    5340:	ba 01       	movw	r22, r20
    5342:	df 91       	pop	r29
    5344:	cf 91       	pop	r28
    5346:	1f 91       	pop	r17
    5348:	08 95       	ret

0000534a <String::move(String&)>:
move():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:194
	return *this;
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
void String::move(String &rhs)
{
    534a:	0f 93       	push	r16
    534c:	1f 93       	push	r17
    534e:	cf 93       	push	r28
    5350:	df 93       	push	r29
    5352:	8c 01       	movw	r16, r24
    5354:	eb 01       	movw	r28, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:195
	if (buffer) {
    5356:	fc 01       	movw	r30, r24
    5358:	80 81       	ld	r24, Z
    535a:	91 81       	ldd	r25, Z+1	; 0x01
    535c:	00 97       	sbiw	r24, 0x00	; 0
    535e:	e1 f0       	breq	.+56     	; 0x5398 <String::move(String&)+0x4e>
    5360:	68 81       	ld	r22, Y
    5362:	79 81       	ldd	r23, Y+1	; 0x01
_ZNK6StringcvMS_KFvvEEv.isra.0():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:138
	friend StringSumHelper & operator + (const StringSumHelper &lhs, float num);
	friend StringSumHelper & operator + (const StringSumHelper &lhs, double num);
	friend StringSumHelper & operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs);

	// comparison (only works w/ Strings and "strings")
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
    5364:	61 15       	cp	r22, r1
    5366:	71 05       	cpc	r23, r1
    5368:	a9 f0       	breq	.+42     	; 0x5394 <String::move(String&)+0x4a>
move():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:196
		if (rhs && capacity >= rhs.len) {
    536a:	42 81       	ldd	r20, Z+2	; 0x02
    536c:	53 81       	ldd	r21, Z+3	; 0x03
    536e:	2c 81       	ldd	r18, Y+4	; 0x04
    5370:	3d 81       	ldd	r19, Y+5	; 0x05
    5372:	42 17       	cp	r20, r18
    5374:	53 07       	cpc	r21, r19
    5376:	70 f0       	brcs	.+28     	; 0x5394 <String::move(String&)+0x4a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:197
			strcpy(buffer, rhs.buffer);
    5378:	0e 94 c8 6e 	call	0xdd90	; 0xdd90 <strcpy>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:198
			len = rhs.len;
    537c:	8c 81       	ldd	r24, Y+4	; 0x04
    537e:	9d 81       	ldd	r25, Y+5	; 0x05
    5380:	f8 01       	movw	r30, r16
    5382:	95 83       	std	Z+5, r25	; 0x05
    5384:	84 83       	std	Z+4, r24	; 0x04
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:210
	buffer = rhs.buffer;
	capacity = rhs.capacity;
	len = rhs.len;
	rhs.buffer = NULL;
	rhs.capacity = 0;
	rhs.len = 0;
    5386:	1d 82       	std	Y+5, r1	; 0x05
    5388:	1c 82       	std	Y+4, r1	; 0x04
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:211
}
    538a:	df 91       	pop	r29
    538c:	cf 91       	pop	r28
    538e:	1f 91       	pop	r17
    5390:	0f 91       	pop	r16
    5392:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:202
			strcpy(buffer, rhs.buffer);
			len = rhs.len;
			rhs.len = 0;
			return;
		} else {
			free(buffer);
    5394:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:205
		}
	}
	buffer = rhs.buffer;
    5398:	88 81       	ld	r24, Y
    539a:	99 81       	ldd	r25, Y+1	; 0x01
    539c:	f8 01       	movw	r30, r16
    539e:	91 83       	std	Z+1, r25	; 0x01
    53a0:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:206
	capacity = rhs.capacity;
    53a2:	8a 81       	ldd	r24, Y+2	; 0x02
    53a4:	9b 81       	ldd	r25, Y+3	; 0x03
    53a6:	93 83       	std	Z+3, r25	; 0x03
    53a8:	82 83       	std	Z+2, r24	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:207
	len = rhs.len;
    53aa:	8c 81       	ldd	r24, Y+4	; 0x04
    53ac:	9d 81       	ldd	r25, Y+5	; 0x05
    53ae:	95 83       	std	Z+5, r25	; 0x05
    53b0:	84 83       	std	Z+4, r24	; 0x04
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:208
	rhs.buffer = NULL;
    53b2:	19 82       	std	Y+1, r1	; 0x01
    53b4:	18 82       	st	Y, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:209
	rhs.capacity = 0;
    53b6:	1b 82       	std	Y+3, r1	; 0x03
    53b8:	1a 82       	std	Y+2, r1	; 0x02
    53ba:	e5 cf       	rjmp	.-54     	; 0x5386 <String::move(String&)+0x3c>

000053bc <String::reserve(unsigned int)>:
reserve():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:146
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
    53bc:	0f 93       	push	r16
    53be:	1f 93       	push	r17
    53c0:	cf 93       	push	r28
    53c2:	df 93       	push	r29
    53c4:	ec 01       	movw	r28, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:147
	if (buffer && capacity >= size) return 1;
    53c6:	88 81       	ld	r24, Y
    53c8:	99 81       	ldd	r25, Y+1	; 0x01
    53ca:	00 97       	sbiw	r24, 0x00	; 0
    53cc:	59 f0       	breq	.+22     	; 0x53e4 <String::reserve(unsigned int)+0x28>
    53ce:	2a 81       	ldd	r18, Y+2	; 0x02
    53d0:	3b 81       	ldd	r19, Y+3	; 0x03
    53d2:	26 17       	cp	r18, r22
    53d4:	37 07       	cpc	r19, r23
    53d6:	30 f0       	brcs	.+12     	; 0x53e4 <String::reserve(unsigned int)+0x28>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:149
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    53d8:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:153
		return 1;
	}
	return 0;
}
    53da:	df 91       	pop	r29
    53dc:	cf 91       	pop	r28
    53de:	1f 91       	pop	r17
    53e0:	0f 91       	pop	r16
    53e2:	08 95       	ret
    53e4:	8b 01       	movw	r16, r22
changeBuffer():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:157

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    53e6:	6f 5f       	subi	r22, 0xFF	; 255
    53e8:	7f 4f       	sbci	r23, 0xFF	; 255
    53ea:	0e 94 b6 6d 	call	0xdb6c	; 0xdb6c <realloc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:158
	if (newbuffer) {
    53ee:	00 97       	sbiw	r24, 0x00	; 0
    53f0:	59 f0       	breq	.+22     	; 0x5408 <String::reserve(unsigned int)+0x4c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:159
		buffer = newbuffer;
    53f2:	99 83       	std	Y+1, r25	; 0x01
    53f4:	88 83       	st	Y, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:160
		capacity = maxStrLen;
    53f6:	1b 83       	std	Y+3, r17	; 0x03
    53f8:	0a 83       	std	Y+2, r16	; 0x02
reserve():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:149

unsigned char String::reserve(unsigned int size)
{
	if (buffer && capacity >= size) return 1;
	if (changeBuffer(size)) {
		if (len == 0) buffer[0] = 0;
    53fa:	2c 81       	ldd	r18, Y+4	; 0x04
    53fc:	3d 81       	ldd	r19, Y+5	; 0x05
    53fe:	23 2b       	or	r18, r19
    5400:	59 f7       	brne	.-42     	; 0x53d8 <String::reserve(unsigned int)+0x1c>
    5402:	fc 01       	movw	r30, r24
    5404:	10 82       	st	Z, r1
    5406:	e8 cf       	rjmp	.-48     	; 0x53d8 <String::reserve(unsigned int)+0x1c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:152
		return 1;
	}
	return 0;
    5408:	80 e0       	ldi	r24, 0x00	; 0
    540a:	e7 cf       	rjmp	.-50     	; 0x53da <String::reserve(unsigned int)+0x1e>

0000540c <String::concat(char const*, unsigned int)>:
concat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:264
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
    540c:	ef 92       	push	r14
    540e:	ff 92       	push	r15
    5410:	0f 93       	push	r16
    5412:	1f 93       	push	r17
    5414:	cf 93       	push	r28
    5416:	df 93       	push	r29
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:266
	unsigned int newlen = len + length;
	if (!cstr) return 0;
    5418:	61 15       	cp	r22, r1
    541a:	71 05       	cpc	r23, r1
    541c:	41 f4       	brne	.+16     	; 0x542e <String::concat(char const*, unsigned int)+0x22>
    541e:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:272
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
    5420:	df 91       	pop	r29
    5422:	cf 91       	pop	r28
    5424:	1f 91       	pop	r17
    5426:	0f 91       	pop	r16
    5428:	ff 90       	pop	r15
    542a:	ef 90       	pop	r14
    542c:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:267

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
    542e:	41 15       	cp	r20, r1
    5430:	51 05       	cpc	r21, r1
    5432:	b1 f0       	breq	.+44     	; 0x5460 <String::concat(char const*, unsigned int)+0x54>
    5434:	7b 01       	movw	r14, r22
    5436:	ec 01       	movw	r28, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:265
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
    5438:	0c 81       	ldd	r16, Y+4	; 0x04
    543a:	1d 81       	ldd	r17, Y+5	; 0x05
    543c:	04 0f       	add	r16, r20
    543e:	15 1f       	adc	r17, r21
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:268
	if (!cstr) return 0;
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
    5440:	b8 01       	movw	r22, r16
    5442:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
    5446:	88 23       	and	r24, r24
    5448:	51 f3       	breq	.-44     	; 0x541e <String::concat(char const*, unsigned int)+0x12>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:269
	strcpy(buffer + len, cstr);
    544a:	28 81       	ld	r18, Y
    544c:	39 81       	ldd	r19, Y+1	; 0x01
    544e:	8c 81       	ldd	r24, Y+4	; 0x04
    5450:	9d 81       	ldd	r25, Y+5	; 0x05
    5452:	b7 01       	movw	r22, r14
    5454:	82 0f       	add	r24, r18
    5456:	93 1f       	adc	r25, r19
    5458:	0e 94 c8 6e 	call	0xdd90	; 0xdd90 <strcpy>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:270
	len = newlen;
    545c:	1d 83       	std	Y+5, r17	; 0x05
    545e:	0c 83       	std	Y+4, r16	; 0x04
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:267

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
    5460:	81 e0       	ldi	r24, 0x01	; 1
    5462:	de cf       	rjmp	.-68     	; 0x5420 <String::concat(char const*, unsigned int)+0x14>

00005464 <operator+(StringSumHelper const&, char const*)>:
operator+():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:361
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
	return a;
}

StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
{
    5464:	cf 93       	push	r28
    5466:	df 93       	push	r29
    5468:	ec 01       	movw	r28, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:363
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
    546a:	fb 01       	movw	r30, r22
    546c:	01 90       	ld	r0, Z+
    546e:	00 20       	and	r0, r0
    5470:	e9 f7       	brne	.-6      	; 0x546c <operator+(StringSumHelper const&, char const*)+0x8>
    5472:	31 97       	sbiw	r30, 0x01	; 1
    5474:	af 01       	movw	r20, r30
    5476:	46 1b       	sub	r20, r22
    5478:	57 0b       	sbc	r21, r23
    547a:	0e 94 06 2a 	call	0x540c	; 0x540c <String::concat(char const*, unsigned int)>
    547e:	81 11       	cpse	r24, r1
    5480:	03 c0       	rjmp	.+6      	; 0x5488 <operator+(StringSumHelper const&, char const*)+0x24>
    5482:	ce 01       	movw	r24, r28
    5484:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <String::invalidate()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:365
	return a;
}
    5488:	ce 01       	movw	r24, r28
    548a:	df 91       	pop	r29
    548c:	cf 91       	pop	r28
    548e:	08 95       	ret

00005490 <operator+(StringSumHelper const&, String const&)>:
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:354
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
    5490:	cf 93       	push	r28
    5492:	df 93       	push	r29
    5494:	ec 01       	movw	r28, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:356
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
    5496:	fb 01       	movw	r30, r22
    5498:	44 81       	ldd	r20, Z+4	; 0x04
    549a:	55 81       	ldd	r21, Z+5	; 0x05
    549c:	60 81       	ld	r22, Z
    549e:	71 81       	ldd	r23, Z+1	; 0x01
    54a0:	0e 94 06 2a 	call	0x540c	; 0x540c <String::concat(char const*, unsigned int)>
    54a4:	81 11       	cpse	r24, r1
    54a6:	03 c0       	rjmp	.+6      	; 0x54ae <operator+(StringSumHelper const&, String const&)+0x1e>
    54a8:	ce 01       	movw	r24, r28
    54aa:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <String::invalidate()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:358
	return a;
}
    54ae:	ce 01       	movw	r24, r28
    54b0:	df 91       	pop	r29
    54b2:	cf 91       	pop	r28
    54b4:	08 95       	ret

000054b6 <String::concat(float)>:
concat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:324
	ultoa(num, buf, 10);
	return concat(buf, strlen(buf));
}

unsigned char String::concat(float num)
{
    54b6:	ef 92       	push	r14
    54b8:	ff 92       	push	r15
    54ba:	0f 93       	push	r16
    54bc:	1f 93       	push	r17
    54be:	cf 93       	push	r28
    54c0:	df 93       	push	r29
    54c2:	cd b7       	in	r28, 0x3d	; 61
    54c4:	de b7       	in	r29, 0x3e	; 62
    54c6:	64 97       	sbiw	r28, 0x14	; 20
    54c8:	0f b6       	in	r0, 0x3f	; 63
    54ca:	f8 94       	cli
    54cc:	de bf       	out	0x3e, r29	; 62
    54ce:	0f be       	out	0x3f, r0	; 63
    54d0:	cd bf       	out	0x3d, r28	; 61
    54d2:	7c 01       	movw	r14, r24
    54d4:	cb 01       	movw	r24, r22
    54d6:	ba 01       	movw	r22, r20
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:326
	char buf[20];
	char* string = dtostrf(num, 4, 2, buf);
    54d8:	8e 01       	movw	r16, r28
    54da:	0f 5f       	subi	r16, 0xFF	; 255
    54dc:	1f 4f       	sbci	r17, 0xFF	; 255
    54de:	22 e0       	ldi	r18, 0x02	; 2
    54e0:	44 e0       	ldi	r20, 0x04	; 4
    54e2:	0e 94 ba 62 	call	0xc574	; 0xc574 <dtostrf>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:327
	return concat(string, strlen(string));
    54e6:	fc 01       	movw	r30, r24
    54e8:	01 90       	ld	r0, Z+
    54ea:	00 20       	and	r0, r0
    54ec:	e9 f7       	brne	.-6      	; 0x54e8 <String::concat(float)+0x32>
    54ee:	31 97       	sbiw	r30, 0x01	; 1
    54f0:	af 01       	movw	r20, r30
    54f2:	48 1b       	sub	r20, r24
    54f4:	59 0b       	sbc	r21, r25
    54f6:	bc 01       	movw	r22, r24
    54f8:	c7 01       	movw	r24, r14
    54fa:	0e 94 06 2a 	call	0x540c	; 0x540c <String::concat(char const*, unsigned int)>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:328
}
    54fe:	64 96       	adiw	r28, 0x14	; 20
    5500:	0f b6       	in	r0, 0x3f	; 63
    5502:	f8 94       	cli
    5504:	de bf       	out	0x3e, r29	; 62
    5506:	0f be       	out	0x3f, r0	; 63
    5508:	cd bf       	out	0x3d, r28	; 61
    550a:	df 91       	pop	r29
    550c:	cf 91       	pop	r28
    550e:	1f 91       	pop	r17
    5510:	0f 91       	pop	r16
    5512:	ff 90       	pop	r15
    5514:	ef 90       	pop	r14
    5516:	08 95       	ret

00005518 <String::concat(int)>:
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:296
	itoa(num, buf, 10);
	return concat(buf, strlen(buf));
}

unsigned char String::concat(int num)
{
    5518:	ef 92       	push	r14
    551a:	ff 92       	push	r15
    551c:	0f 93       	push	r16
    551e:	1f 93       	push	r17
    5520:	cf 93       	push	r28
    5522:	df 93       	push	r29
    5524:	00 d0       	rcall	.+0      	; 0x5526 <String::concat(int)+0xe>
    5526:	00 d0       	rcall	.+0      	; 0x5528 <String::concat(int)+0x10>
    5528:	1f 92       	push	r1
    552a:	1f 92       	push	r1
    552c:	cd b7       	in	r28, 0x3d	; 61
    552e:	de b7       	in	r29, 0x3e	; 62
    5530:	7c 01       	movw	r14, r24
    5532:	cb 01       	movw	r24, r22
itoa():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include/stdlib.h:439
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    5534:	4a e0       	ldi	r20, 0x0A	; 10
    5536:	8e 01       	movw	r16, r28
    5538:	0f 5f       	subi	r16, 0xFF	; 255
    553a:	1f 4f       	sbci	r17, 0xFF	; 255
    553c:	b8 01       	movw	r22, r16
    553e:	0e 94 81 64 	call	0xc902	; 0xc902 <__itoa_ncheck>
concat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:299
	char buf[2 + 3 * sizeof(int)];
	itoa(num, buf, 10);
	return concat(buf, strlen(buf));
    5542:	f8 01       	movw	r30, r16
    5544:	01 90       	ld	r0, Z+
    5546:	00 20       	and	r0, r0
    5548:	e9 f7       	brne	.-6      	; 0x5544 <String::concat(int)+0x2c>
    554a:	31 97       	sbiw	r30, 0x01	; 1
    554c:	af 01       	movw	r20, r30
    554e:	40 1b       	sub	r20, r16
    5550:	51 0b       	sbc	r21, r17
    5552:	b8 01       	movw	r22, r16
    5554:	c7 01       	movw	r24, r14
    5556:	0e 94 06 2a 	call	0x540c	; 0x540c <String::concat(char const*, unsigned int)>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:300
}
    555a:	28 96       	adiw	r28, 0x08	; 8
    555c:	0f b6       	in	r0, 0x3f	; 63
    555e:	f8 94       	cli
    5560:	de bf       	out	0x3e, r29	; 62
    5562:	0f be       	out	0x3f, r0	; 63
    5564:	cd bf       	out	0x3d, r28	; 61
    5566:	df 91       	pop	r29
    5568:	cf 91       	pop	r28
    556a:	1f 91       	pop	r17
    556c:	0f 91       	pop	r16
    556e:	ff 90       	pop	r15
    5570:	ef 90       	pop	r14
    5572:	08 95       	ret

00005574 <String::concat(char)>:
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:281
	if (!cstr) return 0;
	return concat(cstr, strlen(cstr));
}

unsigned char String::concat(char c)
{
    5574:	cf 93       	push	r28
    5576:	df 93       	push	r29
    5578:	1f 92       	push	r1
    557a:	1f 92       	push	r1
    557c:	cd b7       	in	r28, 0x3d	; 61
    557e:	de b7       	in	r29, 0x3e	; 62
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:283
	char buf[2];
	buf[0] = c;
    5580:	69 83       	std	Y+1, r22	; 0x01
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:284
	buf[1] = 0;
    5582:	1a 82       	std	Y+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:285
	return concat(buf, 1);
    5584:	41 e0       	ldi	r20, 0x01	; 1
    5586:	50 e0       	ldi	r21, 0x00	; 0
    5588:	be 01       	movw	r22, r28
    558a:	6f 5f       	subi	r22, 0xFF	; 255
    558c:	7f 4f       	sbci	r23, 0xFF	; 255
    558e:	0e 94 06 2a 	call	0x540c	; 0x540c <String::concat(char const*, unsigned int)>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:286
}
    5592:	0f 90       	pop	r0
    5594:	0f 90       	pop	r0
    5596:	df 91       	pop	r29
    5598:	cf 91       	pop	r28
    559a:	08 95       	ret

0000559c <serialEvent()>:
serialEvent():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:469
		}
	}
	SRamRestart();
}

void serialEvent() {
    559c:	cf 93       	push	r28
    559e:	df 93       	push	r29
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:476
	{
		char inChar = (char)Serial.read();
		strSerial += inChar;
		if (inChar == '\r')
		{
			serialComplete = true;
    55a0:	d1 e0       	ldi	r29, 0x01	; 1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:470
	}
	SRamRestart();
}

void serialEvent() {
	while (Serial.available()) 
    55a2:	82 e5       	ldi	r24, 0x52	; 82
    55a4:	9e e0       	ldi	r25, 0x0E	; 14
    55a6:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <HardwareSerial::available()>
    55aa:	89 2b       	or	r24, r25
    55ac:	79 f0       	breq	.+30     	; 0x55cc <serialEvent()+0x30>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:472
	{
		char inChar = (char)Serial.read();
    55ae:	82 e5       	ldi	r24, 0x52	; 82
    55b0:	9e e0       	ldi	r25, 0x0E	; 14
    55b2:	0e 94 ca 06 	call	0xd94	; 0xd94 <HardwareSerial::read()>
    55b6:	c8 2f       	mov	r28, r24
_ZN6StringpLEc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:115

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
	String & operator += (char c)			{concat(c); return (*this);}
    55b8:	68 2f       	mov	r22, r24
    55ba:	88 e4       	ldi	r24, 0x48	; 72
    55bc:	9f e0       	ldi	r25, 0x0F	; 15
    55be:	0e 94 ba 2a 	call	0x5574	; 0x5574 <String::concat(char)>
serialEvent():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:474
		strSerial += inChar;
		if (inChar == '\r')
    55c2:	cd 30       	cpi	r28, 0x0D	; 13
    55c4:	71 f7       	brne	.-36     	; 0x55a2 <serialEvent()+0x6>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:476
		{
			serialComplete = true;
    55c6:	d0 93 eb 09 	sts	0x09EB, r29	; 0x8009eb <serialComplete>
    55ca:	eb cf       	rjmp	.-42     	; 0x55a2 <serialEvent()+0x6>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:479
		}
	}
}
    55cc:	df 91       	pop	r29
    55ce:	cf 91       	pop	r28
    55d0:	08 95       	ret

000055d2 <serialEventRun()>:
serialEventRun():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:67
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    55d2:	0e 94 16 07 	call	0xe2c	; 0xe2c <Serial0_available()>
    55d6:	81 11       	cpse	r24, r1
    55d8:	0e 94 ce 2a 	call	0x559c	; 0x559c <serialEvent()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:70
#endif
#if defined(HAVE_HWSERIAL1)
  if (Serial1_available && serialEvent1 && Serial1_available()) serialEvent1();
    55dc:	80 e0       	ldi	r24, 0x00	; 0
    55de:	90 e0       	ldi	r25, 0x00	; 0
    55e0:	89 2b       	or	r24, r25
    55e2:	29 f0       	breq	.+10     	; 0x55ee <serialEventRun()+0x1c>
    55e4:	0e 94 0c 07 	call	0xe18	; 0xe18 <Serial1_available()>
    55e8:	81 11       	cpse	r24, r1
    55ea:	0e 94 00 00 	call	0	; 0x0 <__vectors>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:73
#endif
#if defined(HAVE_HWSERIAL2)
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
    55ee:	80 e0       	ldi	r24, 0x00	; 0
    55f0:	90 e0       	ldi	r25, 0x00	; 0
    55f2:	89 2b       	or	r24, r25
    55f4:	29 f0       	breq	.+10     	; 0x5600 <serialEventRun()+0x2e>
    55f6:	0e 94 02 07 	call	0xe04	; 0xe04 <Serial2_available()>
    55fa:	81 11       	cpse	r24, r1
    55fc:	0e 94 00 00 	call	0	; 0x0 <__vectors>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:76
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
    5600:	80 e0       	ldi	r24, 0x00	; 0
    5602:	90 e0       	ldi	r25, 0x00	; 0
    5604:	89 2b       	or	r24, r25
    5606:	29 f0       	breq	.+10     	; 0x5612 <serialEventRun()+0x40>
    5608:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <Serial3_available()>
    560c:	81 11       	cpse	r24, r1
    560e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.cpp:78
#endif
}
    5612:	08 95       	ret

00005614 <String::concat(char const*)>:
concat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:277
}

unsigned char String::concat(const char *cstr)
{
	if (!cstr) return 0;
	return concat(cstr, strlen(cstr));
    5614:	fb 01       	movw	r30, r22
    5616:	01 90       	ld	r0, Z+
    5618:	00 20       	and	r0, r0
    561a:	e9 f7       	brne	.-6      	; 0x5616 <String::concat(char const*)+0x2>
    561c:	31 97       	sbiw	r30, 0x01	; 1
    561e:	af 01       	movw	r20, r30
    5620:	46 1b       	sub	r20, r22
    5622:	57 0b       	sbc	r21, r23
    5624:	0c 94 06 2a 	jmp	0x540c	; 0x540c <String::concat(char const*, unsigned int)>

00005628 <String::concat(String const&)>:
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:260
/*  concat                                   */
/*********************************************/

unsigned char String::concat(const String &s)
{
	return concat(s.buffer, s.len);
    5628:	fb 01       	movw	r30, r22
    562a:	44 81       	ldd	r20, Z+4	; 0x04
    562c:	55 81       	ldd	r21, Z+5	; 0x05
    562e:	60 81       	ld	r22, Z
    5630:	71 81       	ldd	r23, Z+1	; 0x01
    5632:	0c 94 06 2a 	jmp	0x540c	; 0x540c <String::concat(char const*, unsigned int)>

00005636 <String::copy(char const*, unsigned int)>:
copy():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:171
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
    5636:	ef 92       	push	r14
    5638:	ff 92       	push	r15
    563a:	0f 93       	push	r16
    563c:	1f 93       	push	r17
    563e:	cf 93       	push	r28
    5640:	df 93       	push	r29
    5642:	ec 01       	movw	r28, r24
    5644:	7b 01       	movw	r14, r22
    5646:	8a 01       	movw	r16, r20
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:172
	if (!reserve(length)) {
    5648:	ba 01       	movw	r22, r20
    564a:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
    564e:	81 11       	cpse	r24, r1
    5650:	0b c0       	rjmp	.+22     	; 0x5668 <String::copy(char const*, unsigned int)+0x32>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:173
		invalidate();
    5652:	ce 01       	movw	r24, r28
    5654:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <String::invalidate()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:179
		return *this;
	}
	len = length;
	strcpy(buffer, cstr);
	return *this;
}
    5658:	ce 01       	movw	r24, r28
    565a:	df 91       	pop	r29
    565c:	cf 91       	pop	r28
    565e:	1f 91       	pop	r17
    5660:	0f 91       	pop	r16
    5662:	ff 90       	pop	r15
    5664:	ef 90       	pop	r14
    5666:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:176
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
    5668:	1d 83       	std	Y+5, r17	; 0x05
    566a:	0c 83       	std	Y+4, r16	; 0x04
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:177
	strcpy(buffer, cstr);
    566c:	b7 01       	movw	r22, r14
    566e:	88 81       	ld	r24, Y
    5670:	99 81       	ldd	r25, Y+1	; 0x01
    5672:	0e 94 c8 6e 	call	0xdd90	; 0xdd90 <strcpy>
    5676:	f0 cf       	rjmp	.-32     	; 0x5658 <String::copy(char const*, unsigned int)+0x22>

00005678 <String::operator=(char const*) [clone .part.3]>:
_ZN6StringaSEPKc.part.3():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:240
}
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) copy(cstr, strlen(cstr));
    5678:	fb 01       	movw	r30, r22
    567a:	01 90       	ld	r0, Z+
    567c:	00 20       	and	r0, r0
    567e:	e9 f7       	brne	.-6      	; 0x567a <String::operator=(char const*) [clone .part.3]+0x2>
    5680:	31 97       	sbiw	r30, 0x01	; 1
    5682:	af 01       	movw	r20, r30
    5684:	46 1b       	sub	r20, r22
    5686:	57 0b       	sbc	r21, r23
    5688:	0c 94 1b 2b 	jmp	0x5636	; 0x5636 <String::copy(char const*, unsigned int)>

0000568c <String::String(int, unsigned char) [clone .constprop.124]>:
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:76
	char buf[1 + 8 * sizeof(unsigned char)];
	utoa(value, buf, base);
	*this = buf;
}

String::String(int value, unsigned char base)
    568c:	0f 93       	push	r16
    568e:	1f 93       	push	r17
    5690:	cf 93       	push	r28
    5692:	df 93       	push	r29
    5694:	cd b7       	in	r28, 0x3d	; 61
    5696:	de b7       	in	r29, 0x3e	; 62
    5698:	62 97       	sbiw	r28, 0x12	; 18
    569a:	0f b6       	in	r0, 0x3f	; 63
    569c:	f8 94       	cli
    569e:	de bf       	out	0x3e, r29	; 62
    56a0:	0f be       	out	0x3f, r0	; 63
    56a2:	cd bf       	out	0x3d, r28	; 61
    56a4:	8c 01       	movw	r16, r24
    56a6:	cb 01       	movw	r24, r22
_ZN6String4initEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:133
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    56a8:	f8 01       	movw	r30, r16
    56aa:	11 82       	std	Z+1, r1	; 0x01
    56ac:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:134
	capacity = 0;
    56ae:	13 82       	std	Z+3, r1	; 0x03
    56b0:	12 82       	std	Z+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:135
	len = 0;
    56b2:	15 82       	std	Z+5, r1	; 0x05
    56b4:	14 82       	std	Z+4, r1	; 0x04
itoa():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include/stdlib.h:439
    56b6:	4a e0       	ldi	r20, 0x0A	; 10
    56b8:	be 01       	movw	r22, r28
    56ba:	6f 5f       	subi	r22, 0xFF	; 255
    56bc:	7f 4f       	sbci	r23, 0xFF	; 255
    56be:	0e 94 81 64 	call	0xc902	; 0xc902 <__itoa_ncheck>
operator=():
    56c2:	be 01       	movw	r22, r28
    56c4:	6f 5f       	subi	r22, 0xFF	; 255
    56c6:	7f 4f       	sbci	r23, 0xFF	; 255
    56c8:	c8 01       	movw	r24, r16
    56ca:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:82
{
	init();
	char buf[2 + 8 * sizeof(int)];
	itoa(value, buf, base);
	*this = buf;
}
    56ce:	62 96       	adiw	r28, 0x12	; 18
    56d0:	0f b6       	in	r0, 0x3f	; 63
    56d2:	f8 94       	cli
    56d4:	de bf       	out	0x3e, r29	; 62
    56d6:	0f be       	out	0x3f, r0	; 63
    56d8:	cd bf       	out	0x3d, r28	; 61
    56da:	df 91       	pop	r29
    56dc:	cf 91       	pop	r28
    56de:	1f 91       	pop	r17
    56e0:	0f 91       	pop	r16
    56e2:	08 95       	ret

000056e4 <String::String(unsigned char, unsigned char) [clone .constprop.111]>:
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:68
	buf[0] = c;
	buf[1] = 0;
	*this = buf;
}

String::String(unsigned char value, unsigned char base)
    56e4:	0f 93       	push	r16
    56e6:	1f 93       	push	r17
    56e8:	cf 93       	push	r28
    56ea:	df 93       	push	r29
    56ec:	00 d0       	rcall	.+0      	; 0x56ee <String::String(unsigned char, unsigned char) [clone .constprop.111]+0xa>
    56ee:	00 d0       	rcall	.+0      	; 0x56f0 <String::String(unsigned char, unsigned char) [clone .constprop.111]+0xc>
    56f0:	00 d0       	rcall	.+0      	; 0x56f2 <String::String(unsigned char, unsigned char) [clone .constprop.111]+0xe>
    56f2:	cd b7       	in	r28, 0x3d	; 61
    56f4:	de b7       	in	r29, 0x3e	; 62
    56f6:	8c 01       	movw	r16, r24
    56f8:	86 2f       	mov	r24, r22
_ZN6String4initEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:133
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    56fa:	f8 01       	movw	r30, r16
    56fc:	11 82       	std	Z+1, r1	; 0x01
    56fe:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:134
	capacity = 0;
    5700:	13 82       	std	Z+3, r1	; 0x03
    5702:	12 82       	std	Z+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:135
	len = 0;
    5704:	15 82       	std	Z+5, r1	; 0x05
    5706:	14 82       	std	Z+4, r1	; 0x04
utoa():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include/stdlib.h:527
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__utoa_ncheck (unsigned int, char *, unsigned char);
	return __utoa_ncheck (__val, __s, __radix);
    5708:	40 e1       	ldi	r20, 0x10	; 16
    570a:	be 01       	movw	r22, r28
    570c:	6f 5f       	subi	r22, 0xFF	; 255
    570e:	7f 4f       	sbci	r23, 0xFF	; 255
    5710:	90 e0       	ldi	r25, 0x00	; 0
    5712:	0e 94 da 64 	call	0xc9b4	; 0xc9b4 <__utoa_ncheck>
operator=():
    5716:	be 01       	movw	r22, r28
    5718:	6f 5f       	subi	r22, 0xFF	; 255
    571a:	7f 4f       	sbci	r23, 0xFF	; 255
    571c:	c8 01       	movw	r24, r16
    571e:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:74
{
	init();
	char buf[1 + 8 * sizeof(unsigned char)];
	utoa(value, buf, base);
	*this = buf;
}
    5722:	29 96       	adiw	r28, 0x09	; 9
    5724:	0f b6       	in	r0, 0x3f	; 63
    5726:	f8 94       	cli
    5728:	de bf       	out	0x3e, r29	; 62
    572a:	0f be       	out	0x3f, r0	; 63
    572c:	cd bf       	out	0x3d, r28	; 61
    572e:	df 91       	pop	r29
    5730:	cf 91       	pop	r28
    5732:	1f 91       	pop	r17
    5734:	0f 91       	pop	r16
    5736:	08 95       	ret

00005738 <String::String(long, unsigned char) [clone .constprop.40]>:
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:92
	char buf[1 + 8 * sizeof(unsigned int)];
	utoa(value, buf, base);
	*this = buf;
}

String::String(long value, unsigned char base)
    5738:	0f 93       	push	r16
    573a:	1f 93       	push	r17
    573c:	cf 93       	push	r28
    573e:	df 93       	push	r29
    5740:	cd b7       	in	r28, 0x3d	; 61
    5742:	de b7       	in	r29, 0x3e	; 62
    5744:	a2 97       	sbiw	r28, 0x22	; 34
    5746:	0f b6       	in	r0, 0x3f	; 63
    5748:	f8 94       	cli
    574a:	de bf       	out	0x3e, r29	; 62
    574c:	0f be       	out	0x3f, r0	; 63
    574e:	cd bf       	out	0x3d, r28	; 61
    5750:	8c 01       	movw	r16, r24
    5752:	cb 01       	movw	r24, r22
    5754:	ba 01       	movw	r22, r20
_ZN6String4initEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:133
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    5756:	f8 01       	movw	r30, r16
    5758:	11 82       	std	Z+1, r1	; 0x01
    575a:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:134
	capacity = 0;
    575c:	13 82       	std	Z+3, r1	; 0x03
    575e:	12 82       	std	Z+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:135
	len = 0;
    5760:	15 82       	std	Z+5, r1	; 0x05
    5762:	14 82       	std	Z+4, r1	; 0x04
ltoa():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include/stdlib.h:484
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__ltoa_ncheck (long, char *, unsigned char);
	return __ltoa_ncheck (__val, __s, __radix);
    5764:	2a e0       	ldi	r18, 0x0A	; 10
    5766:	ae 01       	movw	r20, r28
    5768:	4f 5f       	subi	r20, 0xFF	; 255
    576a:	5f 4f       	sbci	r21, 0xFF	; 255
    576c:	0e 94 8c 64 	call	0xc918	; 0xc918 <__ltoa_ncheck>
operator=():
    5770:	be 01       	movw	r22, r28
    5772:	6f 5f       	subi	r22, 0xFF	; 255
    5774:	7f 4f       	sbci	r23, 0xFF	; 255
    5776:	c8 01       	movw	r24, r16
    5778:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:98
{
	init();
	char buf[2 + 8 * sizeof(long)];
	ltoa(value, buf, base);
	*this = buf;
}
    577c:	a2 96       	adiw	r28, 0x22	; 34
    577e:	0f b6       	in	r0, 0x3f	; 63
    5780:	f8 94       	cli
    5782:	de bf       	out	0x3e, r29	; 62
    5784:	0f be       	out	0x3f, r0	; 63
    5786:	cd bf       	out	0x3d, r28	; 61
    5788:	df 91       	pop	r29
    578a:	cf 91       	pop	r28
    578c:	1f 91       	pop	r17
    578e:	0f 91       	pop	r16
    5790:	08 95       	ret

00005792 <String::String(float, unsigned char)>:
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:108
	char buf[1 + 8 * sizeof(unsigned long)];
	ultoa(value, buf, base);
	*this = buf;
}

String::String(float value, unsigned char decimalPlaces)
    5792:	ef 92       	push	r14
    5794:	ff 92       	push	r15
    5796:	0f 93       	push	r16
    5798:	1f 93       	push	r17
    579a:	cf 93       	push	r28
    579c:	df 93       	push	r29
    579e:	cd b7       	in	r28, 0x3d	; 61
    57a0:	de b7       	in	r29, 0x3e	; 62
    57a2:	a1 97       	sbiw	r28, 0x21	; 33
    57a4:	0f b6       	in	r0, 0x3f	; 63
    57a6:	f8 94       	cli
    57a8:	de bf       	out	0x3e, r29	; 62
    57aa:	0f be       	out	0x3f, r0	; 63
    57ac:	cd bf       	out	0x3d, r28	; 61
    57ae:	7c 01       	movw	r14, r24
    57b0:	cb 01       	movw	r24, r22
    57b2:	ba 01       	movw	r22, r20
_ZN6String4initEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:133
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    57b4:	f7 01       	movw	r30, r14
    57b6:	11 82       	std	Z+1, r1	; 0x01
    57b8:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:134
	capacity = 0;
    57ba:	13 82       	std	Z+3, r1	; 0x03
    57bc:	12 82       	std	Z+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:135
	len = 0;
    57be:	15 82       	std	Z+5, r1	; 0x05
    57c0:	14 82       	std	Z+4, r1	; 0x04
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:112

String::String(float value, unsigned char decimalPlaces)
{
	init();
	char buf[33];
	*this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
    57c2:	42 e0       	ldi	r20, 0x02	; 2
    57c4:	42 0f       	add	r20, r18
    57c6:	8e 01       	movw	r16, r28
    57c8:	0f 5f       	subi	r16, 0xFF	; 255
    57ca:	1f 4f       	sbci	r17, 0xFF	; 255
    57cc:	0e 94 ba 62 	call	0xc574	; 0xc574 <dtostrf>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:240
}
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) copy(cstr, strlen(cstr));
    57d0:	00 97       	sbiw	r24, 0x00	; 0
    57d2:	89 f0       	breq	.+34     	; 0x57f6 <String::String(float, unsigned char)+0x64>
    57d4:	bc 01       	movw	r22, r24
    57d6:	c7 01       	movw	r24, r14
    57d8:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:113
String::String(float value, unsigned char decimalPlaces)
{
	init();
	char buf[33];
	*this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}
    57dc:	a1 96       	adiw	r28, 0x21	; 33
    57de:	0f b6       	in	r0, 0x3f	; 63
    57e0:	f8 94       	cli
    57e2:	de bf       	out	0x3e, r29	; 62
    57e4:	0f be       	out	0x3f, r0	; 63
    57e6:	cd bf       	out	0x3d, r28	; 61
    57e8:	df 91       	pop	r29
    57ea:	cf 91       	pop	r28
    57ec:	1f 91       	pop	r17
    57ee:	0f 91       	pop	r16
    57f0:	ff 90       	pop	r15
    57f2:	ef 90       	pop	r14
    57f4:	08 95       	ret
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:241
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) copy(cstr, strlen(cstr));
	else invalidate();
    57f6:	c7 01       	movw	r24, r14
    57f8:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <String::invalidate()>
    57fc:	ef cf       	rjmp	.-34     	; 0x57dc <String::String(float, unsigned char)+0x4a>

000057fe <String::operator=(String const&)>:
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:215
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
    57fe:	cf 93       	push	r28
    5800:	df 93       	push	r29
    5802:	ec 01       	movw	r28, r24
    5804:	fb 01       	movw	r30, r22
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:216
	if (this == &rhs) return *this;
    5806:	86 17       	cp	r24, r22
    5808:	97 07       	cpc	r25, r23
    580a:	49 f0       	breq	.+18     	; 0x581e <String::operator=(String const&)+0x20>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:218
	
	if (rhs.buffer) copy(rhs.buffer, rhs.len);
    580c:	60 81       	ld	r22, Z
    580e:	71 81       	ldd	r23, Z+1	; 0x01
    5810:	61 15       	cp	r22, r1
    5812:	71 05       	cpc	r23, r1
    5814:	41 f0       	breq	.+16     	; 0x5826 <String::operator=(String const&)+0x28>
    5816:	44 81       	ldd	r20, Z+4	; 0x04
    5818:	55 81       	ldd	r21, Z+5	; 0x05
    581a:	0e 94 1b 2b 	call	0x5636	; 0x5636 <String::copy(char const*, unsigned int)>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:222
	else invalidate();
	
	return *this;
}
    581e:	ce 01       	movw	r24, r28
    5820:	df 91       	pop	r29
    5822:	cf 91       	pop	r28
    5824:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:219
String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
	
	if (rhs.buffer) copy(rhs.buffer, rhs.len);
	else invalidate();
    5826:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <String::invalidate()>
    582a:	f9 cf       	rjmp	.-14     	; 0x581e <String::operator=(String const&)+0x20>

0000582c <String::String(String const&)>:
_ZN6String4initEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:133
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    582c:	fc 01       	movw	r30, r24
    582e:	11 82       	std	Z+1, r1	; 0x01
    5830:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:134
	capacity = 0;
    5832:	13 82       	std	Z+3, r1	; 0x03
    5834:	12 82       	std	Z+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:135
	len = 0;
    5836:	15 82       	std	Z+5, r1	; 0x05
    5838:	14 82       	std	Z+4, r1	; 0x04
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:37
}

String::String(const String &value)
{
	init();
	*this = value;
    583a:	0c 94 ff 2b 	jmp	0x57fe	; 0x57fe <String::operator=(String const&)>

0000583e <String::String(char const*)>:
_ZN6String4initEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:133
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    583e:	fc 01       	movw	r30, r24
    5840:	11 82       	std	Z+1, r1	; 0x01
    5842:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:134
	capacity = 0;
    5844:	13 82       	std	Z+3, r1	; 0x03
    5846:	12 82       	std	Z+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:135
	len = 0;
    5848:	15 82       	std	Z+5, r1	; 0x05
    584a:	14 82       	std	Z+4, r1	; 0x04
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:31
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
    584c:	61 15       	cp	r22, r1
    584e:	71 05       	cpc	r23, r1
    5850:	51 f0       	breq	.+20     	; 0x5866 <String::String(char const*)+0x28>
    5852:	fb 01       	movw	r30, r22
    5854:	01 90       	ld	r0, Z+
    5856:	00 20       	and	r0, r0
    5858:	e9 f7       	brne	.-6      	; 0x5854 <String::String(char const*)+0x16>
    585a:	31 97       	sbiw	r30, 0x01	; 1
    585c:	af 01       	movw	r20, r30
    585e:	46 1b       	sub	r20, r22
    5860:	57 0b       	sbc	r21, r23
    5862:	0c 94 1b 2b 	jmp	0x5636	; 0x5636 <String::copy(char const*, unsigned int)>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:32
}
    5866:	08 95       	ret

00005868 <sendata(unsigned char, unsigned char*) [clone .constprop.30]>:
sendata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:132
//		return String(buf);
//	}
//}


String sendata(byte addr, byte data[]) {
    5868:	2f 92       	push	r2
    586a:	3f 92       	push	r3
    586c:	4f 92       	push	r4
    586e:	5f 92       	push	r5
    5870:	6f 92       	push	r6
    5872:	7f 92       	push	r7
    5874:	8f 92       	push	r8
    5876:	9f 92       	push	r9
    5878:	af 92       	push	r10
    587a:	bf 92       	push	r11
    587c:	cf 92       	push	r12
    587e:	df 92       	push	r13
    5880:	ef 92       	push	r14
    5882:	ff 92       	push	r15
    5884:	0f 93       	push	r16
    5886:	1f 93       	push	r17
    5888:	cf 93       	push	r28
    588a:	df 93       	push	r29
    588c:	cd b7       	in	r28, 0x3d	; 61
    588e:	de b7       	in	r29, 0x3e	; 62
    5890:	2f 97       	sbiw	r28, 0x0f	; 15
    5892:	0f b6       	in	r0, 0x3f	; 63
    5894:	f8 94       	cli
    5896:	de bf       	out	0x3e, r29	; 62
    5898:	0f be       	out	0x3f, r0	; 63
    589a:	cd bf       	out	0x3d, r28	; 61
    589c:	6c 01       	movw	r12, r24
    589e:	7b 01       	movw	r14, r22
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:133
	byte length = data[0] & 0x0F;
    58a0:	fb 01       	movw	r30, r22
    58a2:	00 81       	ld	r16, Z
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:137
	length += 2;
	byte crc = 0x00;

	Wire.beginTransmission(addr);
    58a4:	8f e7       	ldi	r24, 0x7F	; 127
    58a6:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
    58aa:	57 01       	movw	r10, r14
    58ac:	f3 e0       	ldi	r31, 0x03	; 3
    58ae:	af 0e       	add	r10, r31
    58b0:	b1 1c       	adc	r11, r1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:135


String sendata(byte addr, byte data[]) {
	byte length = data[0] & 0x0F;
	length += 2;
	byte crc = 0x00;
    58b2:	10 e0       	ldi	r17, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:138

	Wire.beginTransmission(addr);
	for (int i = 0; i <= sizeof(data) / sizeof(byte); i++) {
    58b4:	ea 14       	cp	r14, r10
    58b6:	fb 04       	cpc	r15, r11
    58b8:	61 f0       	breq	.+24     	; 0x58d2 <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x6a>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:139
		Wire.write(data[i]);
    58ba:	f7 01       	movw	r30, r14
    58bc:	61 91       	ld	r22, Z+
    58be:	7f 01       	movw	r14, r30
    58c0:	8c e3       	ldi	r24, 0x3C	; 60
    58c2:	9f e0       	ldi	r25, 0x0F	; 15
    58c4:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:140
		crc = crc + data[i];
    58c8:	f7 01       	movw	r30, r14
    58ca:	31 97       	sbiw	r30, 0x01	; 1
    58cc:	80 81       	ld	r24, Z
    58ce:	18 0f       	add	r17, r24
    58d0:	f1 cf       	rjmp	.-30     	; 0x58b4 <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x4c>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:143
	}
	crc &= 0xFF;
	Wire.write(crc);
    58d2:	61 2f       	mov	r22, r17
    58d4:	8c e3       	ldi	r24, 0x3C	; 60
    58d6:	9f e0       	ldi	r25, 0x0F	; 15
    58d8:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:145

	if (Wire.endTransmission() != 0) return "*trans";
    58dc:	8c e3       	ldi	r24, 0x3C	; 60
    58de:	9f e0       	ldi	r25, 0x0F	; 15
    58e0:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
    58e4:	68 e8       	ldi	r22, 0x88	; 136
    58e6:	73 e0       	ldi	r23, 0x03	; 3
    58e8:	81 11       	cpse	r24, r1
    58ea:	3d c0       	rjmp	.+122    	; 0x5966 <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0xfe>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:133
//	}
//}


String sendata(byte addr, byte data[]) {
	byte length = data[0] & 0x0F;
    58ec:	0f 70       	andi	r16, 0x0F	; 15
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:134
	length += 2;
    58ee:	0e 5f       	subi	r16, 0xFE	; 254
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:147
	crc &= 0xFF;
	Wire.write(crc);

	if (Wire.endTransmission() != 0) return "*trans";

	delay(20);
    58f0:	64 e1       	ldi	r22, 0x14	; 20
    58f2:	70 e0       	ldi	r23, 0x00	; 0
    58f4:	80 e0       	ldi	r24, 0x00	; 0
    58f6:	90 e0       	ldi	r25, 0x00	; 0
    58f8:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:148
	Wire.requestFrom(addr, length);
    58fc:	40 2f       	mov	r20, r16
    58fe:	6f e7       	ldi	r22, 0x7F	; 127
    5900:	8c e3       	ldi	r24, 0x3C	; 60
    5902:	9f e0       	ldi	r25, 0x0F	; 15
    5904:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <TwoWire::requestFrom(unsigned char, unsigned char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:151

	byte* _return = 0;
	_return = (byte*)malloc(length * sizeof(byte));
    5908:	10 e0       	ldi	r17, 0x00	; 0
    590a:	c8 01       	movw	r24, r16
    590c:	0e 94 d8 62 	call	0xc5b0	; 0xc5b0 <malloc>
    5910:	7c 01       	movw	r14, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:153

	unsigned long starttime = millis();
    5912:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    5916:	2b 01       	movw	r4, r22
    5918:	3c 01       	movw	r6, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:155
	int returncount = 0;
	if (DEBUG || debugMode) Serial.print("$ I2C: ");
    591a:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <debugMode>
    591e:	88 23       	and	r24, r24
    5920:	31 f0       	breq	.+12     	; 0x592e <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0xc6>
    5922:	6f e8       	ldi	r22, 0x8F	; 143
    5924:	73 e0       	ldi	r23, 0x03	; 3
    5926:	82 e5       	ldi	r24, 0x52	; 82
    5928:	9e e0       	ldi	r25, 0x0E	; 14
    592a:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:135


String sendata(byte addr, byte data[]) {
	byte length = data[0] & 0x0F;
	length += 2;
	byte crc = 0x00;
    592e:	57 01       	movw	r10, r14
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:169
			_return[returncount] = in;
		}
		returncount++;
		if (DEBUG || debugMode) {
			char sz[6];
			sprintf(sz, "0x%02X\t", in);
    5930:	9c e9       	ldi	r25, 0x9C	; 156
    5932:	29 2e       	mov	r2, r25
    5934:	93 e0       	ldi	r25, 0x03	; 3
    5936:	39 2e       	mov	r3, r25
    5938:	ce 01       	movw	r24, r28
    593a:	01 96       	adiw	r24, 0x01	; 1
    593c:	4c 01       	movw	r8, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:156
	_return = (byte*)malloc(length * sizeof(byte));

	unsigned long starttime = millis();
	int returncount = 0;
	if (DEBUG || debugMode) Serial.print("$ I2C: ");
	while (Wire.available())
    593e:	90 91 75 0c 	lds	r25, 0x0C75	; 0x800c75 <TwoWire::rxBufferLength>
    5942:	80 91 76 0c 	lds	r24, 0x0C76	; 0x800c76 <TwoWire::rxBufferIndex>
    5946:	98 17       	cp	r25, r24
    5948:	09 f4       	brne	.+2      	; 0x594c <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0xe4>
    594a:	46 c0       	rjmp	.+140    	; 0x59d8 <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x170>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:158
	{
		byte in = Wire.read();
    594c:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:159
		if (returncount >= length) {
    5950:	95 01       	movw	r18, r10
    5952:	2e 19       	sub	r18, r14
    5954:	3f 09       	sbc	r19, r15
    5956:	20 17       	cp	r18, r16
    5958:	31 07       	cpc	r19, r17
    595a:	14 f1       	brlt	.+68     	; 0x59a0 <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x138>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:160
			free(_return);
    595c:	c7 01       	movw	r24, r14
    595e:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:161
			return "*ovf";
    5962:	67 e9       	ldi	r22, 0x97	; 151
    5964:	73 e0       	ldi	r23, 0x03	; 3
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:182
	}
	crc = 0;
	for (int i = 0; i < length - 1; i++)	crc += _return[i];
	if (crc != _return[length - 1]) {
		free(_return);
		return "*crc";
    5966:	c6 01       	movw	r24, r12
    5968:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:192
		sprintf(_temp, "%02X", (byte)_return[i]);
		s += String(_temp);
	}
	free(_return);
	return s;
}
    596c:	c6 01       	movw	r24, r12
    596e:	2f 96       	adiw	r28, 0x0f	; 15
    5970:	0f b6       	in	r0, 0x3f	; 63
    5972:	f8 94       	cli
    5974:	de bf       	out	0x3e, r29	; 62
    5976:	0f be       	out	0x3f, r0	; 63
    5978:	cd bf       	out	0x3d, r28	; 61
    597a:	df 91       	pop	r29
    597c:	cf 91       	pop	r28
    597e:	1f 91       	pop	r17
    5980:	0f 91       	pop	r16
    5982:	ff 90       	pop	r15
    5984:	ef 90       	pop	r14
    5986:	df 90       	pop	r13
    5988:	cf 90       	pop	r12
    598a:	bf 90       	pop	r11
    598c:	af 90       	pop	r10
    598e:	9f 90       	pop	r9
    5990:	8f 90       	pop	r8
    5992:	7f 90       	pop	r7
    5994:	6f 90       	pop	r6
    5996:	5f 90       	pop	r5
    5998:	4f 90       	pop	r4
    599a:	3f 90       	pop	r3
    599c:	2f 90       	pop	r2
    599e:	08 95       	ret
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:164
		if (returncount >= length) {
			free(_return);
			return "*ovf";
		}
		else {
			_return[returncount] = in;
    59a0:	f5 01       	movw	r30, r10
    59a2:	81 93       	st	Z+, r24
    59a4:	5f 01       	movw	r10, r30
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:167
		}
		returncount++;
		if (DEBUG || debugMode) {
    59a6:	20 91 fa 09 	lds	r18, 0x09FA	; 0x8009fa <debugMode>
    59aa:	22 23       	and	r18, r18
    59ac:	41 f2       	breq	.-112    	; 0x593e <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0xd6>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:169
			char sz[6];
			sprintf(sz, "0x%02X\t", in);
    59ae:	99 27       	eor	r25, r25
    59b0:	9f 93       	push	r25
    59b2:	8f 93       	push	r24
    59b4:	3f 92       	push	r3
    59b6:	2f 92       	push	r2
    59b8:	9f 92       	push	r9
    59ba:	8f 92       	push	r8
    59bc:	0e 94 de 6e 	call	0xddbc	; 0xddbc <sprintf>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:170
			Serial.print(sz);
    59c0:	b4 01       	movw	r22, r8
    59c2:	82 e5       	ldi	r24, 0x52	; 82
    59c4:	9e e0       	ldi	r25, 0x0E	; 14
    59c6:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
    59ca:	0f 90       	pop	r0
    59cc:	0f 90       	pop	r0
    59ce:	0f 90       	pop	r0
    59d0:	0f 90       	pop	r0
    59d2:	0f 90       	pop	r0
    59d4:	0f 90       	pop	r0
    59d6:	b3 cf       	rjmp	.-154    	; 0x593e <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0xd6>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:173
		}
	}
	if (DEBUG || debugMode) Serial.println();
    59d8:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <debugMode>
    59dc:	88 23       	and	r24, r24
    59de:	31 f0       	breq	.+12     	; 0x59ec <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x184>
write():
    59e0:	6a e6       	ldi	r22, 0x6A	; 106
    59e2:	73 e0       	ldi	r23, 0x03	; 3
    59e4:	82 e5       	ldi	r24, 0x52	; 82
    59e6:	9e e0       	ldi	r25, 0x0E	; 14
    59e8:	0e 94 b4 25 	call	0x4b68	; 0x4b68 <Print::write(char const*) [clone .part.2]>
sendata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:174
	if (millis() - starttime > 120) {
    59ec:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    59f0:	64 19       	sub	r22, r4
    59f2:	75 09       	sbc	r23, r5
    59f4:	86 09       	sbc	r24, r6
    59f6:	97 09       	sbc	r25, r7
    59f8:	69 37       	cpi	r22, 0x79	; 121
    59fa:	71 05       	cpc	r23, r1
    59fc:	81 05       	cpc	r24, r1
    59fe:	91 05       	cpc	r25, r1
    5a00:	30 f0       	brcs	.+12     	; 0x5a0e <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x1a6>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:175
		free(_return);
    5a02:	c7 01       	movw	r24, r14
    5a04:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:176
		return "*ttl";
    5a08:	64 ea       	ldi	r22, 0xA4	; 164
    5a0a:	73 e0       	ldi	r23, 0x03	; 3
    5a0c:	ac cf       	rjmp	.-168    	; 0x5966 <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0xfe>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:174
			sprintf(sz, "0x%02X\t", in);
			Serial.print(sz);
		}
	}
	if (DEBUG || debugMode) Serial.println();
	if (millis() - starttime > 120) {
    5a0e:	f7 01       	movw	r30, r14
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:178
		free(_return);
		return "*ttl";
	}
	crc = 0;
    5a10:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:179
	for (int i = 0; i < length - 1; i++)	crc += _return[i];
    5a12:	58 01       	movw	r10, r16
    5a14:	91 e0       	ldi	r25, 0x01	; 1
    5a16:	a9 1a       	sub	r10, r25
    5a18:	b1 08       	sbc	r11, r1
    5a1a:	9f 01       	movw	r18, r30
    5a1c:	2e 19       	sub	r18, r14
    5a1e:	3f 09       	sbc	r19, r15
    5a20:	2a 15       	cp	r18, r10
    5a22:	3b 05       	cpc	r19, r11
    5a24:	1c f4       	brge	.+6      	; 0x5a2c <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x1c4>
    5a26:	91 91       	ld	r25, Z+
    5a28:	89 0f       	add	r24, r25
    5a2a:	f7 cf       	rjmp	.-18     	; 0x5a1a <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x1b2>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:180
	if (crc != _return[length - 1]) {
    5a2c:	0e 0d       	add	r16, r14
    5a2e:	1f 1d       	adc	r17, r15
    5a30:	f8 01       	movw	r30, r16
    5a32:	31 97       	sbiw	r30, 0x01	; 1
    5a34:	90 81       	ld	r25, Z
    5a36:	89 17       	cp	r24, r25
    5a38:	31 f0       	breq	.+12     	; 0x5a46 <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x1de>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:181
		free(_return);
    5a3a:	c7 01       	movw	r24, r14
    5a3c:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:182
		return "*crc";
    5a40:	69 ea       	ldi	r22, 0xA9	; 169
    5a42:	73 e0       	ldi	r23, 0x03	; 3
    5a44:	90 cf       	rjmp	.-224    	; 0x5966 <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0xfe>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:184
	}
	String s = "";
    5a46:	63 ea       	ldi	r22, 0xA3	; 163
    5a48:	73 e0       	ldi	r23, 0x03	; 3
    5a4a:	ce 01       	movw	r24, r28
    5a4c:	07 96       	adiw	r24, 0x07	; 7
    5a4e:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    5a52:	47 01       	movw	r8, r14
    5a54:	ef ef       	ldi	r30, 0xFF	; 255
    5a56:	8e 1a       	sub	r8, r30
    5a58:	9e 0a       	sbc	r9, r30
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:187
	char _temp[3];
	for (int i = 1; i < length - 1; i++) {
		sprintf(_temp, "%02X", (byte)_return[i]);
    5a5a:	8e ea       	ldi	r24, 0xAE	; 174
    5a5c:	68 2e       	mov	r6, r24
    5a5e:	83 e0       	ldi	r24, 0x03	; 3
    5a60:	78 2e       	mov	r7, r24
    5a62:	8e 01       	movw	r16, r28
    5a64:	03 5f       	subi	r16, 0xF3	; 243
    5a66:	1f 4f       	sbci	r17, 0xFF	; 255
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:186
		free(_return);
		return "*crc";
	}
	String s = "";
	char _temp[3];
	for (int i = 1; i < length - 1; i++) {
    5a68:	c4 01       	movw	r24, r8
    5a6a:	8e 19       	sub	r24, r14
    5a6c:	9f 09       	sbc	r25, r15
    5a6e:	8a 15       	cp	r24, r10
    5a70:	9b 05       	cpc	r25, r11
    5a72:	14 f5       	brge	.+68     	; 0x5ab8 <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x250>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:187
		sprintf(_temp, "%02X", (byte)_return[i]);
    5a74:	f4 01       	movw	r30, r8
    5a76:	81 91       	ld	r24, Z+
    5a78:	4f 01       	movw	r8, r30
    5a7a:	1f 92       	push	r1
    5a7c:	8f 93       	push	r24
    5a7e:	7f 92       	push	r7
    5a80:	6f 92       	push	r6
    5a82:	1f 93       	push	r17
    5a84:	0f 93       	push	r16
    5a86:	0e 94 de 6e 	call	0xddbc	; 0xddbc <sprintf>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:188
		s += String(_temp);
    5a8a:	b8 01       	movw	r22, r16
    5a8c:	ce 01       	movw	r24, r28
    5a8e:	01 96       	adiw	r24, 0x01	; 1
    5a90:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
_ZN6StringpLERKS_():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:113
	unsigned char concat(double num);
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
    5a94:	be 01       	movw	r22, r28
    5a96:	6f 5f       	subi	r22, 0xFF	; 255
    5a98:	7f 4f       	sbci	r23, 0xFF	; 255
    5a9a:	ce 01       	movw	r24, r28
    5a9c:	07 96       	adiw	r24, 0x07	; 7
    5a9e:	0e 94 14 2b 	call	0x5628	; 0x5628 <String::concat(String const&)>
sendata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:188
    5aa2:	ce 01       	movw	r24, r28
    5aa4:	01 96       	adiw	r24, 0x01	; 1
    5aa6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    5aaa:	0f 90       	pop	r0
    5aac:	0f 90       	pop	r0
    5aae:	0f 90       	pop	r0
    5ab0:	0f 90       	pop	r0
    5ab2:	0f 90       	pop	r0
    5ab4:	0f 90       	pop	r0
    5ab6:	d8 cf       	rjmp	.-80     	; 0x5a68 <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x200>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:190
	}
	free(_return);
    5ab8:	c7 01       	movw	r24, r14
    5aba:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
_ZN6String4initEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:133
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    5abe:	f6 01       	movw	r30, r12
    5ac0:	11 82       	std	Z+1, r1	; 0x01
    5ac2:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:134
	capacity = 0;
    5ac4:	13 82       	std	Z+3, r1	; 0x03
    5ac6:	12 82       	std	Z+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:135
	len = 0;
    5ac8:	15 82       	std	Z+5, r1	; 0x05
    5aca:	14 82       	std	Z+4, r1	; 0x04
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:50

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String::String(String &&rval)
{
	init();
	move(rval);
    5acc:	be 01       	movw	r22, r28
    5ace:	69 5f       	subi	r22, 0xF9	; 249
    5ad0:	7f 4f       	sbci	r23, 0xFF	; 255
    5ad2:	c6 01       	movw	r24, r12
    5ad4:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
sendata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:184
	for (int i = 0; i < length - 1; i++)	crc += _return[i];
	if (crc != _return[length - 1]) {
		free(_return);
		return "*crc";
	}
	String s = "";
    5ad8:	ce 01       	movw	r24, r28
    5ada:	07 96       	adiw	r24, 0x07	; 7
    5adc:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    5ae0:	45 cf       	rjmp	.-374    	; 0x596c <sendata(unsigned char, unsigned char*) [clone .constprop.30]+0x104>

00005ae2 <update_K_temp()>:
update_K_temp():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:1
void update_K_temp() {
    5ae2:	cf 92       	push	r12
    5ae4:	df 92       	push	r13
    5ae6:	ef 92       	push	r14
    5ae8:	ff 92       	push	r15
    5aea:	0f 93       	push	r16
    5aec:	1f 93       	push	r17
    5aee:	cf 93       	push	r28
    5af0:	df 93       	push	r29
    5af2:	cd b7       	in	r28, 0x3d	; 61
    5af4:	de b7       	in	r29, 0x3e	; 62
    5af6:	2c 97       	sbiw	r28, 0x0c	; 12
    5af8:	0f b6       	in	r0, 0x3f	; 63
    5afa:	f8 94       	cli
    5afc:	de bf       	out	0x3e, r29	; 62
    5afe:	0f be       	out	0x3f, r0	; 63
    5b00:	cd bf       	out	0x3d, r28	; 61
    5b02:	03 e0       	ldi	r16, 0x03	; 3
    5b04:	10 e0       	ldi	r17, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:6
	float temp = 0.0f;
	//noFault = true;
	int retry = 0;
	while (retry < 3) {
		temp = max.readThermocoupleTemperature();
    5b06:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]>
    5b0a:	6b 01       	movw	r12, r22
    5b0c:	7c 01       	movw	r14, r24
readFault():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:164
    @brief  Read the fault register (8 bits)
    @returns 8 bits of fault register data
*/
/**************************************************************************/
uint8_t Adafruit_MAX31856::readFault(void) {
  return readRegister8(MAX31856_SR_REG);
    5b0e:	8f e0       	ldi	r24, 0x0F	; 15
    5b10:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <Adafruit_MAX31856::readRegister8(unsigned char) [clone .constprop.103]>
update_K_temp():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:7
		fault = max.readFault();
    5b14:	80 93 5f 09 	sts	0x095F, r24	; 0x80095f <fault>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:8
		SerialDebug("Fault:0x", String(fault, HEX));
    5b18:	68 2f       	mov	r22, r24
    5b1a:	ce 01       	movw	r24, r28
    5b1c:	07 96       	adiw	r24, 0x07	; 7
    5b1e:	0e 94 72 2b 	call	0x56e4	; 0x56e4 <String::String(unsigned char, unsigned char) [clone .constprop.111]>
    5b22:	63 eb       	ldi	r22, 0xB3	; 179
    5b24:	73 e0       	ldi	r23, 0x03	; 3
    5b26:	ce 01       	movw	r24, r28
    5b28:	01 96       	adiw	r24, 0x01	; 1
    5b2a:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    5b2e:	be 01       	movw	r22, r28
    5b30:	69 5f       	subi	r22, 0xF9	; 249
    5b32:	7f 4f       	sbci	r23, 0xFF	; 255
    5b34:	ce 01       	movw	r24, r28
    5b36:	01 96       	adiw	r24, 0x01	; 1
    5b38:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    5b3c:	ce 01       	movw	r24, r28
    5b3e:	01 96       	adiw	r24, 0x01	; 1
    5b40:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    5b44:	ce 01       	movw	r24, r28
    5b46:	07 96       	adiw	r24, 0x07	; 7
    5b48:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:10

		if (fault) {
    5b4c:	80 91 5f 09 	lds	r24, 0x095F	; 0x80095f <fault>
    5b50:	88 23       	and	r24, r24
    5b52:	79 f1       	breq	.+94     	; 0x5bb2 <update_K_temp()+0xd0>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:12
			retry++;
			delay(10);
    5b54:	6a e0       	ldi	r22, 0x0A	; 10
    5b56:	70 e0       	ldi	r23, 0x00	; 0
    5b58:	80 e0       	ldi	r24, 0x00	; 0
    5b5a:	90 e0       	ldi	r25, 0x00	; 0
    5b5c:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
    5b60:	01 50       	subi	r16, 0x01	; 1
    5b62:	11 09       	sbc	r17, r1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:5
void update_K_temp() {
	float temp = 0.0f;
	//noFault = true;
	int retry = 0;
	while (retry < 3) {
    5b64:	81 f6       	brne	.-96     	; 0x5b06 <update_K_temp()+0x24>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:20
		{
			K_temperature = temp + k_cal;
			break;
		} 
	}
	if (fault) Serial.println("*Thermo Error");
    5b66:	6c eb       	ldi	r22, 0xBC	; 188
    5b68:	73 e0       	ldi	r23, 0x03	; 3
    5b6a:	82 e5       	ldi	r24, 0x52	; 82
    5b6c:	9e e0       	ldi	r25, 0x0E	; 14
    5b6e:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:21
	lcd.createChar(5, fault ? k_fail_icon : k_icon);
    5b72:	10 91 5f 09 	lds	r17, 0x095F	; 0x80095f <fault>
    5b76:	61 e6       	ldi	r22, 0x61	; 97
    5b78:	72 e0       	ldi	r23, 0x02	; 2
    5b7a:	11 23       	and	r17, r17
    5b7c:	11 f0       	breq	.+4      	; 0x5b82 <update_K_temp()+0xa0>
    5b7e:	68 e0       	ldi	r22, 0x08	; 8
    5b80:	72 e0       	ldi	r23, 0x02	; 2
    5b82:	85 e0       	ldi	r24, 0x05	; 5
    5b84:	0e 94 f6 22 	call	0x45ec	; 0x45ec <LiquidCrystal_I2C::createChar(unsigned char, unsigned char*) [clone .constprop.164]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:22
	fault ? ThermoER.resume() : ThermoER.pause();
    5b88:	80 ee       	ldi	r24, 0xE0	; 224
    5b8a:	9f e0       	ldi	r25, 0x0F	; 15
    5b8c:	11 23       	and	r17, r17
    5b8e:	31 f1       	breq	.+76     	; 0x5bdc <update_K_temp()+0xfa>
    5b90:	0e 94 60 1d 	call	0x3ac0	; 0x3ac0 <BlinkControl::resume()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:23
}
    5b94:	2c 96       	adiw	r28, 0x0c	; 12
    5b96:	0f b6       	in	r0, 0x3f	; 63
    5b98:	f8 94       	cli
    5b9a:	de bf       	out	0x3e, r29	; 62
    5b9c:	0f be       	out	0x3f, r0	; 63
    5b9e:	cd bf       	out	0x3d, r28	; 61
    5ba0:	df 91       	pop	r29
    5ba2:	cf 91       	pop	r28
    5ba4:	1f 91       	pop	r17
    5ba6:	0f 91       	pop	r16
    5ba8:	ff 90       	pop	r15
    5baa:	ef 90       	pop	r14
    5bac:	df 90       	pop	r13
    5bae:	cf 90       	pop	r12
    5bb0:	08 95       	ret
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:16
			retry++;
			delay(10);
		}
		else
		{
			K_temperature = temp + k_cal;
    5bb2:	a7 01       	movw	r20, r14
    5bb4:	96 01       	movw	r18, r12
    5bb6:	60 91 60 09 	lds	r22, 0x0960	; 0x800960 <k_cal>
    5bba:	70 91 61 09 	lds	r23, 0x0961	; 0x800961 <k_cal+0x1>
    5bbe:	80 91 62 09 	lds	r24, 0x0962	; 0x800962 <k_cal+0x2>
    5bc2:	90 91 63 09 	lds	r25, 0x0963	; 0x800963 <k_cal+0x3>
    5bc6:	0e 94 75 6a 	call	0xd4ea	; 0xd4ea <__addsf3>
    5bca:	60 93 10 02 	sts	0x0210, r22	; 0x800210 <K_temperature>
    5bce:	70 93 11 02 	sts	0x0211, r23	; 0x800211 <K_temperature+0x1>
    5bd2:	80 93 12 02 	sts	0x0212, r24	; 0x800212 <K_temperature+0x2>
    5bd6:	90 93 13 02 	sts	0x0213, r25	; 0x800213 <K_temperature+0x3>
    5bda:	cb cf       	rjmp	.-106    	; 0x5b72 <update_K_temp()+0x90>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:22
			break;
		} 
	}
	if (fault) Serial.println("*Thermo Error");
	lcd.createChar(5, fault ? k_fail_icon : k_icon);
	fault ? ThermoER.resume() : ThermoER.pause();
    5bdc:	0e 94 c4 23 	call	0x4788	; 0x4788 <BlinkControl::pause()>
    5be0:	d9 cf       	rjmp	.-78     	; 0x5b94 <update_K_temp()+0xb2>

00005be2 <inttostring(int, int)>:
inttostring():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:20
	String s = String(str);
	free(str);
	return s;
}

String inttostring(int value, int integer) {
    5be2:	af 92       	push	r10
    5be4:	bf 92       	push	r11
    5be6:	cf 92       	push	r12
    5be8:	df 92       	push	r13
    5bea:	ef 92       	push	r14
    5bec:	ff 92       	push	r15
    5bee:	0f 93       	push	r16
    5bf0:	1f 93       	push	r17
    5bf2:	cf 93       	push	r28
    5bf4:	df 93       	push	r29
    5bf6:	7c 01       	movw	r14, r24
    5bf8:	6b 01       	movw	r12, r22
    5bfa:	ea 01       	movw	r28, r20
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:23
	char* str = 0;
	char* format = "%0d";
	format[1] = (char)(integer + '0');
    5bfc:	8a ec       	ldi	r24, 0xCA	; 202
    5bfe:	a8 2e       	mov	r10, r24
    5c00:	83 e0       	ldi	r24, 0x03	; 3
    5c02:	b8 2e       	mov	r11, r24
    5c04:	84 2f       	mov	r24, r20
    5c06:	80 5d       	subi	r24, 0xD0	; 208
    5c08:	80 93 cb 03 	sts	0x03CB, r24	; 0x8003cb <keys+0x86>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:25
	int len = integer + 1;
	str = (char*)malloc(len * sizeof(char));
    5c0c:	ca 01       	movw	r24, r20
    5c0e:	01 96       	adiw	r24, 0x01	; 1
    5c10:	0e 94 d8 62 	call	0xc5b0	; 0xc5b0 <malloc>
    5c14:	8c 01       	movw	r16, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:26
	if (value == -9999) for (int i = 0; i < len - 1; i++) str[i] = '-';
    5c16:	81 ef       	ldi	r24, 0xF1	; 241
    5c18:	c8 16       	cp	r12, r24
    5c1a:	88 ed       	ldi	r24, 0xD8	; 216
    5c1c:	d8 06       	cpc	r13, r24
    5c1e:	d9 f4       	brne	.+54     	; 0x5c56 <inttostring(int, int)+0x74>
    5c20:	f8 01       	movw	r30, r16
    5c22:	c0 0f       	add	r28, r16
    5c24:	d1 1f       	adc	r29, r17
    5c26:	8d e2       	ldi	r24, 0x2D	; 45
    5c28:	81 93       	st	Z+, r24
    5c2a:	ec 17       	cp	r30, r28
    5c2c:	fd 07       	cpc	r31, r29
    5c2e:	e1 f7       	brne	.-8      	; 0x5c28 <inttostring(int, int)+0x46>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:28
	else sprintf(str, format, value);
	String s = String(str);
    5c30:	b8 01       	movw	r22, r16
    5c32:	c7 01       	movw	r24, r14
    5c34:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:29
	free(str);
    5c38:	c8 01       	movw	r24, r16
    5c3a:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:31
	return s;
}
    5c3e:	c7 01       	movw	r24, r14
    5c40:	df 91       	pop	r29
    5c42:	cf 91       	pop	r28
    5c44:	1f 91       	pop	r17
    5c46:	0f 91       	pop	r16
    5c48:	ff 90       	pop	r15
    5c4a:	ef 90       	pop	r14
    5c4c:	df 90       	pop	r13
    5c4e:	cf 90       	pop	r12
    5c50:	bf 90       	pop	r11
    5c52:	af 90       	pop	r10
    5c54:	08 95       	ret
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:27
	char* format = "%0d";
	format[1] = (char)(integer + '0');
	int len = integer + 1;
	str = (char*)malloc(len * sizeof(char));
	if (value == -9999) for (int i = 0; i < len - 1; i++) str[i] = '-';
	else sprintf(str, format, value);
    5c56:	df 92       	push	r13
    5c58:	cf 92       	push	r12
    5c5a:	bf 92       	push	r11
    5c5c:	af 92       	push	r10
    5c5e:	1f 93       	push	r17
    5c60:	0f 93       	push	r16
    5c62:	0e 94 de 6e 	call	0xddbc	; 0xddbc <sprintf>
    5c66:	0f 90       	pop	r0
    5c68:	0f 90       	pop	r0
    5c6a:	0f 90       	pop	r0
    5c6c:	0f 90       	pop	r0
    5c6e:	0f 90       	pop	r0
    5c70:	0f 90       	pop	r0
    5c72:	de cf       	rjmp	.-68     	; 0x5c30 <inttostring(int, int)+0x4e>

00005c74 <floattostring(float, int, int)>:
floattostring():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:6
void flushAllSerial() {
  flush_EC_serial();
  flush_pH_serial();
}

String floattostring(float value, int integer, int decimal) {
    5c74:	4f 92       	push	r4
    5c76:	5f 92       	push	r5
    5c78:	6f 92       	push	r6
    5c7a:	7f 92       	push	r7
    5c7c:	af 92       	push	r10
    5c7e:	bf 92       	push	r11
    5c80:	cf 92       	push	r12
    5c82:	df 92       	push	r13
    5c84:	ef 92       	push	r14
    5c86:	ff 92       	push	r15
    5c88:	0f 93       	push	r16
    5c8a:	1f 93       	push	r17
    5c8c:	cf 93       	push	r28
    5c8e:	df 93       	push	r29
    5c90:	6c 01       	movw	r12, r24
    5c92:	2a 01       	movw	r4, r20
    5c94:	3b 01       	movw	r6, r22
    5c96:	58 01       	movw	r10, r16
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:10
	//we make a char array, which size = 0
	char* str = 0;
	//resize the array to fit the input serial command length
	int len = integer + decimal + 2;
    5c98:	89 01       	movw	r16, r18
    5c9a:	0a 0d       	add	r16, r10
    5c9c:	1b 1d       	adc	r17, r11
    5c9e:	78 01       	movw	r14, r16
    5ca0:	82 e0       	ldi	r24, 0x02	; 2
    5ca2:	e8 0e       	add	r14, r24
    5ca4:	f1 1c       	adc	r15, r1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:11
	str = (char*)malloc(len * sizeof(char));
    5ca6:	c7 01       	movw	r24, r14
    5ca8:	0e 94 d8 62 	call	0xc5b0	; 0xc5b0 <malloc>
    5cac:	ec 01       	movw	r28, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:13
	//convert the string to a char array
	if (isnan(value)) for (int i = 0; i < len - 1; i++) str[i] = '-';
    5cae:	a3 01       	movw	r20, r6
    5cb0:	92 01       	movw	r18, r4
    5cb2:	c3 01       	movw	r24, r6
    5cb4:	b2 01       	movw	r22, r4
    5cb6:	0e 94 e2 6b 	call	0xd7c4	; 0xd7c4 <__unordsf2>
    5cba:	81 11       	cpse	r24, r1
    5cbc:	1f c0       	rjmp	.+62     	; 0x5cfc <floattostring(float, int, int)+0x88>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:14
	else dtostrf(value, len - 1, decimal, str);
    5cbe:	4f ef       	ldi	r20, 0xFF	; 255
    5cc0:	4e 0d       	add	r20, r14
    5cc2:	8e 01       	movw	r16, r28
    5cc4:	2a 2d       	mov	r18, r10
    5cc6:	c3 01       	movw	r24, r6
    5cc8:	b2 01       	movw	r22, r4
    5cca:	0e 94 ba 62 	call	0xc574	; 0xc574 <dtostrf>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:15
	String s = String(str);
    5cce:	be 01       	movw	r22, r28
    5cd0:	c6 01       	movw	r24, r12
    5cd2:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:16
	free(str);
    5cd6:	ce 01       	movw	r24, r28
    5cd8:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:18
	return s;
}
    5cdc:	c6 01       	movw	r24, r12
    5cde:	df 91       	pop	r29
    5ce0:	cf 91       	pop	r28
    5ce2:	1f 91       	pop	r17
    5ce4:	0f 91       	pop	r16
    5ce6:	ff 90       	pop	r15
    5ce8:	ef 90       	pop	r14
    5cea:	df 90       	pop	r13
    5cec:	cf 90       	pop	r12
    5cee:	bf 90       	pop	r11
    5cf0:	af 90       	pop	r10
    5cf2:	7f 90       	pop	r7
    5cf4:	6f 90       	pop	r6
    5cf6:	5f 90       	pop	r5
    5cf8:	4f 90       	pop	r4
    5cfa:	08 95       	ret
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:13
	char* str = 0;
	//resize the array to fit the input serial command length
	int len = integer + decimal + 2;
	str = (char*)malloc(len * sizeof(char));
	//convert the string to a char array
	if (isnan(value)) for (int i = 0; i < len - 1; i++) str[i] = '-';
    5cfc:	fe 01       	movw	r30, r28
    5cfe:	2d e2       	ldi	r18, 0x2D	; 45
    5d00:	21 93       	st	Z+, r18
    5d02:	cf 01       	movw	r24, r30
    5d04:	8c 1b       	sub	r24, r28
    5d06:	9d 0b       	sbc	r25, r29
    5d08:	08 17       	cp	r16, r24
    5d0a:	19 07       	cpc	r17, r25
    5d0c:	cc f7       	brge	.-14     	; 0x5d00 <floattostring(float, int, int)+0x8c>
    5d0e:	df cf       	rjmp	.-66     	; 0x5cce <floattostring(float, int, int)+0x5a>

00005d10 <SyncRTCbyGPS(bool)>:
SyncRTCbyGPS():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:48
	sscanf(data, "%d-%d-%d %d:%d:%d", &_Year, &_Month, &_Day, &_Hour, &_Minute, &_Second);
	DateTime value = DateTime(_Year, _Month, _Day, _Hour, _Minute, _Second);
	return value;
}

String SyncRTCbyGPS(bool applysync) {
    5d10:	2f 92       	push	r2
    5d12:	3f 92       	push	r3
    5d14:	4f 92       	push	r4
    5d16:	5f 92       	push	r5
    5d18:	6f 92       	push	r6
    5d1a:	7f 92       	push	r7
    5d1c:	8f 92       	push	r8
    5d1e:	9f 92       	push	r9
    5d20:	af 92       	push	r10
    5d22:	bf 92       	push	r11
    5d24:	cf 92       	push	r12
    5d26:	df 92       	push	r13
    5d28:	ef 92       	push	r14
    5d2a:	ff 92       	push	r15
    5d2c:	0f 93       	push	r16
    5d2e:	1f 93       	push	r17
    5d30:	cf 93       	push	r28
    5d32:	df 93       	push	r29
    5d34:	cd b7       	in	r28, 0x3d	; 61
    5d36:	de b7       	in	r29, 0x3e	; 62
    5d38:	a0 97       	sbiw	r28, 0x20	; 32
    5d3a:	0f b6       	in	r0, 0x3f	; 63
    5d3c:	f8 94       	cli
    5d3e:	de bf       	out	0x3e, r29	; 62
    5d40:	0f be       	out	0x3f, r0	; 63
    5d42:	cd bf       	out	0x3d, r28	; 61
    5d44:	8c 01       	movw	r16, r24
    5d46:	68 a3       	std	Y+32, r22	; 0x20
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:49
	if (gps.date.isValid() && gps.time.isValid()) 
    5d48:	80 91 a7 11 	lds	r24, 0x11A7	; 0x8011a7 <gps+0x22>
    5d4c:	88 23       	and	r24, r24
    5d4e:	f1 f1       	breq	.+124    	; 0x5dcc <SyncRTCbyGPS(bool)+0xbc>
    5d50:	80 91 b5 11 	lds	r24, 0x11B5	; 0x8011b5 <gps+0x30>
    5d54:	88 23       	and	r24, r24
    5d56:	d1 f1       	breq	.+116    	; 0x5dcc <SyncRTCbyGPS(bool)+0xbc>
year():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:395
   newDate = atol(term);
}

uint16_t TinyGPSDate::year()
{
   updated = false;
    5d58:	10 92 a8 11 	sts	0x11A8, r1	; 0x8011a8 <gps+0x23>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:396
   uint16_t year = date % 100;
    5d5c:	40 90 a9 11 	lds	r4, 0x11A9	; 0x8011a9 <gps+0x24>
    5d60:	50 90 aa 11 	lds	r5, 0x11AA	; 0x8011aa <gps+0x25>
    5d64:	60 90 ab 11 	lds	r6, 0x11AB	; 0x8011ab <gps+0x26>
    5d68:	70 90 ac 11 	lds	r7, 0x11AC	; 0x8011ac <gps+0x27>
    5d6c:	94 e6       	ldi	r25, 0x64	; 100
    5d6e:	c9 2e       	mov	r12, r25
    5d70:	d1 2c       	mov	r13, r1
    5d72:	e1 2c       	mov	r14, r1
    5d74:	f1 2c       	mov	r15, r1
    5d76:	c3 01       	movw	r24, r6
    5d78:	b2 01       	movw	r22, r4
    5d7a:	a7 01       	movw	r20, r14
    5d7c:	96 01       	movw	r18, r12
    5d7e:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5d82:	86 2e       	mov	r8, r22
    5d84:	26 2e       	mov	r2, r22
    5d86:	37 2e       	mov	r3, r23
SyncRTCbyGPS():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:52
	{
		//Check GPS datetime data is not 2000/00/00 00:00:00
		if (gps.date.year() == 2000 || gps.date.month()&gps.date.day()&gps.time.hour()&gps.time.minute()&gps.time.second() == 0) {
    5d88:	21 14       	cp	r2, r1
    5d8a:	31 04       	cpc	r3, r1
    5d8c:	09 f0       	breq	.+2      	; 0x5d90 <SyncRTCbyGPS(bool)+0x80>
    5d8e:	3f c0       	rjmp	.+126    	; 0x5e0e <SyncRTCbyGPS(bool)+0xfe>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:53
			SerialDebug("GPS Sync fail:", "check valid");
    5d90:	68 ef       	ldi	r22, 0xF8	; 248
    5d92:	73 e0       	ldi	r23, 0x03	; 3
    5d94:	ce 01       	movw	r24, r28
    5d96:	43 96       	adiw	r24, 0x13	; 19
    5d98:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    5d9c:	6e ed       	ldi	r22, 0xDE	; 222
    5d9e:	73 e0       	ldi	r23, 0x03	; 3
    5da0:	ce 01       	movw	r24, r28
    5da2:	01 96       	adiw	r24, 0x01	; 1
    5da4:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    5da8:	be 01       	movw	r22, r28
    5daa:	6d 5e       	subi	r22, 0xED	; 237
    5dac:	7f 4f       	sbci	r23, 0xFF	; 255
    5dae:	ce 01       	movw	r24, r28
    5db0:	01 96       	adiw	r24, 0x01	; 1
    5db2:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    5db6:	ce 01       	movw	r24, r28
    5db8:	01 96       	adiw	r24, 0x01	; 1
    5dba:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    5dbe:	ce 01       	movw	r24, r28
    5dc0:	43 96       	adiw	r24, 0x13	; 19
    5dc2:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:54
			return "*Sync[f:2]";
    5dc6:	64 e0       	ldi	r22, 0x04	; 4
    5dc8:	74 e0       	ldi	r23, 0x04	; 4
    5dca:	1d c0       	rjmp	.+58     	; 0x5e06 <SyncRTCbyGPS(bool)+0xf6>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:74
			SerialDebug("RTC Adjusted", "");
		}
	}
	else 
	{
		SerialDebug("GPS Sync fail:", "GPS valid check");
    5dcc:	6e ec       	ldi	r22, 0xCE	; 206
    5dce:	73 e0       	ldi	r23, 0x03	; 3
    5dd0:	ce 01       	movw	r24, r28
    5dd2:	43 96       	adiw	r24, 0x13	; 19
    5dd4:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    5dd8:	6e ed       	ldi	r22, 0xDE	; 222
    5dda:	73 e0       	ldi	r23, 0x03	; 3
    5ddc:	ce 01       	movw	r24, r28
    5dde:	01 96       	adiw	r24, 0x01	; 1
    5de0:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    5de4:	be 01       	movw	r22, r28
    5de6:	6d 5e       	subi	r22, 0xED	; 237
    5de8:	7f 4f       	sbci	r23, 0xFF	; 255
    5dea:	ce 01       	movw	r24, r28
    5dec:	01 96       	adiw	r24, 0x01	; 1
    5dee:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    5df2:	ce 01       	movw	r24, r28
    5df4:	01 96       	adiw	r24, 0x01	; 1
    5df6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    5dfa:	ce 01       	movw	r24, r28
    5dfc:	43 96       	adiw	r24, 0x13	; 19
    5dfe:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:75
		return "*Sync[f:3]";
    5e02:	6d ee       	ldi	r22, 0xED	; 237
    5e04:	73 e0       	ldi	r23, 0x03	; 3
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:77
	}
	return "*OK";
    5e06:	c8 01       	movw	r24, r16
    5e08:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    5e0c:	37 c1       	rjmp	.+622    	; 0x607c <SyncRTCbyGPS(bool)+0x36c>
month():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:403
}

uint8_t TinyGPSDate::month()
{
   updated = false;
   return (date / 100) % 100;
    5e0e:	ca 01       	movw	r24, r20
    5e10:	b9 01       	movw	r22, r18
    5e12:	a7 01       	movw	r20, r14
    5e14:	96 01       	movw	r18, r12
    5e16:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5e1a:	b6 2e       	mov	r11, r22
day():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:409
}

uint8_t TinyGPSDate::day()
{
   updated = false;
   return date / 10000;
    5e1c:	c3 01       	movw	r24, r6
    5e1e:	b2 01       	movw	r22, r4
    5e20:	20 e1       	ldi	r18, 0x10	; 16
    5e22:	37 e2       	ldi	r19, 0x27	; 39
    5e24:	40 e0       	ldi	r20, 0x00	; 0
    5e26:	50 e0       	ldi	r21, 0x00	; 0
    5e28:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5e2c:	92 2e       	mov	r9, r18
hour():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:414
}

uint8_t TinyGPSTime::hour()
{
   updated = false;
    5e2e:	10 92 b6 11 	sts	0x11B6, r1	; 0x8011b6 <gps+0x31>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:415
   return time / 1000000;
    5e32:	40 90 b7 11 	lds	r4, 0x11B7	; 0x8011b7 <gps+0x32>
    5e36:	50 90 b8 11 	lds	r5, 0x11B8	; 0x8011b8 <gps+0x33>
    5e3a:	60 90 b9 11 	lds	r6, 0x11B9	; 0x8011b9 <gps+0x34>
    5e3e:	70 90 ba 11 	lds	r7, 0x11BA	; 0x8011ba <gps+0x35>
    5e42:	c3 01       	movw	r24, r6
    5e44:	b2 01       	movw	r22, r4
    5e46:	20 e4       	ldi	r18, 0x40	; 64
    5e48:	32 e4       	ldi	r19, 0x42	; 66
    5e4a:	4f e0       	ldi	r20, 0x0F	; 15
    5e4c:	50 e0       	ldi	r21, 0x00	; 0
    5e4e:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5e52:	a2 2e       	mov	r10, r18
minute():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:421
}

uint8_t TinyGPSTime::minute()
{
   updated = false;
   return (time / 10000) % 100;
    5e54:	c3 01       	movw	r24, r6
    5e56:	b2 01       	movw	r22, r4
    5e58:	20 e1       	ldi	r18, 0x10	; 16
    5e5a:	37 e2       	ldi	r19, 0x27	; 39
    5e5c:	40 e0       	ldi	r20, 0x00	; 0
    5e5e:	50 e0       	ldi	r21, 0x00	; 0
    5e60:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5e64:	ca 01       	movw	r24, r20
    5e66:	b9 01       	movw	r22, r18
    5e68:	a7 01       	movw	r20, r14
    5e6a:	96 01       	movw	r18, r12
    5e6c:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5e70:	6f 8f       	std	Y+31, r22	; 0x1f
month():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:403
}

uint8_t TinyGPSDate::month()
{
   updated = false;
   return (date / 100) % 100;
    5e72:	c3 01       	movw	r24, r6
    5e74:	b2 01       	movw	r22, r4
    5e76:	a7 01       	movw	r20, r14
    5e78:	96 01       	movw	r18, r12
    5e7a:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5e7e:	ca 01       	movw	r24, r20
    5e80:	b9 01       	movw	r22, r18
    5e82:	a7 01       	movw	r20, r14
    5e84:	96 01       	movw	r18, r12
    5e86:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5e8a:	46 2f       	mov	r20, r22
SyncRTCbyGPS():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:52

String SyncRTCbyGPS(bool applysync) {
	if (gps.date.isValid() && gps.time.isValid()) 
	{
		//Check GPS datetime data is not 2000/00/00 00:00:00
		if (gps.date.year() == 2000 || gps.date.month()&gps.date.day()&gps.time.hour()&gps.time.minute()&gps.time.second() == 0) {
    5e8c:	89 2d       	mov	r24, r9
    5e8e:	8a 21       	and	r24, r10
    5e90:	8b 21       	and	r24, r11
    5e92:	cf 8c       	ldd	r12, Y+31	; 0x1f
    5e94:	8c 21       	and	r24, r12
    5e96:	90 e0       	ldi	r25, 0x00	; 0
    5e98:	21 e0       	ldi	r18, 0x01	; 1
    5e9a:	30 e0       	ldi	r19, 0x00	; 0
    5e9c:	44 23       	and	r20, r20
    5e9e:	11 f0       	breq	.+4      	; 0x5ea4 <SyncRTCbyGPS(bool)+0x194>
    5ea0:	30 e0       	ldi	r19, 0x00	; 0
    5ea2:	20 e0       	ldi	r18, 0x00	; 0
    5ea4:	82 23       	and	r24, r18
    5ea6:	93 23       	and	r25, r19
    5ea8:	89 2b       	or	r24, r25
    5eaa:	09 f0       	breq	.+2      	; 0x5eae <SyncRTCbyGPS(bool)+0x19e>
    5eac:	71 cf       	rjmp	.-286    	; 0x5d90 <SyncRTCbyGPS(bool)+0x80>
__base_ctor ():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:227
/**************************************************************************/
DateTime::DateTime(uint16_t year, uint8_t month, uint8_t day, uint8_t hour,
                   uint8_t min, uint8_t sec) {
  if (year >= 2000U)
    year -= 2000U;
  yOff = year;
    5eae:	8b 8a       	std	Y+19, r8	; 0x13
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:228
  m = month;
    5eb0:	bc 8a       	std	Y+20, r11	; 0x14
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:229
  d = day;
    5eb2:	9d 8a       	std	Y+21, r9	; 0x15
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:230
  hh = hour;
    5eb4:	ae 8a       	std	Y+22, r10	; 0x16
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:231
  mm = min;
    5eb6:	df 8c       	ldd	r13, Y+31	; 0x1f
    5eb8:	df 8a       	std	Y+23, r13	; 0x17
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:232
  ss = sec;
    5eba:	68 8f       	std	Y+24, r22	; 0x18
unixtime():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:591
    @return Number of seconds since 1970-01-01 00:00:00.
*/
/**************************************************************************/
uint32_t DateTime::unixtime(void) const {
  uint32_t t;
  uint16_t days = date2days(yOff, m, d);
    5ebc:	49 2d       	mov	r20, r9
    5ebe:	6b 2d       	mov	r22, r11
    5ec0:	c1 01       	movw	r24, r2
    5ec2:	0e 94 72 0d 	call	0x1ae4	; 0x1ae4 <date2days(unsigned int, unsigned char, unsigned char)>
time2ulong():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:151
    @param s Seconds
    @return Number of seconds total
*/
/**************************************************************************/
static uint32_t time2ulong(uint16_t days, uint8_t h, uint8_t m, uint8_t s) {
  return ((days * 24UL + h) * 60 + m) * 60 + s;
    5ec6:	9c 01       	movw	r18, r24
    5ec8:	a8 e1       	ldi	r26, 0x18	; 24
    5eca:	b0 e0       	ldi	r27, 0x00	; 0
    5ecc:	0e 94 65 6a 	call	0xd4ca	; 0xd4ca <__umulhisi3>
    5ed0:	2e 89       	ldd	r18, Y+22	; 0x16
    5ed2:	6b 01       	movw	r12, r22
    5ed4:	7c 01       	movw	r14, r24
    5ed6:	c2 0e       	add	r12, r18
    5ed8:	d1 1c       	adc	r13, r1
    5eda:	e1 1c       	adc	r14, r1
    5edc:	f1 1c       	adc	r15, r1
    5ede:	a7 01       	movw	r20, r14
    5ee0:	96 01       	movw	r18, r12
    5ee2:	ac e3       	ldi	r26, 0x3C	; 60
    5ee4:	b0 e0       	ldi	r27, 0x00	; 0
    5ee6:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
    5eea:	2f 89       	ldd	r18, Y+23	; 0x17
    5eec:	6b 01       	movw	r12, r22
    5eee:	7c 01       	movw	r14, r24
    5ef0:	c2 0e       	add	r12, r18
    5ef2:	d1 1c       	adc	r13, r1
    5ef4:	e1 1c       	adc	r14, r1
    5ef6:	f1 1c       	adc	r15, r1
    5ef8:	a7 01       	movw	r20, r14
    5efa:	96 01       	movw	r18, r12
    5efc:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
    5f00:	28 8d       	ldd	r18, Y+24	; 0x18
    5f02:	42 2e       	mov	r4, r18
    5f04:	51 2c       	mov	r5, r1
    5f06:	71 2c       	mov	r7, r1
    5f08:	61 2c       	mov	r6, r1
__base_ctor ():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:183

    @param t Time elapsed in seconds since 1970-01-01 00:00:00.
*/
/**************************************************************************/
DateTime::DateTime(uint32_t t) {
  t -= SECONDS_FROM_1970_TO_2000; // bring to 2000 timestamp from 1970
    5f0a:	20 e8       	ldi	r18, 0x80	; 128
    5f0c:	42 0e       	add	r4, r18
    5f0e:	20 e7       	ldi	r18, 0x70	; 112
    5f10:	52 1e       	adc	r5, r18
    5f12:	61 1c       	adc	r6, r1
    5f14:	71 1c       	adc	r7, r1
    5f16:	46 0e       	add	r4, r22
    5f18:	57 1e       	adc	r5, r23
    5f1a:	68 1e       	adc	r6, r24
    5f1c:	79 1e       	adc	r7, r25
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:185

  ss = t % 60;
    5f1e:	8c e3       	ldi	r24, 0x3C	; 60
    5f20:	c8 2e       	mov	r12, r24
    5f22:	d1 2c       	mov	r13, r1
    5f24:	e1 2c       	mov	r14, r1
    5f26:	f1 2c       	mov	r15, r1
    5f28:	c3 01       	movw	r24, r6
    5f2a:	b2 01       	movw	r22, r4
    5f2c:	a7 01       	movw	r20, r14
    5f2e:	96 01       	movw	r18, r12
    5f30:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5f34:	b6 2e       	mov	r11, r22
    5f36:	87 2e       	mov	r8, r23
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:187
  t /= 60;
  mm = t % 60;
    5f38:	ca 01       	movw	r24, r20
    5f3a:	b9 01       	movw	r22, r18
    5f3c:	a7 01       	movw	r20, r14
    5f3e:	96 01       	movw	r18, r12
    5f40:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5f44:	c6 2e       	mov	r12, r22
    5f46:	97 2e       	mov	r9, r23
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:188
  t /= 60;
    5f48:	c3 01       	movw	r24, r6
    5f4a:	b2 01       	movw	r22, r4
    5f4c:	20 e1       	ldi	r18, 0x10	; 16
    5f4e:	3e e0       	ldi	r19, 0x0E	; 14
    5f50:	40 e0       	ldi	r20, 0x00	; 0
    5f52:	50 e0       	ldi	r21, 0x00	; 0
    5f54:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:189
  hh = t % 24;
    5f58:	ca 01       	movw	r24, r20
    5f5a:	b9 01       	movw	r22, r18
    5f5c:	28 e1       	ldi	r18, 0x18	; 24
    5f5e:	30 e0       	ldi	r19, 0x00	; 0
    5f60:	40 e0       	ldi	r20, 0x00	; 0
    5f62:	50 e0       	ldi	r21, 0x00	; 0
    5f64:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5f68:	d6 2e       	mov	r13, r22
    5f6a:	a7 2e       	mov	r10, r23
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:190
  uint16_t days = t / 24;
    5f6c:	c3 01       	movw	r24, r6
    5f6e:	b2 01       	movw	r22, r4
    5f70:	20 e8       	ldi	r18, 0x80	; 128
    5f72:	31 e5       	ldi	r19, 0x51	; 81
    5f74:	41 e0       	ldi	r20, 0x01	; 1
    5f76:	50 e0       	ldi	r21, 0x00	; 0
    5f78:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    5f7c:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:196
  uint8_t leap;
  for (yOff = 0;; ++yOff) {
    leap = yOff % 4 == 0;
    if (days < 365U + leap)
      break;
    days -= 365 + leap;
    5f7e:	63 e9       	ldi	r22, 0x93	; 147
    5f80:	7e ef       	ldi	r23, 0xFE	; 254
    5f82:	a8 2f       	mov	r26, r24
    5f84:	a3 70       	andi	r26, 0x03	; 3
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:193
  t /= 60;
  hh = t % 24;
  uint16_t days = t / 24;
  uint8_t leap;
  for (yOff = 0;; ++yOff) {
    leap = yOff % 4 == 0;
    5f86:	41 e0       	ldi	r20, 0x01	; 1
    5f88:	50 e0       	ldi	r21, 0x00	; 0
    5f8a:	11 f0       	breq	.+4      	; 0x5f90 <SyncRTCbyGPS(bool)+0x280>
    5f8c:	50 e0       	ldi	r21, 0x00	; 0
    5f8e:	40 e0       	ldi	r20, 0x00	; 0
    5f90:	91 e0       	ldi	r25, 0x01	; 1
    5f92:	98 0f       	add	r25, r24
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:194
    if (days < 365U + leap)
    5f94:	fa 01       	movw	r30, r20
    5f96:	e3 59       	subi	r30, 0x93	; 147
    5f98:	fe 4f       	sbci	r31, 0xFE	; 254
    5f9a:	2e 17       	cp	r18, r30
    5f9c:	3f 07       	cpc	r19, r31
    5f9e:	b0 f4       	brcc	.+44     	; 0x5fcc <SyncRTCbyGPS(bool)+0x2bc>
    5fa0:	e2 ed       	ldi	r30, 0xD2	; 210
    5fa2:	f3 e0       	ldi	r31, 0x03	; 3
    5fa4:	91 e0       	ldi	r25, 0x01	; 1
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:198
      break;
    days -= 365 + leap;
  }
  for (m = 1; m < 12; ++m) {
    5fa6:	9c 30       	cpi	r25, 0x0C	; 12
    5fa8:	c1 f0       	breq	.+48     	; 0x5fda <SyncRTCbyGPS(bool)+0x2ca>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:199
    uint8_t daysPerMonth = pgm_read_byte(daysInMonth + m - 1);
    5faa:	44 91       	lpm	r20, Z
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:200
    if (leap && m == 2)
    5fac:	a1 11       	cpse	r26, r1
    5fae:	03 c0       	rjmp	.+6      	; 0x5fb6 <SyncRTCbyGPS(bool)+0x2a6>
    5fb0:	92 30       	cpi	r25, 0x02	; 2
    5fb2:	09 f4       	brne	.+2      	; 0x5fb6 <SyncRTCbyGPS(bool)+0x2a6>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:201
      ++daysPerMonth;
    5fb4:	4f 5f       	subi	r20, 0xFF	; 255
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:202
    if (days < daysPerMonth)
    5fb6:	50 e0       	ldi	r21, 0x00	; 0
    5fb8:	61 e0       	ldi	r22, 0x01	; 1
    5fba:	69 0f       	add	r22, r25
    5fbc:	31 96       	adiw	r30, 0x01	; 1
    5fbe:	24 17       	cp	r18, r20
    5fc0:	35 07       	cpc	r19, r21
    5fc2:	58 f0       	brcs	.+22     	; 0x5fda <SyncRTCbyGPS(bool)+0x2ca>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:204
      break;
    days -= daysPerMonth;
    5fc4:	24 1b       	sub	r18, r20
    5fc6:	35 0b       	sbc	r19, r21
    5fc8:	96 2f       	mov	r25, r22
    5fca:	ed cf       	rjmp	.-38     	; 0x5fa6 <SyncRTCbyGPS(bool)+0x296>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:196
  uint8_t leap;
  for (yOff = 0;; ++yOff) {
    leap = yOff % 4 == 0;
    if (days < 365U + leap)
      break;
    days -= 365 + leap;
    5fcc:	fb 01       	movw	r30, r22
    5fce:	e4 1b       	sub	r30, r20
    5fd0:	f5 0b       	sbc	r31, r21
    5fd2:	2e 0f       	add	r18, r30
    5fd4:	3f 1f       	adc	r19, r31
    5fd6:	89 2f       	mov	r24, r25
    5fd8:	d4 cf       	rjmp	.-88     	; 0x5f82 <SyncRTCbyGPS(bool)+0x272>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:206
      ++daysPerMonth;
    if (days < daysPerMonth)
      break;
    days -= daysPerMonth;
  }
  d = days + 1;
    5fda:	2f 5f       	subi	r18, 0xFF	; 255
SyncRTCbyGPS():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:58
			SerialDebug("GPS Sync fail:", "check valid");
			return "*Sync[f:2]";
		}
		
		DateTime GPS = DateTime(gps.date.year(), gps.date.month(), gps.date.day(), gps.time.hour(), gps.time.minute(), gps.time.second());
		GPS = GPS + TimeSpan(0, 8, 0, 0);
    5fdc:	8b 8b       	std	Y+19, r24	; 0x13
    5fde:	9c 8b       	std	Y+20, r25	; 0x14
    5fe0:	2d 8b       	std	Y+21, r18	; 0x15
    5fe2:	de 8a       	std	Y+22, r13	; 0x16
    5fe4:	cf 8a       	std	Y+23, r12	; 0x17
    5fe6:	b8 8e       	std	Y+24, r11	; 0x18
    5fe8:	ae 01       	movw	r20, r28
    5fea:	4f 5f       	subi	r20, 0xFF	; 255
    5fec:	5f 4f       	sbci	r21, 0xFF	; 255
    5fee:	7a 01       	movw	r14, r20
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:60
		//gps.date.year(), gps.date.month(), gps.date.day(), gps.time.hour(), gps.time.minute(), gps.time.second()
		if (!applysync) 
    5ff0:	58 a1       	ldd	r21, Y+32	; 0x20
    5ff2:	55 23       	and	r21, r21
    5ff4:	f9 f0       	breq	.+62     	; 0x6034 <SyncRTCbyGPS(bool)+0x324>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:68
			sprintf(sz, "%02d/%02d/%02d %02d:%02d:%02d", GPS.year()%100, GPS.month(), GPS.day(), GPS.hour(), GPS.minute(), GPS.second());
			return String(sz);
		}
		else 
		{
			RTC.adjust(GPS);
    5ff6:	ce 01       	movw	r24, r28
    5ff8:	43 96       	adiw	r24, 0x13	; 19
    5ffa:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <RTC_DS3231::adjust(DateTime const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:69
			SerialDebug("RTC Adjusted", "");
    5ffe:	63 ea       	ldi	r22, 0xA3	; 163
    6000:	73 e0       	ldi	r23, 0x03	; 3
    6002:	ce 01       	movw	r24, r28
    6004:	49 96       	adiw	r24, 0x19	; 25
    6006:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    600a:	6d e2       	ldi	r22, 0x2D	; 45
    600c:	74 e0       	ldi	r23, 0x04	; 4
    600e:	c7 01       	movw	r24, r14
    6010:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    6014:	be 01       	movw	r22, r28
    6016:	67 5e       	subi	r22, 0xE7	; 231
    6018:	7f 4f       	sbci	r23, 0xFF	; 255
    601a:	c7 01       	movw	r24, r14
    601c:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    6020:	c7 01       	movw	r24, r14
    6022:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    6026:	ce 01       	movw	r24, r28
    6028:	49 96       	adiw	r24, 0x19	; 25
    602a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:77
	else 
	{
		SerialDebug("GPS Sync fail:", "GPS valid check");
		return "*Sync[f:3]";
	}
	return "*OK";
    602e:	6a e3       	ldi	r22, 0x3A	; 58
    6030:	74 e0       	ldi	r23, 0x04	; 4
    6032:	e9 ce       	rjmp	.-558    	; 0x5e06 <SyncRTCbyGPS(bool)+0xf6>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:63
		GPS = GPS + TimeSpan(0, 8, 0, 0);
		//gps.date.year(), gps.date.month(), gps.date.day(), gps.time.hour(), gps.time.minute(), gps.time.second()
		if (!applysync) 
		{
			char sz[18];
			sprintf(sz, "%02d/%02d/%02d %02d:%02d:%02d", GPS.year()%100, GPS.month(), GPS.day(), GPS.hour(), GPS.minute(), GPS.second());
    6034:	8f 92       	push	r8
    6036:	bf 92       	push	r11
    6038:	9f 92       	push	r9
    603a:	cf 92       	push	r12
    603c:	af 92       	push	r10
    603e:	df 92       	push	r13
    6040:	1f 92       	push	r1
    6042:	2f 93       	push	r18
    6044:	1f 92       	push	r1
    6046:	9f 93       	push	r25
_ZNK8DateTime4yearEv():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.h:97

  /*!
      @brief  Return the year.
      @return Year (range: 2000--2099).
  */
  uint16_t year() const { return 2000U + yOff; }
    6048:	90 e0       	ldi	r25, 0x00	; 0
    604a:	80 53       	subi	r24, 0x30	; 48
    604c:	98 4f       	sbci	r25, 0xF8	; 248
SyncRTCbyGPS():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:63
    604e:	64 e6       	ldi	r22, 0x64	; 100
    6050:	70 e0       	ldi	r23, 0x00	; 0
    6052:	0e 94 03 6c 	call	0xd806	; 0xd806 <__udivmodhi4>
    6056:	9f 93       	push	r25
    6058:	8f 93       	push	r24
    605a:	8f e0       	ldi	r24, 0x0F	; 15
    605c:	94 e0       	ldi	r25, 0x04	; 4
    605e:	9f 93       	push	r25
    6060:	8f 93       	push	r24
    6062:	ff 92       	push	r15
    6064:	ef 92       	push	r14
    6066:	0e 94 de 6e 	call	0xddbc	; 0xddbc <sprintf>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:64
			return String(sz);
    606a:	b7 01       	movw	r22, r14
    606c:	c8 01       	movw	r24, r16
    606e:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    6072:	0f b6       	in	r0, 0x3f	; 63
    6074:	f8 94       	cli
    6076:	de bf       	out	0x3e, r29	; 62
    6078:	0f be       	out	0x3f, r0	; 63
    607a:	cd bf       	out	0x3d, r28	; 61
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:78
	{
		SerialDebug("GPS Sync fail:", "GPS valid check");
		return "*Sync[f:3]";
	}
	return "*OK";
    607c:	c8 01       	movw	r24, r16
    607e:	a0 96       	adiw	r28, 0x20	; 32
    6080:	0f b6       	in	r0, 0x3f	; 63
    6082:	f8 94       	cli
    6084:	de bf       	out	0x3e, r29	; 62
    6086:	0f be       	out	0x3f, r0	; 63
    6088:	cd bf       	out	0x3d, r28	; 61
    608a:	df 91       	pop	r29
    608c:	cf 91       	pop	r28
    608e:	1f 91       	pop	r17
    6090:	0f 91       	pop	r16
    6092:	ff 90       	pop	r15
    6094:	ef 90       	pop	r14
    6096:	df 90       	pop	r13
    6098:	cf 90       	pop	r12
    609a:	bf 90       	pop	r11
    609c:	af 90       	pop	r10
    609e:	9f 90       	pop	r9
    60a0:	8f 90       	pop	r8
    60a2:	7f 90       	pop	r7
    60a4:	6f 90       	pop	r6
    60a6:	5f 90       	pop	r5
    60a8:	4f 90       	pop	r4
    60aa:	3f 90       	pop	r3
    60ac:	2f 90       	pop	r2
    60ae:	08 95       	ret

000060b0 <update_time_info()>:
update_time_info():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:30
	}
	//!RTC_alive ? RTCER.resume() : RTCER.pause();
}


void update_time_info() {
    60b0:	df 92       	push	r13
    60b2:	ef 92       	push	r14
    60b4:	ff 92       	push	r15
    60b6:	0f 93       	push	r16
    60b8:	1f 93       	push	r17
    60ba:	cf 93       	push	r28
    60bc:	df 93       	push	r29
    60be:	cd b7       	in	r28, 0x3d	; 61
    60c0:	de b7       	in	r29, 0x3e	; 62
    60c2:	68 97       	sbiw	r28, 0x18	; 24
    60c4:	0f b6       	in	r0, 0x3f	; 63
    60c6:	f8 94       	cli
    60c8:	de bf       	out	0x3e, r29	; 62
    60ca:	0f be       	out	0x3f, r0	; 63
    60cc:	cd bf       	out	0x3d, r28	; 61
beginTransmission():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:201
    60ce:	88 e6       	ldi	r24, 0x68	; 104
    60d0:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
now():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1589
    @return DateTime object with the current date/time
*/
/**************************************************************************/
DateTime RTC_DS3231::now() {
  Wire.beginTransmission(DS3231_ADDRESS);
  Wire._I2C_WRITE((byte)0);
    60d4:	60 e0       	ldi	r22, 0x00	; 0
    60d6:	8c e3       	ldi	r24, 0x3C	; 60
    60d8:	9f e0       	ldi	r25, 0x0F	; 15
    60da:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1590
  Wire.endTransmission();
    60de:	8c e3       	ldi	r24, 0x3C	; 60
    60e0:	9f e0       	ldi	r25, 0x0F	; 15
    60e2:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
requestFrom():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:161
  // clamp to buffer length
  if(quantity > BUFFER_LENGTH){
    quantity = BUFFER_LENGTH;
  }
  // perform blocking read into buffer
  uint8_t read = twi_readFrom(address, rxBuffer, quantity, sendStop);
    60e6:	67 e0       	ldi	r22, 0x07	; 7
    60e8:	88 e6       	ldi	r24, 0x68	; 104
    60ea:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <twi_readFrom.constprop.140>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:163
  // set rx buffer iterator vars
  rxBufferIndex = 0;
    60ee:	10 92 76 0c 	sts	0x0C76, r1	; 0x800c76 <TwoWire::rxBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:164
  rxBufferLength = read;
    60f2:	80 93 75 0c 	sts	0x0C75, r24	; 0x800c75 <TwoWire::rxBufferLength>
now():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1593

  Wire.requestFrom(DS3231_ADDRESS, 7);
  uint8_t ss = bcd2bin(Wire._I2C_READ() & 0x7F);
    60f6:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
    60fa:	8f 77       	andi	r24, 0x7F	; 127
bcd2bin():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:795
   values as BCD.
    @param val BCD value
    @return Binary value
*/
/**************************************************************************/
static uint8_t bcd2bin(uint8_t val) { return val - 6 * (val >> 4); }
    60fc:	28 2f       	mov	r18, r24
    60fe:	30 e0       	ldi	r19, 0x00	; 0
    6100:	94 e0       	ldi	r25, 0x04	; 4
    6102:	35 95       	asr	r19
    6104:	27 95       	ror	r18
    6106:	9a 95       	dec	r25
    6108:	e1 f7       	brne	.-8      	; 0x6102 <update_time_info()+0x52>
    610a:	92 2f       	mov	r25, r18
    610c:	99 0f       	add	r25, r25
    610e:	99 0f       	add	r25, r25
    6110:	e2 2e       	mov	r14, r18
    6112:	e9 1a       	sub	r14, r25
    6114:	ee 0c       	add	r14, r14
    6116:	e8 0e       	add	r14, r24
now():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1594
  Wire._I2C_WRITE((byte)0);
  Wire.endTransmission();

  Wire.requestFrom(DS3231_ADDRESS, 7);
  uint8_t ss = bcd2bin(Wire._I2C_READ() & 0x7F);
  uint8_t mm = bcd2bin(Wire._I2C_READ());
    6118:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
bcd2bin():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:795
   values as BCD.
    @param val BCD value
    @return Binary value
*/
/**************************************************************************/
static uint8_t bcd2bin(uint8_t val) { return val - 6 * (val >> 4); }
    611c:	9c 01       	movw	r18, r24
    611e:	44 e0       	ldi	r20, 0x04	; 4
    6120:	35 95       	asr	r19
    6122:	27 95       	ror	r18
    6124:	4a 95       	dec	r20
    6126:	e1 f7       	brne	.-8      	; 0x6120 <update_time_info()+0x70>
    6128:	2f 70       	andi	r18, 0x0F	; 15
    612a:	33 27       	eor	r19, r19
    612c:	92 2f       	mov	r25, r18
    612e:	99 0f       	add	r25, r25
    6130:	99 0f       	add	r25, r25
    6132:	f2 2e       	mov	r15, r18
    6134:	f9 1a       	sub	r15, r25
    6136:	ff 0c       	add	r15, r15
    6138:	f8 0e       	add	r15, r24
now():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1595
  Wire.endTransmission();

  Wire.requestFrom(DS3231_ADDRESS, 7);
  uint8_t ss = bcd2bin(Wire._I2C_READ() & 0x7F);
  uint8_t mm = bcd2bin(Wire._I2C_READ());
  uint8_t hh = bcd2bin(Wire._I2C_READ());
    613a:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
bcd2bin():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:795
   values as BCD.
    @param val BCD value
    @return Binary value
*/
/**************************************************************************/
static uint8_t bcd2bin(uint8_t val) { return val - 6 * (val >> 4); }
    613e:	9c 01       	movw	r18, r24
    6140:	54 e0       	ldi	r21, 0x04	; 4
    6142:	35 95       	asr	r19
    6144:	27 95       	ror	r18
    6146:	5a 95       	dec	r21
    6148:	e1 f7       	brne	.-8      	; 0x6142 <update_time_info()+0x92>
    614a:	2f 70       	andi	r18, 0x0F	; 15
    614c:	33 27       	eor	r19, r19
    614e:	92 2f       	mov	r25, r18
    6150:	99 0f       	add	r25, r25
    6152:	99 0f       	add	r25, r25
    6154:	02 2f       	mov	r16, r18
    6156:	09 1b       	sub	r16, r25
    6158:	00 0f       	add	r16, r16
    615a:	08 0f       	add	r16, r24
now():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1596

  Wire.requestFrom(DS3231_ADDRESS, 7);
  uint8_t ss = bcd2bin(Wire._I2C_READ() & 0x7F);
  uint8_t mm = bcd2bin(Wire._I2C_READ());
  uint8_t hh = bcd2bin(Wire._I2C_READ());
  Wire._I2C_READ();
    615c:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1597
  uint8_t d = bcd2bin(Wire._I2C_READ());
    6160:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
bcd2bin():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:795
   values as BCD.
    @param val BCD value
    @return Binary value
*/
/**************************************************************************/
static uint8_t bcd2bin(uint8_t val) { return val - 6 * (val >> 4); }
    6164:	9c 01       	movw	r18, r24
    6166:	64 e0       	ldi	r22, 0x04	; 4
    6168:	35 95       	asr	r19
    616a:	27 95       	ror	r18
    616c:	6a 95       	dec	r22
    616e:	e1 f7       	brne	.-8      	; 0x6168 <update_time_info()+0xb8>
    6170:	2f 70       	andi	r18, 0x0F	; 15
    6172:	33 27       	eor	r19, r19
    6174:	92 2f       	mov	r25, r18
    6176:	99 0f       	add	r25, r25
    6178:	99 0f       	add	r25, r25
    617a:	12 2f       	mov	r17, r18
    617c:	19 1b       	sub	r17, r25
    617e:	11 0f       	add	r17, r17
    6180:	18 0f       	add	r17, r24
now():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1598
  uint8_t ss = bcd2bin(Wire._I2C_READ() & 0x7F);
  uint8_t mm = bcd2bin(Wire._I2C_READ());
  uint8_t hh = bcd2bin(Wire._I2C_READ());
  Wire._I2C_READ();
  uint8_t d = bcd2bin(Wire._I2C_READ());
  uint8_t m = bcd2bin(Wire._I2C_READ());
    6182:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
bcd2bin():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:795
   values as BCD.
    @param val BCD value
    @return Binary value
*/
/**************************************************************************/
static uint8_t bcd2bin(uint8_t val) { return val - 6 * (val >> 4); }
    6186:	9c 01       	movw	r18, r24
    6188:	74 e0       	ldi	r23, 0x04	; 4
    618a:	35 95       	asr	r19
    618c:	27 95       	ror	r18
    618e:	7a 95       	dec	r23
    6190:	e1 f7       	brne	.-8      	; 0x618a <update_time_info()+0xda>
    6192:	2f 70       	andi	r18, 0x0F	; 15
    6194:	33 27       	eor	r19, r19
    6196:	92 2f       	mov	r25, r18
    6198:	99 0f       	add	r25, r25
    619a:	99 0f       	add	r25, r25
    619c:	d2 2e       	mov	r13, r18
    619e:	d9 1a       	sub	r13, r25
    61a0:	dd 0c       	add	r13, r13
    61a2:	d8 0e       	add	r13, r24
now():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1599
  uint8_t mm = bcd2bin(Wire._I2C_READ());
  uint8_t hh = bcd2bin(Wire._I2C_READ());
  Wire._I2C_READ();
  uint8_t d = bcd2bin(Wire._I2C_READ());
  uint8_t m = bcd2bin(Wire._I2C_READ());
  uint16_t y = bcd2bin(Wire._I2C_READ()) + 2000U;
    61a4:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
bcd2bin():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:795
   values as BCD.
    @param val BCD value
    @return Binary value
*/
/**************************************************************************/
static uint8_t bcd2bin(uint8_t val) { return val - 6 * (val >> 4); }
    61a8:	9c 01       	movw	r18, r24
    61aa:	e4 e0       	ldi	r30, 0x04	; 4
    61ac:	35 95       	asr	r19
    61ae:	27 95       	ror	r18
    61b0:	ea 95       	dec	r30
    61b2:	e1 f7       	brne	.-8      	; 0x61ac <update_time_info()+0xfc>
    61b4:	2f 70       	andi	r18, 0x0F	; 15
    61b6:	33 27       	eor	r19, r19
    61b8:	92 2f       	mov	r25, r18
    61ba:	99 0f       	add	r25, r25
    61bc:	99 0f       	add	r25, r25
    61be:	29 1b       	sub	r18, r25
    61c0:	22 0f       	add	r18, r18
    61c2:	28 0f       	add	r18, r24
now():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1599
  uint8_t mm = bcd2bin(Wire._I2C_READ());
  uint8_t hh = bcd2bin(Wire._I2C_READ());
  Wire._I2C_READ();
  uint8_t d = bcd2bin(Wire._I2C_READ());
  uint8_t m = bcd2bin(Wire._I2C_READ());
  uint16_t y = bcd2bin(Wire._I2C_READ()) + 2000U;
    61c4:	82 2f       	mov	r24, r18
    61c6:	90 e0       	ldi	r25, 0x00	; 0
_ZNK8DateTime4yearEv():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.h:97
    61c8:	80 53       	subi	r24, 0x30	; 48
    61ca:	98 4f       	sbci	r25, 0xF8	; 248
update_time_info():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:32
  DateTime now = RTC.now();
  year = now.year();  month = now.month();   day = now.day();
    61cc:	90 93 24 0c 	sts	0x0C24, r25	; 0x800c24 <year+0x1>
    61d0:	80 93 23 0c 	sts	0x0C23, r24	; 0x800c23 <year>
    61d4:	2d 2d       	mov	r18, r13
    61d6:	30 e0       	ldi	r19, 0x00	; 0
    61d8:	30 93 26 0c 	sts	0x0C26, r19	; 0x800c26 <month+0x1>
    61dc:	20 93 25 0c 	sts	0x0C25, r18	; 0x800c25 <month>
    61e0:	21 2f       	mov	r18, r17
    61e2:	30 e0       	ldi	r19, 0x00	; 0
    61e4:	30 93 28 0c 	sts	0x0C28, r19	; 0x800c28 <day+0x1>
    61e8:	20 93 27 0c 	sts	0x0C27, r18	; 0x800c27 <day>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:33
  hour = now.hour();  minute = now.minute(); second = now.second();
    61ec:	20 2f       	mov	r18, r16
    61ee:	30 e0       	ldi	r19, 0x00	; 0
    61f0:	30 93 35 09 	sts	0x0935, r19	; 0x800935 <hour+0x1>
    61f4:	20 93 34 09 	sts	0x0934, r18	; 0x800934 <hour>
    61f8:	2f 2d       	mov	r18, r15
    61fa:	30 e0       	ldi	r19, 0x00	; 0
    61fc:	30 93 37 09 	sts	0x0937, r19	; 0x800937 <minute+0x1>
    6200:	20 93 36 09 	sts	0x0936, r18	; 0x800936 <minute>
    6204:	2e 2d       	mov	r18, r14
    6206:	30 e0       	ldi	r19, 0x00	; 0
    6208:	30 93 39 09 	sts	0x0939, r19	; 0x800939 <second+0x1>
    620c:	20 93 38 09 	sts	0x0938, r18	; 0x800938 <second>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:36
  char time_format[18];
  //int temp_year = year % 100;
  sprintf(time_format, "%02d/%02d/%02d %02d:%02d:%02d", year % 100, month, day, hour, minute, second);
    6210:	1f 92       	push	r1
    6212:	ef 92       	push	r14
    6214:	1f 92       	push	r1
    6216:	ff 92       	push	r15
    6218:	1f 92       	push	r1
    621a:	0f 93       	push	r16
    621c:	1f 92       	push	r1
    621e:	1f 93       	push	r17
    6220:	1f 92       	push	r1
    6222:	df 92       	push	r13
    6224:	64 e6       	ldi	r22, 0x64	; 100
    6226:	70 e0       	ldi	r23, 0x00	; 0
    6228:	0e 94 17 6c 	call	0xd82e	; 0xd82e <__divmodhi4>
    622c:	9f 93       	push	r25
    622e:	8f 93       	push	r24
    6230:	8f e0       	ldi	r24, 0x0F	; 15
    6232:	94 e0       	ldi	r25, 0x04	; 4
    6234:	9f 93       	push	r25
    6236:	8f 93       	push	r24
    6238:	8e 01       	movw	r16, r28
    623a:	0f 5f       	subi	r16, 0xFF	; 255
    623c:	1f 4f       	sbci	r17, 0xFF	; 255
    623e:	1f 93       	push	r17
    6240:	0f 93       	push	r16
    6242:	0e 94 de 6e 	call	0xddbc	; 0xddbc <sprintf>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:38
  //sprintf(time_format, "%02d/%02d/%02d %02d:%02d:%02d", now.year()%100, now.month(), now.day(), now.hour(), now.minute(), now.second());
  lcd_qSprint(time_format, 0, 0);
    6246:	b8 01       	movw	r22, r16
    6248:	ce 01       	movw	r24, r28
    624a:	43 96       	adiw	r24, 0x13	; 19
    624c:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
lcd_qSprint():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:2
void lcd_qSprint(String s, int column, int row) {
	lcd.setCursor(column, row);
    6250:	60 e0       	ldi	r22, 0x00	; 0
    6252:	80 e0       	ldi	r24, 0x00	; 0
    6254:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:3
	lcd.print(s);
    6258:	be 01       	movw	r22, r28
    625a:	6d 5e       	subi	r22, 0xED	; 237
    625c:	7f 4f       	sbci	r23, 0xFF	; 255
    625e:	8b eb       	ldi	r24, 0xBB	; 187
    6260:	90 e1       	ldi	r25, 0x10	; 16
    6262:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
update_time_info():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:38
    6266:	ce 01       	movw	r24, r28
    6268:	43 96       	adiw	r24, 0x13	; 19
    626a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    626e:	0f b6       	in	r0, 0x3f	; 63
    6270:	f8 94       	cli
    6272:	de bf       	out	0x3e, r29	; 62
    6274:	0f be       	out	0x3f, r0	; 63
    6276:	cd bf       	out	0x3d, r28	; 61
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:39
}
    6278:	68 96       	adiw	r28, 0x18	; 24
    627a:	0f b6       	in	r0, 0x3f	; 63
    627c:	f8 94       	cli
    627e:	de bf       	out	0x3e, r29	; 62
    6280:	0f be       	out	0x3f, r0	; 63
    6282:	cd bf       	out	0x3d, r28	; 61
    6284:	df 91       	pop	r29
    6286:	cf 91       	pop	r28
    6288:	1f 91       	pop	r17
    628a:	0f 91       	pop	r16
    628c:	ff 90       	pop	r15
    628e:	ef 90       	pop	r14
    6290:	df 90       	pop	r13
    6292:	08 95       	ret

00006294 <LCDUpdateRow1()>:
LCDUpdateRow1():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:73
		lcd.setCursor(14, 3);
		lcd.write(5);
		lcd.print(floattostring(K_temperature, 2, 2));
}

void LCDUpdateRow1() {
    6294:	0f 93       	push	r16
    6296:	1f 93       	push	r17
    6298:	cf 93       	push	r28
    629a:	df 93       	push	r29
    629c:	00 d0       	rcall	.+0      	; 0x629e <LCDUpdateRow1()+0xa>
    629e:	00 d0       	rcall	.+0      	; 0x62a0 <LCDUpdateRow1()+0xc>
    62a0:	1f 92       	push	r1
    62a2:	1f 92       	push	r1
    62a4:	cd b7       	in	r28, 0x3d	; 61
    62a6:	de b7       	in	r29, 0x3e	; 62
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:74
	if (!resetRow1.isCounterCompleted())
    62a8:	80 91 4a 12 	lds	r24, 0x124A	; 0x80124a <resetRow1+0x18>
    62ac:	81 11       	cpse	r24, r1
    62ae:	04 c0       	rjmp	.+8      	; 0x62b8 <LCDUpdateRow1()+0x24>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:76
	{
		RemoveBTNmessage();
    62b0:	0e 94 7f 28 	call	0x50fe	; 0x50fe <RemoveBTNmessage()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:77
		resetRow1.stop();
    62b4:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <Countimer::stop() [clone .constprop.145]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:79
	}
	lcd.setCursor(0, 1);
    62b8:	61 e0       	ldi	r22, 0x01	; 1
    62ba:	80 e0       	ldi	r24, 0x00	; 0
    62bc:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
    62c0:	0e ed       	ldi	r16, 0xDE	; 222
    62c2:	19 e0       	ldi	r17, 0x09	; 9
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:80
	for (int i = 0; i < 10; i++)	lcd.print(keypaddata[i] == '\0' ? " " : String(keypaddata[i]));
    62c4:	f8 01       	movw	r30, r16
    62c6:	81 91       	ld	r24, Z+
    62c8:	8f 01       	movw	r16, r30
    62ca:	81 11       	cpse	r24, r1
    62cc:	20 c0       	rjmp	.+64     	; 0x630e <LCDUpdateRow1()+0x7a>
    62ce:	6c e8       	ldi	r22, 0x8C	; 140
    62d0:	77 e0       	ldi	r23, 0x07	; 7
    62d2:	ce 01       	movw	r24, r28
    62d4:	01 96       	adiw	r24, 0x01	; 1
    62d6:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    62da:	be 01       	movw	r22, r28
    62dc:	6f 5f       	subi	r22, 0xFF	; 255
    62de:	7f 4f       	sbci	r23, 0xFF	; 255
    62e0:	8b eb       	ldi	r24, 0xBB	; 187
    62e2:	90 e1       	ldi	r25, 0x10	; 16
    62e4:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    62e8:	ce 01       	movw	r24, r28
    62ea:	01 96       	adiw	r24, 0x01	; 1
    62ec:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    62f0:	f9 e0       	ldi	r31, 0x09	; 9
    62f2:	08 3e       	cpi	r16, 0xE8	; 232
    62f4:	1f 07       	cpc	r17, r31
    62f6:	31 f7       	brne	.-52     	; 0x62c4 <LCDUpdateRow1()+0x30>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:82
	//lcd.print(String(keypaddata));
}
    62f8:	28 96       	adiw	r28, 0x08	; 8
    62fa:	0f b6       	in	r0, 0x3f	; 63
    62fc:	f8 94       	cli
    62fe:	de bf       	out	0x3e, r29	; 62
    6300:	0f be       	out	0x3f, r0	; 63
    6302:	cd bf       	out	0x3d, r28	; 61
    6304:	df 91       	pop	r29
    6306:	cf 91       	pop	r28
    6308:	1f 91       	pop	r17
    630a:	0f 91       	pop	r16
    630c:	08 95       	ret
_ZN6String4initEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:133
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    630e:	1a 82       	std	Y+2, r1	; 0x02
    6310:	19 82       	std	Y+1, r1	; 0x01
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:134
	capacity = 0;
    6312:	1c 82       	std	Y+4, r1	; 0x04
    6314:	1b 82       	std	Y+3, r1	; 0x03
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:135
	len = 0;
    6316:	1e 82       	std	Y+6, r1	; 0x06
    6318:	1d 82       	std	Y+5, r1	; 0x05
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:63

String::String(char c)
{
	init();
	char buf[2];
	buf[0] = c;
    631a:	8f 83       	std	Y+7, r24	; 0x07
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:64
	buf[1] = 0;
    631c:	18 86       	std	Y+8, r1	; 0x08
operator=():
    631e:	be 01       	movw	r22, r28
    6320:	69 5f       	subi	r22, 0xF9	; 249
    6322:	7f 4f       	sbci	r23, 0xFF	; 255
    6324:	ce 01       	movw	r24, r28
    6326:	01 96       	adiw	r24, 0x01	; 1
    6328:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
    632c:	d6 cf       	rjmp	.-84     	; 0x62da <LCDUpdateRow1()+0x46>

0000632e <waitUntilpHReturn(unsigned long)>:
waitUntilpHReturn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:130
	for (int i = type.length(); i < 5; i++)	lcd.print(" ");

	Atlas_pH.print("Sleep\r");
}

String waitUntilpHReturn(unsigned long ttl) {
    632e:	8f 92       	push	r8
    6330:	9f 92       	push	r9
    6332:	af 92       	push	r10
    6334:	bf 92       	push	r11
    6336:	cf 92       	push	r12
    6338:	df 92       	push	r13
    633a:	ef 92       	push	r14
    633c:	ff 92       	push	r15
    633e:	0f 93       	push	r16
    6340:	1f 93       	push	r17
    6342:	cf 93       	push	r28
    6344:	df 93       	push	r29
    6346:	00 d0       	rcall	.+0      	; 0x6348 <waitUntilpHReturn(unsigned long)+0x1a>
    6348:	00 d0       	rcall	.+0      	; 0x634a <waitUntilpHReturn(unsigned long)+0x1c>
    634a:	cd b7       	in	r28, 0x3d	; 61
    634c:	de b7       	in	r29, 0x3e	; 62
    634e:	8c 01       	movw	r16, r24
    6350:	4a 01       	movw	r8, r20
    6352:	5b 01       	movw	r10, r22
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:131
	String s = "";
    6354:	63 ea       	ldi	r22, 0xA3	; 163
    6356:	73 e0       	ldi	r23, 0x03	; 3
    6358:	ce 01       	movw	r24, r28
    635a:	01 96       	adiw	r24, 0x01	; 1
    635c:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:132
	s.reserve(20);
    6360:	64 e1       	ldi	r22, 0x14	; 20
    6362:	70 e0       	ldi	r23, 0x00	; 0
    6364:	ce 01       	movw	r24, r28
    6366:	01 96       	adiw	r24, 0x01	; 1
    6368:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:133
	for (unsigned long time = millis(); millis() - time < ttl;) {
    636c:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    6370:	6b 01       	movw	r12, r22
    6372:	7c 01       	movw	r14, r24
    6374:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    6378:	6c 19       	sub	r22, r12
    637a:	7d 09       	sbc	r23, r13
    637c:	8e 09       	sbc	r24, r14
    637e:	9f 09       	sbc	r25, r15
    6380:	68 15       	cp	r22, r8
    6382:	79 05       	cpc	r23, r9
    6384:	8a 05       	cpc	r24, r10
    6386:	9b 05       	cpc	r25, r11
    6388:	b8 f5       	brcc	.+110    	; 0x63f8 <waitUntilpHReturn(unsigned long)+0xca>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:134
		if (Atlas_pH.available()) {
    638a:	8b e7       	ldi	r24, 0x7B	; 123
    638c:	9c e0       	ldi	r25, 0x0C	; 12
    638e:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <HardwareSerial::available()>
    6392:	89 2b       	or	r24, r25
    6394:	79 f3       	breq	.-34     	; 0x6374 <waitUntilpHReturn(unsigned long)+0x46>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:135
			char inchar = (char)Atlas_pH.read();
    6396:	8b e7       	ldi	r24, 0x7B	; 123
    6398:	9c e0       	ldi	r25, 0x0C	; 12
    639a:	0e 94 ca 06 	call	0xd94	; 0xd94 <HardwareSerial::read()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:136
			if (inchar == '\r') return s;
    639e:	8d 30       	cpi	r24, 0x0D	; 13
    63a0:	29 f5       	brne	.+74     	; 0x63ec <waitUntilpHReturn(unsigned long)+0xbe>
_ZN6String4initEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:133
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    63a2:	f8 01       	movw	r30, r16
    63a4:	11 82       	std	Z+1, r1	; 0x01
    63a6:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:134
	capacity = 0;
    63a8:	13 82       	std	Z+3, r1	; 0x03
    63aa:	12 82       	std	Z+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:135
	len = 0;
    63ac:	15 82       	std	Z+5, r1	; 0x05
    63ae:	14 82       	std	Z+4, r1	; 0x04
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:50

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String::String(String &&rval)
{
	init();
	move(rval);
    63b0:	be 01       	movw	r22, r28
    63b2:	6f 5f       	subi	r22, 0xFF	; 255
    63b4:	7f 4f       	sbci	r23, 0xFF	; 255
    63b6:	c8 01       	movw	r24, r16
    63b8:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
waitUntilpHReturn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:131

	Atlas_pH.print("Sleep\r");
}

String waitUntilpHReturn(unsigned long ttl) {
	String s = "";
    63bc:	ce 01       	movw	r24, r28
    63be:	01 96       	adiw	r24, 0x01	; 1
    63c0:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:141
			if (inchar == '\r') return s;
			else				s += inchar;
		}
	}
	return "ttl";
    63c4:	c8 01       	movw	r24, r16
    63c6:	26 96       	adiw	r28, 0x06	; 6
    63c8:	0f b6       	in	r0, 0x3f	; 63
    63ca:	f8 94       	cli
    63cc:	de bf       	out	0x3e, r29	; 62
    63ce:	0f be       	out	0x3f, r0	; 63
    63d0:	cd bf       	out	0x3d, r28	; 61
    63d2:	df 91       	pop	r29
    63d4:	cf 91       	pop	r28
    63d6:	1f 91       	pop	r17
    63d8:	0f 91       	pop	r16
    63da:	ff 90       	pop	r15
    63dc:	ef 90       	pop	r14
    63de:	df 90       	pop	r13
    63e0:	cf 90       	pop	r12
    63e2:	bf 90       	pop	r11
    63e4:	af 90       	pop	r10
    63e6:	9f 90       	pop	r9
    63e8:	8f 90       	pop	r8
    63ea:	08 95       	ret
_ZN6StringpLEc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:115
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
	String & operator += (char c)			{concat(c); return (*this);}
    63ec:	68 2f       	mov	r22, r24
    63ee:	ce 01       	movw	r24, r28
    63f0:	01 96       	adiw	r24, 0x01	; 1
    63f2:	0e 94 ba 2a 	call	0x5574	; 0x5574 <String::concat(char)>
    63f6:	be cf       	rjmp	.-132    	; 0x6374 <waitUntilpHReturn(unsigned long)+0x46>
waitUntilpHReturn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:140
			char inchar = (char)Atlas_pH.read();
			if (inchar == '\r') return s;
			else				s += inchar;
		}
	}
	return "ttl";
    63f8:	65 ea       	ldi	r22, 0xA5	; 165
    63fa:	73 e0       	ldi	r23, 0x03	; 3
    63fc:	c8 01       	movw	r24, r16
    63fe:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    6402:	dc cf       	rjmp	.-72     	; 0x63bc <waitUntilpHReturn(unsigned long)+0x8e>

00006404 <pHCalibration(String, float)>:
pHCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:92
	Atlas_EC.print("Sleep\r");
	Atlas_pH.print("Sleep\r");
}
*/

void pHCalibration(String type, float target) {
    6404:	cf 92       	push	r12
    6406:	df 92       	push	r13
    6408:	ef 92       	push	r14
    640a:	ff 92       	push	r15
    640c:	0f 93       	push	r16
    640e:	1f 93       	push	r17
    6410:	cf 93       	push	r28
    6412:	df 93       	push	r29
    6414:	cd b7       	in	r28, 0x3d	; 61
    6416:	de b7       	in	r29, 0x3e	; 62
    6418:	6e 97       	sbiw	r28, 0x1e	; 30
    641a:	0f b6       	in	r0, 0x3f	; 63
    641c:	f8 94       	cli
    641e:	de bf       	out	0x3e, r29	; 62
    6420:	0f be       	out	0x3f, r0	; 63
    6422:	cd bf       	out	0x3d, r28	; 61
    6424:	8c 01       	movw	r16, r24
    6426:	6a 01       	movw	r12, r20
    6428:	7b 01       	movw	r14, r22
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:93
	String str = "";
    642a:	63 ea       	ldi	r22, 0xA3	; 163
    642c:	73 e0       	ldi	r23, 0x03	; 3
    642e:	ce 01       	movw	r24, r28
    6430:	0d 96       	adiw	r24, 0x0d	; 13
    6432:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:94
	str.reserve(10);
    6436:	6a e0       	ldi	r22, 0x0A	; 10
    6438:	70 e0       	ldi	r23, 0x00	; 0
    643a:	ce 01       	movw	r24, r28
    643c:	0d 96       	adiw	r24, 0x0d	; 13
    643e:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:95
	flush_pH_serial();
    6442:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <flush_pH_serial()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:96
	update_K_temp();
    6446:	0e 94 71 2d 	call	0x5ae2	; 0x5ae2 <update_K_temp()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:98

	Atlas_pH.print('\r');
    644a:	6d e0       	ldi	r22, 0x0D	; 13
    644c:	8b e7       	ldi	r24, 0x7B	; 123
    644e:	9c e0       	ldi	r25, 0x0C	; 12
    6450:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:99
	str = waitUntilpHReturn(150);
    6454:	46 e9       	ldi	r20, 0x96	; 150
    6456:	50 e0       	ldi	r21, 0x00	; 0
    6458:	60 e0       	ldi	r22, 0x00	; 0
    645a:	70 e0       	ldi	r23, 0x00	; 0
    645c:	ce 01       	movw	r24, r28
    645e:	01 96       	adiw	r24, 0x01	; 1
    6460:	0e 94 97 31 	call	0x632e	; 0x632e <waitUntilpHReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String & String::operator = (String &&rval)
{
	if (this != &rval) move(rval);
    6464:	be 01       	movw	r22, r28
    6466:	6f 5f       	subi	r22, 0xFF	; 255
    6468:	7f 4f       	sbci	r23, 0xFF	; 255
    646a:	ce 01       	movw	r24, r28
    646c:	0d 96       	adiw	r24, 0x0d	; 13
    646e:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
pHCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:99
    6472:	ce 01       	movw	r24, r28
    6474:	01 96       	adiw	r24, 0x01	; 1
    6476:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:100
	if (DEBUG || debugMode) {
    647a:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <debugMode>
    647e:	88 23       	and	r24, r24
    6480:	69 f0       	breq	.+26     	; 0x649c <pHCalibration(String, float)+0x98>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:101
		Serial.print("wake pH:");
    6482:	6e e3       	ldi	r22, 0x3E	; 62
    6484:	74 e0       	ldi	r23, 0x04	; 4
    6486:	82 e5       	ldi	r24, 0x52	; 82
    6488:	9e e0       	ldi	r25, 0x0E	; 14
    648a:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:102
		Serial.println(str);
    648e:	be 01       	movw	r22, r28
    6490:	63 5f       	subi	r22, 0xF3	; 243
    6492:	7f 4f       	sbci	r23, 0xFF	; 255
    6494:	82 e5       	ldi	r24, 0x52	; 82
    6496:	9e e0       	ldi	r25, 0x0E	; 14
    6498:	0e 94 4e 28 	call	0x509c	; 0x509c <Print::println(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:105
	}

	String s = "T,";	s += K_temperature;		s += "\r";
    649c:	67 e4       	ldi	r22, 0x47	; 71
    649e:	74 e0       	ldi	r23, 0x04	; 4
    64a0:	ce 01       	movw	r24, r28
    64a2:	43 96       	adiw	r24, 0x13	; 19
    64a4:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
_ZN6StringpLEf():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:121
	String & operator += (unsigned char num)		{concat(num); return (*this);}
	String & operator += (int num)			{concat(num); return (*this);}
	String & operator += (unsigned int num)		{concat(num); return (*this);}
	String & operator += (long num)			{concat(num); return (*this);}
	String & operator += (unsigned long num)	{concat(num); return (*this);}
	String & operator += (float num)		{concat(num); return (*this);}
    64a8:	40 91 10 02 	lds	r20, 0x0210	; 0x800210 <K_temperature>
    64ac:	50 91 11 02 	lds	r21, 0x0211	; 0x800211 <K_temperature+0x1>
    64b0:	60 91 12 02 	lds	r22, 0x0212	; 0x800212 <K_temperature+0x2>
    64b4:	70 91 13 02 	lds	r23, 0x0213	; 0x800213 <K_temperature+0x3>
    64b8:	ce 01       	movw	r24, r28
    64ba:	43 96       	adiw	r24, 0x13	; 19
    64bc:	0e 94 5b 2a 	call	0x54b6	; 0x54b6 <String::concat(float)>
_ZN6StringpLEPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:114
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
    64c0:	66 e9       	ldi	r22, 0x96	; 150
    64c2:	78 e0       	ldi	r23, 0x08	; 8
    64c4:	ce 01       	movw	r24, r28
    64c6:	43 96       	adiw	r24, 0x13	; 19
    64c8:	0e 94 0a 2b 	call	0x5614	; 0x5614 <String::concat(char const*)>
pHCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:106
	Atlas_pH.print(s);
    64cc:	be 01       	movw	r22, r28
    64ce:	6d 5e       	subi	r22, 0xED	; 237
    64d0:	7f 4f       	sbci	r23, 0xFF	; 255
    64d2:	8b e7       	ldi	r24, 0x7B	; 123
    64d4:	9c e0       	ldi	r25, 0x0C	; 12
    64d6:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:107
	str = waitUntilpHReturn(150);
    64da:	46 e9       	ldi	r20, 0x96	; 150
    64dc:	50 e0       	ldi	r21, 0x00	; 0
    64de:	60 e0       	ldi	r22, 0x00	; 0
    64e0:	70 e0       	ldi	r23, 0x00	; 0
    64e2:	ce 01       	movw	r24, r28
    64e4:	01 96       	adiw	r24, 0x01	; 1
    64e6:	0e 94 97 31 	call	0x632e	; 0x632e <waitUntilpHReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    64ea:	be 01       	movw	r22, r28
    64ec:	6f 5f       	subi	r22, 0xFF	; 255
    64ee:	7f 4f       	sbci	r23, 0xFF	; 255
    64f0:	ce 01       	movw	r24, r28
    64f2:	0d 96       	adiw	r24, 0x0d	; 13
    64f4:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
pHCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:107
    64f8:	ce 01       	movw	r24, r28
    64fa:	01 96       	adiw	r24, 0x01	; 1
    64fc:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:108
	if (DEBUG || debugMode) {
    6500:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <debugMode>
    6504:	88 23       	and	r24, r24
    6506:	69 f0       	breq	.+26     	; 0x6522 <pHCalibration(String, float)+0x11e>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:109
		Serial.print("sendT2pH");
    6508:	6a e4       	ldi	r22, 0x4A	; 74
    650a:	74 e0       	ldi	r23, 0x04	; 4
    650c:	82 e5       	ldi	r24, 0x52	; 82
    650e:	9e e0       	ldi	r25, 0x0E	; 14
    6510:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:110
		Serial.println(str);
    6514:	be 01       	movw	r22, r28
    6516:	63 5f       	subi	r22, 0xF3	; 243
    6518:	7f 4f       	sbci	r23, 0xFF	; 255
    651a:	82 e5       	ldi	r24, 0x52	; 82
    651c:	9e e0       	ldi	r25, 0x0E	; 14
    651e:	0e 94 4e 28 	call	0x509c	; 0x509c <Print::println(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:113
	}

	String cmd = "";
    6522:	63 ea       	ldi	r22, 0xA3	; 163
    6524:	73 e0       	ldi	r23, 0x03	; 3
    6526:	ce 01       	movw	r24, r28
    6528:	49 96       	adiw	r24, 0x19	; 25
    652a:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:114
	cmd = "Cal," + type + "," + String(target, 3) + "\r";
    652e:	23 e0       	ldi	r18, 0x03	; 3
    6530:	b7 01       	movw	r22, r14
    6532:	a6 01       	movw	r20, r12
    6534:	ce 01       	movw	r24, r28
    6536:	07 96       	adiw	r24, 0x07	; 7
    6538:	0e 94 c9 2b 	call	0x5792	; 0x5792 <String::String(float, unsigned char)>
_ZN15StringSumHelperC2EPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:217

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    653c:	63 e5       	ldi	r22, 0x53	; 83
    653e:	74 e0       	ldi	r23, 0x04	; 4
    6540:	ce 01       	movw	r24, r28
    6542:	01 96       	adiw	r24, 0x01	; 1
    6544:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
pHCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:114
    6548:	b8 01       	movw	r22, r16
    654a:	ce 01       	movw	r24, r28
    654c:	01 96       	adiw	r24, 0x01	; 1
    654e:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    6552:	6a ef       	ldi	r22, 0xFA	; 250
    6554:	77 e0       	ldi	r23, 0x07	; 7
    6556:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    655a:	be 01       	movw	r22, r28
    655c:	69 5f       	subi	r22, 0xF9	; 249
    655e:	7f 4f       	sbci	r23, 0xFF	; 255
    6560:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    6564:	66 e9       	ldi	r22, 0x96	; 150
    6566:	78 e0       	ldi	r23, 0x08	; 8
    6568:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    656c:	bc 01       	movw	r22, r24
    656e:	ce 01       	movw	r24, r28
    6570:	49 96       	adiw	r24, 0x19	; 25
    6572:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <String::operator=(String const&)>
_ZN15StringSumHelperD2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    6576:	ce 01       	movw	r24, r28
    6578:	01 96       	adiw	r24, 0x01	; 1
    657a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
pHCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:114
    657e:	ce 01       	movw	r24, r28
    6580:	07 96       	adiw	r24, 0x07	; 7
    6582:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:115
	Atlas_pH.print(cmd);
    6586:	be 01       	movw	r22, r28
    6588:	67 5e       	subi	r22, 0xE7	; 231
    658a:	7f 4f       	sbci	r23, 0xFF	; 255
    658c:	8b e7       	ldi	r24, 0x7B	; 123
    658e:	9c e0       	ldi	r25, 0x0C	; 12
    6590:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:116
	str = waitUntilpHReturn(1000);
    6594:	48 ee       	ldi	r20, 0xE8	; 232
    6596:	53 e0       	ldi	r21, 0x03	; 3
    6598:	60 e0       	ldi	r22, 0x00	; 0
    659a:	70 e0       	ldi	r23, 0x00	; 0
    659c:	ce 01       	movw	r24, r28
    659e:	01 96       	adiw	r24, 0x01	; 1
    65a0:	0e 94 97 31 	call	0x632e	; 0x632e <waitUntilpHReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    65a4:	be 01       	movw	r22, r28
    65a6:	6f 5f       	subi	r22, 0xFF	; 255
    65a8:	7f 4f       	sbci	r23, 0xFF	; 255
    65aa:	ce 01       	movw	r24, r28
    65ac:	0d 96       	adiw	r24, 0x0d	; 13
    65ae:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
pHCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:116
    65b2:	ce 01       	movw	r24, r28
    65b4:	01 96       	adiw	r24, 0x01	; 1
    65b6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:117
	if (DEBUG || debugMode) {
    65ba:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <debugMode>
    65be:	88 23       	and	r24, r24
    65c0:	69 f0       	breq	.+26     	; 0x65dc <pHCalibration(String, float)+0x1d8>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:118
		Serial.print("calpH");
    65c2:	68 e5       	ldi	r22, 0x58	; 88
    65c4:	74 e0       	ldi	r23, 0x04	; 4
    65c6:	82 e5       	ldi	r24, 0x52	; 82
    65c8:	9e e0       	ldi	r25, 0x0E	; 14
    65ca:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:119
		Serial.println(str);
    65ce:	be 01       	movw	r22, r28
    65d0:	63 5f       	subi	r22, 0xF3	; 243
    65d2:	7f 4f       	sbci	r23, 0xFF	; 255
    65d4:	82 e5       	ldi	r24, 0x52	; 82
    65d6:	9e e0       	ldi	r25, 0x0E	; 14
    65d8:	0e 94 4e 28 	call	0x509c	; 0x509c <Print::println(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:122
	}

	Serial.println(cmd);
    65dc:	be 01       	movw	r22, r28
    65de:	67 5e       	subi	r22, 0xE7	; 231
    65e0:	7f 4f       	sbci	r23, 0xFF	; 255
    65e2:	82 e5       	ldi	r24, 0x52	; 82
    65e4:	9e e0       	ldi	r25, 0x0E	; 14
    65e6:	0e 94 4e 28 	call	0x509c	; 0x509c <Print::println(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:123
	lcd.setCursor(8, 3);
    65ea:	63 e0       	ldi	r22, 0x03	; 3
    65ec:	88 e0       	ldi	r24, 0x08	; 8
    65ee:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
_ZN15StringSumHelperC2EPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:217
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    65f2:	6b e7       	ldi	r22, 0x7B	; 123
    65f4:	75 e0       	ldi	r23, 0x05	; 5
    65f6:	ce 01       	movw	r24, r28
    65f8:	01 96       	adiw	r24, 0x01	; 1
    65fa:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
pHCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:124
	lcd.print("-" + type);
    65fe:	b8 01       	movw	r22, r16
    6600:	ce 01       	movw	r24, r28
    6602:	01 96       	adiw	r24, 0x01	; 1
    6604:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    6608:	bc 01       	movw	r22, r24
    660a:	8b eb       	ldi	r24, 0xBB	; 187
    660c:	90 e1       	ldi	r25, 0x10	; 16
    660e:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
_ZN15StringSumHelperD2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    6612:	ce 01       	movw	r24, r28
    6614:	01 96       	adiw	r24, 0x01	; 1
    6616:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
pHCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:125
	for (int i = type.length(); i < 5; i++)	lcd.print(" ");
    661a:	f8 01       	movw	r30, r16
    661c:	04 81       	ldd	r16, Z+4	; 0x04
    661e:	15 81       	ldd	r17, Z+5	; 0x05
    6620:	05 30       	cpi	r16, 0x05	; 5
    6622:	11 05       	cpc	r17, r1
    6624:	4c f4       	brge	.+18     	; 0x6638 <pHCalibration(String, float)+0x234>
    6626:	6c e8       	ldi	r22, 0x8C	; 140
    6628:	77 e0       	ldi	r23, 0x07	; 7
    662a:	8b eb       	ldi	r24, 0xBB	; 187
    662c:	90 e1       	ldi	r25, 0x10	; 16
    662e:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
    6632:	0f 5f       	subi	r16, 0xFF	; 255
    6634:	1f 4f       	sbci	r17, 0xFF	; 255
    6636:	f4 cf       	rjmp	.-24     	; 0x6620 <pHCalibration(String, float)+0x21c>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:127

	Atlas_pH.print("Sleep\r");
    6638:	6e e5       	ldi	r22, 0x5E	; 94
    663a:	74 e0       	ldi	r23, 0x04	; 4
    663c:	8b e7       	ldi	r24, 0x7B	; 123
    663e:	9c e0       	ldi	r25, 0x0C	; 12
    6640:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:113
	if (DEBUG || debugMode) {
		Serial.print("sendT2pH");
		Serial.println(str);
	}

	String cmd = "";
    6644:	ce 01       	movw	r24, r28
    6646:	49 96       	adiw	r24, 0x19	; 25
    6648:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:105
	if (DEBUG || debugMode) {
		Serial.print("wake pH:");
		Serial.println(str);
	}

	String s = "T,";	s += K_temperature;		s += "\r";
    664c:	ce 01       	movw	r24, r28
    664e:	43 96       	adiw	r24, 0x13	; 19
    6650:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:93
	Atlas_pH.print("Sleep\r");
}
*/

void pHCalibration(String type, float target) {
	String str = "";
    6654:	ce 01       	movw	r24, r28
    6656:	0d 96       	adiw	r24, 0x0d	; 13
    6658:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:128
	lcd.setCursor(8, 3);
	lcd.print("-" + type);
	for (int i = type.length(); i < 5; i++)	lcd.print(" ");

	Atlas_pH.print("Sleep\r");
}
    665c:	6e 96       	adiw	r28, 0x1e	; 30
    665e:	0f b6       	in	r0, 0x3f	; 63
    6660:	f8 94       	cli
    6662:	de bf       	out	0x3e, r29	; 62
    6664:	0f be       	out	0x3f, r0	; 63
    6666:	cd bf       	out	0x3d, r28	; 61
    6668:	df 91       	pop	r29
    666a:	cf 91       	pop	r28
    666c:	1f 91       	pop	r17
    666e:	0f 91       	pop	r16
    6670:	ff 90       	pop	r15
    6672:	ef 90       	pop	r14
    6674:	df 90       	pop	r13
    6676:	cf 90       	pop	r12
    6678:	08 95       	ret

0000667a <waitUntilECReturn(unsigned long)>:
waitUntilECReturn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:93
	lcd.setCursor(1, 3);
	lcd.print("-" + type);
	for (int i = type.length(); i < 5; i++)	lcd.print(" ");
	Atlas_EC.print("Sleep\r");
}
String waitUntilECReturn(unsigned long ttl) {
    667a:	8f 92       	push	r8
    667c:	9f 92       	push	r9
    667e:	af 92       	push	r10
    6680:	bf 92       	push	r11
    6682:	cf 92       	push	r12
    6684:	df 92       	push	r13
    6686:	ef 92       	push	r14
    6688:	ff 92       	push	r15
    668a:	0f 93       	push	r16
    668c:	1f 93       	push	r17
    668e:	cf 93       	push	r28
    6690:	df 93       	push	r29
    6692:	00 d0       	rcall	.+0      	; 0x6694 <waitUntilECReturn(unsigned long)+0x1a>
    6694:	00 d0       	rcall	.+0      	; 0x6696 <waitUntilECReturn(unsigned long)+0x1c>
    6696:	cd b7       	in	r28, 0x3d	; 61
    6698:	de b7       	in	r29, 0x3e	; 62
    669a:	8c 01       	movw	r16, r24
    669c:	4a 01       	movw	r8, r20
    669e:	5b 01       	movw	r10, r22
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:94
	String s = "";
    66a0:	63 ea       	ldi	r22, 0xA3	; 163
    66a2:	73 e0       	ldi	r23, 0x03	; 3
    66a4:	ce 01       	movw	r24, r28
    66a6:	01 96       	adiw	r24, 0x01	; 1
    66a8:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:95
	s.reserve(20);
    66ac:	64 e1       	ldi	r22, 0x14	; 20
    66ae:	70 e0       	ldi	r23, 0x00	; 0
    66b0:	ce 01       	movw	r24, r28
    66b2:	01 96       	adiw	r24, 0x01	; 1
    66b4:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:96
	for (unsigned long time = millis(); millis() - time < ttl;) {
    66b8:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    66bc:	6b 01       	movw	r12, r22
    66be:	7c 01       	movw	r14, r24
    66c0:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    66c4:	6c 19       	sub	r22, r12
    66c6:	7d 09       	sbc	r23, r13
    66c8:	8e 09       	sbc	r24, r14
    66ca:	9f 09       	sbc	r25, r15
    66cc:	68 15       	cp	r22, r8
    66ce:	79 05       	cpc	r23, r9
    66d0:	8a 05       	cpc	r24, r10
    66d2:	9b 05       	cpc	r25, r11
    66d4:	b8 f5       	brcc	.+110    	; 0x6744 <waitUntilECReturn(unsigned long)+0xca>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:97
		if (Atlas_EC.available()) {
    66d6:	88 e1       	ldi	r24, 0x18	; 24
    66d8:	9d e0       	ldi	r25, 0x0D	; 13
    66da:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <HardwareSerial::available()>
    66de:	89 2b       	or	r24, r25
    66e0:	79 f3       	breq	.-34     	; 0x66c0 <waitUntilECReturn(unsigned long)+0x46>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:98
			char inchar = (char)Atlas_EC.read();
    66e2:	88 e1       	ldi	r24, 0x18	; 24
    66e4:	9d e0       	ldi	r25, 0x0D	; 13
    66e6:	0e 94 ca 06 	call	0xd94	; 0xd94 <HardwareSerial::read()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:99
			if (inchar == '\r') return s;
    66ea:	8d 30       	cpi	r24, 0x0D	; 13
    66ec:	29 f5       	brne	.+74     	; 0x6738 <waitUntilECReturn(unsigned long)+0xbe>
_ZN6String4initEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:133
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    66ee:	f8 01       	movw	r30, r16
    66f0:	11 82       	std	Z+1, r1	; 0x01
    66f2:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:134
	capacity = 0;
    66f4:	13 82       	std	Z+3, r1	; 0x03
    66f6:	12 82       	std	Z+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:135
	len = 0;
    66f8:	15 82       	std	Z+5, r1	; 0x05
    66fa:	14 82       	std	Z+4, r1	; 0x04
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:50

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String::String(String &&rval)
{
	init();
	move(rval);
    66fc:	be 01       	movw	r22, r28
    66fe:	6f 5f       	subi	r22, 0xFF	; 255
    6700:	7f 4f       	sbci	r23, 0xFF	; 255
    6702:	c8 01       	movw	r24, r16
    6704:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
waitUntilECReturn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:94
	lcd.print("-" + type);
	for (int i = type.length(); i < 5; i++)	lcd.print(" ");
	Atlas_EC.print("Sleep\r");
}
String waitUntilECReturn(unsigned long ttl) {
	String s = "";
    6708:	ce 01       	movw	r24, r28
    670a:	01 96       	adiw	r24, 0x01	; 1
    670c:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:104
			if (inchar == '\r') return s;
			else				s += inchar;
		}
	}
	return "ttl";
    6710:	c8 01       	movw	r24, r16
    6712:	26 96       	adiw	r28, 0x06	; 6
    6714:	0f b6       	in	r0, 0x3f	; 63
    6716:	f8 94       	cli
    6718:	de bf       	out	0x3e, r29	; 62
    671a:	0f be       	out	0x3f, r0	; 63
    671c:	cd bf       	out	0x3d, r28	; 61
    671e:	df 91       	pop	r29
    6720:	cf 91       	pop	r28
    6722:	1f 91       	pop	r17
    6724:	0f 91       	pop	r16
    6726:	ff 90       	pop	r15
    6728:	ef 90       	pop	r14
    672a:	df 90       	pop	r13
    672c:	cf 90       	pop	r12
    672e:	bf 90       	pop	r11
    6730:	af 90       	pop	r10
    6732:	9f 90       	pop	r9
    6734:	8f 90       	pop	r8
    6736:	08 95       	ret
_ZN6StringpLEc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:115

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
	String & operator += (char c)			{concat(c); return (*this);}
    6738:	68 2f       	mov	r22, r24
    673a:	ce 01       	movw	r24, r28
    673c:	01 96       	adiw	r24, 0x01	; 1
    673e:	0e 94 ba 2a 	call	0x5574	; 0x5574 <String::concat(char)>
    6742:	be cf       	rjmp	.-132    	; 0x66c0 <waitUntilECReturn(unsigned long)+0x46>
waitUntilECReturn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:103
			char inchar = (char)Atlas_EC.read();
			if (inchar == '\r') return s;
			else				s += inchar;
		}
	}
	return "ttl";
    6744:	65 ea       	ldi	r22, 0xA5	; 165
    6746:	73 e0       	ldi	r23, 0x03	; 3
    6748:	c8 01       	movw	r24, r16
    674a:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    674e:	dc cf       	rjmp	.-72     	; 0x6708 <waitUntilECReturn(unsigned long)+0x8e>

00006750 <ECCalibration(String, long)>:
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:61
    Atlas_EC.read();
  }
}


void ECCalibration(String type, long target) {
    6750:	cf 92       	push	r12
    6752:	df 92       	push	r13
    6754:	ef 92       	push	r14
    6756:	ff 92       	push	r15
    6758:	0f 93       	push	r16
    675a:	1f 93       	push	r17
    675c:	cf 93       	push	r28
    675e:	df 93       	push	r29
    6760:	cd b7       	in	r28, 0x3d	; 61
    6762:	de b7       	in	r29, 0x3e	; 62
    6764:	6e 97       	sbiw	r28, 0x1e	; 30
    6766:	0f b6       	in	r0, 0x3f	; 63
    6768:	f8 94       	cli
    676a:	de bf       	out	0x3e, r29	; 62
    676c:	0f be       	out	0x3f, r0	; 63
    676e:	cd bf       	out	0x3d, r28	; 61
    6770:	8c 01       	movw	r16, r24
    6772:	6a 01       	movw	r12, r20
    6774:	7b 01       	movw	r14, r22
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:62
	String str = "";
    6776:	63 ea       	ldi	r22, 0xA3	; 163
    6778:	73 e0       	ldi	r23, 0x03	; 3
    677a:	ce 01       	movw	r24, r28
    677c:	0d 96       	adiw	r24, 0x0d	; 13
    677e:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:63
	str.reserve(10);
    6782:	6a e0       	ldi	r22, 0x0A	; 10
    6784:	70 e0       	ldi	r23, 0x00	; 0
    6786:	ce 01       	movw	r24, r28
    6788:	0d 96       	adiw	r24, 0x0d	; 13
    678a:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:64
	flush_EC_serial();
    678e:	0e 94 2e 1e 	call	0x3c5c	; 0x3c5c <flush_EC_serial()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:65
	update_K_temp();
    6792:	0e 94 71 2d 	call	0x5ae2	; 0x5ae2 <update_K_temp()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:67

	Atlas_EC.print("\r");
    6796:	66 e9       	ldi	r22, 0x96	; 150
    6798:	78 e0       	ldi	r23, 0x08	; 8
    679a:	88 e1       	ldi	r24, 0x18	; 24
    679c:	9d e0       	ldi	r25, 0x0D	; 13
    679e:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:68
	str = waitUntilECReturn(150);
    67a2:	46 e9       	ldi	r20, 0x96	; 150
    67a4:	50 e0       	ldi	r21, 0x00	; 0
    67a6:	60 e0       	ldi	r22, 0x00	; 0
    67a8:	70 e0       	ldi	r23, 0x00	; 0
    67aa:	ce 01       	movw	r24, r28
    67ac:	01 96       	adiw	r24, 0x01	; 1
    67ae:	0e 94 3d 33 	call	0x667a	; 0x667a <waitUntilECReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String & String::operator = (String &&rval)
{
	if (this != &rval) move(rval);
    67b2:	be 01       	movw	r22, r28
    67b4:	6f 5f       	subi	r22, 0xFF	; 255
    67b6:	7f 4f       	sbci	r23, 0xFF	; 255
    67b8:	ce 01       	movw	r24, r28
    67ba:	0d 96       	adiw	r24, 0x0d	; 13
    67bc:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:68
    67c0:	ce 01       	movw	r24, r28
    67c2:	01 96       	adiw	r24, 0x01	; 1
    67c4:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:70

	SerialDebug("wakeEC :", str);
    67c8:	be 01       	movw	r22, r28
    67ca:	63 5f       	subi	r22, 0xF3	; 243
    67cc:	7f 4f       	sbci	r23, 0xFF	; 255
    67ce:	ce 01       	movw	r24, r28
    67d0:	07 96       	adiw	r24, 0x07	; 7
    67d2:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    67d6:	65 e6       	ldi	r22, 0x65	; 101
    67d8:	74 e0       	ldi	r23, 0x04	; 4
    67da:	ce 01       	movw	r24, r28
    67dc:	01 96       	adiw	r24, 0x01	; 1
    67de:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    67e2:	be 01       	movw	r22, r28
    67e4:	69 5f       	subi	r22, 0xF9	; 249
    67e6:	7f 4f       	sbci	r23, 0xFF	; 255
    67e8:	ce 01       	movw	r24, r28
    67ea:	01 96       	adiw	r24, 0x01	; 1
    67ec:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    67f0:	ce 01       	movw	r24, r28
    67f2:	01 96       	adiw	r24, 0x01	; 1
    67f4:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    67f8:	ce 01       	movw	r24, r28
    67fa:	07 96       	adiw	r24, 0x07	; 7
    67fc:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:72

	String s = "T,";	s += K_temperature;		s += "\r";
    6800:	67 e4       	ldi	r22, 0x47	; 71
    6802:	74 e0       	ldi	r23, 0x04	; 4
    6804:	ce 01       	movw	r24, r28
    6806:	43 96       	adiw	r24, 0x13	; 19
    6808:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
_ZN6StringpLEf():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:121
	String & operator += (unsigned char num)		{concat(num); return (*this);}
	String & operator += (int num)			{concat(num); return (*this);}
	String & operator += (unsigned int num)		{concat(num); return (*this);}
	String & operator += (long num)			{concat(num); return (*this);}
	String & operator += (unsigned long num)	{concat(num); return (*this);}
	String & operator += (float num)		{concat(num); return (*this);}
    680c:	40 91 10 02 	lds	r20, 0x0210	; 0x800210 <K_temperature>
    6810:	50 91 11 02 	lds	r21, 0x0211	; 0x800211 <K_temperature+0x1>
    6814:	60 91 12 02 	lds	r22, 0x0212	; 0x800212 <K_temperature+0x2>
    6818:	70 91 13 02 	lds	r23, 0x0213	; 0x800213 <K_temperature+0x3>
    681c:	ce 01       	movw	r24, r28
    681e:	43 96       	adiw	r24, 0x13	; 19
    6820:	0e 94 5b 2a 	call	0x54b6	; 0x54b6 <String::concat(float)>
_ZN6StringpLEPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:114
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
    6824:	66 e9       	ldi	r22, 0x96	; 150
    6826:	78 e0       	ldi	r23, 0x08	; 8
    6828:	ce 01       	movw	r24, r28
    682a:	43 96       	adiw	r24, 0x13	; 19
    682c:	0e 94 0a 2b 	call	0x5614	; 0x5614 <String::concat(char const*)>
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:73
	Atlas_EC.print(s);
    6830:	be 01       	movw	r22, r28
    6832:	6d 5e       	subi	r22, 0xED	; 237
    6834:	7f 4f       	sbci	r23, 0xFF	; 255
    6836:	88 e1       	ldi	r24, 0x18	; 24
    6838:	9d e0       	ldi	r25, 0x0D	; 13
    683a:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:74
	str = waitUntilECReturn(100);
    683e:	44 e6       	ldi	r20, 0x64	; 100
    6840:	50 e0       	ldi	r21, 0x00	; 0
    6842:	60 e0       	ldi	r22, 0x00	; 0
    6844:	70 e0       	ldi	r23, 0x00	; 0
    6846:	ce 01       	movw	r24, r28
    6848:	01 96       	adiw	r24, 0x01	; 1
    684a:	0e 94 3d 33 	call	0x667a	; 0x667a <waitUntilECReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    684e:	be 01       	movw	r22, r28
    6850:	6f 5f       	subi	r22, 0xFF	; 255
    6852:	7f 4f       	sbci	r23, 0xFF	; 255
    6854:	ce 01       	movw	r24, r28
    6856:	0d 96       	adiw	r24, 0x0d	; 13
    6858:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:74
    685c:	ce 01       	movw	r24, r28
    685e:	01 96       	adiw	r24, 0x01	; 1
    6860:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:76

	SerialDebug("sendT2EC:", str);
    6864:	be 01       	movw	r22, r28
    6866:	63 5f       	subi	r22, 0xF3	; 243
    6868:	7f 4f       	sbci	r23, 0xFF	; 255
    686a:	ce 01       	movw	r24, r28
    686c:	07 96       	adiw	r24, 0x07	; 7
    686e:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    6872:	6e e6       	ldi	r22, 0x6E	; 110
    6874:	74 e0       	ldi	r23, 0x04	; 4
    6876:	ce 01       	movw	r24, r28
    6878:	01 96       	adiw	r24, 0x01	; 1
    687a:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    687e:	be 01       	movw	r22, r28
    6880:	69 5f       	subi	r22, 0xF9	; 249
    6882:	7f 4f       	sbci	r23, 0xFF	; 255
    6884:	ce 01       	movw	r24, r28
    6886:	01 96       	adiw	r24, 0x01	; 1
    6888:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    688c:	ce 01       	movw	r24, r28
    688e:	01 96       	adiw	r24, 0x01	; 1
    6890:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    6894:	ce 01       	movw	r24, r28
    6896:	07 96       	adiw	r24, 0x07	; 7
    6898:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:78

	String cmd = "";
    689c:	63 ea       	ldi	r22, 0xA3	; 163
    689e:	73 e0       	ldi	r23, 0x03	; 3
    68a0:	ce 01       	movw	r24, r28
    68a2:	49 96       	adiw	r24, 0x19	; 25
    68a4:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
_ZN15StringSumHelperC2EPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:217

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    68a8:	63 e5       	ldi	r22, 0x53	; 83
    68aa:	74 e0       	ldi	r23, 0x04	; 4
    68ac:	ce 01       	movw	r24, r28
    68ae:	01 96       	adiw	r24, 0x01	; 1
    68b0:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:79
	cmd = "Cal," + type;
    68b4:	b8 01       	movw	r22, r16
    68b6:	ce 01       	movw	r24, r28
    68b8:	01 96       	adiw	r24, 0x01	; 1
    68ba:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    68be:	bc 01       	movw	r22, r24
    68c0:	ce 01       	movw	r24, r28
    68c2:	49 96       	adiw	r24, 0x19	; 25
    68c4:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <String::operator=(String const&)>
_ZN15StringSumHelperD2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    68c8:	ce 01       	movw	r24, r28
    68ca:	01 96       	adiw	r24, 0x01	; 1
    68cc:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:80
	if (target != NULL) cmd += "," + String(target);
    68d0:	c1 14       	cp	r12, r1
    68d2:	d1 04       	cpc	r13, r1
    68d4:	e1 04       	cpc	r14, r1
    68d6:	f1 04       	cpc	r15, r1
    68d8:	01 f1       	breq	.+64     	; 0x691a <ECCalibration(String, long)+0x1ca>
    68da:	b7 01       	movw	r22, r14
    68dc:	a6 01       	movw	r20, r12
    68de:	ce 01       	movw	r24, r28
    68e0:	07 96       	adiw	r24, 0x07	; 7
    68e2:	0e 94 9c 2b 	call	0x5738	; 0x5738 <String::String(long, unsigned char) [clone .constprop.40]>
_ZN15StringSumHelperC2EPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:217
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    68e6:	6a ef       	ldi	r22, 0xFA	; 250
    68e8:	77 e0       	ldi	r23, 0x07	; 7
    68ea:	ce 01       	movw	r24, r28
    68ec:	01 96       	adiw	r24, 0x01	; 1
    68ee:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:80
    68f2:	be 01       	movw	r22, r28
    68f4:	69 5f       	subi	r22, 0xF9	; 249
    68f6:	7f 4f       	sbci	r23, 0xFF	; 255
    68f8:	ce 01       	movw	r24, r28
    68fa:	01 96       	adiw	r24, 0x01	; 1
    68fc:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
_ZN6StringpLERKS_():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:113
	unsigned char concat(double num);
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
    6900:	bc 01       	movw	r22, r24
    6902:	ce 01       	movw	r24, r28
    6904:	49 96       	adiw	r24, 0x19	; 25
    6906:	0e 94 14 2b 	call	0x5628	; 0x5628 <String::concat(String const&)>
_ZN15StringSumHelperD2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    690a:	ce 01       	movw	r24, r28
    690c:	01 96       	adiw	r24, 0x01	; 1
    690e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:80
    6912:	ce 01       	movw	r24, r28
    6914:	07 96       	adiw	r24, 0x07	; 7
    6916:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
_ZN6StringpLEPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:114
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
    691a:	66 e9       	ldi	r22, 0x96	; 150
    691c:	78 e0       	ldi	r23, 0x08	; 8
    691e:	ce 01       	movw	r24, r28
    6920:	49 96       	adiw	r24, 0x19	; 25
    6922:	0e 94 0a 2b 	call	0x5614	; 0x5614 <String::concat(char const*)>
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:82
	cmd += "\r";
	Atlas_EC.print(cmd);
    6926:	be 01       	movw	r22, r28
    6928:	67 5e       	subi	r22, 0xE7	; 231
    692a:	7f 4f       	sbci	r23, 0xFF	; 255
    692c:	88 e1       	ldi	r24, 0x18	; 24
    692e:	9d e0       	ldi	r25, 0x0D	; 13
    6930:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:83
	str = waitUntilECReturn(1000);
    6934:	48 ee       	ldi	r20, 0xE8	; 232
    6936:	53 e0       	ldi	r21, 0x03	; 3
    6938:	60 e0       	ldi	r22, 0x00	; 0
    693a:	70 e0       	ldi	r23, 0x00	; 0
    693c:	ce 01       	movw	r24, r28
    693e:	01 96       	adiw	r24, 0x01	; 1
    6940:	0e 94 3d 33 	call	0x667a	; 0x667a <waitUntilECReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    6944:	be 01       	movw	r22, r28
    6946:	6f 5f       	subi	r22, 0xFF	; 255
    6948:	7f 4f       	sbci	r23, 0xFF	; 255
    694a:	ce 01       	movw	r24, r28
    694c:	0d 96       	adiw	r24, 0x0d	; 13
    694e:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:83
    6952:	ce 01       	movw	r24, r28
    6954:	01 96       	adiw	r24, 0x01	; 1
    6956:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:85

	SerialDebug("calEC:", str);
    695a:	be 01       	movw	r22, r28
    695c:	63 5f       	subi	r22, 0xF3	; 243
    695e:	7f 4f       	sbci	r23, 0xFF	; 255
    6960:	ce 01       	movw	r24, r28
    6962:	07 96       	adiw	r24, 0x07	; 7
    6964:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    6968:	68 e7       	ldi	r22, 0x78	; 120
    696a:	74 e0       	ldi	r23, 0x04	; 4
    696c:	ce 01       	movw	r24, r28
    696e:	01 96       	adiw	r24, 0x01	; 1
    6970:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    6974:	be 01       	movw	r22, r28
    6976:	69 5f       	subi	r22, 0xF9	; 249
    6978:	7f 4f       	sbci	r23, 0xFF	; 255
    697a:	ce 01       	movw	r24, r28
    697c:	01 96       	adiw	r24, 0x01	; 1
    697e:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    6982:	ce 01       	movw	r24, r28
    6984:	01 96       	adiw	r24, 0x01	; 1
    6986:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    698a:	ce 01       	movw	r24, r28
    698c:	07 96       	adiw	r24, 0x07	; 7
    698e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:87

	Serial.println(cmd);
    6992:	be 01       	movw	r22, r28
    6994:	67 5e       	subi	r22, 0xE7	; 231
    6996:	7f 4f       	sbci	r23, 0xFF	; 255
    6998:	82 e5       	ldi	r24, 0x52	; 82
    699a:	9e e0       	ldi	r25, 0x0E	; 14
    699c:	0e 94 4e 28 	call	0x509c	; 0x509c <Print::println(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:88
	lcd.setCursor(1, 3);
    69a0:	63 e0       	ldi	r22, 0x03	; 3
    69a2:	81 e0       	ldi	r24, 0x01	; 1
    69a4:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
_ZN15StringSumHelperC2EPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:217

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    69a8:	6b e7       	ldi	r22, 0x7B	; 123
    69aa:	75 e0       	ldi	r23, 0x05	; 5
    69ac:	ce 01       	movw	r24, r28
    69ae:	01 96       	adiw	r24, 0x01	; 1
    69b0:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:89
	lcd.print("-" + type);
    69b4:	b8 01       	movw	r22, r16
    69b6:	ce 01       	movw	r24, r28
    69b8:	01 96       	adiw	r24, 0x01	; 1
    69ba:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    69be:	bc 01       	movw	r22, r24
    69c0:	8b eb       	ldi	r24, 0xBB	; 187
    69c2:	90 e1       	ldi	r25, 0x10	; 16
    69c4:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
_ZN15StringSumHelperD2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    69c8:	ce 01       	movw	r24, r28
    69ca:	01 96       	adiw	r24, 0x01	; 1
    69cc:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
ECCalibration():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:90
	for (int i = type.length(); i < 5; i++)	lcd.print(" ");
    69d0:	f8 01       	movw	r30, r16
    69d2:	04 81       	ldd	r16, Z+4	; 0x04
    69d4:	15 81       	ldd	r17, Z+5	; 0x05
    69d6:	05 30       	cpi	r16, 0x05	; 5
    69d8:	11 05       	cpc	r17, r1
    69da:	4c f4       	brge	.+18     	; 0x69ee <ECCalibration(String, long)+0x29e>
    69dc:	6c e8       	ldi	r22, 0x8C	; 140
    69de:	77 e0       	ldi	r23, 0x07	; 7
    69e0:	8b eb       	ldi	r24, 0xBB	; 187
    69e2:	90 e1       	ldi	r25, 0x10	; 16
    69e4:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
    69e8:	0f 5f       	subi	r16, 0xFF	; 255
    69ea:	1f 4f       	sbci	r17, 0xFF	; 255
    69ec:	f4 cf       	rjmp	.-24     	; 0x69d6 <ECCalibration(String, long)+0x286>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:91
	Atlas_EC.print("Sleep\r");
    69ee:	6e e5       	ldi	r22, 0x5E	; 94
    69f0:	74 e0       	ldi	r23, 0x04	; 4
    69f2:	88 e1       	ldi	r24, 0x18	; 24
    69f4:	9d e0       	ldi	r25, 0x0D	; 13
    69f6:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:78
	Atlas_EC.print(s);
	str = waitUntilECReturn(100);

	SerialDebug("sendT2EC:", str);

	String cmd = "";
    69fa:	ce 01       	movw	r24, r28
    69fc:	49 96       	adiw	r24, 0x19	; 25
    69fe:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:72
	Atlas_EC.print("\r");
	str = waitUntilECReturn(150);

	SerialDebug("wakeEC :", str);

	String s = "T,";	s += K_temperature;		s += "\r";
    6a02:	ce 01       	movw	r24, r28
    6a04:	43 96       	adiw	r24, 0x13	; 19
    6a06:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:62
  }
}


void ECCalibration(String type, long target) {
	String str = "";
    6a0a:	ce 01       	movw	r24, r28
    6a0c:	0d 96       	adiw	r24, 0x0d	; 13
    6a0e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:92
	Serial.println(cmd);
	lcd.setCursor(1, 3);
	lcd.print("-" + type);
	for (int i = type.length(); i < 5; i++)	lcd.print(" ");
	Atlas_EC.print("Sleep\r");
}
    6a12:	6e 96       	adiw	r28, 0x1e	; 30
    6a14:	0f b6       	in	r0, 0x3f	; 63
    6a16:	f8 94       	cli
    6a18:	de bf       	out	0x3e, r29	; 62
    6a1a:	0f be       	out	0x3f, r0	; 63
    6a1c:	cd bf       	out	0x3d, r28	; 61
    6a1e:	df 91       	pop	r29
    6a20:	cf 91       	pop	r28
    6a22:	1f 91       	pop	r17
    6a24:	0f 91       	pop	r16
    6a26:	ff 90       	pop	r15
    6a28:	ef 90       	pop	r14
    6a2a:	df 90       	pop	r13
    6a2c:	cf 90       	pop	r12
    6a2e:	08 95       	ret

00006a30 <String::String(__FlashStringHelper const*)>:
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:40
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
    6a30:	ef 92       	push	r14
    6a32:	ff 92       	push	r15
    6a34:	0f 93       	push	r16
    6a36:	1f 93       	push	r17
    6a38:	cf 93       	push	r28
    6a3a:	df 93       	push	r29
    6a3c:	ec 01       	movw	r28, r24
    6a3e:	8b 01       	movw	r16, r22
_ZN6String4initEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:133
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
    6a40:	19 82       	std	Y+1, r1	; 0x01
    6a42:	18 82       	st	Y, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:134
	capacity = 0;
    6a44:	1b 82       	std	Y+3, r1	; 0x03
    6a46:	1a 82       	std	Y+2, r1	; 0x02
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:135
	len = 0;
    6a48:	1d 82       	std	Y+5, r1	; 0x05
    6a4a:	1c 82       	std	Y+4, r1	; 0x04
strlen_P():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\avr/pgmspace.h:1783
#else
extern size_t __strlen_P(const char *) __ATTR_CONST__;  /* internal helper function */
__attribute__((__always_inline__)) static __inline__ size_t strlen_P(const char * s);
static __inline__ size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    6a4c:	cb 01       	movw	r24, r22
    6a4e:	0e 94 4d 64 	call	0xc89a	; 0xc89a <__strlen_P>
    6a52:	7c 01       	movw	r14, r24
copy():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:183
	return *this;
}

String & String::copy(const __FlashStringHelper *pstr, unsigned int length)
{
	if (!reserve(length)) {
    6a54:	bc 01       	movw	r22, r24
    6a56:	ce 01       	movw	r24, r28
    6a58:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
    6a5c:	81 11       	cpse	r24, r1
    6a5e:	09 c0       	rjmp	.+18     	; 0x6a72 <String::String(__FlashStringHelper const*)+0x42>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:184
		invalidate();
    6a60:	ce 01       	movw	r24, r28
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:44

String::String(const __FlashStringHelper *pstr)
{
	init();
	*this = pstr;
}
    6a62:	df 91       	pop	r29
    6a64:	cf 91       	pop	r28
    6a66:	1f 91       	pop	r17
    6a68:	0f 91       	pop	r16
    6a6a:	ff 90       	pop	r15
    6a6c:	ef 90       	pop	r14
copy():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:184
}

String & String::copy(const __FlashStringHelper *pstr, unsigned int length)
{
	if (!reserve(length)) {
		invalidate();
    6a6e:	0c 94 9a 25 	jmp	0x4b34	; 0x4b34 <String::invalidate()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:187
		return *this;
	}
	len = length;
    6a72:	fd 82       	std	Y+5, r15	; 0x05
    6a74:	ec 82       	std	Y+4, r14	; 0x04
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:188
	strcpy_P(buffer, (PGM_P)pstr);
    6a76:	b8 01       	movw	r22, r16
    6a78:	88 81       	ld	r24, Y
    6a7a:	99 81       	ldd	r25, Y+1	; 0x01
__base_ctor ():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:44

String::String(const __FlashStringHelper *pstr)
{
	init();
	*this = pstr;
}
    6a7c:	df 91       	pop	r29
    6a7e:	cf 91       	pop	r28
    6a80:	1f 91       	pop	r17
    6a82:	0f 91       	pop	r16
    6a84:	ff 90       	pop	r15
    6a86:	ef 90       	pop	r14
copy():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:188
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
	strcpy_P(buffer, (PGM_P)pstr);
    6a88:	0c 94 46 64 	jmp	0xc88c	; 0xc88c <strcpy_P>

00006a8c <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]>:
_ZN6SdFile4openEPS_PKch.part.28():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:453
   the value zero, false, is returned for failure.
   Reasons for failure include this SdFile is already open, \a difFile is not
   a directory, \a fileName is invalid, the file does not exist
   or can't be opened in the access mode specified by oflag.
*/
uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag) {
    6a8c:	3f 92       	push	r3
    6a8e:	4f 92       	push	r4
    6a90:	5f 92       	push	r5
    6a92:	6f 92       	push	r6
    6a94:	7f 92       	push	r7
    6a96:	8f 92       	push	r8
    6a98:	9f 92       	push	r9
    6a9a:	af 92       	push	r10
    6a9c:	bf 92       	push	r11
    6a9e:	cf 92       	push	r12
    6aa0:	df 92       	push	r13
    6aa2:	ef 92       	push	r14
    6aa4:	ff 92       	push	r15
    6aa6:	0f 93       	push	r16
    6aa8:	1f 93       	push	r17
    6aaa:	cf 93       	push	r28
    6aac:	df 93       	push	r29
    6aae:	00 d0       	rcall	.+0      	; 0x6ab0 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x24>
    6ab0:	00 d0       	rcall	.+0      	; 0x6ab2 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x26>
    6ab2:	00 d0       	rcall	.+0      	; 0x6ab4 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x28>
    6ab4:	1f 92       	push	r1
    6ab6:	1f 92       	push	r1
    6ab8:	cd b7       	in	r28, 0x3d	; 61
    6aba:	de b7       	in	r29, 0x3e	; 62
    6abc:	7c 01       	movw	r14, r24
    6abe:	fe 01       	movw	r30, r28
    6ac0:	31 96       	adiw	r30, 0x01	; 1
    6ac2:	ce 01       	movw	r24, r28
    6ac4:	0c 96       	adiw	r24, 0x0c	; 12
    6ac6:	6f 01       	movw	r12, r30
make83Name():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:292
  uint8_t c;
  uint8_t n = 7;  // max index for part before dot
  uint8_t i = 0;
  // blank fill name and extension
  while (i < 11) {
    name[i++] = ' ';
    6ac8:	30 e2       	ldi	r19, 0x20	; 32
    6aca:	31 93       	st	Z+, r19
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:291
uint8_t SdFile::make83Name(const char* str, uint8_t* name) {
  uint8_t c;
  uint8_t n = 7;  // max index for part before dot
  uint8_t i = 0;
  // blank fill name and extension
  while (i < 11) {
    6acc:	e8 17       	cp	r30, r24
    6ace:	f9 07       	cpc	r31, r25
    6ad0:	e1 f7       	brne	.-8      	; 0x6aca <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x3e>
    6ad2:	da 01       	movw	r26, r20
_ZN6SdFile4openEPS_PKch.part.28():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:294
    name[i++] = ' ';
  }
  i = 0;
    6ad4:	30 e0       	ldi	r19, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:288
}
//------------------------------------------------------------------------------
// format directory name field from a 8.3 name string
uint8_t SdFile::make83Name(const char* str, uint8_t* name) {
  uint8_t c;
  uint8_t n = 7;  // max index for part before dot
    6ad6:	87 e0       	ldi	r24, 0x07	; 7
make83Name():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:295
  // blank fill name and extension
  while (i < 11) {
    name[i++] = ' ';
  }
  i = 0;
  while ((c = *str++) != '\0') {
    6ad8:	9d 91       	ld	r25, X+
    6ada:	b9 2e       	mov	r11, r25
    6adc:	99 23       	and	r25, r25
    6ade:	09 f4       	brne	.+2      	; 0x6ae2 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x56>
    6ae0:	3c c0       	rjmp	.+120    	; 0x6b5a <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0xce>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:296
    if (c == '.') {
    6ae2:	9e 32       	cpi	r25, 0x2E	; 46
    6ae4:	f1 f4       	brne	.+60     	; 0x6b22 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x96>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:297
      if (n == 10) {
    6ae6:	8a 30       	cpi	r24, 0x0A	; 10
    6ae8:	c9 f4       	brne	.+50     	; 0x6b1c <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x90>
_ZN6SdFile4openEPS_PKch.part.28():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:463
  if (isOpen()) {
    return false;
  }

  if (!make83Name(fileName, dname)) {
    return false;
    6aea:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:549
    return false;
  }

  // open entry in cache
  return openCachedEntry(dirIndex_, oflag);
}
    6aec:	2b 96       	adiw	r28, 0x0b	; 11
    6aee:	0f b6       	in	r0, 0x3f	; 63
    6af0:	f8 94       	cli
    6af2:	de bf       	out	0x3e, r29	; 62
    6af4:	0f be       	out	0x3f, r0	; 63
    6af6:	cd bf       	out	0x3d, r28	; 61
    6af8:	df 91       	pop	r29
    6afa:	cf 91       	pop	r28
    6afc:	1f 91       	pop	r17
    6afe:	0f 91       	pop	r16
    6b00:	ff 90       	pop	r15
    6b02:	ef 90       	pop	r14
    6b04:	df 90       	pop	r13
    6b06:	cf 90       	pop	r12
    6b08:	bf 90       	pop	r11
    6b0a:	af 90       	pop	r10
    6b0c:	9f 90       	pop	r9
    6b0e:	8f 90       	pop	r8
    6b10:	7f 90       	pop	r7
    6b12:	6f 90       	pop	r6
    6b14:	5f 90       	pop	r5
    6b16:	4f 90       	pop	r4
    6b18:	3f 90       	pop	r3
    6b1a:	08 95       	ret
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:301
    if (c == '.') {
      if (n == 10) {
        return false;  // only one dot allowed
      }
      n = 10;  // max index for full 8.3 name
      i = 8;   // place for extension
    6b1c:	38 e0       	ldi	r19, 0x08	; 8
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:300
  while ((c = *str++) != '\0') {
    if (c == '.') {
      if (n == 10) {
        return false;  // only one dot allowed
      }
      n = 10;  // max index for full 8.3 name
    6b1e:	8a e0       	ldi	r24, 0x0A	; 10
    6b20:	db cf       	rjmp	.-74     	; 0x6ad8 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x4c>
    6b22:	e2 ec       	ldi	r30, 0xC2	; 194
    6b24:	f3 e0       	ldi	r31, 0x03	; 3
make83Name():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:307
    } else {
      // illegal FAT characters
      uint8_t b;
      #if defined(__AVR__)
      PGM_P p = PSTR("|<>^+=?/[];,*\"\\");
      while ((b = pgm_read_byte(p++))) if (b == c) {
    6b26:	44 91       	lpm	r20, Z
    6b28:	44 23       	and	r20, r20
    6b2a:	21 f0       	breq	.+8      	; 0x6b34 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0xa8>
    6b2c:	31 96       	adiw	r30, 0x01	; 1
    6b2e:	94 13       	cpse	r25, r20
    6b30:	fa cf       	rjmp	.-12     	; 0x6b26 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x9a>
    6b32:	db cf       	rjmp	.-74     	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:318
      while ((b = *p++)) if (b == c) {
          return false;
        }
      #endif
      // check size and only allow ASCII printable characters
      if (i > n || c < 0X21 || c > 0X7E) {
    6b34:	83 17       	cp	r24, r19
    6b36:	c8 f2       	brcs	.-78     	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
    6b38:	4f ed       	ldi	r20, 0xDF	; 223
    6b3a:	49 0f       	add	r20, r25
    6b3c:	4e 35       	cpi	r20, 0x5E	; 94
    6b3e:	a8 f6       	brcc	.-86     	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:322
        return false;
      }
      // only upper case allowed in 8.3 names - convert lower to upper
      name[i++] = c < 'a' || c > 'z' ?  c : c + ('A' - 'a');
    6b40:	4f e9       	ldi	r20, 0x9F	; 159
    6b42:	49 0f       	add	r20, r25
    6b44:	4a 31       	cpi	r20, 0x1A	; 26
    6b46:	18 f4       	brcc	.+6      	; 0x6b4e <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0xc2>
    6b48:	40 ee       	ldi	r20, 0xE0	; 224
    6b4a:	b4 2e       	mov	r11, r20
    6b4c:	b9 0e       	add	r11, r25
    6b4e:	f6 01       	movw	r30, r12
    6b50:	e3 0f       	add	r30, r19
    6b52:	f1 1d       	adc	r31, r1
    6b54:	b0 82       	st	Z, r11
_ZN6SdFile4openEPS_PKch.part.28():
    6b56:	3f 5f       	subi	r19, 0xFF	; 255
    6b58:	bf cf       	rjmp	.-130    	; 0x6ad8 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x4c>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:462
  // error if already open
  if (isOpen()) {
    return false;
  }

  if (!make83Name(fileName, dname)) {
    6b5a:	89 81       	ldd	r24, Y+1	; 0x01
    6b5c:	80 32       	cpi	r24, 0x20	; 32
    6b5e:	29 f2       	breq	.-118    	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
    6b60:	32 2e       	mov	r3, r18
    6b62:	8b 01       	movw	r16, r22
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:465
    return false;
  }
  vol_ = dirFile->vol_;
    6b64:	db 01       	movw	r26, r22
    6b66:	5b 96       	adiw	r26, 0x1b	; 27
    6b68:	8d 91       	ld	r24, X+
    6b6a:	9c 91       	ld	r25, X
    6b6c:	5c 97       	sbiw	r26, 0x1c	; 28
    6b6e:	f7 01       	movw	r30, r14
    6b70:	94 8f       	std	Z+28, r25	; 0x1c
    6b72:	83 8f       	std	Z+27, r24	; 0x1b
_ZN6SdFile6rewindEv():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:283
    int8_t readDir(dir_t* dir);
    static uint8_t remove(SdFile* dirFile, const char* fileName);
    uint8_t remove(void);
    /** Set the file's current position to zero. */
    void rewind(void) {
      curPosition_ = curCluster_ = 0;
    6b74:	16 96       	adiw	r26, 0x06	; 6
    6b76:	1d 92       	st	X+, r1
    6b78:	1d 92       	st	X+, r1
    6b7a:	1d 92       	st	X+, r1
    6b7c:	1c 92       	st	X, r1
    6b7e:	19 97       	sbiw	r26, 0x09	; 9
    6b80:	fb 01       	movw	r30, r22
    6b82:	12 86       	std	Z+10, r1	; 0x0a
    6b84:	13 86       	std	Z+11, r1	; 0x0b
    6b86:	14 86       	std	Z+12, r1	; 0x0c
    6b88:	15 86       	std	Z+13, r1	; 0x0d
_ZN6SdFile4openEPS_PKch.part.28():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:472

  // bool for empty entry found
  uint8_t emptyFound = false;

  // search for file
  while (dirFile->curPosition_ < dirFile->fileSize_) {
    6b8a:	f8 01       	movw	r30, r16
    6b8c:	82 85       	ldd	r24, Z+10	; 0x0a
    6b8e:	93 85       	ldd	r25, Z+11	; 0x0b
    6b90:	a4 85       	ldd	r26, Z+12	; 0x0c
    6b92:	b5 85       	ldd	r27, Z+13	; 0x0d
    6b94:	43 89       	ldd	r20, Z+19	; 0x13
    6b96:	54 89       	ldd	r21, Z+20	; 0x14
    6b98:	65 89       	ldd	r22, Z+21	; 0x15
    6b9a:	76 89       	ldd	r23, Z+22	; 0x16
    6b9c:	84 17       	cp	r24, r20
    6b9e:	95 07       	cpc	r25, r21
    6ba0:	a6 07       	cpc	r26, r22
    6ba2:	b7 07       	cpc	r27, r23
    6ba4:	08 f0       	brcs	.+2      	; 0x6ba8 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x11c>
    6ba6:	4d c0       	rjmp	.+154    	; 0x6c42 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x1b6>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:473
    uint8_t index = 0XF & (dirFile->curPosition_ >> 5);
    6ba8:	25 e0       	ldi	r18, 0x05	; 5
    6baa:	b6 95       	lsr	r27
    6bac:	a7 95       	ror	r26
    6bae:	97 95       	ror	r25
    6bb0:	87 95       	ror	r24
    6bb2:	2a 95       	dec	r18
    6bb4:	d1 f7       	brne	.-12     	; 0x6baa <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x11e>
    6bb6:	f8 2f       	mov	r31, r24
    6bb8:	ff 70       	andi	r31, 0x0F	; 15
    6bba:	af 2e       	mov	r10, r31
readDirCache():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:876
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* SdFile::readDirCache(void) {
  // error if not directory
  if (!isDir()) {
    6bbc:	d8 01       	movw	r26, r16
    6bbe:	15 96       	adiw	r26, 0x05	; 5
    6bc0:	8c 91       	ld	r24, X
    6bc2:	82 30       	cpi	r24, 0x02	; 2
    6bc4:	08 f4       	brcc	.+2      	; 0x6bc8 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x13c>
    6bc6:	91 cf       	rjmp	.-222    	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:884

  // index of entry in cache
  uint8_t i = (curPosition_ >> 5) & 0XF;

  // use read to locate and cache block
  if (read() < 0) {
    6bc8:	c8 01       	movw	r24, r16
    6bca:	0e 94 13 19 	call	0x3226	; 0x3226 <SdFile::read()>
    6bce:	97 fd       	sbrc	r25, 7
    6bd0:	8c cf       	rjmp	.-232    	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:889
    return NULL;
  }

  // advance to next entry
  curPosition_ += 31;
    6bd2:	f8 01       	movw	r30, r16
    6bd4:	82 85       	ldd	r24, Z+10	; 0x0a
    6bd6:	93 85       	ldd	r25, Z+11	; 0x0b
    6bd8:	a4 85       	ldd	r26, Z+12	; 0x0c
    6bda:	b5 85       	ldd	r27, Z+13	; 0x0d
    6bdc:	4f 96       	adiw	r24, 0x1f	; 31
    6bde:	a1 1d       	adc	r26, r1
    6be0:	b1 1d       	adc	r27, r1
    6be2:	82 87       	std	Z+10, r24	; 0x0a
    6be4:	93 87       	std	Z+11, r25	; 0x0b
    6be6:	a4 87       	std	Z+12, r26	; 0x0c
    6be8:	b5 87       	std	Z+13, r27	; 0x0d
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:892

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
    6bea:	f0 e2       	ldi	r31, 0x20	; 32
    6bec:	af 9e       	mul	r10, r31
    6bee:	b0 01       	movw	r22, r0
    6bf0:	11 24       	eor	r1, r1
    6bf2:	65 50       	subi	r22, 0x05	; 5
    6bf4:	76 4f       	sbci	r23, 0xF6	; 246
_ZN6SdFile4openEPS_PKch.part.28():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:475

  // search for file
  while (dirFile->curPosition_ < dirFile->fileSize_) {
    uint8_t index = 0XF & (dirFile->curPosition_ >> 5);
    p = dirFile->readDirCache();
    if (p == NULL) {
    6bf6:	61 15       	cp	r22, r1
    6bf8:	71 05       	cpc	r23, r1
    6bfa:	09 f4       	brne	.+2      	; 0x6bfe <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x172>
    6bfc:	76 cf       	rjmp	.-276    	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:479
      return false;
    }

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
    6bfe:	db 01       	movw	r26, r22
    6c00:	8c 91       	ld	r24, X
    6c02:	88 23       	and	r24, r24
    6c04:	41 f0       	breq	.+16     	; 0x6c16 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x18a>
    6c06:	85 3e       	cpi	r24, 0xE5	; 229
    6c08:	09 f0       	breq	.+2      	; 0x6c0c <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x180>
    6c0a:	62 c0       	rjmp	.+196    	; 0x6cd0 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x244>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:481
      // remember first empty slot
      if (!emptyFound) {
    6c0c:	bb 20       	and	r11, r11
    6c0e:	29 f0       	breq	.+10     	; 0x6c1a <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x18e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:288
}
//------------------------------------------------------------------------------
// format directory name field from a 8.3 name string
uint8_t SdFile::make83Name(const char* str, uint8_t* name) {
  uint8_t c;
  uint8_t n = 7;  // max index for part before dot
    6c10:	bb 24       	eor	r11, r11
    6c12:	b3 94       	inc	r11
    6c14:	ba cf       	rjmp	.-140    	; 0x6b8a <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0xfe>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:481
      return false;
    }

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
      // remember first empty slot
      if (!emptyFound) {
    6c16:	b1 10       	cpse	r11, r1
    6c18:	0e c0       	rjmp	.+28     	; 0x6c36 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x1aa>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:483
        emptyFound = true;
        dirIndex_ = index;
    6c1a:	f7 01       	movw	r30, r14
    6c1c:	a2 8a       	std	Z+18, r10	; 0x12
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:484
        dirBlock_ = SdVolume::cacheBlockNumber_;
    6c1e:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <SdVolume::cacheBlockNumber_>
    6c22:	90 91 15 02 	lds	r25, 0x0215	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    6c26:	a0 91 16 02 	lds	r26, 0x0216	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    6c2a:	b0 91 17 02 	lds	r27, 0x0217	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
    6c2e:	86 87       	std	Z+14, r24	; 0x0e
    6c30:	97 87       	std	Z+15, r25	; 0x0f
    6c32:	a0 8b       	std	Z+16, r26	; 0x10
    6c34:	b1 8b       	std	Z+17, r27	; 0x11
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:487
      }
      // done if no entries follow
      if (p->name[0] == DIR_NAME_FREE) {
    6c36:	db 01       	movw	r26, r22
    6c38:	8c 91       	ld	r24, X
    6c3a:	81 11       	cpse	r24, r1
    6c3c:	e9 cf       	rjmp	.-46     	; 0x6c10 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x184>
    6c3e:	bb 24       	eor	r11, r11
    6c40:	b3 94       	inc	r11
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:501
      // open found file
      return openCachedEntry(0XF & index, oflag);
    }
  }
  // only create file if O_CREAT and O_WRITE
  if ((oflag & (O_CREAT | O_WRITE)) != (O_CREAT | O_WRITE)) {
    6c42:	83 2d       	mov	r24, r3
    6c44:	82 71       	andi	r24, 0x12	; 18
    6c46:	82 31       	cpi	r24, 0x12	; 18
    6c48:	09 f0       	breq	.+2      	; 0x6c4c <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x1c0>
    6c4a:	4f cf       	rjmp	.-354    	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:506
    return false;
  }

  // cache found slot or add cluster if end of file
  if (emptyFound) {
    6c4c:	bb 20       	and	r11, r11
    6c4e:	09 f4       	brne	.+2      	; 0x6c52 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x1c6>
    6c50:	4d c0       	rjmp	.+154    	; 0x6cec <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x260>
cacheDirEntry():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:71
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) {
    6c52:	f7 01       	movw	r30, r14
    6c54:	66 85       	ldd	r22, Z+14	; 0x0e
    6c56:	77 85       	ldd	r23, Z+15	; 0x0f
    6c58:	80 89       	ldd	r24, Z+16	; 0x10
    6c5a:	91 89       	ldd	r25, Z+17	; 0x11
    6c5c:	41 e0       	ldi	r20, 0x01	; 1
    6c5e:	0e 94 11 11 	call	0x2222	; 0x2222 <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    6c62:	88 23       	and	r24, r24
    6c64:	09 f4       	brne	.+2      	; 0x6c68 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x1dc>
    6c66:	41 cf       	rjmp	.-382    	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:74
    return NULL;
  }
  return SdVolume::cacheBuffer_.dir + dirIndex_;
    6c68:	d7 01       	movw	r26, r14
    6c6a:	52 96       	adiw	r26, 0x12	; 18
    6c6c:	8c 91       	ld	r24, X
    6c6e:	b0 e2       	ldi	r27, 0x20	; 32
    6c70:	8b 9f       	mul	r24, r27
    6c72:	c0 01       	movw	r24, r0
    6c74:	11 24       	eor	r1, r1
    6c76:	85 50       	subi	r24, 0x05	; 5
    6c78:	96 4f       	sbci	r25, 0xF6	; 246
_ZN6SdFile4openEPS_PKch.part.28():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:508
  }

  // cache found slot or add cluster if end of file
  if (emptyFound) {
    p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    if (!p) {
    6c7a:	00 97       	sbiw	r24, 0x00	; 0
    6c7c:	09 f4       	brne	.+2      	; 0x6c80 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x1f4>
    6c7e:	35 cf       	rjmp	.-406    	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:526
    // use first entry in cluster
    dirIndex_ = 0;
    p = SdVolume::cacheBuffer_.dir;
  }
  // initialize as empty file
  memset(p, 0, sizeof(dir_t));
    6c80:	fc 01       	movw	r30, r24
    6c82:	3a 96       	adiw	r30, 0x0a	; 10
    6c84:	26 e1       	ldi	r18, 0x16	; 22
    6c86:	df 01       	movw	r26, r30
    6c88:	1d 92       	st	X+, r1
    6c8a:	2a 95       	dec	r18
    6c8c:	e9 f7       	brne	.-6      	; 0x6c88 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x1fc>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:527
  memcpy(p->name, dname, 11);
    6c8e:	2b e0       	ldi	r18, 0x0B	; 11
    6c90:	f6 01       	movw	r30, r12
    6c92:	dc 01       	movw	r26, r24
    6c94:	01 90       	ld	r0, Z+
    6c96:	0d 92       	st	X+, r0
    6c98:	2a 95       	dec	r18
    6c9a:	e1 f7       	brne	.-8      	; 0x6c94 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x208>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:535
  if (dateTime_) {
    // call user function
    dateTime_(&p->creationDate, &p->creationTime);
  } else {
    // use default date/time
    p->creationDate = FAT_DEFAULT_DATE;
    6c9c:	21 e2       	ldi	r18, 0x21	; 33
    6c9e:	38 e2       	ldi	r19, 0x28	; 40
    6ca0:	fc 01       	movw	r30, r24
    6ca2:	31 8b       	std	Z+17, r19	; 0x11
    6ca4:	20 8b       	std	Z+16, r18	; 0x10
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:536
    p->creationTime = FAT_DEFAULT_TIME;
    6ca6:	40 e0       	ldi	r20, 0x00	; 0
    6ca8:	58 e0       	ldi	r21, 0x08	; 8
    6caa:	57 87       	std	Z+15, r21	; 0x0f
    6cac:	46 87       	std	Z+14, r20	; 0x0e
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:538
  }
  p->lastAccessDate = p->creationDate;
    6cae:	33 8b       	std	Z+19, r19	; 0x13
    6cb0:	22 8b       	std	Z+18, r18	; 0x12
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:539
  p->lastWriteDate = p->creationDate;
    6cb2:	31 8f       	std	Z+25, r19	; 0x19
    6cb4:	20 8f       	std	Z+24, r18	; 0x18
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:540
  p->lastWriteTime = p->creationTime;
    6cb6:	57 8b       	std	Z+23, r21	; 0x17
    6cb8:	46 8b       	std	Z+22, r20	; 0x16
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:543

  // force write of entry to SD
  if (!SdVolume::cacheFlush()) {
    6cba:	81 e0       	ldi	r24, 0x01	; 1
    6cbc:	0e 94 e6 10 	call	0x21cc	; 0x21cc <SdVolume::cacheFlush(unsigned char)>
    6cc0:	88 23       	and	r24, r24
    6cc2:	09 f4       	brne	.+2      	; 0x6cc6 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x23a>
    6cc4:	12 cf       	rjmp	.-476    	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:548
    return false;
  }

  // open entry in cache
  return openCachedEntry(dirIndex_, oflag);
    6cc6:	43 2d       	mov	r20, r3
    6cc8:	d7 01       	movw	r26, r14
    6cca:	52 96       	adiw	r26, 0x12	; 18
    6ccc:	6c 91       	ld	r22, X
    6cce:	0a c0       	rjmp	.+20     	; 0x6ce4 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x258>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:490
      }
      // done if no entries follow
      if (p->name[0] == DIR_NAME_FREE) {
        break;
      }
    } else if (!memcmp(dname, p->name, 11)) {
    6cd0:	4b e0       	ldi	r20, 0x0B	; 11
    6cd2:	50 e0       	ldi	r21, 0x00	; 0
    6cd4:	c6 01       	movw	r24, r12
    6cd6:	0e 94 97 6e 	call	0xdd2e	; 0xdd2e <memcmp>
    6cda:	89 2b       	or	r24, r25
    6cdc:	09 f0       	breq	.+2      	; 0x6ce0 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x254>
    6cde:	55 cf       	rjmp	.-342    	; 0x6b8a <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0xfe>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:497
      if ((oflag & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL)) {
        return false;
      }

      // open found file
      return openCachedEntry(0XF & index, oflag);
    6ce0:	43 2d       	mov	r20, r3
    6ce2:	6a 2d       	mov	r22, r10
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:548
  if (!SdVolume::cacheFlush()) {
    return false;
  }

  // open entry in cache
  return openCachedEntry(dirIndex_, oflag);
    6ce4:	c7 01       	movw	r24, r14
    6ce6:	0e 94 3b 1e 	call	0x3c76	; 0x3c76 <SdFile::openCachedEntry(unsigned char, unsigned char)>
    6cea:	00 cf       	rjmp	.-512    	; 0x6aec <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x60>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:512
    p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    if (!p) {
      return false;
    }
  } else {
    if (dirFile->type_ == FAT_FILE_TYPE_ROOT16) {
    6cec:	f8 01       	movw	r30, r16
    6cee:	85 81       	ldd	r24, Z+5	; 0x05
    6cf0:	82 30       	cpi	r24, 0x02	; 2
    6cf2:	09 f4       	brne	.+2      	; 0x6cf6 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x26a>
    6cf4:	fa ce       	rjmp	.-524    	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
addDirCluster():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:52
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// return with first block of cluster in the cache
uint8_t SdFile::addDirCluster(void) {
  if (!addCluster()) {
    6cf6:	c8 01       	movw	r24, r16
    6cf8:	0e 94 fa 14 	call	0x29f4	; 0x29f4 <SdFile::addCluster()>
    6cfc:	88 23       	and	r24, r24
    6cfe:	09 f4       	brne	.+2      	; 0x6d02 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x276>
    6d00:	f4 ce       	rjmp	.-536    	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:57
    return false;
  }

  // zero data in cluster insure first cluster is in cache
  uint32_t block = vol_->clusterStartBlock(curCluster_);
    6d02:	d8 01       	movw	r26, r16
    6d04:	5b 96       	adiw	r26, 0x1b	; 27
    6d06:	ed 91       	ld	r30, X+
    6d08:	fc 91       	ld	r31, X
    6d0a:	5c 97       	sbiw	r26, 0x1c	; 28
_ZNK8SdVolume17clusterStartBlockEm():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:602
    uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
    uint8_t blockOfCluster(uint32_t position) const {
      return (position >> 9) & (blocksPerCluster_ - 1);
    }
    uint32_t clusterStartBlock(uint32_t cluster) const {
      return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);
    6d0c:	16 96       	adiw	r26, 0x06	; 6
    6d0e:	8d 90       	ld	r8, X+
    6d10:	9d 90       	ld	r9, X+
    6d12:	ad 90       	ld	r10, X+
    6d14:	bc 90       	ld	r11, X
    6d16:	19 97       	sbiw	r26, 0x09	; 9
    6d18:	b2 e0       	ldi	r27, 0x02	; 2
    6d1a:	8b 1a       	sub	r8, r27
    6d1c:	91 08       	sbc	r9, r1
    6d1e:	a1 08       	sbc	r10, r1
    6d20:	b1 08       	sbc	r11, r1
    6d22:	85 85       	ldd	r24, Z+13	; 0x0d
    6d24:	04 c0       	rjmp	.+8      	; 0x6d2e <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x2a2>
    6d26:	88 0c       	add	r8, r8
    6d28:	99 1c       	adc	r9, r9
    6d2a:	aa 1c       	adc	r10, r10
    6d2c:	bb 1c       	adc	r11, r11
    6d2e:	8a 95       	dec	r24
    6d30:	d2 f7       	brpl	.-12     	; 0x6d26 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x29a>
    6d32:	86 85       	ldd	r24, Z+14	; 0x0e
    6d34:	97 85       	ldd	r25, Z+15	; 0x0f
    6d36:	a0 89       	ldd	r26, Z+16	; 0x10
    6d38:	b1 89       	ldd	r27, Z+17	; 0x11
    6d3a:	88 0e       	add	r8, r24
    6d3c:	99 1e       	adc	r9, r25
    6d3e:	aa 1e       	adc	r10, r26
    6d40:	bb 1e       	adc	r11, r27
    6d42:	84 81       	ldd	r24, Z+4	; 0x04
    6d44:	24 01       	movw	r4, r8
    6d46:	35 01       	movw	r6, r10
    6d48:	48 0e       	add	r4, r24
    6d4a:	51 1c       	adc	r5, r1
    6d4c:	61 1c       	adc	r6, r1
    6d4e:	71 1c       	adc	r7, r1
addDirCluster():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:58
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
    6d50:	84 14       	cp	r8, r4
    6d52:	95 04       	cpc	r9, r5
    6d54:	a6 04       	cpc	r10, r6
    6d56:	b7 04       	cpc	r11, r7
    6d58:	09 f1       	breq	.+66     	; 0x6d9c <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x310>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:59
    if (!SdVolume::cacheZeroBlock(block + i - 1)) {
    6d5a:	e1 e0       	ldi	r30, 0x01	; 1
    6d5c:	4e 1a       	sub	r4, r30
    6d5e:	51 08       	sbc	r5, r1
    6d60:	61 08       	sbc	r6, r1
    6d62:	71 08       	sbc	r7, r1
cacheZeroBlock():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:156
  return true;
}
//------------------------------------------------------------------------------
// cache a zero block for blockNumber
uint8_t SdVolume::cacheZeroBlock(uint32_t blockNumber) {
  if (!cacheFlush()) {
    6d64:	81 e0       	ldi	r24, 0x01	; 1
    6d66:	0e 94 e6 10 	call	0x21cc	; 0x21cc <SdVolume::cacheFlush(unsigned char)>
    6d6a:	88 23       	and	r24, r24
    6d6c:	09 f4       	brne	.+2      	; 0x6d70 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x2e4>
    6d6e:	bd ce       	rjmp	.-646    	; 0x6aea <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x5e>
    6d70:	eb ef       	ldi	r30, 0xFB	; 251
    6d72:	f9 e0       	ldi	r31, 0x09	; 9
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:162
    return false;
  }

  // loop take less flash than memset(cacheBuffer_.data, 0, 512);
  for (uint16_t i = 0; i < 512; i++) {
    cacheBuffer_.data[i] = 0;
    6d74:	11 92       	st	Z+, r1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:161
  if (!cacheFlush()) {
    return false;
  }

  // loop take less flash than memset(cacheBuffer_.data, 0, 512);
  for (uint16_t i = 0; i < 512; i++) {
    6d76:	8b ef       	ldi	r24, 0xFB	; 251
    6d78:	9b e0       	ldi	r25, 0x0B	; 11
    6d7a:	8e 17       	cp	r24, r30
    6d7c:	9f 07       	cpc	r25, r31
    6d7e:	d1 f7       	brne	.-12     	; 0x6d74 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x2e8>
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdVolume.cpp:164
    cacheBuffer_.data[i] = 0;
  }
  cacheBlockNumber_ = blockNumber;
    6d80:	40 92 14 02 	sts	0x0214, r4	; 0x800214 <SdVolume::cacheBlockNumber_>
    6d84:	50 92 15 02 	sts	0x0215, r5	; 0x800215 <SdVolume::cacheBlockNumber_+0x1>
    6d88:	60 92 16 02 	sts	0x0216, r6	; 0x800216 <SdVolume::cacheBlockNumber_+0x2>
    6d8c:	70 92 17 02 	sts	0x0217, r7	; 0x800217 <SdVolume::cacheBlockNumber_+0x3>
cacheSetDirty():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:611
    }
    static uint8_t cacheFlush(uint8_t blocking = 1);
    static uint8_t cacheMirrorBlockFlush(uint8_t blocking);
    static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
    static void cacheSetDirty(void) {
      cacheDirty_ |= CACHE_FOR_WRITE;
    6d90:	80 91 cb 09 	lds	r24, 0x09CB	; 0x8009cb <SdVolume::cacheDirty_>
    6d94:	81 60       	ori	r24, 0x01	; 1
    6d96:	80 93 cb 09 	sts	0x09CB, r24	; 0x8009cb <SdVolume::cacheDirty_>
    6d9a:	da cf       	rjmp	.-76     	; 0x6d50 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x2c4>
addDirCluster():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:64
      return false;
    }
  }
  // Increase directory file size by cluster size
  fileSize_ += 512UL << vol_->clusterSizeShift_;
    6d9c:	d8 01       	movw	r26, r16
    6d9e:	5b 96       	adiw	r26, 0x1b	; 27
    6da0:	ed 91       	ld	r30, X+
    6da2:	fc 91       	ld	r31, X
    6da4:	25 85       	ldd	r18, Z+13	; 0x0d
    6da6:	80 e0       	ldi	r24, 0x00	; 0
    6da8:	92 e0       	ldi	r25, 0x02	; 2
    6daa:	a0 e0       	ldi	r26, 0x00	; 0
    6dac:	b0 e0       	ldi	r27, 0x00	; 0
    6dae:	04 c0       	rjmp	.+8      	; 0x6db8 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x32c>
    6db0:	88 0f       	add	r24, r24
    6db2:	99 1f       	adc	r25, r25
    6db4:	aa 1f       	adc	r26, r26
    6db6:	bb 1f       	adc	r27, r27
    6db8:	2a 95       	dec	r18
    6dba:	d2 f7       	brpl	.-12     	; 0x6db0 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x324>
    6dbc:	f8 01       	movw	r30, r16
    6dbe:	43 89       	ldd	r20, Z+19	; 0x13
    6dc0:	54 89       	ldd	r21, Z+20	; 0x14
    6dc2:	65 89       	ldd	r22, Z+21	; 0x15
    6dc4:	76 89       	ldd	r23, Z+22	; 0x16
    6dc6:	84 0f       	add	r24, r20
    6dc8:	95 1f       	adc	r25, r21
    6dca:	a6 1f       	adc	r26, r22
    6dcc:	b7 1f       	adc	r27, r23
    6dce:	83 8b       	std	Z+19, r24	; 0x13
    6dd0:	94 8b       	std	Z+20, r25	; 0x14
    6dd2:	a5 8b       	std	Z+21, r26	; 0x15
    6dd4:	b6 8b       	std	Z+22, r27	; 0x16
_ZN6SdFile4openEPS_PKch.part.28():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:522
    if (!dirFile->addDirCluster()) {
      return false;
    }

    // use first entry in cluster
    dirIndex_ = 0;
    6dd6:	d7 01       	movw	r26, r14
    6dd8:	52 96       	adiw	r26, 0x12	; 18
    6dda:	1c 92       	st	X, r1
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:523
    p = SdVolume::cacheBuffer_.dir;
    6ddc:	8b ef       	ldi	r24, 0xFB	; 251
    6dde:	99 e0       	ldi	r25, 0x09	; 9
    6de0:	4f cf       	rjmp	.-354    	; 0x6c80 <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]+0x1f4>

00006de2 <SDLib::File::File(SdFile, char const*)>:
__base_ctor ():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:21

/* for debugging file open/close leaks
   uint8_t nfilecount=0;
*/

File::File(SdFile f, const char *n) {
    6de2:	ef 92       	push	r14
    6de4:	ff 92       	push	r15
    6de6:	0f 93       	push	r16
    6de8:	1f 93       	push	r17
    6dea:	cf 93       	push	r28
    6dec:	df 93       	push	r29
    6dee:	ec 01       	movw	r28, r24
    6df0:	7b 01       	movw	r14, r22
    6df2:	8a 01       	movw	r16, r20
_ZN5PrintC2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:46
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    6df4:	1b 82       	std	Y+3, r1	; 0x03
    6df6:	1a 82       	std	Y+2, r1	; 0x02
_ZN6StreamC2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Stream.h:63
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    6df8:	88 ee       	ldi	r24, 0xE8	; 232
    6dfa:	93 e0       	ldi	r25, 0x03	; 3
    6dfc:	a0 e0       	ldi	r26, 0x00	; 0
    6dfe:	b0 e0       	ldi	r27, 0x00	; 0
    6e00:	8c 83       	std	Y+4, r24	; 0x04
    6e02:	9d 83       	std	Y+5, r25	; 0x05
    6e04:	ae 83       	std	Y+6, r26	; 0x06
    6e06:	bf 83       	std	Y+7, r27	; 0x07
__base_ctor ():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:21
    6e08:	87 e3       	ldi	r24, 0x37	; 55
    6e0a:	93 e0       	ldi	r25, 0x03	; 3
    6e0c:	99 83       	std	Y+1, r25	; 0x01
    6e0e:	88 83       	st	Y, r24
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:23
  // oh man you are kidding me, new() doesn't exist? Ok we do it by hand!
  _file = (SdFile *)malloc(sizeof(SdFile));
    6e10:	8d e1       	ldi	r24, 0x1D	; 29
    6e12:	90 e0       	ldi	r25, 0x00	; 0
    6e14:	0e 94 d8 62 	call	0xc5b0	; 0xc5b0 <malloc>
    6e18:	9a 8f       	std	Y+26, r25	; 0x1a
    6e1a:	89 8f       	std	Y+25, r24	; 0x19
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:24
  if (_file) {
    6e1c:	00 97       	sbiw	r24, 0x00	; 0
    6e1e:	79 f0       	breq	.+30     	; 0x6e3e <SDLib::File::File(SdFile, char const*)+0x5c>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:25
    memcpy(_file, &f, sizeof(SdFile));
    6e20:	2d e1       	ldi	r18, 0x1D	; 29
    6e22:	f7 01       	movw	r30, r14
    6e24:	dc 01       	movw	r26, r24
    6e26:	01 90       	ld	r0, Z+
    6e28:	0d 92       	st	X+, r0
    6e2a:	2a 95       	dec	r18
    6e2c:	e1 f7       	brne	.-8      	; 0x6e26 <SDLib::File::File(SdFile, char const*)+0x44>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:27

    strncpy(_name, n, 12);
    6e2e:	4c e0       	ldi	r20, 0x0C	; 12
    6e30:	50 e0       	ldi	r21, 0x00	; 0
    6e32:	b8 01       	movw	r22, r16
    6e34:	ce 01       	movw	r24, r28
    6e36:	0c 96       	adiw	r24, 0x0c	; 12
    6e38:	0e 94 cf 6e 	call	0xdd9e	; 0xdd9e <strncpy>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:28
    _name[12] = 0;
    6e3c:	18 8e       	std	Y+24, r1	; 0x18
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:38
       Serial.print(n);
       Serial.print("\": ");
       Serial.println(nfilecount, DEC);
    */
  }
}
    6e3e:	df 91       	pop	r29
    6e40:	cf 91       	pop	r28
    6e42:	1f 91       	pop	r17
    6e44:	0f 91       	pop	r16
    6e46:	ff 90       	pop	r15
    6e48:	ef 90       	pop	r14
    6e4a:	08 95       	ret

00006e4c <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]>:
open():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:432
    // parent is now the parent directory of the file!
    return *parent;
  }


  File SDClass::open(const char *filepath, uint8_t mode) {
    6e4c:	2f 92       	push	r2
    6e4e:	3f 92       	push	r3
    6e50:	4f 92       	push	r4
    6e52:	5f 92       	push	r5
    6e54:	6f 92       	push	r6
    6e56:	7f 92       	push	r7
    6e58:	8f 92       	push	r8
    6e5a:	9f 92       	push	r9
    6e5c:	af 92       	push	r10
    6e5e:	bf 92       	push	r11
    6e60:	cf 92       	push	r12
    6e62:	df 92       	push	r13
    6e64:	ef 92       	push	r14
    6e66:	ff 92       	push	r15
    6e68:	0f 93       	push	r16
    6e6a:	1f 93       	push	r17
    6e6c:	cf 93       	push	r28
    6e6e:	df 93       	push	r29
    6e70:	cd b7       	in	r28, 0x3d	; 61
    6e72:	de b7       	in	r29, 0x3e	; 62
    6e74:	c4 56       	subi	r28, 0x64	; 100
    6e76:	d1 09       	sbc	r29, r1
    6e78:	0f b6       	in	r0, 0x3f	; 63
    6e7a:	f8 94       	cli
    6e7c:	de bf       	out	0x3e, r29	; 62
    6e7e:	0f be       	out	0x3f, r0	; 63
    6e80:	cd bf       	out	0x3d, r28	; 61
    6e82:	5c 01       	movw	r10, r24
_ZN5PrintC2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:46
    6e84:	19 a2       	std	Y+33, r1	; 0x21
    6e86:	18 a2       	std	Y+32, r1	; 0x20
_ZN6SdFileC2Ev():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:154
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
    6e88:	8d e0       	ldi	r24, 0x0D	; 13
    6e8a:	93 e0       	ldi	r25, 0x03	; 3
    6e8c:	9f 8f       	std	Y+31, r25	; 0x1f
    6e8e:	8e 8f       	std	Y+30, r24	; 0x1e
    6e90:	1b a2       	std	Y+35, r1	; 0x23
_ZN5PrintC2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:46
    6e92:	1c 82       	std	Y+4, r1	; 0x04
    6e94:	1b 82       	std	Y+3, r1	; 0x03
_ZN6SdFileC2Ev():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:154
    6e96:	9a 83       	std	Y+2, r25	; 0x02
    6e98:	89 83       	std	Y+1, r24	; 0x01
    6e9a:	1e 82       	std	Y+6, r1	; 0x06
openRoot():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:395
    uint8_t open(SdFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT
      return open(&dirFile, index, oflag);
    }
    /** \deprecated Use: uint8_t SdFile::openRoot(SdVolume* vol); */
    uint8_t openRoot(SdVolume& vol) {
      return openRoot(&vol); // NOLINT
    6e9c:	4e 01       	movw	r8, r28
    6e9e:	8e e1       	ldi	r24, 0x1E	; 30
    6ea0:	88 0e       	add	r8, r24
    6ea2:	91 1c       	adc	r9, r1
    6ea4:	c4 01       	movw	r24, r8
    6ea6:	0e 94 12 14 	call	0x2824	; 0x2824 <SdFile::openRoot(SdVolume*) [clone .constprop.152]>
open():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:382

    d1.openRoot(volume); // start with the mostparent, root!

    // we'll use the pointers to swap between the two objects
    SdFile *parent = &d1;
    SdFile *subdir = &d2;
    6eaa:	8e 01       	movw	r16, r28
    6eac:	0f 5f       	subi	r16, 0xFF	; 255
    6eae:	1f 4f       	sbci	r17, 0xFF	; 255
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:381
    SdFile d2;

    d1.openRoot(volume); // start with the mostparent, root!

    // we'll use the pointers to swap between the two objects
    SdFile *parent = &d1;
    6eb0:	24 01       	movw	r4, r8
openRoot():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:395
    6eb2:	8e e8       	ldi	r24, 0x8E	; 142
    6eb4:	c8 2e       	mov	r12, r24
    6eb6:	82 e0       	ldi	r24, 0x02	; 2
    6eb8:	d8 2e       	mov	r13, r24
    6eba:	18 01       	movw	r2, r16
getParentDir():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:386
    SdFile *subdir = &d2;

    const char *origpath = filepath;

    while (strchr(filepath, '/')) {
    6ebc:	6f e2       	ldi	r22, 0x2F	; 47
    6ebe:	70 e0       	ldi	r23, 0x00	; 0
    6ec0:	c6 01       	movw	r24, r12
    6ec2:	0e 94 b4 6e 	call	0xdd68	; 0xdd68 <strchr>
    6ec6:	00 97       	sbiw	r24, 0x00	; 0
    6ec8:	09 f4       	brne	.+2      	; 0x6ecc <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0x80>
    6eca:	5a c0       	rjmp	.+180    	; 0x6f80 <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0x134>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:389

      // get rid of leading /'s
      if (filepath[0] == '/') {
    6ecc:	f6 01       	movw	r30, r12
    6ece:	20 81       	ld	r18, Z
    6ed0:	2f 32       	cpi	r18, 0x2F	; 47
    6ed2:	71 f4       	brne	.+28     	; 0x6ef0 <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0xa4>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:390
        filepath++;
    6ed4:	ff ef       	ldi	r31, 0xFF	; 255
    6ed6:	cf 1a       	sub	r12, r31
    6ed8:	df 0a       	sbc	r13, r31
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:391
        continue;
    6eda:	90 2f       	mov	r25, r16
    6edc:	81 2f       	mov	r24, r17
    6ede:	82 01       	movw	r16, r4
    6ee0:	49 2e       	mov	r4, r25
    6ee2:	58 2e       	mov	r5, r24
    6ee4:	94 2d       	mov	r25, r4
    6ee6:	85 2d       	mov	r24, r5
    6ee8:	28 01       	movw	r4, r16
    6eea:	09 2f       	mov	r16, r25
    6eec:	18 2f       	mov	r17, r24
    6eee:	e6 cf       	rjmp	.-52     	; 0x6ebc <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0x70>
    6ef0:	8c 19       	sub	r24, r12
    6ef2:	8d 30       	cpi	r24, 0x0D	; 13
    6ef4:	08 f0       	brcs	.+2      	; 0x6ef8 <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0xac>
    6ef6:	8c e0       	ldi	r24, 0x0C	; 12
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:405
      uint8_t idx = strchr(filepath, '/') - filepath;
      if (idx > 12) {
        idx = 12;  // don't let them specify long names
      }
      char subdirname[13];
      strncpy(subdirname, filepath, idx);
    6ef8:	e8 2e       	mov	r14, r24
    6efa:	f1 2c       	mov	r15, r1
    6efc:	a7 01       	movw	r20, r14
    6efe:	b6 01       	movw	r22, r12
    6f00:	ce 01       	movw	r24, r28
    6f02:	88 5a       	subi	r24, 0xA8	; 168
    6f04:	9f 4f       	sbci	r25, 0xFF	; 255
    6f06:	0e 94 cf 6e 	call	0xdd9e	; 0xdd9e <strncpy>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:406
      subdirname[idx] = 0;
    6f0a:	e8 e5       	ldi	r30, 0x58	; 88
    6f0c:	f0 e0       	ldi	r31, 0x00	; 0
    6f0e:	ec 0f       	add	r30, r28
    6f10:	fd 1f       	adc	r31, r29
    6f12:	ee 0d       	add	r30, r14
    6f14:	ff 1d       	adc	r31, r15
    6f16:	10 82       	st	Z, r1
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:409

      // close the subdir (we reuse them) if open
      subdir->close();
    6f18:	c8 01       	movw	r24, r16
    6f1a:	0e 94 9e 16 	call	0x2d3c	; 0x2d3c <SdFile::close()>
open():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:458
uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag) {
  uint8_t dname[11];
  dir_t* p;

  // error if already open
  if (isOpen()) {
    6f1e:	f8 01       	movw	r30, r16
    6f20:	85 81       	ldd	r24, Z+5	; 0x05
    6f22:	88 23       	and	r24, r24
    6f24:	e9 f0       	breq	.+58     	; 0x6f60 <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0x114>
_ZN5PrintC2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:46
    6f26:	1e ae       	std	Y+62, r1	; 0x3e
    6f28:	1d ae       	std	Y+61, r1	; 0x3d
_ZN6SdFileC2Ev():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:154
   \brief Access FAT16 and FAT32 files on SD and SDHC cards.
*/
class SdFile : public Print {
  public:
    /** Create an instance of SdFile. */
    SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
    6f2a:	8d e0       	ldi	r24, 0x0D	; 13
    6f2c:	93 e0       	ldi	r25, 0x03	; 3
    6f2e:	9c af       	std	Y+60, r25	; 0x3c
    6f30:	8b af       	std	Y+59, r24	; 0x3b
    6f32:	21 96       	adiw	r28, 0x01	; 1
    6f34:	1f ae       	std	Y+63, r1	; 0x3f
    6f36:	21 97       	sbiw	r28, 0x01	; 1
open():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:462

    // do the interactive search
    SdFile parentdir = getParentDir(filepath, &pathidx);
    // no more subdirs!

    filepath += pathidx;
    6f38:	83 01       	movw	r16, r6
    6f3a:	02 57       	subi	r16, 0x72	; 114
    6f3c:	1d 4f       	sbci	r17, 0xFD	; 253
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:464

    if (! filepath[0]) {
    6f3e:	f8 01       	movw	r30, r16
    6f40:	80 81       	ld	r24, Z
    6f42:	81 11       	cpse	r24, r1
    6f44:	27 c0       	rjmp	.+78     	; 0x6f94 <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0x148>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:466
      // it was the directory itself!
      return File(parentdir, "/");
    6f46:	be 01       	movw	r22, r28
    6f48:	65 5c       	subi	r22, 0xC5	; 197
    6f4a:	7f 4f       	sbci	r23, 0xFF	; 255
    6f4c:	c1 01       	movw	r24, r2
    6f4e:	0e 94 57 18 	call	0x30ae	; 0x30ae <SdFile::SdFile(SdFile const&)>
    6f52:	4f e7       	ldi	r20, 0x7F	; 127
    6f54:	54 e0       	ldi	r21, 0x04	; 4
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:486
    parentdir.close();

    if ((mode & (O_APPEND | O_WRITE)) == (O_APPEND | O_WRITE)) {
      file.seekSet(file.fileSize());
    }
    return File(file, filepath);
    6f56:	b1 01       	movw	r22, r2
    6f58:	c5 01       	movw	r24, r10
    6f5a:	0e 94 f1 36 	call	0x6de2	; 0x6de2 <SDLib::File::File(SdFile, char const*)>
    6f5e:	38 c0       	rjmp	.+112    	; 0x6fd0 <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0x184>
    6f60:	21 e0       	ldi	r18, 0x01	; 1
    6f62:	ae 01       	movw	r20, r28
    6f64:	48 5a       	subi	r20, 0xA8	; 168
    6f66:	5f 4f       	sbci	r21, 0xFF	; 255
    6f68:	b2 01       	movw	r22, r4
    6f6a:	c8 01       	movw	r24, r16
    6f6c:	0e 94 46 35 	call	0x6a8c	; 0x6a8c <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]>
getParentDir():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:410
      strncpy(subdirname, filepath, idx);
      subdirname[idx] = 0;

      // close the subdir (we reuse them) if open
      subdir->close();
      if (! subdir->open(parent, subdirname, O_READ)) {
    6f70:	88 23       	and	r24, r24
    6f72:	c9 f2       	breq	.-78     	; 0x6f26 <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0xda>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:415
        // failed to open one of the subdirectories
        return SdFile();
      }
      // move forward to the next subdirectory
      filepath += idx;
    6f74:	ce 0c       	add	r12, r14
    6f76:	df 1c       	adc	r13, r15
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:418

      // we reuse the objects, close it.
      parent->close();
    6f78:	c2 01       	movw	r24, r4
    6f7a:	0e 94 9e 16 	call	0x2d3c	; 0x2d3c <SdFile::close()>
    6f7e:	b2 cf       	rjmp	.-156    	; 0x6ee4 <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0x98>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:426
      SdFile *t = parent;
      parent = subdir;
      subdir = t;
    }

    *index = (int)(filepath - origpath);
    6f80:	c6 01       	movw	r24, r12
    6f82:	8e 58       	subi	r24, 0x8E	; 142
    6f84:	92 40       	sbci	r25, 0x02	; 2
    6f86:	3c 01       	movw	r6, r24
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:428
    // parent is now the parent directory of the file!
    return *parent;
    6f88:	b2 01       	movw	r22, r4
    6f8a:	ce 01       	movw	r24, r28
    6f8c:	cb 96       	adiw	r24, 0x3b	; 59
    6f8e:	0e 94 57 18 	call	0x30ae	; 0x30ae <SdFile::SdFile(SdFile const&)>
    6f92:	d2 cf       	rjmp	.-92     	; 0x6f38 <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0xec>
_ZN5PrintC2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:46
    6f94:	19 a2       	std	Y+33, r1	; 0x21
    6f96:	18 a2       	std	Y+32, r1	; 0x20
_ZN6SdFileC2Ev():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:154
    6f98:	8d e0       	ldi	r24, 0x0D	; 13
    6f9a:	93 e0       	ldi	r25, 0x03	; 3
    6f9c:	9f 8f       	std	Y+31, r25	; 0x1f
    6f9e:	8e 8f       	std	Y+30, r24	; 0x1e
    6fa0:	1b a2       	std	Y+35, r1	; 0x23
open():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:473

    // Open the file itself
    SdFile file;

    // failed to open a subdir!
    if (!parentdir.isOpen()) {
    6fa2:	21 96       	adiw	r28, 0x01	; 1
    6fa4:	8f ad       	ldd	r24, Y+63	; 0x3f
    6fa6:	21 97       	sbiw	r28, 0x01	; 1
    6fa8:	81 11       	cpse	r24, r1
    6faa:	2d c0       	rjmp	.+90     	; 0x7006 <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0x1ba>
_ZN5PrintC2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:46
    6fac:	f5 01       	movw	r30, r10
    6fae:	13 82       	std	Z+3, r1	; 0x03
    6fb0:	12 82       	std	Z+2, r1	; 0x02
_ZN6StreamC2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Stream.h:63
    6fb2:	88 ee       	ldi	r24, 0xE8	; 232
    6fb4:	93 e0       	ldi	r25, 0x03	; 3
    6fb6:	a0 e0       	ldi	r26, 0x00	; 0
    6fb8:	b0 e0       	ldi	r27, 0x00	; 0
    6fba:	84 83       	std	Z+4, r24	; 0x04
    6fbc:	95 83       	std	Z+5, r25	; 0x05
    6fbe:	a6 83       	std	Z+6, r26	; 0x06
    6fc0:	b7 83       	std	Z+7, r27	; 0x07
__base_ctor ():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:40

File::File(void) {
    6fc2:	87 e3       	ldi	r24, 0x37	; 55
    6fc4:	93 e0       	ldi	r25, 0x03	; 3
    6fc6:	91 83       	std	Z+1, r25	; 0x01
    6fc8:	80 83       	st	Z, r24
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:41
  _file = 0;
    6fca:	12 8e       	std	Z+26, r1	; 0x1a
    6fcc:	11 8e       	std	Z+25, r1	; 0x19
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:42
  _name[0] = 0;
    6fce:	14 86       	std	Z+12, r1	; 0x0c
open():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:487

    if ((mode & (O_APPEND | O_WRITE)) == (O_APPEND | O_WRITE)) {
      file.seekSet(file.fileSize());
    }
    return File(file, filepath);
  }
    6fd0:	c5 01       	movw	r24, r10
    6fd2:	cc 59       	subi	r28, 0x9C	; 156
    6fd4:	df 4f       	sbci	r29, 0xFF	; 255
    6fd6:	0f b6       	in	r0, 0x3f	; 63
    6fd8:	f8 94       	cli
    6fda:	de bf       	out	0x3e, r29	; 62
    6fdc:	0f be       	out	0x3f, r0	; 63
    6fde:	cd bf       	out	0x3d, r28	; 61
    6fe0:	df 91       	pop	r29
    6fe2:	cf 91       	pop	r28
    6fe4:	1f 91       	pop	r17
    6fe6:	0f 91       	pop	r16
    6fe8:	ff 90       	pop	r15
    6fea:	ef 90       	pop	r14
    6fec:	df 90       	pop	r13
    6fee:	cf 90       	pop	r12
    6ff0:	bf 90       	pop	r11
    6ff2:	af 90       	pop	r10
    6ff4:	9f 90       	pop	r9
    6ff6:	8f 90       	pop	r8
    6ff8:	7f 90       	pop	r7
    6ffa:	6f 90       	pop	r6
    6ffc:	5f 90       	pop	r5
    6ffe:	4f 90       	pop	r4
    7000:	3f 90       	pop	r3
    7002:	2f 90       	pop	r2
    7004:	08 95       	ret
    7006:	27 e1       	ldi	r18, 0x17	; 23
    7008:	a8 01       	movw	r20, r16
    700a:	be 01       	movw	r22, r28
    700c:	65 5c       	subi	r22, 0xC5	; 197
    700e:	7f 4f       	sbci	r23, 0xFF	; 255
    7010:	c4 01       	movw	r24, r8
    7012:	0e 94 46 35 	call	0x6a8c	; 0x6a8c <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:477
    // failed to open a subdir!
    if (!parentdir.isOpen()) {
      return File();
    }

    if (! file.open(parentdir, filepath, mode)) {
    7016:	88 23       	and	r24, r24
    7018:	49 f2       	breq	.-110    	; 0x6fac <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0x160>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:481
      return File();
    }
    // close the parent
    parentdir.close();
    701a:	ce 01       	movw	r24, r28
    701c:	cb 96       	adiw	r24, 0x3b	; 59
    701e:	0e 94 9e 16 	call	0x2d3c	; 0x2d3c <SdFile::close()>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:484

    if ((mode & (O_APPEND | O_WRITE)) == (O_APPEND | O_WRITE)) {
      file.seekSet(file.fileSize());
    7022:	49 a9       	ldd	r20, Y+49	; 0x31
    7024:	5a a9       	ldd	r21, Y+50	; 0x32
    7026:	6b a9       	ldd	r22, Y+51	; 0x33
    7028:	7c a9       	ldd	r23, Y+52	; 0x34
    702a:	c4 01       	movw	r24, r8
    702c:	0e 94 66 14 	call	0x28cc	; 0x28cc <SdFile::seekSet(unsigned long)>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:486
    }
    return File(file, filepath);
    7030:	b4 01       	movw	r22, r8
    7032:	c1 01       	movw	r24, r2
    7034:	0e 94 57 18 	call	0x30ae	; 0x30ae <SdFile::SdFile(SdFile const&)>
    7038:	a8 01       	movw	r20, r16
    703a:	8d cf       	rjmp	.-230    	; 0x6f56 <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]+0x10a>

0000703c <File_check_exists()>:
File_check_exists():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:81
}
void getFilename(char *filename) {      //File Name Set As : IDYYMMDD.csv !!Warning!! Filename should alway be "8digits".csv
	sprintf(filename, "%02X%02d%02d%02d.csv", device_ID, year % 100, month, day);
	return;
}
void File_check_exists() {              //Check wether there is already the same filename's file exsit. If not, creat new one.=======
    703c:	7f 92       	push	r7
    703e:	8f 92       	push	r8
    7040:	9f 92       	push	r9
    7042:	af 92       	push	r10
    7044:	bf 92       	push	r11
    7046:	cf 92       	push	r12
    7048:	df 92       	push	r13
    704a:	ef 92       	push	r14
    704c:	ff 92       	push	r15
    704e:	0f 93       	push	r16
    7050:	1f 93       	push	r17
    7052:	cf 93       	push	r28
    7054:	df 93       	push	r29
    7056:	cd b7       	in	r28, 0x3d	; 61
    7058:	de b7       	in	r29, 0x3e	; 62
    705a:	c4 56       	subi	r28, 0x64	; 100
    705c:	d1 09       	sbc	r29, r1
    705e:	0f b6       	in	r0, 0x3f	; 63
    7060:	f8 94       	cli
    7062:	de bf       	out	0x3e, r29	; 62
    7064:	0f be       	out	0x3f, r0	; 63
    7066:	cd bf       	out	0x3d, r28	; 61
_ZN5PrintC2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:46
    7068:	1e ae       	std	Y+62, r1	; 0x3e
    706a:	1d ae       	std	Y+61, r1	; 0x3d
_ZN6SdFileC2Ev():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:154
    706c:	8d e0       	ldi	r24, 0x0D	; 13
    706e:	93 e0       	ldi	r25, 0x03	; 3
    7070:	9c af       	std	Y+60, r25	; 0x3c
    7072:	8b af       	std	Y+59, r24	; 0x3b
    7074:	21 96       	adiw	r28, 0x01	; 1
    7076:	1f ae       	std	Y+63, r1	; 0x3f
    7078:	21 97       	sbiw	r28, 0x01	; 1
_ZN5PrintC2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:46
    707a:	19 a2       	std	Y+33, r1	; 0x21
    707c:	18 a2       	std	Y+32, r1	; 0x20
_ZN6SdFileC2Ev():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:154
    707e:	9f 8f       	std	Y+31, r25	; 0x1f
    7080:	8e 8f       	std	Y+30, r24	; 0x1e
    7082:	1b a2       	std	Y+35, r1	; 0x23
walkPath():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:160
    SdFile subfile1;
    SdFile subfile2;

    char buffer[PATH_COMPONENT_BUFFER_LEN];

    unsigned int offset = 0;
    7084:	91 2c       	mov	r9, r1
    7086:	81 2c       	mov	r8, r1
File_check_exists():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:167
    SdFile *p_parent;
    SdFile *p_child;

    SdFile *p_tmp_sdfile;

    p_child = &subfile1;
    7088:	7e 01       	movw	r14, r28
    708a:	8b e3       	ldi	r24, 0x3B	; 59
    708c:	e8 0e       	add	r14, r24
    708e:	f1 1c       	adc	r15, r1
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:169

    p_parent = &parentDir;
    7090:	0d e1       	ldi	r16, 0x1D	; 29
    7092:	1f e0       	ldi	r17, 0x0F	; 15
_ZN6SdFileC2Ev():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:154
    7094:	8d e0       	ldi	r24, 0x0D	; 13
    7096:	a8 2e       	mov	r10, r24
    7098:	83 e0       	ldi	r24, 0x03	; 3
    709a:	b8 2e       	mov	r11, r24
getNextPathComponent():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:91
    // TODO: Have buffer local to this function, so we know it's the
    //       correct length?

    int bufferOffset = 0;

    int offset = *p_offset;
    709c:	89 2d       	mov	r24, r9
    709e:	98 2d       	mov	r25, r8
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:94

    // Skip root or other separator
    if (path[offset] == '/') {
    70a0:	fc 01       	movw	r30, r24
    70a2:	e2 57       	subi	r30, 0x72	; 114
    70a4:	fd 4f       	sbci	r31, 0xFD	; 253
    70a6:	20 81       	ld	r18, Z
    70a8:	2f 32       	cpi	r18, 0x2F	; 47
    70aa:	09 f4       	brne	.+2      	; 0x70ae <File_check_exists()+0x72>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:95
      offset++;
    70ac:	01 96       	adiw	r24, 0x01	; 1
    70ae:	dc 01       	movw	r26, r24
    70b0:	a2 57       	subi	r26, 0x72	; 114
    70b2:	bd 4f       	sbci	r27, 0xFD	; 253
    70b4:	fe 01       	movw	r30, r28
    70b6:	e8 5a       	subi	r30, 0xA8	; 168
    70b8:	ff 4f       	sbci	r31, 0xFF	; 255
File_check_exists():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:169

    SdFile *p_tmp_sdfile;

    p_child = &subfile1;

    p_parent = &parentDir;
    70ba:	30 e0       	ldi	r19, 0x00	; 0
    70bc:	20 e0       	ldi	r18, 0x00	; 0
    70be:	6f 01       	movw	r12, r30
getNextPathComponent():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:100
      offset++;
    }

    // Copy the next next path segment
    while (bufferOffset < MAX_COMPONENT_LEN
           && (path[offset] != '/')
    70c0:	4d 91       	ld	r20, X+
    70c2:	4f 32       	cpi	r20, 0x2F	; 47
    70c4:	49 f0       	breq	.+18     	; 0x70d8 <File_check_exists()+0x9c>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:101
           && (path[offset] != '\0')) {
    70c6:	44 23       	and	r20, r20
    70c8:	39 f0       	breq	.+14     	; 0x70d8 <File_check_exists()+0x9c>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:102
      buffer[bufferOffset++] = path[offset++];
    70ca:	01 96       	adiw	r24, 0x01	; 1
    70cc:	2f 5f       	subi	r18, 0xFF	; 255
    70ce:	3f 4f       	sbci	r19, 0xFF	; 255
    70d0:	41 93       	st	Z+, r20
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:101
    }

    // Copy the next next path segment
    while (bufferOffset < MAX_COMPONENT_LEN
           && (path[offset] != '/')
           && (path[offset] != '\0')) {
    70d2:	2c 30       	cpi	r18, 0x0C	; 12
    70d4:	31 05       	cpc	r19, r1
    70d6:	a1 f7       	brne	.-24     	; 0x70c0 <File_check_exists()+0x84>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:105
      buffer[bufferOffset++] = path[offset++];
    }

    buffer[bufferOffset] = '\0';
    70d8:	2c 0d       	add	r18, r12
    70da:	3d 1d       	adc	r19, r13
    70dc:	f9 01       	movw	r30, r18
    70de:	10 82       	st	Z, r1
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:109

    // Skip trailing separator so we can determine if this
    // is the last component in the path or not.
    if (path[offset] == '/') {
    70e0:	fc 01       	movw	r30, r24
    70e2:	e2 57       	subi	r30, 0x72	; 114
    70e4:	fd 4f       	sbci	r31, 0xFD	; 253
    70e6:	20 81       	ld	r18, Z
    70e8:	2f 32       	cpi	r18, 0x2F	; 47
    70ea:	09 f4       	brne	.+2      	; 0x70ee <File_check_exists()+0xb2>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:110
      offset++;
    70ec:	01 96       	adiw	r24, 0x01	; 1
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:113
    }

    *p_offset = offset;
    70ee:	98 2e       	mov	r9, r24
    70f0:	89 2e       	mov	r8, r25
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:115

    return (path[offset] != '\0');
    70f2:	82 57       	subi	r24, 0x72	; 114
    70f4:	9d 4f       	sbci	r25, 0xFD	; 253
    70f6:	fc 01       	movw	r30, r24
    70f8:	70 80       	ld	r7, Z
_ZN5PrintC2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.h:46
    70fa:	1c 82       	std	Y+4, r1	; 0x04
    70fc:	1b 82       	std	Y+3, r1	; 0x03
_ZN6SdFileC2Ev():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFat.h:154
    70fe:	ba 82       	std	Y+2, r11	; 0x02
    7100:	a9 82       	std	Y+1, r10	; 0x01
    7102:	1e 82       	std	Y+6, r1	; 0x06
open():
    7104:	21 e0       	ldi	r18, 0x01	; 1
    7106:	a6 01       	movw	r20, r12
    7108:	b8 01       	movw	r22, r16
    710a:	ce 01       	movw	r24, r28
    710c:	01 96       	adiw	r24, 0x01	; 1
    710e:	0e 94 46 35 	call	0x6a8c	; 0x6a8c <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]>
callback_pathExists():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:249
    */
    SdFile child;

    boolean exists = child.open(parentDir, filePathComponent, O_RDONLY);

    if (exists) {
    7112:	88 23       	and	r24, r24
    7114:	09 f4       	brne	.+2      	; 0x7118 <File_check_exists()+0xdc>
    7116:	5e c0       	rjmp	.+188    	; 0x71d4 <File_check_exists()+0x198>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:250
      child.close();
    7118:	ce 01       	movw	r24, r28
    711a:	01 96       	adiw	r24, 0x01	; 1
    711c:	0e 94 9e 16 	call	0x2d3c	; 0x2d3c <SdFile::close()>
walkPath():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:187
          (*p_parent).close();
        }
        return false;
      }

      if (!moreComponents) {
    7120:	71 10       	cpse	r7, r1
    7122:	1c c0       	rjmp	.+56     	; 0x715c <File_check_exists()+0x120>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:215
      } else {
        return false;
      }
    }

    if (p_parent != &parentDir) {
    7124:	8f e0       	ldi	r24, 0x0F	; 15
    7126:	0d 31       	cpi	r16, 0x1D	; 29
    7128:	18 07       	cpc	r17, r24
    712a:	19 f0       	breq	.+6      	; 0x7132 <File_check_exists()+0xf6>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:216
      (*p_parent).close(); // TODO: Return/ handle different?
    712c:	c8 01       	movw	r24, r16
    712e:	0e 94 9e 16 	call	0x2d3c	; 0x2d3c <SdFile::close()>
File_check_exists():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:88
    myFile = SD.open(filename, FILE_WRITE);
    myFile.println("Device ID,Date,Time,Temperature,K_Temp,Pressure,Humidity,x_CO2,flat,flon,GPS Datetime,Conductivity,TDS,SAL,GRAV,pH,CO2Serial,Thermo Flag,Battery Voltage,Ram");
    myFile.println("ID,YY/MM/DD,HH/MM/SS,Celsius,Celsius,Pa,%,ppm,degree,degree,GMT(0),uS/cm,ppm,PSU,-,-,-,HEX,V,-");
    myFile.close();
  }
}
    7132:	cc 59       	subi	r28, 0x9C	; 156
    7134:	df 4f       	sbci	r29, 0xFF	; 255
    7136:	0f b6       	in	r0, 0x3f	; 63
    7138:	f8 94       	cli
    713a:	de bf       	out	0x3e, r29	; 62
    713c:	0f be       	out	0x3f, r0	; 63
    713e:	cd bf       	out	0x3d, r28	; 61
    7140:	df 91       	pop	r29
    7142:	cf 91       	pop	r28
    7144:	1f 91       	pop	r17
    7146:	0f 91       	pop	r16
    7148:	ff 90       	pop	r15
    714a:	ef 90       	pop	r14
    714c:	df 90       	pop	r13
    714e:	cf 90       	pop	r12
    7150:	bf 90       	pop	r11
    7152:	af 90       	pop	r10
    7154:	9f 90       	pop	r9
    7156:	8f 90       	pop	r8
    7158:	7f 90       	pop	r7
    715a:	08 95       	ret
open():
D:\USER\Documents\Arduino\libraries\SD\src\utility/SdFile.cpp:458
    715c:	f7 01       	movw	r30, r14
    715e:	85 81       	ldd	r24, Z+5	; 0x05
    7160:	81 11       	cpse	r24, r1
    7162:	4b c0       	rjmp	.+150    	; 0x71fa <File_check_exists()+0x1be>
    7164:	21 e0       	ldi	r18, 0x01	; 1
    7166:	a6 01       	movw	r20, r12
    7168:	b8 01       	movw	r22, r16
    716a:	c7 01       	movw	r24, r14
    716c:	0e 94 46 35 	call	0x6a8c	; 0x6a8c <SdFile::open(SdFile*, char const*, unsigned char) [clone .part.28]>
    7170:	d8 2e       	mov	r13, r24
walkPath():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:195

      boolean exists = (*p_child).open(*p_parent, buffer, O_RDONLY);

      // If it's one we've created then we
      // don't need the parent handle anymore.
      if (p_parent != &parentDir) {
    7172:	ff e0       	ldi	r31, 0x0F	; 15
    7174:	0d 31       	cpi	r16, 0x1D	; 29
    7176:	1f 07       	cpc	r17, r31
    7178:	a9 f1       	breq	.+106    	; 0x71e4 <File_check_exists()+0x1a8>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:196
        (*p_parent).close();
    717a:	c8 01       	movw	r24, r16
    717c:	0e 94 9e 16 	call	0x2d3c	; 0x2d3c <SdFile::close()>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:200
      }

      // Handle case when it doesn't exist and we can't continue...
      if (exists) {
    7180:	d1 10       	cpse	r13, r1
    7182:	35 c0       	rjmp	.+106    	; 0x71ee <File_check_exists()+0x1b2>
File_check_exists():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:83
	sprintf(filename, "%02X%02d%02d%02d.csv", device_ID, year % 100, month, day);
	return;
}
void File_check_exists() {              //Check wether there is already the same filename's file exsit. If not, creat new one.=======
  if (!SD.exists(filename)) {
    myFile = SD.open(filename, FILE_WRITE);
    7184:	ce 01       	movw	r24, r28
    7186:	01 96       	adiw	r24, 0x01	; 1
    7188:	0e 94 26 37 	call	0x6e4c	; 0x6e4c <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]>
    718c:	ce 01       	movw	r24, r28
    718e:	01 96       	adiw	r24, 0x01	; 1
    7190:	0e 94 c3 03 	call	0x786	; 0x786 <SDLib::File::operator=(SDLib::File&&) [clone .constprop.162]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:84
    myFile.println("Device ID,Date,Time,Temperature,K_Temp,Pressure,Humidity,x_CO2,flat,flon,GPS Datetime,Conductivity,TDS,SAL,GRAV,pH,CO2Serial,Thermo Flag,Battery Voltage,Ram");
    7194:	61 e8       	ldi	r22, 0x81	; 129
    7196:	74 e0       	ldi	r23, 0x04	; 4
    7198:	8c e0       	ldi	r24, 0x0C	; 12
    719a:	91 e1       	ldi	r25, 0x11	; 17
    719c:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:85
    myFile.println("ID,YY/MM/DD,HH/MM/SS,Celsius,Celsius,Pa,%,ppm,degree,degree,GMT(0),uS/cm,ppm,PSU,-,-,-,HEX,V,-");
    71a0:	6e e1       	ldi	r22, 0x1E	; 30
    71a2:	75 e0       	ldi	r23, 0x05	; 5
    71a4:	8c e0       	ldi	r24, 0x0C	; 12
    71a6:	91 e1       	ldi	r25, 0x11	; 17
    71a8:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
close():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:149
  }
  return _file->fileSize();
}

void File::close() {
  if (_file) {
    71ac:	80 91 25 11 	lds	r24, 0x1125	; 0x801125 <myFile+0x19>
    71b0:	90 91 26 11 	lds	r25, 0x1126	; 0x801126 <myFile+0x1a>
    71b4:	00 97       	sbiw	r24, 0x00	; 0
    71b6:	09 f4       	brne	.+2      	; 0x71ba <File_check_exists()+0x17e>
    71b8:	bc cf       	rjmp	.-136    	; 0x7132 <File_check_exists()+0xf6>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:150
    _file->close();
    71ba:	0e 94 9e 16 	call	0x2d3c	; 0x2d3c <SdFile::close()>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:151
    free(_file);
    71be:	80 91 25 11 	lds	r24, 0x1125	; 0x801125 <myFile+0x19>
    71c2:	90 91 26 11 	lds	r25, 0x1126	; 0x801126 <myFile+0x1a>
    71c6:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:152
    _file = 0;
    71ca:	10 92 26 11 	sts	0x1126, r1	; 0x801126 <myFile+0x1a>
    71ce:	10 92 25 11 	sts	0x1125, r1	; 0x801125 <myFile+0x19>
    71d2:	af cf       	rjmp	.-162    	; 0x7132 <File_check_exists()+0xf6>
walkPath():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:181

      if (!shouldContinue) {
        // TODO: Don't repeat this code?
        // If it's one we've created then we
        // don't need the parent handle anymore.
        if (p_parent != &parentDir) {
    71d4:	ef e0       	ldi	r30, 0x0F	; 15
    71d6:	0d 31       	cpi	r16, 0x1D	; 29
    71d8:	1e 07       	cpc	r17, r30
    71da:	a1 f2       	breq	.-88     	; 0x7184 <File_check_exists()+0x148>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:196
      boolean exists = (*p_child).open(*p_parent, buffer, O_RDONLY);

      // If it's one we've created then we
      // don't need the parent handle anymore.
      if (p_parent != &parentDir) {
        (*p_parent).close();
    71dc:	c8 01       	movw	r24, r16
    71de:	0e 94 9e 16 	call	0x2d3c	; 0x2d3c <SdFile::close()>
    71e2:	d0 cf       	rjmp	.-96     	; 0x7184 <File_check_exists()+0x148>
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:200
      }

      // Handle case when it doesn't exist and we can't continue...
      if (exists) {
    71e4:	88 23       	and	r24, r24
    71e6:	71 f2       	breq	.-100    	; 0x7184 <File_check_exists()+0x148>
File_check_exists():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:204
        // We alternate between two file handles as we go down
        // the path.
        if (p_parent == &parentDir) {
          p_parent = &subfile2;
    71e8:	8e 01       	movw	r16, r28
    71ea:	02 5e       	subi	r16, 0xE2	; 226
    71ec:	1f 4f       	sbci	r17, 0xFF	; 255
    71ee:	90 2f       	mov	r25, r16
    71f0:	81 2f       	mov	r24, r17
    71f2:	87 01       	movw	r16, r14
    71f4:	e9 2e       	mov	r14, r25
    71f6:	f8 2e       	mov	r15, r24
    71f8:	51 cf       	rjmp	.-350    	; 0x709c <File_check_exists()+0x60>
walkPath():
D:\USER\Documents\Arduino\libraries\SD\src/SD.cpp:195

      boolean exists = (*p_child).open(*p_parent, buffer, O_RDONLY);

      // If it's one we've created then we
      // don't need the parent handle anymore.
      if (p_parent != &parentDir) {
    71fa:	ff e0       	ldi	r31, 0x0F	; 15
    71fc:	0d 31       	cpi	r16, 0x1D	; 29
    71fe:	1f 07       	cpc	r17, r31
    7200:	09 f2       	breq	.-126    	; 0x7184 <File_check_exists()+0x148>
    7202:	ec cf       	rjmp	.-40     	; 0x71dc <File_check_exists()+0x1a0>

00007204 <twi_stop>:
twi_stop():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:412
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
    7204:	85 ed       	ldi	r24, 0xD5	; 213
    7206:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:418

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  // We cannot use micros() from an ISR, so approximate the timeout with cycle-counted delays
  const uint8_t us_per_loop = 8;
  uint32_t counter = (twi_timeout_us + us_per_loop - 1)/us_per_loop; // Round up
    720a:	80 91 51 0c 	lds	r24, 0x0C51	; 0x800c51 <twi_timeout_us>
    720e:	90 91 52 0c 	lds	r25, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    7212:	a0 91 53 0c 	lds	r26, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    7216:	b0 91 54 0c 	lds	r27, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    721a:	07 96       	adiw	r24, 0x07	; 7
    721c:	a1 1d       	adc	r26, r1
    721e:	b1 1d       	adc	r27, r1
    7220:	23 e0       	ldi	r18, 0x03	; 3
    7222:	b6 95       	lsr	r27
    7224:	a7 95       	ror	r26
    7226:	97 95       	ror	r25
    7228:	87 95       	ror	r24
    722a:	2a 95       	dec	r18
    722c:	d1 f7       	brne	.-12     	; 0x7222 <twi_stop+0x1e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:419
  while(TWCR & _BV(TWSTO)){
    722e:	20 91 bc 00 	lds	r18, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    7232:	24 fd       	sbrc	r18, 4
    7234:	03 c0       	rjmp	.+6      	; 0x723c <twi_stop+0x38>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:432
      }
    }
  }

  // update twi state
  twi_state = TWI_READY;
    7236:	10 92 4f 0c 	sts	0x0C4F, r1	; 0x800c4f <twi_state>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:433
}
    723a:	08 95       	ret
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:420
  // TWINT is not set after a stop condition!
  // We cannot use micros() from an ISR, so approximate the timeout with cycle-counted delays
  const uint8_t us_per_loop = 8;
  uint32_t counter = (twi_timeout_us + us_per_loop - 1)/us_per_loop; // Round up
  while(TWCR & _BV(TWSTO)){
    if(twi_timeout_us > 0ul){
    723c:	40 91 51 0c 	lds	r20, 0x0C51	; 0x800c51 <twi_timeout_us>
    7240:	50 91 52 0c 	lds	r21, 0x0C52	; 0x800c52 <twi_timeout_us+0x1>
    7244:	60 91 53 0c 	lds	r22, 0x0C53	; 0x800c53 <twi_timeout_us+0x2>
    7248:	70 91 54 0c 	lds	r23, 0x0C54	; 0x800c54 <twi_timeout_us+0x3>
    724c:	45 2b       	or	r20, r21
    724e:	46 2b       	or	r20, r22
    7250:	47 2b       	or	r20, r23
    7252:	69 f3       	breq	.-38     	; 0x722e <twi_stop+0x2a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:421
      if (counter > 0ul){
    7254:	00 97       	sbiw	r24, 0x00	; 0
    7256:	a1 05       	cpc	r26, r1
    7258:	b1 05       	cpc	r27, r1
    725a:	41 f0       	breq	.+16     	; 0x726c <twi_stop+0x68>
_delay_us():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay.h:276
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    725c:	25 e3       	ldi	r18, 0x35	; 53
    725e:	2a 95       	dec	r18
    7260:	f1 f7       	brne	.-4      	; 0x725e <twi_stop+0x5a>
    7262:	00 00       	nop
twi_stop():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:423
        _delay_us(10);
        counter--;
    7264:	01 97       	sbiw	r24, 0x01	; 1
    7266:	a1 09       	sbc	r26, r1
    7268:	b1 09       	sbc	r27, r1
    726a:	e1 cf       	rjmp	.-62     	; 0x722e <twi_stop+0x2a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:425
      } else {
        twi_handleTimeout(twi_do_reset_on_timeout);
    726c:	80 91 50 0c 	lds	r24, 0x0C50	; 0x800c50 <twi_do_reset_on_timeout>
    7270:	0c 94 bc 1a 	jmp	0x3578	; 0x3578 <twi_handleTimeout>

00007274 <bool& EEPROMClass::get<bool>(int, bool&) [clone .isra.32]>:
_ZN11EEPROMClass3getIbEERT_iS2_.isra.32():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:130
    EEPtr begin()                        { return 0x00; }
    EEPtr end()                          { return length(); } //Standards requires this to be the item after the last valid entry. The returned pointer is invalid.
    uint16_t length()                    { return E2END + 1; }
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
    7274:	cf 93       	push	r28
    7276:	df 93       	push	r29
    7278:	eb 01       	movw	r28, r22
operator*():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:42

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    727a:	0e 94 fb 69 	call	0xd3f6	; 0xd3f6 <eeprom_read_byte>
_ZN11EEPROMClass3getIbEERT_iS2_.isra.32():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:133
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
    727e:	88 83       	st	Y, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:135
        return t;
    }
    7280:	ce 01       	movw	r24, r28
    7282:	df 91       	pop	r29
    7284:	cf 91       	pop	r28
    7286:	08 95       	ret

00007288 <float& EEPROMClass::get<float>(int, float&) [clone .isra.28]>:
_ZN11EEPROMClass3getIfEERT_iS2_.isra.28():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:130
    EEPtr begin()                        { return 0x00; }
    EEPtr end()                          { return length(); } //Standards requires this to be the item after the last valid entry. The returned pointer is invalid.
    uint16_t length()                    { return E2END + 1; }
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
    7288:	cf 92       	push	r12
    728a:	df 92       	push	r13
    728c:	ef 92       	push	r14
    728e:	ff 92       	push	r15
    7290:	0f 93       	push	r16
    7292:	1f 93       	push	r17
    7294:	cf 93       	push	r28
    7296:	df 93       	push	r29
    7298:	eb 01       	movw	r28, r22
    729a:	7b 01       	movw	r14, r22
    729c:	24 e0       	ldi	r18, 0x04	; 4
    729e:	e2 0e       	add	r14, r18
    72a0:	f1 1c       	adc	r15, r1
    72a2:	8b 01       	movw	r16, r22
operator*():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:42

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    72a4:	6c 01       	movw	r12, r24
    72a6:	c6 1a       	sub	r12, r22
    72a8:	d7 0a       	sbc	r13, r23
    72aa:	c6 01       	movw	r24, r12
    72ac:	80 0f       	add	r24, r16
    72ae:	91 1f       	adc	r25, r17
    72b0:	0e 94 fb 69 	call	0xd3f6	; 0xd3f6 <eeprom_read_byte>
_ZN11EEPROMClass3getIfEERT_iS2_.isra.28():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:133
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
    72b4:	f8 01       	movw	r30, r16
    72b6:	81 93       	st	Z+, r24
    72b8:	8f 01       	movw	r16, r30
    72ba:	ee 15       	cp	r30, r14
    72bc:	ff 05       	cpc	r31, r15
    72be:	a9 f7       	brne	.-22     	; 0x72aa <float& EEPROMClass::get<float>(int, float&) [clone .isra.28]+0x22>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:135
        return t;
    }
    72c0:	ce 01       	movw	r24, r28
    72c2:	df 91       	pop	r29
    72c4:	cf 91       	pop	r28
    72c6:	1f 91       	pop	r17
    72c8:	0f 91       	pop	r16
    72ca:	ff 90       	pop	r15
    72cc:	ef 90       	pop	r14
    72ce:	df 90       	pop	r13
    72d0:	cf 90       	pop	r12
    72d2:	08 95       	ret

000072d4 <int& EEPROMClass::get<int>(int, int&) [clone .isra.23]>:
_ZN11EEPROMClass3getIiEERT_iS2_.isra.23():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:130
    EEPtr begin()                        { return 0x00; }
    EEPtr end()                          { return length(); } //Standards requires this to be the item after the last valid entry. The returned pointer is invalid.
    uint16_t length()                    { return E2END + 1; }
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
    72d4:	0f 93       	push	r16
    72d6:	1f 93       	push	r17
    72d8:	cf 93       	push	r28
    72da:	df 93       	push	r29
    72dc:	8c 01       	movw	r16, r24
    72de:	eb 01       	movw	r28, r22
operator*():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:42

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    72e0:	0e 94 fb 69 	call	0xd3f6	; 0xd3f6 <eeprom_read_byte>
_ZN11EEPROMClass3getIiEERT_iS2_.isra.23():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:133
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
    72e4:	88 83       	st	Y, r24
operator*():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:42

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    72e6:	c8 01       	movw	r24, r16
    72e8:	01 96       	adiw	r24, 0x01	; 1
    72ea:	0e 94 fb 69 	call	0xd3f6	; 0xd3f6 <eeprom_read_byte>
_ZN11EEPROMClass3getIiEERT_iS2_.isra.23():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:133
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
    72ee:	89 83       	std	Y+1, r24	; 0x01
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:135
        return t;
    }
    72f0:	ce 01       	movw	r24, r28
    72f2:	df 91       	pop	r29
    72f4:	cf 91       	pop	r28
    72f6:	1f 91       	pop	r17
    72f8:	0f 91       	pop	r16
    72fa:	08 95       	ret

000072fc <PrintEEPParameter()>:
_Z7ReadEEPIPiEviRKT_():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:76
	return temp == value;
}

template <class T> void ReadEEP(int addr, const T &value)
{
	EEPROM.get(addr, *value);
    72fc:	61 e2       	ldi	r22, 0x21	; 33
    72fe:	7c e0       	ldi	r23, 0x0C	; 12
    7300:	90 e0       	ldi	r25, 0x00	; 0
    7302:	80 e0       	ldi	r24, 0x00	; 0
    7304:	0e 94 6a 39 	call	0x72d4	; 0x72d4 <int& EEPROMClass::get<int>(int, int&) [clone .isra.23]>
_Z7ReadEEPIPfEviRKT_():
    7308:	60 e6       	ldi	r22, 0x60	; 96
    730a:	79 e0       	ldi	r23, 0x09	; 9
    730c:	82 e0       	ldi	r24, 0x02	; 2
    730e:	90 e0       	ldi	r25, 0x00	; 0
    7310:	0e 94 44 39 	call	0x7288	; 0x7288 <float& EEPROMClass::get<float>(int, float&) [clone .isra.28]>
operator*():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:42

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    7314:	86 e0       	ldi	r24, 0x06	; 6
    7316:	90 e0       	ldi	r25, 0x00	; 0
    7318:	0e 94 fb 69 	call	0xd3f6	; 0xd3f6 <eeprom_read_byte>
_ZN11EEPROMClass3getImEERT_iS2_.isra.30():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:133
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
    731c:	80 93 89 02 	sts	0x0289, r24	; 0x800289 <interval>
operator*():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:42

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    7320:	87 e0       	ldi	r24, 0x07	; 7
    7322:	90 e0       	ldi	r25, 0x00	; 0
    7324:	0e 94 fb 69 	call	0xd3f6	; 0xd3f6 <eeprom_read_byte>
_ZN11EEPROMClass3getImEERT_iS2_.isra.30():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:133
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
    7328:	80 93 8a 02 	sts	0x028A, r24	; 0x80028a <interval+0x1>
operator*():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:42

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    732c:	88 e0       	ldi	r24, 0x08	; 8
    732e:	90 e0       	ldi	r25, 0x00	; 0
    7330:	0e 94 fb 69 	call	0xd3f6	; 0xd3f6 <eeprom_read_byte>
_ZN11EEPROMClass3getImEERT_iS2_.isra.30():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:133
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
    7334:	80 93 8b 02 	sts	0x028B, r24	; 0x80028b <interval+0x2>
operator*():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:42

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    7338:	89 e0       	ldi	r24, 0x09	; 9
    733a:	90 e0       	ldi	r25, 0x00	; 0
    733c:	0e 94 fb 69 	call	0xd3f6	; 0xd3f6 <eeprom_read_byte>
_ZN11EEPROMClass3getImEERT_iS2_.isra.30():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:133
    
    //Functionality to 'get' and 'put' objects to and from EEPROM.
    template< typename T > T &get( int idx, T &t ){
        EEPtr e = idx;
        uint8_t *ptr = (uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  *ptr++ = *e;
    7340:	80 93 8c 02 	sts	0x028C, r24	; 0x80028c <interval+0x3>
_Z7ReadEEPIPbEviRKT_():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:76
    7344:	60 ef       	ldi	r22, 0xF0	; 240
    7346:	79 e0       	ldi	r23, 0x09	; 9
    7348:	8a e0       	ldi	r24, 0x0A	; 10
    734a:	90 e0       	ldi	r25, 0x00	; 0
    734c:	0e 94 3a 39 	call	0x7274	; 0x7274 <bool& EEPROMClass::get<bool>(int, bool&) [clone .isra.32]>
_Z7ReadEEPIPiEviRKT_():
    7350:	6c ed       	ldi	r22, 0xDC	; 220
    7352:	79 e0       	ldi	r23, 0x09	; 9
    7354:	82 e1       	ldi	r24, 0x12	; 18
    7356:	90 e0       	ldi	r25, 0x00	; 0
    7358:	0e 94 6a 39 	call	0x72d4	; 0x72d4 <int& EEPROMClass::get<int>(int, int&) [clone .isra.23]>
_Z7ReadEEPIPfEviRKT_():
    735c:	6c e1       	ldi	r22, 0x1C	; 28
    735e:	79 e0       	ldi	r23, 0x09	; 9
    7360:	88 e1       	ldi	r24, 0x18	; 24
    7362:	90 e0       	ldi	r25, 0x00	; 0
    7364:	0e 94 44 39 	call	0x7288	; 0x7288 <float& EEPROMClass::get<float>(int, float&) [clone .isra.28]>
    7368:	68 e1       	ldi	r22, 0x18	; 24
    736a:	79 e0       	ldi	r23, 0x09	; 9
    736c:	8e e1       	ldi	r24, 0x1E	; 30
    736e:	90 e0       	ldi	r25, 0x00	; 0
    7370:	0e 94 44 39 	call	0x7288	; 0x7288 <float& EEPROMClass::get<float>(int, float&) [clone .isra.28]>
_Z7ReadEEPIPiEviRKT_():
    7374:	66 e4       	ldi	r22, 0x46	; 70
    7376:	79 e0       	ldi	r23, 0x09	; 9
    7378:	88 e4       	ldi	r24, 0x48	; 72
    737a:	90 e0       	ldi	r25, 0x00	; 0
    737c:	0e 94 6a 39 	call	0x72d4	; 0x72d4 <int& EEPROMClass::get<int>(int, int&) [clone .isra.23]>
_Z7ReadEEPIPfEviRKT_():
    7380:	62 e2       	ldi	r22, 0x22	; 34
    7382:	79 e0       	ldi	r23, 0x09	; 9
    7384:	84 e2       	ldi	r24, 0x24	; 36
    7386:	90 e0       	ldi	r25, 0x00	; 0
    7388:	0e 94 44 39 	call	0x7288	; 0x7288 <float& EEPROMClass::get<float>(int, float&) [clone .isra.28]>
    738c:	67 e5       	ldi	r22, 0x57	; 87
    738e:	79 e0       	ldi	r23, 0x09	; 9
    7390:	80 e5       	ldi	r24, 0x50	; 80
    7392:	90 e0       	ldi	r25, 0x00	; 0
    7394:	0e 94 44 39 	call	0x7288	; 0x7288 <float& EEPROMClass::get<float>(int, float&) [clone .isra.28]>
    7398:	6b e5       	ldi	r22, 0x5B	; 91
    739a:	79 e0       	ldi	r23, 0x09	; 9
    739c:	86 e5       	ldi	r24, 0x56	; 86
    739e:	90 e0       	ldi	r25, 0x00	; 0
    73a0:	0e 94 44 39 	call	0x7288	; 0x7288 <float& EEPROMClass::get<float>(int, float&) [clone .isra.28]>
_Z7ReadEEPIPiEviRKT_():
    73a4:	65 e5       	ldi	r22, 0x55	; 85
    73a6:	79 e0       	ldi	r23, 0x09	; 9
    73a8:	8c e5       	ldi	r24, 0x5C	; 92
    73aa:	90 e0       	ldi	r25, 0x00	; 0
    73ac:	0e 94 6a 39 	call	0x72d4	; 0x72d4 <int& EEPROMClass::get<int>(int, int&) [clone .isra.23]>
_Z7ReadEEPIPbEviRKT_():
    73b0:	64 e5       	ldi	r22, 0x54	; 84
    73b2:	79 e0       	ldi	r23, 0x09	; 9
    73b4:	80 e6       	ldi	r24, 0x60	; 96
    73b6:	90 e0       	ldi	r25, 0x00	; 0
    73b8:	0e 94 3a 39 	call	0x7274	; 0x7274 <bool& EEPROMClass::get<bool>(int, bool&) [clone .isra.32]>
UpdateEEPParameter():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:29
	ReadEEP(pCO2_highP_addr, &pCO2_highP);
	//Get pCO2 pressure guard sample time
	ReadEEP(pCO2_PSampleT_addr, &pCO2_PSampleT);
	//Get pCO2 pressure guard recover mode
	ReadEEP(pCO2_PRecoverMode_addr, &pCO2_PRecoverMode);
	lcd.createChar(3, (bool)ec_print ? ES_Stand : EC_Stand);
    73bc:	80 91 46 09 	lds	r24, 0x0946	; 0x800946 <ec_print>
    73c0:	90 91 47 09 	lds	r25, 0x0947	; 0x800947 <ec_print+0x1>
PrintEEPParameter():
    73c4:	61 e7       	ldi	r22, 0x71	; 113
    73c6:	72 e0       	ldi	r23, 0x02	; 2
UpdateEEPParameter():
    73c8:	89 2b       	or	r24, r25
    73ca:	11 f0       	breq	.+4      	; 0x73d0 <PrintEEPParameter()+0xd4>
PrintEEPParameter():
    73cc:	60 e0       	ldi	r22, 0x00	; 0
    73ce:	72 e0       	ldi	r23, 0x02	; 2
UpdateEEPParameter():
    73d0:	83 e0       	ldi	r24, 0x03	; 3
    73d2:	0e 94 f6 22 	call	0x45ec	; 0x45ec <LiquidCrystal_I2C::createChar(unsigned char, unsigned char*) [clone .constprop.164]>
PrintEEPParameter():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:34
}

void PrintEEPParameter() {
	UpdateEEPParameter();
	if (DEBUG || debugMode) 
    73d6:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <debugMode>
    73da:	88 23       	and	r24, r24
    73dc:	09 f4       	brne	.+2      	; 0x73e0 <PrintEEPParameter()+0xe4>
    73de:	d1 c0       	rjmp	.+418    	; 0x7582 <PrintEEPParameter()+0x286>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:36
	{
		Serial.print("ID\tk_cal\tinter\tpower\tPMW\tVmin\tVmax\tVSlope\tECprint\tPGLow\tPGHigh\tPGTime\tPGMode\n");
    73e0:	6d e7       	ldi	r22, 0x7D	; 125
    73e2:	75 e0       	ldi	r23, 0x05	; 5
    73e4:	82 e5       	ldi	r24, 0x52	; 82
    73e6:	9e e0       	ldi	r25, 0x0E	; 14
    73e8:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:37
		Serial.print(device_ID);
    73ec:	60 91 21 0c 	lds	r22, 0x0C21	; 0x800c21 <device_ID>
    73f0:	70 91 22 0c 	lds	r23, 0x0C22	; 0x800c22 <device_ID+0x1>
    73f4:	82 e5       	ldi	r24, 0x52	; 82
    73f6:	9e e0       	ldi	r25, 0x0E	; 14
    73f8:	0e 94 22 26 	call	0x4c44	; 0x4c44 <Print::print(int, int) [clone .constprop.175]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:38
		Serial.print('\t');
    73fc:	69 e0       	ldi	r22, 0x09	; 9
    73fe:	82 e5       	ldi	r24, 0x52	; 82
    7400:	9e e0       	ldi	r25, 0x0E	; 14
    7402:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:111
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    7406:	40 91 60 09 	lds	r20, 0x0960	; 0x800960 <k_cal>
    740a:	50 91 61 09 	lds	r21, 0x0961	; 0x800961 <k_cal+0x1>
    740e:	60 91 62 09 	lds	r22, 0x0962	; 0x800962 <k_cal+0x2>
    7412:	70 91 63 09 	lds	r23, 0x0963	; 0x800963 <k_cal+0x3>
    7416:	22 e0       	ldi	r18, 0x02	; 2
    7418:	82 e5       	ldi	r24, 0x52	; 82
    741a:	9e e0       	ldi	r25, 0x0E	; 14
    741c:	0e 94 58 26 	call	0x4cb0	; 0x4cb0 <Print::printFloat(double, unsigned char)>
PrintEEPParameter():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:40
		Serial.print(k_cal);
		Serial.print('\t');
    7420:	69 e0       	ldi	r22, 0x09	; 9
    7422:	82 e5       	ldi	r24, 0x52	; 82
    7424:	9e e0       	ldi	r25, 0x0E	; 14
    7426:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:106
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    742a:	40 91 89 02 	lds	r20, 0x0289	; 0x800289 <interval>
    742e:	50 91 8a 02 	lds	r21, 0x028A	; 0x80028a <interval+0x1>
    7432:	60 91 8b 02 	lds	r22, 0x028B	; 0x80028b <interval+0x2>
    7436:	70 91 8c 02 	lds	r23, 0x028C	; 0x80028c <interval+0x3>
    743a:	2a e0       	ldi	r18, 0x0A	; 10
    743c:	82 e5       	ldi	r24, 0x52	; 82
    743e:	9e e0       	ldi	r25, 0x0E	; 14
    7440:	0e 94 d6 25 	call	0x4bac	; 0x4bac <Print::printNumber(unsigned long, unsigned char)>
PrintEEPParameter():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:42
		Serial.print(interval);
		Serial.print('\t');
    7444:	69 e0       	ldi	r22, 0x09	; 9
    7446:	82 e5       	ldi	r24, 0x52	; 82
    7448:	9e e0       	ldi	r25, 0x0E	; 14
    744a:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:43
		Serial.print(powerSaving);
    744e:	60 91 f0 09 	lds	r22, 0x09F0	; 0x8009f0 <powerSaving>
    7452:	70 e0       	ldi	r23, 0x00	; 0
    7454:	82 e5       	ldi	r24, 0x52	; 82
    7456:	9e e0       	ldi	r25, 0x0E	; 14
    7458:	0e 94 22 26 	call	0x4c44	; 0x4c44 <Print::print(int, int) [clone .constprop.175]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:44
		Serial.print('\t');
    745c:	69 e0       	ldi	r22, 0x09	; 9
    745e:	82 e5       	ldi	r24, 0x52	; 82
    7460:	9e e0       	ldi	r25, 0x0E	; 14
    7462:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:45
		Serial.print(pumpPower);
    7466:	60 91 dc 09 	lds	r22, 0x09DC	; 0x8009dc <pumpPower>
    746a:	70 91 dd 09 	lds	r23, 0x09DD	; 0x8009dd <pumpPower+0x1>
    746e:	82 e5       	ldi	r24, 0x52	; 82
    7470:	9e e0       	ldi	r25, 0x0E	; 14
    7472:	0e 94 22 26 	call	0x4c44	; 0x4c44 <Print::print(int, int) [clone .constprop.175]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:46
		Serial.print('\t');
    7476:	69 e0       	ldi	r22, 0x09	; 9
    7478:	82 e5       	ldi	r24, 0x52	; 82
    747a:	9e e0       	ldi	r25, 0x0E	; 14
    747c:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:111
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    7480:	40 91 1c 09 	lds	r20, 0x091C	; 0x80091c <V_min>
    7484:	50 91 1d 09 	lds	r21, 0x091D	; 0x80091d <V_min+0x1>
    7488:	60 91 1e 09 	lds	r22, 0x091E	; 0x80091e <V_min+0x2>
    748c:	70 91 1f 09 	lds	r23, 0x091F	; 0x80091f <V_min+0x3>
    7490:	22 e0       	ldi	r18, 0x02	; 2
    7492:	82 e5       	ldi	r24, 0x52	; 82
    7494:	9e e0       	ldi	r25, 0x0E	; 14
    7496:	0e 94 58 26 	call	0x4cb0	; 0x4cb0 <Print::printFloat(double, unsigned char)>
PrintEEPParameter():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:48
		Serial.print(V_min);
		Serial.print('\t');
    749a:	69 e0       	ldi	r22, 0x09	; 9
    749c:	82 e5       	ldi	r24, 0x52	; 82
    749e:	9e e0       	ldi	r25, 0x0E	; 14
    74a0:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:111
    74a4:	40 91 18 09 	lds	r20, 0x0918	; 0x800918 <__data_end>
    74a8:	50 91 19 09 	lds	r21, 0x0919	; 0x800919 <__data_end+0x1>
    74ac:	60 91 1a 09 	lds	r22, 0x091A	; 0x80091a <__data_end+0x2>
    74b0:	70 91 1b 09 	lds	r23, 0x091B	; 0x80091b <__data_end+0x3>
    74b4:	22 e0       	ldi	r18, 0x02	; 2
    74b6:	82 e5       	ldi	r24, 0x52	; 82
    74b8:	9e e0       	ldi	r25, 0x0E	; 14
    74ba:	0e 94 58 26 	call	0x4cb0	; 0x4cb0 <Print::printFloat(double, unsigned char)>
PrintEEPParameter():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:50
		Serial.print(V_max);
		Serial.print('\t');
    74be:	69 e0       	ldi	r22, 0x09	; 9
    74c0:	82 e5       	ldi	r24, 0x52	; 82
    74c2:	9e e0       	ldi	r25, 0x0E	; 14
    74c4:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:111
    74c8:	40 91 22 09 	lds	r20, 0x0922	; 0x800922 <voltage_slope>
    74cc:	50 91 23 09 	lds	r21, 0x0923	; 0x800923 <voltage_slope+0x1>
    74d0:	60 91 24 09 	lds	r22, 0x0924	; 0x800924 <voltage_slope+0x2>
    74d4:	70 91 25 09 	lds	r23, 0x0925	; 0x800925 <voltage_slope+0x3>
    74d8:	22 e0       	ldi	r18, 0x02	; 2
    74da:	82 e5       	ldi	r24, 0x52	; 82
    74dc:	9e e0       	ldi	r25, 0x0E	; 14
    74de:	0e 94 58 26 	call	0x4cb0	; 0x4cb0 <Print::printFloat(double, unsigned char)>
PrintEEPParameter():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:52
		Serial.print(voltage_slope);
		Serial.print('\t');
    74e2:	69 e0       	ldi	r22, 0x09	; 9
    74e4:	82 e5       	ldi	r24, 0x52	; 82
    74e6:	9e e0       	ldi	r25, 0x0E	; 14
    74e8:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:53
		Serial.print(ec_print);
    74ec:	60 91 46 09 	lds	r22, 0x0946	; 0x800946 <ec_print>
    74f0:	70 91 47 09 	lds	r23, 0x0947	; 0x800947 <ec_print+0x1>
    74f4:	82 e5       	ldi	r24, 0x52	; 82
    74f6:	9e e0       	ldi	r25, 0x0E	; 14
    74f8:	0e 94 22 26 	call	0x4c44	; 0x4c44 <Print::print(int, int) [clone .constprop.175]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:54
		Serial.print('\t');
    74fc:	69 e0       	ldi	r22, 0x09	; 9
    74fe:	82 e5       	ldi	r24, 0x52	; 82
    7500:	9e e0       	ldi	r25, 0x0E	; 14
    7502:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:111
    7506:	40 91 57 09 	lds	r20, 0x0957	; 0x800957 <pCO2_lowP>
    750a:	50 91 58 09 	lds	r21, 0x0958	; 0x800958 <pCO2_lowP+0x1>
    750e:	60 91 59 09 	lds	r22, 0x0959	; 0x800959 <pCO2_lowP+0x2>
    7512:	70 91 5a 09 	lds	r23, 0x095A	; 0x80095a <pCO2_lowP+0x3>
    7516:	22 e0       	ldi	r18, 0x02	; 2
    7518:	82 e5       	ldi	r24, 0x52	; 82
    751a:	9e e0       	ldi	r25, 0x0E	; 14
    751c:	0e 94 58 26 	call	0x4cb0	; 0x4cb0 <Print::printFloat(double, unsigned char)>
PrintEEPParameter():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:56
		Serial.print(pCO2_lowP);
		Serial.print('\t');
    7520:	69 e0       	ldi	r22, 0x09	; 9
    7522:	82 e5       	ldi	r24, 0x52	; 82
    7524:	9e e0       	ldi	r25, 0x0E	; 14
    7526:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:111
    752a:	40 91 5b 09 	lds	r20, 0x095B	; 0x80095b <pCO2_highP>
    752e:	50 91 5c 09 	lds	r21, 0x095C	; 0x80095c <pCO2_highP+0x1>
    7532:	60 91 5d 09 	lds	r22, 0x095D	; 0x80095d <pCO2_highP+0x2>
    7536:	70 91 5e 09 	lds	r23, 0x095E	; 0x80095e <pCO2_highP+0x3>
    753a:	22 e0       	ldi	r18, 0x02	; 2
    753c:	82 e5       	ldi	r24, 0x52	; 82
    753e:	9e e0       	ldi	r25, 0x0E	; 14
    7540:	0e 94 58 26 	call	0x4cb0	; 0x4cb0 <Print::printFloat(double, unsigned char)>
PrintEEPParameter():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:58
		Serial.print(pCO2_highP);
		Serial.print('\t');
    7544:	69 e0       	ldi	r22, 0x09	; 9
    7546:	82 e5       	ldi	r24, 0x52	; 82
    7548:	9e e0       	ldi	r25, 0x0E	; 14
    754a:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:59
		Serial.print(pCO2_PSampleT);
    754e:	60 91 55 09 	lds	r22, 0x0955	; 0x800955 <pCO2_PSampleT>
    7552:	70 91 56 09 	lds	r23, 0x0956	; 0x800956 <pCO2_PSampleT+0x1>
    7556:	82 e5       	ldi	r24, 0x52	; 82
    7558:	9e e0       	ldi	r25, 0x0E	; 14
    755a:	0e 94 22 26 	call	0x4c44	; 0x4c44 <Print::print(int, int) [clone .constprop.175]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:60
		Serial.print('\t');
    755e:	69 e0       	ldi	r22, 0x09	; 9
    7560:	82 e5       	ldi	r24, 0x52	; 82
    7562:	9e e0       	ldi	r25, 0x0E	; 14
    7564:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:61
		Serial.print(pCO2_PRecoverMode);
    7568:	60 91 54 09 	lds	r22, 0x0954	; 0x800954 <pCO2_PRecoverMode>
    756c:	70 e0       	ldi	r23, 0x00	; 0
    756e:	82 e5       	ldi	r24, 0x52	; 82
    7570:	9e e0       	ldi	r25, 0x0E	; 14
    7572:	0e 94 22 26 	call	0x4c44	; 0x4c44 <Print::print(int, int) [clone .constprop.175]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:62
		Serial.print("\n");
    7576:	6b e6       	ldi	r22, 0x6B	; 107
    7578:	73 e0       	ldi	r23, 0x03	; 3
    757a:	82 e5       	ldi	r24, 0x52	; 82
    757c:	9e e0       	ldi	r25, 0x0E	; 14
    757e:	0c 94 7d 28 	jmp	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:64
	}
}
    7582:	08 95       	ret

00007584 <doMeasure()>:
doMeasure():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:13
	}
	else SD_alive = true;
	//lcd_qSprint(SD_alive ? "OK >w<" : "**FAIL**", 7, 1);
}

void doMeasure() {
    7584:	2f 92       	push	r2
    7586:	3f 92       	push	r3
    7588:	4f 92       	push	r4
    758a:	5f 92       	push	r5
    758c:	6f 92       	push	r6
    758e:	7f 92       	push	r7
    7590:	8f 92       	push	r8
    7592:	9f 92       	push	r9
    7594:	af 92       	push	r10
    7596:	bf 92       	push	r11
    7598:	cf 92       	push	r12
    759a:	df 92       	push	r13
    759c:	ef 92       	push	r14
    759e:	ff 92       	push	r15
    75a0:	0f 93       	push	r16
    75a2:	1f 93       	push	r17
    75a4:	cf 93       	push	r28
    75a6:	df 93       	push	r29
    75a8:	cd b7       	in	r28, 0x3d	; 61
    75aa:	de b7       	in	r29, 0x3e	; 62
    75ac:	c6 56       	subi	r28, 0x66	; 102
    75ae:	d1 09       	sbc	r29, r1
    75b0:	0f b6       	in	r0, 0x3f	; 63
    75b2:	f8 94       	cli
    75b4:	de bf       	out	0x3e, r29	; 62
    75b6:	0f be       	out	0x3f, r0	; 63
    75b8:	cd bf       	out	0x3d, r28	; 61
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:14
  SDIO.on();
    75ba:	89 e2       	ldi	r24, 0x29	; 41
    75bc:	90 e1       	ldi	r25, 0x10	; 16
    75be:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <BlinkControl::on(bool) [clone .constprop.44]>
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:8
	for (unsigned long start = millis(); millis() - start < 100;)	if(ss.available() > 0)		gps.encode(ss.read());
}

void updateGPSdata() {
///update location data
	if (gps.location.isValid())
    75c2:	80 91 85 11 	lds	r24, 0x1185	; 0x801185 <gps>
    75c6:	9e 01       	movw	r18, r28
    75c8:	2f 5f       	subi	r18, 0xFF	; 255
    75ca:	3f 4f       	sbci	r19, 0xFF	; 255
    75cc:	19 01       	movw	r2, r18
    75ce:	88 23       	and	r24, r24
    75d0:	09 f4       	brne	.+2      	; 0x75d4 <doMeasure()+0x50>
    75d2:	98 c2       	rjmp	.+1328   	; 0x7b04 <doMeasure()+0x580>
lat():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:357
   TinyGPSPlus::parseDegrees(term, rawNewLngData);
}

double TinyGPSLocation::lat()
{
   updated = false;
    75d4:	10 92 86 11 	sts	0x1186, r1	; 0x801186 <gps+0x1>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:358
   double ret = rawLatData.deg + rawLatData.billionths / 1000000000.0;
    75d8:	60 91 89 11 	lds	r22, 0x1189	; 0x801189 <gps+0x4>
    75dc:	70 91 8a 11 	lds	r23, 0x118A	; 0x80118a <gps+0x5>
    75e0:	80 91 8b 11 	lds	r24, 0x118B	; 0x80118b <gps+0x6>
    75e4:	90 91 8c 11 	lds	r25, 0x118C	; 0x80118c <gps+0x7>
    75e8:	0e 94 d9 68 	call	0xd1b2	; 0xd1b2 <__floatunsisf>
    75ec:	28 e2       	ldi	r18, 0x28	; 40
    75ee:	3b e6       	ldi	r19, 0x6B	; 107
    75f0:	4e e6       	ldi	r20, 0x6E	; 110
    75f2:	5e e4       	ldi	r21, 0x4E	; 78
    75f4:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
    75f8:	6b 01       	movw	r12, r22
    75fa:	7c 01       	movw	r14, r24
    75fc:	60 91 87 11 	lds	r22, 0x1187	; 0x801187 <gps+0x2>
    7600:	70 91 88 11 	lds	r23, 0x1188	; 0x801188 <gps+0x3>
    7604:	90 e0       	ldi	r25, 0x00	; 0
    7606:	80 e0       	ldi	r24, 0x00	; 0
    7608:	0e 94 d9 68 	call	0xd1b2	; 0xd1b2 <__floatunsisf>
    760c:	9b 01       	movw	r18, r22
    760e:	ac 01       	movw	r20, r24
    7610:	c7 01       	movw	r24, r14
    7612:	b6 01       	movw	r22, r12
    7614:	0e 94 75 6a 	call	0xd4ea	; 0xd4ea <__addsf3>
    7618:	ab 01       	movw	r20, r22
    761a:	bc 01       	movw	r22, r24
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:359
   return rawLatData.negative ? -ret : ret;
    761c:	80 91 8d 11 	lds	r24, 0x118D	; 0x80118d <gps+0x8>
    7620:	81 11       	cpse	r24, r1
    7622:	70 58       	subi	r23, 0x80	; 128
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:11
	{
		//GPSLED.resume();
		flat = floattostring(gps.location.lat(), 2, 6);
    7624:	06 e0       	ldi	r16, 0x06	; 6
    7626:	10 e0       	ldi	r17, 0x00	; 0
    7628:	22 e0       	ldi	r18, 0x02	; 2
    762a:	30 e0       	ldi	r19, 0x00	; 0
    762c:	c1 01       	movw	r24, r2
    762e:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <floattostring(float, int, int)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String & String::operator = (String &&rval)
{
	if (this != &rval) move(rval);
    7632:	b1 01       	movw	r22, r2
    7634:	8f e7       	ldi	r24, 0x7F	; 127
    7636:	91 e1       	ldi	r25, 0x11	; 17
    7638:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:11
    763c:	c1 01       	movw	r24, r2
    763e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
lng():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:364
}

double TinyGPSLocation::lng()
{
   updated = false;
    7642:	10 92 86 11 	sts	0x1186, r1	; 0x801186 <gps+0x1>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:365
   double ret = rawLngData.deg + rawLngData.billionths / 1000000000.0;
    7646:	60 91 90 11 	lds	r22, 0x1190	; 0x801190 <gps+0xb>
    764a:	70 91 91 11 	lds	r23, 0x1191	; 0x801191 <gps+0xc>
    764e:	80 91 92 11 	lds	r24, 0x1192	; 0x801192 <gps+0xd>
    7652:	90 91 93 11 	lds	r25, 0x1193	; 0x801193 <gps+0xe>
    7656:	0e 94 d9 68 	call	0xd1b2	; 0xd1b2 <__floatunsisf>
    765a:	28 e2       	ldi	r18, 0x28	; 40
    765c:	3b e6       	ldi	r19, 0x6B	; 107
    765e:	4e e6       	ldi	r20, 0x6E	; 110
    7660:	5e e4       	ldi	r21, 0x4E	; 78
    7662:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
    7666:	6b 01       	movw	r12, r22
    7668:	7c 01       	movw	r14, r24
    766a:	60 91 8e 11 	lds	r22, 0x118E	; 0x80118e <gps+0x9>
    766e:	70 91 8f 11 	lds	r23, 0x118F	; 0x80118f <gps+0xa>
    7672:	90 e0       	ldi	r25, 0x00	; 0
    7674:	80 e0       	ldi	r24, 0x00	; 0
    7676:	0e 94 d9 68 	call	0xd1b2	; 0xd1b2 <__floatunsisf>
    767a:	9b 01       	movw	r18, r22
    767c:	ac 01       	movw	r20, r24
    767e:	c7 01       	movw	r24, r14
    7680:	b6 01       	movw	r22, r12
    7682:	0e 94 75 6a 	call	0xd4ea	; 0xd4ea <__addsf3>
    7686:	ab 01       	movw	r20, r22
    7688:	bc 01       	movw	r22, r24
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:366
   return rawLngData.negative ? -ret : ret;
    768a:	80 91 94 11 	lds	r24, 0x1194	; 0x801194 <gps+0xf>
    768e:	81 11       	cpse	r24, r1
    7690:	70 58       	subi	r23, 0x80	; 128
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:12
		flon = floattostring(gps.location.lng(), 3, 6);
    7692:	06 e0       	ldi	r16, 0x06	; 6
    7694:	10 e0       	ldi	r17, 0x00	; 0
    7696:	23 e0       	ldi	r18, 0x03	; 3
    7698:	30 e0       	ldi	r19, 0x00	; 0
    769a:	c1 01       	movw	r24, r2
    769c:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <floattostring(float, int, int)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    76a0:	b1 01       	movw	r22, r2
    76a2:	89 e7       	ldi	r24, 0x79	; 121
    76a4:	91 e1       	ldi	r25, 0x11	; 17
    76a6:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:12
    76aa:	c1 01       	movw	r24, r2
    76ac:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:21
		//GPSLED.pause();
		flat = "-";
		flon = "-";
	}
///update datetime data
	if (gps.date.isValid() && gps.time.isValid())
    76b0:	80 91 a7 11 	lds	r24, 0x11A7	; 0x8011a7 <gps+0x22>
    76b4:	88 23       	and	r24, r24
    76b6:	09 f4       	brne	.+2      	; 0x76ba <doMeasure()+0x136>
    76b8:	32 c2       	rjmp	.+1124   	; 0x7b1e <doMeasure()+0x59a>
    76ba:	80 91 b5 11 	lds	r24, 0x11B5	; 0x8011b5 <gps+0x30>
    76be:	88 23       	and	r24, r24
    76c0:	09 f4       	brne	.+2      	; 0x76c4 <doMeasure()+0x140>
    76c2:	2d c2       	rjmp	.+1114   	; 0x7b1e <doMeasure()+0x59a>
month():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:402
   return year + 2000;
}

uint8_t TinyGPSDate::month()
{
   updated = false;
    76c4:	10 92 b6 11 	sts	0x11B6, r1	; 0x8011b6 <gps+0x31>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:403
   return (date / 100) % 100;
    76c8:	80 90 b7 11 	lds	r8, 0x11B7	; 0x8011b7 <gps+0x32>
    76cc:	90 90 b8 11 	lds	r9, 0x11B8	; 0x8011b8 <gps+0x33>
    76d0:	a0 90 b9 11 	lds	r10, 0x11B9	; 0x8011b9 <gps+0x34>
    76d4:	b0 90 ba 11 	lds	r11, 0x11BA	; 0x8011ba <gps+0x35>
day():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:408
}

uint8_t TinyGPSDate::day()
{
   updated = false;
    76d8:	10 92 a8 11 	sts	0x11A8, r1	; 0x8011a8 <gps+0x23>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:409
   return date / 10000;
    76dc:	40 90 a9 11 	lds	r4, 0x11A9	; 0x8011a9 <gps+0x24>
    76e0:	50 90 aa 11 	lds	r5, 0x11AA	; 0x8011aa <gps+0x25>
    76e4:	60 90 ab 11 	lds	r6, 0x11AB	; 0x8011ab <gps+0x26>
    76e8:	70 90 ac 11 	lds	r7, 0x11AC	; 0x8011ac <gps+0x27>
month():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:403
}

uint8_t TinyGPSDate::month()
{
   updated = false;
   return (date / 100) % 100;
    76ec:	54 e6       	ldi	r21, 0x64	; 100
    76ee:	c5 2e       	mov	r12, r21
    76f0:	d1 2c       	mov	r13, r1
    76f2:	e1 2c       	mov	r14, r1
    76f4:	f1 2c       	mov	r15, r1
    76f6:	c5 01       	movw	r24, r10
    76f8:	b4 01       	movw	r22, r8
    76fa:	a7 01       	movw	r20, r14
    76fc:	96 01       	movw	r18, r12
    76fe:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    7702:	ca 01       	movw	r24, r20
    7704:	b9 01       	movw	r22, r18
    7706:	a7 01       	movw	r20, r14
    7708:	96 01       	movw	r18, r12
    770a:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:24
	{
		char sz[22];
		sprintf(sz, "%04d/%02d/%02d %02d:%02d:%02d", gps.date.year(), gps.date.month(), gps.date.day(), gps.time.hour(), gps.time.minute(), gps.time.second());
    770e:	7f 93       	push	r23
    7710:	6f 93       	push	r22
minute():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:421
}

uint8_t TinyGPSTime::minute()
{
   updated = false;
   return (time / 10000) % 100;
    7712:	c5 01       	movw	r24, r10
    7714:	b4 01       	movw	r22, r8
    7716:	20 e1       	ldi	r18, 0x10	; 16
    7718:	37 e2       	ldi	r19, 0x27	; 39
    771a:	40 e0       	ldi	r20, 0x00	; 0
    771c:	50 e0       	ldi	r21, 0x00	; 0
    771e:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    7722:	ca 01       	movw	r24, r20
    7724:	b9 01       	movw	r22, r18
    7726:	a7 01       	movw	r20, r14
    7728:	96 01       	movw	r18, r12
    772a:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:24
    772e:	7f 93       	push	r23
    7730:	6f 93       	push	r22
hour():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:415
}

uint8_t TinyGPSTime::hour()
{
   updated = false;
   return time / 1000000;
    7732:	c5 01       	movw	r24, r10
    7734:	b4 01       	movw	r22, r8
    7736:	20 e4       	ldi	r18, 0x40	; 64
    7738:	32 e4       	ldi	r19, 0x42	; 66
    773a:	4f e0       	ldi	r20, 0x0F	; 15
    773c:	50 e0       	ldi	r21, 0x00	; 0
    773e:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:24
    7742:	1f 92       	push	r1
    7744:	2f 93       	push	r18
day():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:409
}

uint8_t TinyGPSDate::day()
{
   updated = false;
   return date / 10000;
    7746:	c3 01       	movw	r24, r6
    7748:	b2 01       	movw	r22, r4
    774a:	20 e1       	ldi	r18, 0x10	; 16
    774c:	37 e2       	ldi	r19, 0x27	; 39
    774e:	40 e0       	ldi	r20, 0x00	; 0
    7750:	50 e0       	ldi	r21, 0x00	; 0
    7752:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:24
    7756:	1f 92       	push	r1
    7758:	2f 93       	push	r18
month():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:403
}

uint8_t TinyGPSDate::month()
{
   updated = false;
   return (date / 100) % 100;
    775a:	c3 01       	movw	r24, r6
    775c:	b2 01       	movw	r22, r4
    775e:	a7 01       	movw	r20, r14
    7760:	96 01       	movw	r18, r12
    7762:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
    7766:	4b 01       	movw	r8, r22
    7768:	ca 01       	movw	r24, r20
    776a:	b9 01       	movw	r22, r18
    776c:	a7 01       	movw	r20, r14
    776e:	96 01       	movw	r18, r12
    7770:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:24
    7774:	7f 93       	push	r23
    7776:	6f 93       	push	r22
year():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:397

uint16_t TinyGPSDate::year()
{
   updated = false;
   uint16_t year = date % 100;
   return year + 2000;
    7778:	30 e3       	ldi	r19, 0x30	; 48
    777a:	83 1a       	sub	r8, r19
    777c:	38 ef       	ldi	r19, 0xF8	; 248
    777e:	93 0a       	sbc	r9, r19
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:24
    7780:	9f 92       	push	r9
    7782:	8f 92       	push	r8
    7784:	8b ec       	ldi	r24, 0xCB	; 203
    7786:	95 e0       	ldi	r25, 0x05	; 5
    7788:	9f 93       	push	r25
    778a:	8f 93       	push	r24
    778c:	3f 92       	push	r3
    778e:	2f 92       	push	r2
    7790:	0e 94 de 6e 	call	0xddbc	; 0xddbc <sprintf>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:25
		GPS_datetime = String(sz);
    7794:	b1 01       	movw	r22, r2
    7796:	ce 01       	movw	r24, r28
    7798:	4c 96       	adiw	r24, 0x1c	; 28
    779a:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    779e:	be 01       	movw	r22, r28
    77a0:	64 5e       	subi	r22, 0xE4	; 228
    77a2:	7f 4f       	sbci	r23, 0xFF	; 255
    77a4:	83 e7       	ldi	r24, 0x73	; 115
    77a6:	91 e1       	ldi	r25, 0x11	; 17
    77a8:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
updateGPSdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:25
    77ac:	ce 01       	movw	r24, r28
    77ae:	4c 96       	adiw	r24, 0x1c	; 28
    77b0:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    77b4:	0f b6       	in	r0, 0x3f	; 63
    77b6:	f8 94       	cli
    77b8:	de bf       	out	0x3e, r29	; 62
    77ba:	0f be       	out	0x3f, r0	; 63
    77bc:	cd bf       	out	0x3d, r28	; 61
getID():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:83
//	}
//}

void getID()
{
	byte requestchar[] = { 0x24, 0x00, 0x28};
    77be:	80 91 dd 02 	lds	r24, 0x02DD	; 0x8002dd <__malloc_margin+0x36>
    77c2:	90 91 de 02 	lds	r25, 0x02DE	; 0x8002de <__malloc_margin+0x37>
    77c6:	a0 91 df 02 	lds	r26, 0x02DF	; 0x8002df <__malloc_margin+0x38>
    77ca:	8a a3       	std	Y+34, r24	; 0x22
    77cc:	9b a3       	std	Y+35, r25	; 0x23
    77ce:	ac a3       	std	Y+36, r26	; 0x24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:84
	String s = "";
    77d0:	63 ea       	ldi	r22, 0xA3	; 163
    77d2:	73 e0       	ldi	r23, 0x03	; 3
    77d4:	ce 01       	movw	r24, r28
    77d6:	4c 96       	adiw	r24, 0x1c	; 28
    77d8:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    77dc:	03 e0       	ldi	r16, 0x03	; 3
    77de:	10 e0       	ldi	r17, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:87
	for (int retry = 0; retry < 3; retry++)
	{
		s = sendata(co2Addr, requestchar);
    77e0:	be 01       	movw	r22, r28
    77e2:	6e 5d       	subi	r22, 0xDE	; 222
    77e4:	7f 4f       	sbci	r23, 0xFF	; 255
    77e6:	c1 01       	movw	r24, r2
    77e8:	0e 94 34 2c 	call	0x5868	; 0x5868 <sendata(unsigned char, unsigned char*) [clone .constprop.30]>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    77ec:	b1 01       	movw	r22, r2
    77ee:	ce 01       	movw	r24, r28
    77f0:	4c 96       	adiw	r24, 0x1c	; 28
    77f2:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
getID():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:87
    77f6:	c1 01       	movw	r24, r2
    77f8:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:88
		if (s[0] != '*') break;
    77fc:	70 e0       	ldi	r23, 0x00	; 0
    77fe:	60 e0       	ldi	r22, 0x00	; 0
    7800:	ce 01       	movw	r24, r28
    7802:	4c 96       	adiw	r24, 0x1c	; 28
    7804:	0e 94 29 06 	call	0xc52	; 0xc52 <String::operator[](unsigned int)>
    7808:	dc 01       	movw	r26, r24
    780a:	8c 91       	ld	r24, X
    780c:	8a 32       	cpi	r24, 0x2A	; 42
    780e:	19 f4       	brne	.+6      	; 0x7816 <doMeasure()+0x292>
    7810:	01 50       	subi	r16, 0x01	; 1
    7812:	11 09       	sbc	r17, r1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:85

void getID()
{
	byte requestchar[] = { 0x24, 0x00, 0x28};
	String s = "";
	for (int retry = 0; retry < 3; retry++)
    7814:	29 f7       	brne	.-54     	; 0x77e0 <doMeasure()+0x25c>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:90
	{
		s = sendata(co2Addr, requestchar);
		if (s[0] != '*') break;
	}
	if (s[0] == '*') {
    7816:	70 e0       	ldi	r23, 0x00	; 0
    7818:	60 e0       	ldi	r22, 0x00	; 0
    781a:	ce 01       	movw	r24, r28
    781c:	4c 96       	adiw	r24, 0x1c	; 28
    781e:	0e 94 29 06 	call	0xc52	; 0xc52 <String::operator[](unsigned int)>
    7822:	fc 01       	movw	r30, r24
    7824:	80 81       	ld	r24, Z
    7826:	8a 32       	cpi	r24, 0x2A	; 42
    7828:	09 f0       	breq	.+2      	; 0x782c <doMeasure()+0x2a8>
    782a:	80 c1       	rjmp	.+768    	; 0x7b2c <doMeasure()+0x5a8>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:91
		Serial.println("*K30 Read ID Error");
    782c:	69 ee       	ldi	r22, 0xE9	; 233
    782e:	75 e0       	ldi	r23, 0x05	; 5
    7830:	82 e5       	ldi	r24, 0x52	; 82
    7832:	9e e0       	ldi	r25, 0x0E	; 14
    7834:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
operator=():
    7838:	6c ef       	ldi	r22, 0xFC	; 252
    783a:	75 e0       	ldi	r23, 0x05	; 5
    783c:	86 e0       	ldi	r24, 0x06	; 6
    783e:	91 e1       	ldi	r25, 0x11	; 17
    7840:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
getID():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:84
//}

void getID()
{
	byte requestchar[] = { 0x24, 0x00, 0x28};
	String s = "";
    7844:	ce 01       	movw	r24, r28
    7846:	4c 96       	adiw	r24, 0x1c	; 28
    7848:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
measure_CO2():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:19
//		Serial.println("K30 Read CO2 Error");
//	}
//}

void measure_CO2() {
	byte requestchar[] = { 0x22, 0x00, 0x08};
    784c:	80 91 e0 02 	lds	r24, 0x02E0	; 0x8002e0 <__malloc_margin+0x39>
    7850:	90 91 e1 02 	lds	r25, 0x02E1	; 0x8002e1 <__malloc_margin+0x3a>
    7854:	a0 91 e2 02 	lds	r26, 0x02E2	; 0x8002e2 <__malloc_margin+0x3b>
    7858:	8a a3       	std	Y+34, r24	; 0x22
    785a:	9b a3       	std	Y+35, r25	; 0x23
    785c:	ac a3       	std	Y+36, r26	; 0x24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:20
	String s = "";
    785e:	63 ea       	ldi	r22, 0xA3	; 163
    7860:	73 e0       	ldi	r23, 0x03	; 3
    7862:	ce 01       	movw	r24, r28
    7864:	4c 96       	adiw	r24, 0x1c	; 28
    7866:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    786a:	03 e0       	ldi	r16, 0x03	; 3
    786c:	10 e0       	ldi	r17, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:23
	for (int retry = 0; retry < 3; retry++)
	{
		s = sendata(co2Addr, requestchar);
    786e:	be 01       	movw	r22, r28
    7870:	6e 5d       	subi	r22, 0xDE	; 222
    7872:	7f 4f       	sbci	r23, 0xFF	; 255
    7874:	c1 01       	movw	r24, r2
    7876:	0e 94 34 2c 	call	0x5868	; 0x5868 <sendata(unsigned char, unsigned char*) [clone .constprop.30]>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    787a:	b1 01       	movw	r22, r2
    787c:	ce 01       	movw	r24, r28
    787e:	4c 96       	adiw	r24, 0x1c	; 28
    7880:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
measure_CO2():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:23
    7884:	c1 01       	movw	r24, r2
    7886:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:24
		if (s[0] != '*') break;
    788a:	70 e0       	ldi	r23, 0x00	; 0
    788c:	60 e0       	ldi	r22, 0x00	; 0
    788e:	ce 01       	movw	r24, r28
    7890:	4c 96       	adiw	r24, 0x1c	; 28
    7892:	0e 94 29 06 	call	0xc52	; 0xc52 <String::operator[](unsigned int)>
    7896:	dc 01       	movw	r26, r24
    7898:	8c 91       	ld	r24, X
    789a:	8a 32       	cpi	r24, 0x2A	; 42
    789c:	19 f4       	brne	.+6      	; 0x78a4 <doMeasure()+0x320>
    789e:	01 50       	subi	r16, 0x01	; 1
    78a0:	11 09       	sbc	r17, r1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:21
//}

void measure_CO2() {
	byte requestchar[] = { 0x22, 0x00, 0x08};
	String s = "";
	for (int retry = 0; retry < 3; retry++)
    78a2:	29 f7       	brne	.-54     	; 0x786e <doMeasure()+0x2ea>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:26
	{
		s = sendata(co2Addr, requestchar);
		if (s[0] != '*') break;
	}
	if (s[0] == '*') {
    78a4:	70 e0       	ldi	r23, 0x00	; 0
    78a6:	60 e0       	ldi	r22, 0x00	; 0
    78a8:	ce 01       	movw	r24, r28
    78aa:	4c 96       	adiw	r24, 0x1c	; 28
    78ac:	0e 94 29 06 	call	0xc52	; 0xc52 <String::operator[](unsigned int)>
    78b0:	fc 01       	movw	r30, r24
    78b2:	80 81       	ld	r24, Z
    78b4:	8a 32       	cpi	r24, 0x2A	; 42
    78b6:	09 f0       	breq	.+2      	; 0x78ba <doMeasure()+0x336>
    78b8:	41 c1       	rjmp	.+642    	; 0x7b3c <doMeasure()+0x5b8>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:27
		Serial.println("*K30 Read CO2 Error");
    78ba:	65 e0       	ldi	r22, 0x05	; 5
    78bc:	76 e0       	ldi	r23, 0x06	; 6
    78be:	82 e5       	ldi	r24, 0x52	; 82
    78c0:	9e e0       	ldi	r25, 0x0E	; 14
    78c2:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:28
		valCO2 = -9999;
    78c6:	81 ef       	ldi	r24, 0xF1	; 241
    78c8:	98 ed       	ldi	r25, 0xD8	; 216
    78ca:	90 93 51 09 	sts	0x0951, r25	; 0x800951 <valCO2+0x1>
    78ce:	80 93 50 09 	sts	0x0950, r24	; 0x800950 <valCO2>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:20
//	}
//}

void measure_CO2() {
	byte requestchar[] = { 0x22, 0x00, 0x08};
	String s = "";
    78d2:	ce 01       	movw	r24, r28
    78d4:	4c 96       	adiw	r24, 0x1c	; 28
    78d6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
tsys01_get():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/TSYS01.ino:2
void tsys01_get() {
	if (isnan(temperature)) m_tsys01.begin();
    78da:	60 91 48 09 	lds	r22, 0x0948	; 0x800948 <temperature>
    78de:	70 91 49 09 	lds	r23, 0x0949	; 0x800949 <temperature+0x1>
    78e2:	80 91 4a 09 	lds	r24, 0x094A	; 0x80094a <temperature+0x2>
    78e6:	90 91 4b 09 	lds	r25, 0x094B	; 0x80094b <temperature+0x3>
    78ea:	9b 01       	movw	r18, r22
    78ec:	ac 01       	movw	r20, r24
    78ee:	0e 94 e2 6b 	call	0xd7c4	; 0xd7c4 <__unordsf2>
    78f2:	81 11       	cpse	r24, r1
begin():
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:30
}

/**
 * \brief Perform initial configuration. Has to be called once.
 */
void tsys01::begin(void) { Wire.begin(); }
    78f4:	0e 94 a5 1a 	call	0x354a	; 0x354a <TwoWire::begin() [clone .constprop.113]>
is_connected():
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:53
 * \return bool : status of TSYS01
 *       - true : Device is present
 *       - false : Device is not acknowledging I2C address
  */
bool tsys01::is_connected(void) {
  Wire.beginTransmission((uint8_t)tsys01_i2c_address);
    78f8:	80 91 2d 11 	lds	r24, 0x112D	; 0x80112d <m_tsys01>
    78fc:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:54
  return (Wire.endTransmission() == 0);
    7900:	8c e3       	ldi	r24, 0x3C	; 60
    7902:	9f e0       	ldi	r25, 0x0F	; 15
    7904:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
tsys01_get():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/TSYS01.ino:6
	connected = m_tsys01.is_connected();
	float tsys01_temp = 0.00;

	if (connected) {
    7908:	81 11       	cpse	r24, r1
    790a:	0c 94 50 48 	jmp	0x90a0	; 0x90a0 <doMeasure()+0x1b1c>
doMeasure():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/TSYS01.ino:7
		for (int i = 0; i < sample_times; i++) {
    790e:	31 2c       	mov	r3, r1
    7910:	21 2c       	mov	r2, r1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/TSYS01.ino:4
void tsys01_get() {
	if (isnan(temperature)) m_tsys01.begin();
	connected = m_tsys01.is_connected();
	float tsys01_temp = 0.00;
    7912:	c1 2c       	mov	r12, r1
    7914:	d1 2c       	mov	r13, r1
    7916:	76 01       	movw	r14, r12
tsys01_get():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/TSYS01.ino:7

	if (connected) {
		for (int i = 0; i < sample_times; i++) {
    7918:	f3 e0       	ldi	r31, 0x03	; 3
    791a:	2f 16       	cp	r2, r31
    791c:	31 04       	cpc	r3, r1
    791e:	09 f4       	brne	.+2      	; 0x7922 <doMeasure()+0x39e>
    7920:	47 c1       	rjmp	.+654    	; 0x7bb0 <doMeasure()+0x62c>
read_temperature():
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:261
  uint32_t adc;
  uint8_t i;
  float temp = 0;

  // If first time temperature is requested, get EEPROM coefficients
  if (tsys01_coeff_read == false)
    7922:	80 91 52 11 	lds	r24, 0x1152	; 0x801152 <m_tsys01+0x25>
    7926:	81 11       	cpse	r24, r1
    7928:	38 c0       	rjmp	.+112    	; 0x799a <doMeasure()+0x416>
    792a:	02 e4       	ldi	r16, 0x42	; 66
    792c:	11 e1       	ldi	r17, 0x11	; 17
    792e:	30 ea       	ldi	r19, 0xA0	; 160
    7930:	b3 2e       	mov	r11, r19
read_eeprom_coeff():
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:111
  enum tsys01_status status;
  uint8_t i2c_status;
  uint8_t buffer[2];
  uint8_t i;

  Wire.beginTransmission((uint8_t)tsys01_i2c_address);
    7932:	80 91 2d 11 	lds	r24, 0x112D	; 0x80112d <m_tsys01>
    7936:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:112
  Wire.write(command);
    793a:	6b 2d       	mov	r22, r11
    793c:	8c e3       	ldi	r24, 0x3C	; 60
    793e:	9f e0       	ldi	r25, 0x0F	; 15
    7940:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:113
  i2c_status = Wire.endTransmission();
    7944:	8c e3       	ldi	r24, 0x3C	; 60
    7946:	9f e0       	ldi	r25, 0x0F	; 15
    7948:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
    794c:	98 2e       	mov	r9, r24
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:115

  Wire.requestFrom((uint8_t)tsys01_i2c_address, 2U);
    794e:	42 e0       	ldi	r20, 0x02	; 2
    7950:	60 91 2d 11 	lds	r22, 0x112D	; 0x80112d <m_tsys01>
    7954:	8c e3       	ldi	r24, 0x3C	; 60
    7956:	9f e0       	ldi	r25, 0x0F	; 15
    7958:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <TwoWire::requestFrom(unsigned char, unsigned char)>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:117
  for (i = 0; i < 2; i++) {
    buffer[i] = Wire.read();
    795c:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
    7960:	a8 2e       	mov	r10, r24
    7962:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:124

  // Send the conversion command

  if (i2c_status == tsys01_STATUS_ERR_OVERFLOW)
    return tsys01_status_no_i2c_acknowledge;
  if (i2c_status != tsys01_STATUS_OK)
    7966:	91 10       	cpse	r9, r1
    7968:	bb c0       	rjmp	.+374    	; 0x7ae0 <doMeasure()+0x55c>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:127
    return tsys01_status_i2c_transfer_error;

  *coeff = (buffer[0] << 8) | buffer[1];
    796a:	60 96       	adiw	r28, 0x10	; 16
    796c:	af ae       	std	Y+63, r10	; 0x3f
    796e:	60 97       	sbiw	r28, 0x10	; 16
    7970:	2f 96       	adiw	r28, 0x0f	; 15
    7972:	1f ae       	std	Y+63, r1	; 0x3f
    7974:	2f 97       	sbiw	r28, 0x0f	; 15
    7976:	60 96       	adiw	r28, 0x10	; 16
    7978:	2e ad       	ldd	r18, Y+62	; 0x3e
    797a:	3f ad       	ldd	r19, Y+63	; 0x3f
    797c:	60 97       	sbiw	r28, 0x10	; 16
    797e:	28 2b       	or	r18, r24
    7980:	c9 01       	movw	r24, r18
    7982:	d8 01       	movw	r26, r16
    7984:	8d 93       	st	X+, r24
    7986:	9d 93       	st	X+, r25
    7988:	8d 01       	movw	r16, r26
    798a:	b3 94       	inc	r11
    798c:	b3 94       	inc	r11
read_eeprom():
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:146
enum tsys01_status tsys01::read_eeprom(void) {
  enum tsys01_status status;
  uint8_t i;

  // Read all coefficients from EEPROM
  for (i = 0; i < PROM_ELEMENTS_NUMBER; i++) {
    798e:	b0 eb       	ldi	r27, 0xB0	; 176
    7990:	bb 12       	cpse	r11, r27
    7992:	cf cf       	rjmp	.-98     	; 0x7932 <doMeasure()+0x3ae>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:157

  // CRC check
  if (crc_check(eeprom_coeff))
    return tsys01_status_crc_error;

  tsys01_coeff_read = true;
    7994:	e1 e0       	ldi	r30, 0x01	; 1
    7996:	e0 93 52 11 	sts	0x1152, r30	; 0x801152 <m_tsys01+0x25>
conversion_and_read_adc():
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:199
  uint8_t i;

  /* Read data */

  // Wait for conversion
  Wire.beginTransmission((uint8_t)tsys01_i2c_address);
    799a:	80 91 2d 11 	lds	r24, 0x112D	; 0x80112d <m_tsys01>
    799e:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:200
  Wire.write((uint8_t)TSYS01_START_ADC_CONVERSION);
    79a2:	68 e4       	ldi	r22, 0x48	; 72
    79a4:	8c e3       	ldi	r24, 0x3C	; 60
    79a6:	9f e0       	ldi	r25, 0x0F	; 15
    79a8:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:201
  Wire.endTransmission();
    79ac:	8c e3       	ldi	r24, 0x3C	; 60
    79ae:	9f e0       	ldi	r25, 0x0F	; 15
    79b0:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:202
  delay(TSYS01_CONVERSION_TIME);
    79b4:	6a e0       	ldi	r22, 0x0A	; 10
    79b6:	70 e0       	ldi	r23, 0x00	; 0
    79b8:	80 e0       	ldi	r24, 0x00	; 0
    79ba:	90 e0       	ldi	r25, 0x00	; 0
    79bc:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:205

  // Read ADC
  Wire.beginTransmission((uint8_t)tsys01_i2c_address);
    79c0:	80 91 2d 11 	lds	r24, 0x112D	; 0x80112d <m_tsys01>
    79c4:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:206
  Wire.write((uint8_t)TSYS01_READ_ADC_TEMPERATURE);
    79c8:	60 e0       	ldi	r22, 0x00	; 0
    79ca:	8c e3       	ldi	r24, 0x3C	; 60
    79cc:	9f e0       	ldi	r25, 0x0F	; 15
    79ce:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <TwoWire::write(unsigned char)>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:207
  Wire.endTransmission();
    79d2:	8c e3       	ldi	r24, 0x3C	; 60
    79d4:	9f e0       	ldi	r25, 0x0F	; 15
    79d6:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:208
  Wire.requestFrom((uint8_t)tsys01_i2c_address, 3U);
    79da:	43 e0       	ldi	r20, 0x03	; 3
    79dc:	60 91 2d 11 	lds	r22, 0x112D	; 0x80112d <m_tsys01>
    79e0:	8c e3       	ldi	r24, 0x3C	; 60
    79e2:	9f e0       	ldi	r25, 0x0F	; 15
    79e4:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <TwoWire::requestFrom(unsigned char, unsigned char)>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:210
  for (i = 0; i < 3; i++) {
    buffer[i] = Wire.read();
    79e8:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
    79ec:	18 2f       	mov	r17, r24
    79ee:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
    79f2:	08 2f       	mov	r16, r24
    79f4:	0e 94 3c 04 	call	0x878	; 0x878 <TwoWire::read() [clone .constprop.142]>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:220

  // Send the read command
  if (status != tsys01_status_ok)
    return status;

  *adc = ((uint32_t)buffer[0] << 16) | ((uint32_t)buffer[1] << 8) |
    79f8:	60 2f       	mov	r22, r16
    79fa:	70 e0       	ldi	r23, 0x00	; 0
    79fc:	90 e0       	ldi	r25, 0x00	; 0
    79fe:	80 e0       	ldi	r24, 0x00	; 0
    7a00:	98 2f       	mov	r25, r24
    7a02:	87 2f       	mov	r24, r23
    7a04:	76 2f       	mov	r23, r22
    7a06:	66 27       	eor	r22, r22
    7a08:	81 2b       	or	r24, r17
read_temperature():
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:270

  status = conversion_and_read_adc(&adc);
  if (status != tsys01_status_ok)
    return status;

  adc /= 256;
    7a0a:	67 2f       	mov	r22, r23
    7a0c:	78 2f       	mov	r23, r24
    7a0e:	89 2f       	mov	r24, r25
    7a10:	99 27       	eor	r25, r25
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:275

  for (i = 4; i > 0; i--) {
    temp += coeff_mul[i] *
            eeprom_coeff[1 + (4 - i)]; // eeprom_coeff[1+(4-i)] equiv. ki
    temp *= (float)adc / 100000;
    7a12:	0e 94 d9 68 	call	0xd1b2	; 0xd1b2 <__floatunsisf>
    7a16:	20 e0       	ldi	r18, 0x00	; 0
    7a18:	30 e5       	ldi	r19, 0x50	; 80
    7a1a:	43 ec       	ldi	r20, 0xC3	; 195
    7a1c:	57 e4       	ldi	r21, 0x47	; 71
    7a1e:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
    7a22:	2b 01       	movw	r4, r22
    7a24:	3c 01       	movw	r6, r24
    7a26:	0d e2       	ldi	r16, 0x2D	; 45
    7a28:	11 e1       	ldi	r17, 0x11	; 17
    7a2a:	24 e4       	ldi	r18, 0x44	; 68
    7a2c:	31 e1       	ldi	r19, 0x11	; 17
    7a2e:	2e 96       	adiw	r28, 0x0e	; 14
    7a30:	3f af       	std	Y+63, r19	; 0x3f
    7a32:	2e af       	std	Y+62, r18	; 0x3e
    7a34:	2e 97       	sbiw	r28, 0x0e	; 14
doMeasure():
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:258

enum tsys01_status tsys01::read_temperature(float *temperature) {
  enum tsys01_status status = tsys01_status_ok;
  uint32_t adc;
  uint8_t i;
  float temp = 0;
    7a36:	81 2c       	mov	r8, r1
    7a38:	91 2c       	mov	r9, r1
    7a3a:	54 01       	movw	r10, r8
read_temperature():
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:274

  adc /= 256;

  for (i = 4; i > 0; i--) {
    temp += coeff_mul[i] *
            eeprom_coeff[1 + (4 - i)]; // eeprom_coeff[1+(4-i)] equiv. ki
    7a3c:	2e 96       	adiw	r28, 0x0e	; 14
    7a3e:	ae ad       	ldd	r26, Y+62	; 0x3e
    7a40:	bf ad       	ldd	r27, Y+63	; 0x3f
    7a42:	2e 97       	sbiw	r28, 0x0e	; 14
    7a44:	6d 91       	ld	r22, X+
    7a46:	7d 91       	ld	r23, X+
    7a48:	2e 96       	adiw	r28, 0x0e	; 14
    7a4a:	bf af       	std	Y+63, r27	; 0x3f
    7a4c:	ae af       	std	Y+62, r26	; 0x3e
    7a4e:	2e 97       	sbiw	r28, 0x0e	; 14
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:273
    return status;

  adc /= 256;

  for (i = 4; i > 0; i--) {
    temp += coeff_mul[i] *
    7a50:	90 e0       	ldi	r25, 0x00	; 0
    7a52:	80 e0       	ldi	r24, 0x00	; 0
    7a54:	0e 94 d9 68 	call	0xd1b2	; 0xd1b2 <__floatunsisf>
    7a58:	f8 01       	movw	r30, r16
    7a5a:	21 89       	ldd	r18, Z+17	; 0x11
    7a5c:	32 89       	ldd	r19, Z+18	; 0x12
    7a5e:	43 89       	ldd	r20, Z+19	; 0x13
    7a60:	54 89       	ldd	r21, Z+20	; 0x14
    7a62:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
    7a66:	a5 01       	movw	r20, r10
    7a68:	94 01       	movw	r18, r8
    7a6a:	0e 94 75 6a 	call	0xd4ea	; 0xd4ea <__addsf3>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:275
            eeprom_coeff[1 + (4 - i)]; // eeprom_coeff[1+(4-i)] equiv. ki
    temp *= (float)adc / 100000;
    7a6e:	a3 01       	movw	r20, r6
    7a70:	92 01       	movw	r18, r4
    7a72:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
    7a76:	4b 01       	movw	r8, r22
    7a78:	5c 01       	movw	r10, r24
    7a7a:	04 50       	subi	r16, 0x04	; 4
    7a7c:	11 09       	sbc	r17, r1
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:272
  if (status != tsys01_status_ok)
    return status;

  adc /= 256;

  for (i = 4; i > 0; i--) {
    7a7e:	2d e1       	ldi	r18, 0x1D	; 29
    7a80:	31 e1       	ldi	r19, 0x11	; 17
    7a82:	20 17       	cp	r18, r16
    7a84:	31 07       	cpc	r19, r17
    7a86:	d1 f6       	brne	.-76     	; 0x7a3c <doMeasure()+0x4b8>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:277
    temp += coeff_mul[i] *
            eeprom_coeff[1 + (4 - i)]; // eeprom_coeff[1+(4-i)] equiv. ki
    temp *= (float)adc / 100000;
  }
  temp *= 10;
    7a88:	20 e0       	ldi	r18, 0x00	; 0
    7a8a:	30 e0       	ldi	r19, 0x00	; 0
    7a8c:	40 e2       	ldi	r20, 0x20	; 32
    7a8e:	51 e4       	ldi	r21, 0x41	; 65
    7a90:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
    7a94:	4b 01       	movw	r8, r22
    7a96:	5c 01       	movw	r10, r24
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:278
  temp += coeff_mul[0] * eeprom_coeff[5];
    7a98:	60 91 4c 11 	lds	r22, 0x114C	; 0x80114c <m_tsys01+0x1f>
    7a9c:	70 91 4d 11 	lds	r23, 0x114D	; 0x80114d <m_tsys01+0x20>
    7aa0:	90 e0       	ldi	r25, 0x00	; 0
    7aa2:	80 e0       	ldi	r24, 0x00	; 0
    7aa4:	0e 94 d9 68 	call	0xd1b2	; 0xd1b2 <__floatunsisf>
    7aa8:	20 91 2e 11 	lds	r18, 0x112E	; 0x80112e <m_tsys01+0x1>
    7aac:	30 91 2f 11 	lds	r19, 0x112F	; 0x80112f <m_tsys01+0x2>
    7ab0:	40 91 30 11 	lds	r20, 0x1130	; 0x801130 <m_tsys01+0x3>
    7ab4:	50 91 31 11 	lds	r21, 0x1131	; 0x801131 <m_tsys01+0x4>
    7ab8:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
    7abc:	a5 01       	movw	r20, r10
    7abe:	94 01       	movw	r18, r8
    7ac0:	0e 94 75 6a 	call	0xd4ea	; 0xd4ea <__addsf3>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:279
  temp /= 100;
    7ac4:	20 e0       	ldi	r18, 0x00	; 0
    7ac6:	30 e0       	ldi	r19, 0x00	; 0
    7ac8:	48 ec       	ldi	r20, 0xC8	; 200
    7aca:	52 e4       	ldi	r21, 0x42	; 66
    7acc:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:281

  *temperature = temp;
    7ad0:	60 93 48 09 	sts	0x0948, r22	; 0x800948 <temperature>
    7ad4:	70 93 49 09 	sts	0x0949, r23	; 0x800949 <temperature+0x1>
    7ad8:	80 93 4a 09 	sts	0x094A, r24	; 0x80094a <temperature+0x2>
    7adc:	90 93 4b 09 	sts	0x094B, r25	; 0x80094b <temperature+0x3>
tsys01_get():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/TSYS01.ino:9
			m_tsys01.read_temperature(&temperature);
			tsys01_temp += temperature;
    7ae0:	20 91 48 09 	lds	r18, 0x0948	; 0x800948 <temperature>
    7ae4:	30 91 49 09 	lds	r19, 0x0949	; 0x800949 <temperature+0x1>
    7ae8:	40 91 4a 09 	lds	r20, 0x094A	; 0x80094a <temperature+0x2>
    7aec:	50 91 4b 09 	lds	r21, 0x094B	; 0x80094b <temperature+0x3>
    7af0:	c7 01       	movw	r24, r14
    7af2:	b6 01       	movw	r22, r12
    7af4:	0e 94 75 6a 	call	0xd4ea	; 0xd4ea <__addsf3>
    7af8:	6b 01       	movw	r12, r22
    7afa:	7c 01       	movw	r14, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/TSYS01.ino:7
	if (isnan(temperature)) m_tsys01.begin();
	connected = m_tsys01.is_connected();
	float tsys01_temp = 0.00;

	if (connected) {
		for (int i = 0; i < sample_times; i++) {
    7afc:	3f ef       	ldi	r19, 0xFF	; 255
    7afe:	23 1a       	sub	r2, r19
    7b00:	33 0a       	sbc	r3, r19
    7b02:	0a cf       	rjmp	.-492    	; 0x7918 <doMeasure()+0x394>
operator=():
    7b04:	6b e7       	ldi	r22, 0x7B	; 123
    7b06:	75 e0       	ldi	r23, 0x05	; 5
    7b08:	8f e7       	ldi	r24, 0x7F	; 127
    7b0a:	91 e1       	ldi	r25, 0x11	; 17
    7b0c:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
    7b10:	6b e7       	ldi	r22, 0x7B	; 123
    7b12:	75 e0       	ldi	r23, 0x05	; 5
    7b14:	89 e7       	ldi	r24, 0x79	; 121
    7b16:	91 e1       	ldi	r25, 0x11	; 17
    7b18:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
    7b1c:	c9 cd       	rjmp	.-1134   	; 0x76b0 <doMeasure()+0x12c>
    7b1e:	6b e7       	ldi	r22, 0x7B	; 123
    7b20:	75 e0       	ldi	r23, 0x05	; 5
    7b22:	83 e7       	ldi	r24, 0x73	; 115
    7b24:	91 e1       	ldi	r25, 0x11	; 17
    7b26:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
    7b2a:	49 ce       	rjmp	.-878    	; 0x77be <doMeasure()+0x23a>
getID():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:95
	if (s[0] == '*') {
		Serial.println("*K30 Read ID Error");
		K30Serial = "--------";
	}
	else {
		K30Serial = s;
    7b2c:	be 01       	movw	r22, r28
    7b2e:	64 5e       	subi	r22, 0xE4	; 228
    7b30:	7f 4f       	sbci	r23, 0xFF	; 255
    7b32:	86 e0       	ldi	r24, 0x06	; 6
    7b34:	91 e1       	ldi	r25, 0x11	; 17
    7b36:	0e 94 ff 2b 	call	0x57fe	; 0x57fe <String::operator=(String const&)>
    7b3a:	84 ce       	rjmp	.-760    	; 0x7844 <doMeasure()+0x2c0>
measure_CO2():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:31
	if (s[0] == '*') {
		Serial.println("*K30 Read CO2 Error");
		valCO2 = -9999;
	}
	else {
		valCO2 = StringtoInt(s);
    7b3c:	be 01       	movw	r22, r28
    7b3e:	64 5e       	subi	r22, 0xE4	; 228
    7b40:	7f 4f       	sbci	r23, 0xFF	; 255
    7b42:	c1 01       	movw	r24, r2
    7b44:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
doMeasure():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:211
}

int StringtoInt(String s) {
	int value = 0x0000;
	byte _temp = 0;
	for (int i = 0; i < s.length(); i++) {
    7b48:	10 e0       	ldi	r17, 0x00	; 0
    7b4a:	00 e0       	ldi	r16, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:209
	}
	return value;
}

int StringtoInt(String s) {
	int value = 0x0000;
    7b4c:	f1 2c       	mov	r15, r1
    7b4e:	e1 2c       	mov	r14, r1
StringtoInt():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:211
	byte _temp = 0;
	for (int i = 0; i < s.length(); i++) {
    7b50:	8d 81       	ldd	r24, Y+5	; 0x05
    7b52:	9e 81       	ldd	r25, Y+6	; 0x06
    7b54:	08 17       	cp	r16, r24
    7b56:	19 07       	cpc	r17, r25
    7b58:	18 f5       	brcc	.+70     	; 0x7ba0 <doMeasure()+0x61c>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:213
		//judge is 0-9 or A-F
		_temp = s[i] - (s[i] < 58 ? 48 : 55);
    7b5a:	b8 01       	movw	r22, r16
    7b5c:	c1 01       	movw	r24, r2
    7b5e:	0e 94 29 06 	call	0xc52	; 0xc52 <String::operator[](unsigned int)>
    7b62:	dc 01       	movw	r26, r24
    7b64:	dc 90       	ld	r13, X
    7b66:	b8 01       	movw	r22, r16
    7b68:	c1 01       	movw	r24, r2
    7b6a:	0e 94 29 06 	call	0xc52	; 0xc52 <String::operator[](unsigned int)>
    7b6e:	fc 01       	movw	r30, r24
    7b70:	80 81       	ld	r24, Z
    7b72:	8a 33       	cpi	r24, 0x3A	; 58
    7b74:	9c f4       	brge	.+38     	; 0x7b9c <doMeasure()+0x618>
doMeasure():
    7b76:	80 e3       	ldi	r24, 0x30	; 48
StringtoInt():
    7b78:	d8 1a       	sub	r13, r24
    7b7a:	8d 2d       	mov	r24, r13
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:215
		//& operate with 0b1111 to ensure only 1 bit
		value |= _temp & 0xF;
    7b7c:	8f 70       	andi	r24, 0x0F	; 15
    7b7e:	e8 2a       	or	r14, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:217
		//shift 1 bit
		if (i < s.length() - 1)	value = value << 4;
    7b80:	8d 81       	ldd	r24, Y+5	; 0x05
    7b82:	9e 81       	ldd	r25, Y+6	; 0x06
    7b84:	01 97       	sbiw	r24, 0x01	; 1
    7b86:	08 17       	cp	r16, r24
    7b88:	19 07       	cpc	r17, r25
    7b8a:	28 f4       	brcc	.+10     	; 0x7b96 <doMeasure()+0x612>
    7b8c:	44 e0       	ldi	r20, 0x04	; 4
    7b8e:	ee 0c       	add	r14, r14
    7b90:	ff 1c       	adc	r15, r15
    7b92:	4a 95       	dec	r20
    7b94:	e1 f7       	brne	.-8      	; 0x7b8e <doMeasure()+0x60a>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:211
}

int StringtoInt(String s) {
	int value = 0x0000;
	byte _temp = 0;
	for (int i = 0; i < s.length(); i++) {
    7b96:	0f 5f       	subi	r16, 0xFF	; 255
    7b98:	1f 4f       	sbci	r17, 0xFF	; 255
    7b9a:	da cf       	rjmp	.-76     	; 0x7b50 <doMeasure()+0x5cc>
doMeasure():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:213
		//judge is 0-9 or A-F
		_temp = s[i] - (s[i] < 58 ? 48 : 55);
    7b9c:	87 e3       	ldi	r24, 0x37	; 55
    7b9e:	ec cf       	rjmp	.-40     	; 0x7b78 <doMeasure()+0x5f4>
measure_CO2():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/CO2_READ.ino:31
	if (s[0] == '*') {
		Serial.println("*K30 Read CO2 Error");
		valCO2 = -9999;
	}
	else {
		valCO2 = StringtoInt(s);
    7ba0:	f0 92 51 09 	sts	0x0951, r15	; 0x800951 <valCO2+0x1>
    7ba4:	e0 92 50 09 	sts	0x0950, r14	; 0x800950 <valCO2>
    7ba8:	c1 01       	movw	r24, r2
    7baa:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    7bae:	91 ce       	rjmp	.-734    	; 0x78d2 <doMeasure()+0x34e>
tsys01_get():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/TSYS01.ino:11
			m_tsys01.read_temperature(&temperature);
			tsys01_temp += temperature;
		}
		temperature = tsys01_temp / sample_times;
    7bb0:	20 e0       	ldi	r18, 0x00	; 0
    7bb2:	30 e0       	ldi	r19, 0x00	; 0
    7bb4:	40 e4       	ldi	r20, 0x40	; 64
    7bb6:	50 e4       	ldi	r21, 0x40	; 64
    7bb8:	c7 01       	movw	r24, r14
    7bba:	b6 01       	movw	r22, r12
    7bbc:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
    7bc0:	60 93 48 09 	sts	0x0948, r22	; 0x800948 <temperature>
    7bc4:	70 93 49 09 	sts	0x0949, r23	; 0x800949 <temperature+0x1>
    7bc8:	80 93 4a 09 	sts	0x094A, r24	; 0x80094a <temperature+0x2>
    7bcc:	90 93 4b 09 	sts	0x094B, r25	; 0x80094b <temperature+0x3>
begin():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:84
 *   @param theWire the I2C object to use, defaults to &Wire
 *   @returns true on success, false otherwise
 */
bool Adafruit_BME280::begin(uint8_t addr, TwoWire *theWire) {
  bool status = false;
  _i2caddr = addr;
    7bd0:	86 e7       	ldi	r24, 0x76	; 118
    7bd2:	80 93 d1 10 	sts	0x10D1, r24	; 0x8010d1 <bme280+0xa>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:85
  _wire = theWire;
    7bd6:	8c e3       	ldi	r24, 0x3C	; 60
    7bd8:	9f e0       	ldi	r25, 0x0F	; 15
    7bda:	90 93 c8 10 	sts	0x10C8, r25	; 0x8010c8 <bme280+0x1>
    7bde:	80 93 c7 10 	sts	0x10C7, r24	; 0x8010c7 <bme280>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:86
  status = init();
    7be2:	0e 94 4f 21 	call	0x429e	; 0x429e <Adafruit_BME280::init() [clone .constprop.73]>
measure_BME280():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:8
	float humid_temp = 0.0f;
	//if (pressure == NULL) bme280.begin();
	//if (bme280connected) bme280.begin();
	//bme280connected = bme280.is_connected();
	
	if (bme280.begin(0x76, &Wire))
    7be6:	88 23       	and	r24, r24
    7be8:	11 f4       	brne	.+4      	; 0x7bee <doMeasure()+0x66a>
    7bea:	0c 94 88 48 	jmp	0x9110	; 0x9110 <doMeasure()+0x1b8c>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:10
	{
		delay(2);
    7bee:	62 e0       	ldi	r22, 0x02	; 2
    7bf0:	70 e0       	ldi	r23, 0x00	; 0
    7bf2:	80 e0       	ldi	r24, 0x00	; 0
    7bf4:	90 e0       	ldi	r25, 0x00	; 0
    7bf6:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
readPressure():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:447
 *   @returns the pressure value (in Pascal) read from the device
 */
float Adafruit_BME280::readPressure(void) {
  int64_t var1, var2, p;

  readTemperature(); // must be done first to get t_fine
    7bfa:	0e 94 f9 1f 	call	0x3ff2	; 0x3ff2 <Adafruit_BME280::readTemperature() [clone .constprop.87]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:449

  int32_t adc_P = read24(BME280_REGISTER_PRESSUREDATA);
    7bfe:	87 ef       	ldi	r24, 0xF7	; 247
    7c00:	0e 94 56 1f 	call	0x3eac	; 0x3eac <Adafruit_BME280::read24(unsigned char) [clone .constprop.88]>
    7c04:	6d 96       	adiw	r28, 0x1d	; 29
    7c06:	6c af       	std	Y+60, r22	; 0x3c
    7c08:	7d af       	std	Y+61, r23	; 0x3d
    7c0a:	8e af       	std	Y+62, r24	; 0x3e
    7c0c:	9f af       	std	Y+63, r25	; 0x3f
    7c0e:	6d 97       	sbiw	r28, 0x1d	; 29
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:450
  if (adc_P == 0x800000) // value in case pressure measurement was disabled
    7c10:	61 15       	cp	r22, r1
    7c12:	71 05       	cpc	r23, r1
    7c14:	80 48       	sbci	r24, 0x80	; 128
    7c16:	91 05       	cpc	r25, r1
    7c18:	11 f4       	brne	.+4      	; 0x7c1e <doMeasure()+0x69a>
    7c1a:	0c 94 64 48 	jmp	0x90c8	; 0x90c8 <doMeasure()+0x1b44>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:454
    return NAN;
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
    7c1e:	80 91 d6 10 	lds	r24, 0x10D6	; 0x8010d6 <bme280+0xf>
    7c22:	90 91 d7 10 	lds	r25, 0x10D7	; 0x8010d7 <bme280+0x10>
    7c26:	a0 91 d8 10 	lds	r26, 0x10D8	; 0x8010d8 <bme280+0x11>
    7c2a:	b0 91 d9 10 	lds	r27, 0x10D9	; 0x8010d9 <bme280+0x12>
    7c2e:	6c 01       	movw	r12, r24
    7c30:	7d 01       	movw	r14, r26
    7c32:	ff 0c       	add	r15, r15
    7c34:	cc 08       	sbc	r12, r12
    7c36:	dc 2c       	mov	r13, r12
    7c38:	76 01       	movw	r14, r12
    7c3a:	9c 01       	movw	r18, r24
    7c3c:	ad 01       	movw	r20, r26
    7c3e:	6c 2d       	mov	r22, r12
    7c40:	7c 2d       	mov	r23, r12
    7c42:	8c 2d       	mov	r24, r12
    7c44:	9c 2d       	mov	r25, r12
    7c46:	34 5f       	subi	r19, 0xF4	; 244
    7c48:	41 40       	sbci	r20, 0x01	; 1
    7c4a:	51 09       	sbc	r21, r1
    7c4c:	61 09       	sbc	r22, r1
    7c4e:	71 09       	sbc	r23, r1
    7c50:	81 09       	sbc	r24, r1
    7c52:	91 09       	sbc	r25, r1
    7c54:	2d 96       	adiw	r28, 0x0d	; 13
    7c56:	2f af       	std	Y+63, r18	; 0x3f
    7c58:	2d 97       	sbiw	r28, 0x0d	; 13
    7c5a:	2f 96       	adiw	r28, 0x0f	; 15
    7c5c:	3f af       	std	Y+63, r19	; 0x3f
    7c5e:	2f 97       	sbiw	r28, 0x0f	; 15
    7c60:	61 96       	adiw	r28, 0x11	; 17
    7c62:	4f af       	std	Y+63, r20	; 0x3f
    7c64:	61 97       	sbiw	r28, 0x11	; 17
    7c66:	62 96       	adiw	r28, 0x12	; 18
    7c68:	5f af       	std	Y+63, r21	; 0x3f
    7c6a:	62 97       	sbiw	r28, 0x12	; 18
    7c6c:	63 96       	adiw	r28, 0x13	; 19
    7c6e:	6f af       	std	Y+63, r22	; 0x3f
    7c70:	63 97       	sbiw	r28, 0x13	; 19
    7c72:	64 96       	adiw	r28, 0x14	; 20
    7c74:	7f af       	std	Y+63, r23	; 0x3f
    7c76:	64 97       	sbiw	r28, 0x14	; 20
    7c78:	65 96       	adiw	r28, 0x15	; 21
    7c7a:	8f af       	std	Y+63, r24	; 0x3f
    7c7c:	65 97       	sbiw	r28, 0x15	; 21
    7c7e:	66 96       	adiw	r28, 0x16	; 22
    7c80:	9f af       	std	Y+63, r25	; 0x3f
    7c82:	66 97       	sbiw	r28, 0x16	; 22
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:455
  var2 = var1 * var1 * (int64_t)_bme280_calib.dig_P6;
    7c84:	59 01       	movw	r10, r18
    7c86:	6a 01       	movw	r12, r20
    7c88:	7b 01       	movw	r14, r22
    7c8a:	8c 01       	movw	r16, r24
    7c8c:	0e 94 33 6c 	call	0xd866	; 0xd866 <__muldi3>
    7c90:	67 96       	adiw	r28, 0x17	; 23
    7c92:	2f af       	std	Y+63, r18	; 0x3f
    7c94:	67 97       	sbiw	r28, 0x17	; 23
    7c96:	68 96       	adiw	r28, 0x18	; 24
    7c98:	3f af       	std	Y+63, r19	; 0x3f
    7c9a:	68 97       	sbiw	r28, 0x18	; 24
    7c9c:	69 96       	adiw	r28, 0x19	; 25
    7c9e:	4f af       	std	Y+63, r20	; 0x3f
    7ca0:	69 97       	sbiw	r28, 0x19	; 25
    7ca2:	a3 96       	adiw	r28, 0x23	; 35
    7ca4:	5f af       	std	Y+63, r21	; 0x3f
    7ca6:	a3 97       	sbiw	r28, 0x23	; 35
    7ca8:	a4 96       	adiw	r28, 0x24	; 36
    7caa:	6f af       	std	Y+63, r22	; 0x3f
    7cac:	a4 97       	sbiw	r28, 0x24	; 36
    7cae:	a5 96       	adiw	r28, 0x25	; 37
    7cb0:	7f af       	std	Y+63, r23	; 0x3f
    7cb2:	a5 97       	sbiw	r28, 0x25	; 37
    7cb4:	a6 96       	adiw	r28, 0x26	; 38
    7cb6:	8f af       	std	Y+63, r24	; 0x3f
    7cb8:	a6 97       	sbiw	r28, 0x26	; 38
    7cba:	a7 96       	adiw	r28, 0x27	; 39
    7cbc:	9f af       	std	Y+63, r25	; 0x3f
    7cbe:	a7 97       	sbiw	r28, 0x27	; 39
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:459
  var2 = var2 + ((var1 * (int64_t)_bme280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bme280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bme280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bme280_calib.dig_P2) << 12);
    7cc0:	30 91 eb 10 	lds	r19, 0x10EB	; 0x8010eb <bme280+0x24>
    7cc4:	20 91 ea 10 	lds	r18, 0x10EA	; 0x8010ea <bme280+0x23>
    7cc8:	93 2f       	mov	r25, r19
    7cca:	99 0f       	add	r25, r25
    7ccc:	99 0b       	sbc	r25, r25
    7cce:	49 2f       	mov	r20, r25
    7cd0:	59 2f       	mov	r21, r25
    7cd2:	69 2f       	mov	r22, r25
    7cd4:	79 2f       	mov	r23, r25
    7cd6:	89 2f       	mov	r24, r25
    7cd8:	0e 94 33 6c 	call	0xd866	; 0xd866 <__muldi3>
    7cdc:	0c e0       	ldi	r16, 0x0C	; 12
    7cde:	0e 94 62 6d 	call	0xdac4	; 0xdac4 <__ashldi3>
    7ce2:	92 2e       	mov	r9, r18
    7ce4:	83 2e       	mov	r8, r19
    7ce6:	74 2e       	mov	r7, r20
    7ce8:	65 2e       	mov	r6, r21
    7cea:	56 2e       	mov	r5, r22
    7cec:	47 2e       	mov	r4, r23
    7cee:	38 2e       	mov	r3, r24
    7cf0:	29 2e       	mov	r2, r25
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:458

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bme280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bme280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bme280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bme280_calib.dig_P3) >> 8) +
    7cf2:	30 91 ed 10 	lds	r19, 0x10ED	; 0x8010ed <bme280+0x26>
    7cf6:	20 91 ec 10 	lds	r18, 0x10EC	; 0x8010ec <bme280+0x25>
    7cfa:	93 2f       	mov	r25, r19
    7cfc:	99 0f       	add	r25, r25
    7cfe:	99 0b       	sbc	r25, r25
    7d00:	67 96       	adiw	r28, 0x17	; 23
    7d02:	af ac       	ldd	r10, Y+63	; 0x3f
    7d04:	67 97       	sbiw	r28, 0x17	; 23
    7d06:	68 96       	adiw	r28, 0x18	; 24
    7d08:	bf ac       	ldd	r11, Y+63	; 0x3f
    7d0a:	68 97       	sbiw	r28, 0x18	; 24
    7d0c:	69 96       	adiw	r28, 0x19	; 25
    7d0e:	cf ac       	ldd	r12, Y+63	; 0x3f
    7d10:	69 97       	sbiw	r28, 0x19	; 25
    7d12:	a3 96       	adiw	r28, 0x23	; 35
    7d14:	df ac       	ldd	r13, Y+63	; 0x3f
    7d16:	a3 97       	sbiw	r28, 0x23	; 35
    7d18:	a4 96       	adiw	r28, 0x24	; 36
    7d1a:	ef ac       	ldd	r14, Y+63	; 0x3f
    7d1c:	a4 97       	sbiw	r28, 0x24	; 36
    7d1e:	a5 96       	adiw	r28, 0x25	; 37
    7d20:	ff ac       	ldd	r15, Y+63	; 0x3f
    7d22:	a5 97       	sbiw	r28, 0x25	; 37
    7d24:	a6 96       	adiw	r28, 0x26	; 38
    7d26:	0f ad       	ldd	r16, Y+63	; 0x3f
    7d28:	a6 97       	sbiw	r28, 0x26	; 38
    7d2a:	a7 96       	adiw	r28, 0x27	; 39
    7d2c:	1f ad       	ldd	r17, Y+63	; 0x3f
    7d2e:	a7 97       	sbiw	r28, 0x27	; 39
    7d30:	49 2f       	mov	r20, r25
    7d32:	59 2f       	mov	r21, r25
    7d34:	69 2f       	mov	r22, r25
    7d36:	79 2f       	mov	r23, r25
    7d38:	89 2f       	mov	r24, r25
    7d3a:	0e 94 33 6c 	call	0xd866	; 0xd866 <__muldi3>
    7d3e:	08 e0       	ldi	r16, 0x08	; 8
    7d40:	0e 94 7b 6d 	call	0xdaf6	; 0xdaf6 <__ashrdi3>
    7d44:	a9 2c       	mov	r10, r9
    7d46:	b8 2c       	mov	r11, r8
    7d48:	c7 2c       	mov	r12, r7
    7d4a:	d6 2c       	mov	r13, r6
    7d4c:	e5 2c       	mov	r14, r5
    7d4e:	f4 2c       	mov	r15, r4
    7d50:	03 2d       	mov	r16, r3
    7d52:	12 2d       	mov	r17, r2
    7d54:	0e 94 98 6d 	call	0xdb30	; 0xdb30 <__adddi3>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:461
         ((var1 * (int64_t)_bme280_calib.dig_P2) << 12);
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bme280_calib.dig_P1) >> 33;
    7d58:	70 58       	subi	r23, 0x80	; 128
    7d5a:	8f 4f       	sbci	r24, 0xFF	; 255
    7d5c:	9f 4f       	sbci	r25, 0xFF	; 255
    7d5e:	20 90 e8 10 	lds	r2, 0x10E8	; 0x8010e8 <bme280+0x21>
    7d62:	30 90 e9 10 	lds	r3, 0x10E9	; 0x8010e9 <bme280+0x22>
    7d66:	51 01       	movw	r10, r2
    7d68:	c1 2c       	mov	r12, r1
    7d6a:	d1 2c       	mov	r13, r1
    7d6c:	e1 2c       	mov	r14, r1
    7d6e:	f1 2c       	mov	r15, r1
    7d70:	00 e0       	ldi	r16, 0x00	; 0
    7d72:	10 e0       	ldi	r17, 0x00	; 0
    7d74:	0e 94 33 6c 	call	0xd866	; 0xd866 <__muldi3>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:460
  var2 = var1 * var1 * (int64_t)_bme280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bme280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bme280_calib.dig_P4) << 35);
  var1 = ((var1 * var1 * (int64_t)_bme280_calib.dig_P3) >> 8) +
         ((var1 * (int64_t)_bme280_calib.dig_P2) << 12);
  var1 =
    7d78:	01 e2       	ldi	r16, 0x21	; 33
    7d7a:	0e 94 7b 6d 	call	0xdaf6	; 0xdaf6 <__ashrdi3>
    7d7e:	6e 96       	adiw	r28, 0x1e	; 30
    7d80:	2f af       	std	Y+63, r18	; 0x3f
    7d82:	6e 97       	sbiw	r28, 0x1e	; 30
    7d84:	6f 96       	adiw	r28, 0x1f	; 31
    7d86:	3f af       	std	Y+63, r19	; 0x3f
    7d88:	6f 97       	sbiw	r28, 0x1f	; 31
    7d8a:	a0 96       	adiw	r28, 0x20	; 32
    7d8c:	4f af       	std	Y+63, r20	; 0x3f
    7d8e:	a0 97       	sbiw	r28, 0x20	; 32
    7d90:	a1 96       	adiw	r28, 0x21	; 33
    7d92:	5f af       	std	Y+63, r21	; 0x3f
    7d94:	a1 97       	sbiw	r28, 0x21	; 33
    7d96:	a2 96       	adiw	r28, 0x22	; 34
    7d98:	6f af       	std	Y+63, r22	; 0x3f
    7d9a:	a2 97       	sbiw	r28, 0x22	; 34
    7d9c:	27 2e       	mov	r2, r23
    7d9e:	38 2e       	mov	r3, r24
    7da0:	49 2e       	mov	r4, r25
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:463
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bme280_calib.dig_P1) >> 33;

  if (var1 == 0) {
    7da2:	a0 e0       	ldi	r26, 0x00	; 0
    7da4:	0e 94 aa 6d 	call	0xdb54	; 0xdb54 <__cmpdi2_s8>
    7da8:	11 f4       	brne	.+4      	; 0x7dae <doMeasure()+0x82a>
    7daa:	0c 94 6a 48 	jmp	0x90d4	; 0x90d4 <doMeasure()+0x1b50>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:455
  if (adc_P == 0x800000) // value in case pressure measurement was disabled
    return NAN;
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bme280_calib.dig_P6;
    7dae:	30 91 f3 10 	lds	r19, 0x10F3	; 0x8010f3 <bme280+0x2c>
    7db2:	20 91 f2 10 	lds	r18, 0x10F2	; 0x8010f2 <bme280+0x2b>
    7db6:	93 2f       	mov	r25, r19
    7db8:	99 0f       	add	r25, r25
    7dba:	99 0b       	sbc	r25, r25
    7dbc:	67 96       	adiw	r28, 0x17	; 23
    7dbe:	af ac       	ldd	r10, Y+63	; 0x3f
    7dc0:	67 97       	sbiw	r28, 0x17	; 23
    7dc2:	68 96       	adiw	r28, 0x18	; 24
    7dc4:	bf ac       	ldd	r11, Y+63	; 0x3f
    7dc6:	68 97       	sbiw	r28, 0x18	; 24
    7dc8:	69 96       	adiw	r28, 0x19	; 25
    7dca:	cf ac       	ldd	r12, Y+63	; 0x3f
    7dcc:	69 97       	sbiw	r28, 0x19	; 25
    7dce:	a3 96       	adiw	r28, 0x23	; 35
    7dd0:	df ac       	ldd	r13, Y+63	; 0x3f
    7dd2:	a3 97       	sbiw	r28, 0x23	; 35
    7dd4:	a4 96       	adiw	r28, 0x24	; 36
    7dd6:	ef ac       	ldd	r14, Y+63	; 0x3f
    7dd8:	a4 97       	sbiw	r28, 0x24	; 36
    7dda:	a5 96       	adiw	r28, 0x25	; 37
    7ddc:	ff ac       	ldd	r15, Y+63	; 0x3f
    7dde:	a5 97       	sbiw	r28, 0x25	; 37
    7de0:	a6 96       	adiw	r28, 0x26	; 38
    7de2:	0f ad       	ldd	r16, Y+63	; 0x3f
    7de4:	a6 97       	sbiw	r28, 0x26	; 38
    7de6:	a7 96       	adiw	r28, 0x27	; 39
    7de8:	1f ad       	ldd	r17, Y+63	; 0x3f
    7dea:	a7 97       	sbiw	r28, 0x27	; 39
    7dec:	49 2f       	mov	r20, r25
    7dee:	59 2f       	mov	r21, r25
    7df0:	69 2f       	mov	r22, r25
    7df2:	79 2f       	mov	r23, r25
    7df4:	89 2f       	mov	r24, r25
    7df6:	0e 94 33 6c 	call	0xd866	; 0xd866 <__muldi3>
    7dfa:	67 96       	adiw	r28, 0x17	; 23
    7dfc:	2f af       	std	Y+63, r18	; 0x3f
    7dfe:	67 97       	sbiw	r28, 0x17	; 23
    7e00:	68 96       	adiw	r28, 0x18	; 24
    7e02:	3f af       	std	Y+63, r19	; 0x3f
    7e04:	68 97       	sbiw	r28, 0x18	; 24
    7e06:	69 96       	adiw	r28, 0x19	; 25
    7e08:	4f af       	std	Y+63, r20	; 0x3f
    7e0a:	69 97       	sbiw	r28, 0x19	; 25
    7e0c:	55 2e       	mov	r5, r21
    7e0e:	3b 01       	movw	r6, r22
    7e10:	4c 01       	movw	r8, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:456
  var2 = var2 + ((var1 * (int64_t)_bme280_calib.dig_P5) << 17);
    7e12:	30 91 f1 10 	lds	r19, 0x10F1	; 0x8010f1 <bme280+0x2a>
    7e16:	20 91 f0 10 	lds	r18, 0x10F0	; 0x8010f0 <bme280+0x29>
    7e1a:	93 2f       	mov	r25, r19
    7e1c:	99 0f       	add	r25, r25
    7e1e:	99 0b       	sbc	r25, r25
    7e20:	2d 96       	adiw	r28, 0x0d	; 13
    7e22:	af ac       	ldd	r10, Y+63	; 0x3f
    7e24:	2d 97       	sbiw	r28, 0x0d	; 13
    7e26:	2f 96       	adiw	r28, 0x0f	; 15
    7e28:	bf ac       	ldd	r11, Y+63	; 0x3f
    7e2a:	2f 97       	sbiw	r28, 0x0f	; 15
    7e2c:	61 96       	adiw	r28, 0x11	; 17
    7e2e:	cf ac       	ldd	r12, Y+63	; 0x3f
    7e30:	61 97       	sbiw	r28, 0x11	; 17
    7e32:	62 96       	adiw	r28, 0x12	; 18
    7e34:	df ac       	ldd	r13, Y+63	; 0x3f
    7e36:	62 97       	sbiw	r28, 0x12	; 18
    7e38:	63 96       	adiw	r28, 0x13	; 19
    7e3a:	ef ac       	ldd	r14, Y+63	; 0x3f
    7e3c:	63 97       	sbiw	r28, 0x13	; 19
    7e3e:	64 96       	adiw	r28, 0x14	; 20
    7e40:	ff ac       	ldd	r15, Y+63	; 0x3f
    7e42:	64 97       	sbiw	r28, 0x14	; 20
    7e44:	65 96       	adiw	r28, 0x15	; 21
    7e46:	0f ad       	ldd	r16, Y+63	; 0x3f
    7e48:	65 97       	sbiw	r28, 0x15	; 21
    7e4a:	66 96       	adiw	r28, 0x16	; 22
    7e4c:	1f ad       	ldd	r17, Y+63	; 0x3f
    7e4e:	66 97       	sbiw	r28, 0x16	; 22
    7e50:	49 2f       	mov	r20, r25
    7e52:	59 2f       	mov	r21, r25
    7e54:	69 2f       	mov	r22, r25
    7e56:	79 2f       	mov	r23, r25
    7e58:	89 2f       	mov	r24, r25
    7e5a:	0e 94 33 6c 	call	0xd866	; 0xd866 <__muldi3>
    7e5e:	01 e1       	ldi	r16, 0x11	; 17
    7e60:	0e 94 62 6d 	call	0xdac4	; 0xdac4 <__ashldi3>
    7e64:	67 96       	adiw	r28, 0x17	; 23
    7e66:	af ac       	ldd	r10, Y+63	; 0x3f
    7e68:	67 97       	sbiw	r28, 0x17	; 23
    7e6a:	68 96       	adiw	r28, 0x18	; 24
    7e6c:	bf ac       	ldd	r11, Y+63	; 0x3f
    7e6e:	68 97       	sbiw	r28, 0x18	; 24
    7e70:	69 96       	adiw	r28, 0x19	; 25
    7e72:	cf ac       	ldd	r12, Y+63	; 0x3f
    7e74:	69 97       	sbiw	r28, 0x19	; 25
    7e76:	d5 2c       	mov	r13, r5
    7e78:	73 01       	movw	r14, r6
    7e7a:	84 01       	movw	r16, r8
    7e7c:	0e 94 98 6d 	call	0xdb30	; 0xdb30 <__adddi3>
    7e80:	59 01       	movw	r10, r18
    7e82:	6a 01       	movw	r12, r20
    7e84:	7b 01       	movw	r14, r22
    7e86:	18 2f       	mov	r17, r24
    7e88:	59 2e       	mov	r5, r25
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:452
  readTemperature(); // must be done first to get t_fine

  int32_t adc_P = read24(BME280_REGISTER_PRESSUREDATA);
  if (adc_P == 0x800000) // value in case pressure measurement was disabled
    return NAN;
  adc_P >>= 4;
    7e8a:	6d 96       	adiw	r28, 0x1d	; 29
    7e8c:	4c ad       	ldd	r20, Y+60	; 0x3c
    7e8e:	5d ad       	ldd	r21, Y+61	; 0x3d
    7e90:	6e ad       	ldd	r22, Y+62	; 0x3e
    7e92:	7f ad       	ldd	r23, Y+63	; 0x3f
    7e94:	6d 97       	sbiw	r28, 0x1d	; 29
    7e96:	84 e0       	ldi	r24, 0x04	; 4
    7e98:	75 95       	asr	r23
    7e9a:	67 95       	ror	r22
    7e9c:	57 95       	ror	r21
    7e9e:	47 95       	ror	r20
    7ea0:	8a 95       	dec	r24
    7ea2:	d1 f7       	brne	.-12     	; 0x7e98 <doMeasure()+0x914>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:466
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bme280_calib.dig_P1) >> 33;

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
    7ea4:	80 e0       	ldi	r24, 0x00	; 0
    7ea6:	90 e0       	ldi	r25, 0x00	; 0
    7ea8:	a0 e1       	ldi	r26, 0x10	; 16
    7eaa:	b0 e0       	ldi	r27, 0x00	; 0
    7eac:	84 1b       	sub	r24, r20
    7eae:	95 0b       	sbc	r25, r21
    7eb0:	a6 0b       	sbc	r26, r22
    7eb2:	b7 0b       	sbc	r27, r23
    7eb4:	3c 01       	movw	r6, r24
    7eb6:	4d 01       	movw	r8, r26
    7eb8:	99 0c       	add	r9, r9
    7eba:	66 08       	sbc	r6, r6
    7ebc:	76 2c       	mov	r7, r6
    7ebe:	43 01       	movw	r8, r6
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:467
  p = (((p << 31) - var2) * 3125) / var1;
    7ec0:	9c 01       	movw	r18, r24
    7ec2:	ad 01       	movw	r20, r26
    7ec4:	66 2d       	mov	r22, r6
    7ec6:	76 2d       	mov	r23, r6
    7ec8:	86 2d       	mov	r24, r6
    7eca:	96 2d       	mov	r25, r6
    7ecc:	0f e1       	ldi	r16, 0x1F	; 31
    7ece:	0e 94 62 6d 	call	0xdac4	; 0xdac4 <__ashldi3>
    7ed2:	39 01       	movw	r6, r18
    7ed4:	4a 01       	movw	r8, r20
    7ed6:	b6 2f       	mov	r27, r22
    7ed8:	a7 2f       	mov	r26, r23
    7eda:	f8 2f       	mov	r31, r24
    7edc:	e9 2f       	mov	r30, r25
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:457
  adc_P >>= 4;

  var1 = ((int64_t)t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)_bme280_calib.dig_P6;
  var2 = var2 + ((var1 * (int64_t)_bme280_calib.dig_P5) << 17);
  var2 = var2 + (((int64_t)_bme280_calib.dig_P4) << 35);
    7ede:	30 91 ef 10 	lds	r19, 0x10EF	; 0x8010ef <bme280+0x28>
    7ee2:	20 91 ee 10 	lds	r18, 0x10EE	; 0x8010ee <bme280+0x27>
    7ee6:	93 2f       	mov	r25, r19
    7ee8:	99 0f       	add	r25, r25
    7eea:	99 0b       	sbc	r25, r25
    7eec:	49 2f       	mov	r20, r25
    7eee:	59 2f       	mov	r21, r25
    7ef0:	69 2f       	mov	r22, r25
    7ef2:	79 2f       	mov	r23, r25
    7ef4:	89 2f       	mov	r24, r25
    7ef6:	03 e2       	ldi	r16, 0x23	; 35
    7ef8:	0e 94 62 6d 	call	0xdac4	; 0xdac4 <__ashldi3>
    7efc:	01 2f       	mov	r16, r17
    7efe:	15 2d       	mov	r17, r5
    7f00:	0e 94 98 6d 	call	0xdb30	; 0xdb30 <__adddi3>
    7f04:	59 01       	movw	r10, r18
    7f06:	6a 01       	movw	r12, r20
    7f08:	7b 01       	movw	r14, r22
    7f0a:	8c 01       	movw	r16, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:467

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
    7f0c:	93 01       	movw	r18, r6
    7f0e:	a4 01       	movw	r20, r8
    7f10:	6b 2f       	mov	r22, r27
    7f12:	7a 2f       	mov	r23, r26
    7f14:	8f 2f       	mov	r24, r31
    7f16:	9e 2f       	mov	r25, r30
    7f18:	0e 94 a1 6d 	call	0xdb42	; 0xdb42 <__subdi3>
    7f1c:	e5 e3       	ldi	r30, 0x35	; 53
    7f1e:	ae 2e       	mov	r10, r30
    7f20:	fc e0       	ldi	r31, 0x0C	; 12
    7f22:	bf 2e       	mov	r11, r31
    7f24:	c1 2c       	mov	r12, r1
    7f26:	d1 2c       	mov	r13, r1
    7f28:	e1 2c       	mov	r14, r1
    7f2a:	f1 2c       	mov	r15, r1
    7f2c:	00 e0       	ldi	r16, 0x00	; 0
    7f2e:	10 e0       	ldi	r17, 0x00	; 0
    7f30:	0e 94 33 6c 	call	0xd866	; 0xd866 <__muldi3>
    7f34:	6e 96       	adiw	r28, 0x1e	; 30
    7f36:	af ac       	ldd	r10, Y+63	; 0x3f
    7f38:	6e 97       	sbiw	r28, 0x1e	; 30
    7f3a:	6f 96       	adiw	r28, 0x1f	; 31
    7f3c:	bf ac       	ldd	r11, Y+63	; 0x3f
    7f3e:	6f 97       	sbiw	r28, 0x1f	; 31
    7f40:	a0 96       	adiw	r28, 0x20	; 32
    7f42:	cf ac       	ldd	r12, Y+63	; 0x3f
    7f44:	a0 97       	sbiw	r28, 0x20	; 32
    7f46:	a1 96       	adiw	r28, 0x21	; 33
    7f48:	df ac       	ldd	r13, Y+63	; 0x3f
    7f4a:	a1 97       	sbiw	r28, 0x21	; 33
    7f4c:	a2 96       	adiw	r28, 0x22	; 34
    7f4e:	ef ac       	ldd	r14, Y+63	; 0x3f
    7f50:	a2 97       	sbiw	r28, 0x22	; 34
    7f52:	f2 2c       	mov	r15, r2
    7f54:	03 2d       	mov	r16, r3
    7f56:	14 2d       	mov	r17, r4
    7f58:	0e 94 8d 6c 	call	0xd91a	; 0xd91a <__divdi3>
    7f5c:	2d 96       	adiw	r28, 0x0d	; 13
    7f5e:	2f af       	std	Y+63, r18	; 0x3f
    7f60:	2d 97       	sbiw	r28, 0x0d	; 13
    7f62:	2f 96       	adiw	r28, 0x0f	; 15
    7f64:	3f af       	std	Y+63, r19	; 0x3f
    7f66:	2f 97       	sbiw	r28, 0x0f	; 15
    7f68:	61 96       	adiw	r28, 0x11	; 17
    7f6a:	4f af       	std	Y+63, r20	; 0x3f
    7f6c:	61 97       	sbiw	r28, 0x11	; 17
    7f6e:	62 96       	adiw	r28, 0x12	; 18
    7f70:	5f af       	std	Y+63, r21	; 0x3f
    7f72:	62 97       	sbiw	r28, 0x12	; 18
    7f74:	63 96       	adiw	r28, 0x13	; 19
    7f76:	6f af       	std	Y+63, r22	; 0x3f
    7f78:	63 97       	sbiw	r28, 0x13	; 19
    7f7a:	64 96       	adiw	r28, 0x14	; 20
    7f7c:	7f af       	std	Y+63, r23	; 0x3f
    7f7e:	64 97       	sbiw	r28, 0x14	; 20
    7f80:	65 96       	adiw	r28, 0x15	; 21
    7f82:	8f af       	std	Y+63, r24	; 0x3f
    7f84:	65 97       	sbiw	r28, 0x15	; 21
    7f86:	66 96       	adiw	r28, 0x16	; 22
    7f88:	9f af       	std	Y+63, r25	; 0x3f
    7f8a:	66 97       	sbiw	r28, 0x16	; 22
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:468
  var1 = (((int64_t)_bme280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
    7f8c:	0d e0       	ldi	r16, 0x0D	; 13
    7f8e:	0e 94 7b 6d 	call	0xdaf6	; 0xdaf6 <__ashrdi3>
    7f92:	92 2e       	mov	r9, r18
    7f94:	83 2e       	mov	r8, r19
    7f96:	74 2e       	mov	r7, r20
    7f98:	65 2e       	mov	r6, r21
    7f9a:	56 2e       	mov	r5, r22
    7f9c:	47 2e       	mov	r4, r23
    7f9e:	38 2e       	mov	r3, r24
    7fa0:	29 2e       	mov	r2, r25
    7fa2:	30 91 f9 10 	lds	r19, 0x10F9	; 0x8010f9 <bme280+0x32>
    7fa6:	20 91 f8 10 	lds	r18, 0x10F8	; 0x8010f8 <bme280+0x31>
    7faa:	93 2f       	mov	r25, r19
    7fac:	99 0f       	add	r25, r25
    7fae:	99 0b       	sbc	r25, r25
    7fb0:	a9 2c       	mov	r10, r9
    7fb2:	b8 2c       	mov	r11, r8
    7fb4:	c7 2c       	mov	r12, r7
    7fb6:	d6 2c       	mov	r13, r6
    7fb8:	e5 2c       	mov	r14, r5
    7fba:	f4 2c       	mov	r15, r4
    7fbc:	03 2d       	mov	r16, r3
    7fbe:	12 2d       	mov	r17, r2
    7fc0:	49 2f       	mov	r20, r25
    7fc2:	59 2f       	mov	r21, r25
    7fc4:	69 2f       	mov	r22, r25
    7fc6:	79 2f       	mov	r23, r25
    7fc8:	89 2f       	mov	r24, r25
    7fca:	0e 94 33 6c 	call	0xd866	; 0xd866 <__muldi3>
    7fce:	0e 94 33 6c 	call	0xd866	; 0xd866 <__muldi3>
    7fd2:	09 e1       	ldi	r16, 0x19	; 25
    7fd4:	0e 94 7b 6d 	call	0xdaf6	; 0xdaf6 <__ashrdi3>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:471
  var2 = (((int64_t)_bme280_calib.dig_P8) * p) >> 19;

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bme280_calib.dig_P7) << 4);
    7fd8:	2d 96       	adiw	r28, 0x0d	; 13
    7fda:	af ac       	ldd	r10, Y+63	; 0x3f
    7fdc:	2d 97       	sbiw	r28, 0x0d	; 13
    7fde:	2f 96       	adiw	r28, 0x0f	; 15
    7fe0:	bf ac       	ldd	r11, Y+63	; 0x3f
    7fe2:	2f 97       	sbiw	r28, 0x0f	; 15
    7fe4:	61 96       	adiw	r28, 0x11	; 17
    7fe6:	cf ac       	ldd	r12, Y+63	; 0x3f
    7fe8:	61 97       	sbiw	r28, 0x11	; 17
    7fea:	62 96       	adiw	r28, 0x12	; 18
    7fec:	df ac       	ldd	r13, Y+63	; 0x3f
    7fee:	62 97       	sbiw	r28, 0x12	; 18
    7ff0:	63 96       	adiw	r28, 0x13	; 19
    7ff2:	ef ac       	ldd	r14, Y+63	; 0x3f
    7ff4:	63 97       	sbiw	r28, 0x13	; 19
    7ff6:	64 96       	adiw	r28, 0x14	; 20
    7ff8:	ff ac       	ldd	r15, Y+63	; 0x3f
    7ffa:	64 97       	sbiw	r28, 0x14	; 20
    7ffc:	65 96       	adiw	r28, 0x15	; 21
    7ffe:	0f ad       	ldd	r16, Y+63	; 0x3f
    8000:	65 97       	sbiw	r28, 0x15	; 21
    8002:	66 96       	adiw	r28, 0x16	; 22
    8004:	1f ad       	ldd	r17, Y+63	; 0x3f
    8006:	66 97       	sbiw	r28, 0x16	; 22
    8008:	0e 94 98 6d 	call	0xdb30	; 0xdb30 <__adddi3>
    800c:	19 01       	movw	r2, r18
    800e:	2a 01       	movw	r4, r20
    8010:	3b 01       	movw	r6, r22
    8012:	4c 01       	movw	r8, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:469
    return 0; // avoid exception caused by division by zero
  }
  p = 1048576 - adc_P;
  p = (((p << 31) - var2) * 3125) / var1;
  var1 = (((int64_t)_bme280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
  var2 = (((int64_t)_bme280_calib.dig_P8) * p) >> 19;
    8014:	30 91 f7 10 	lds	r19, 0x10F7	; 0x8010f7 <bme280+0x30>
    8018:	20 91 f6 10 	lds	r18, 0x10F6	; 0x8010f6 <bme280+0x2f>
    801c:	93 2f       	mov	r25, r19
    801e:	99 0f       	add	r25, r25
    8020:	99 0b       	sbc	r25, r25
    8022:	49 2f       	mov	r20, r25
    8024:	59 2f       	mov	r21, r25
    8026:	69 2f       	mov	r22, r25
    8028:	79 2f       	mov	r23, r25
    802a:	89 2f       	mov	r24, r25
    802c:	0e 94 33 6c 	call	0xd866	; 0xd866 <__muldi3>
    8030:	03 e1       	ldi	r16, 0x13	; 19
    8032:	0e 94 7b 6d 	call	0xdaf6	; 0xdaf6 <__ashrdi3>
    8036:	59 01       	movw	r10, r18
    8038:	6a 01       	movw	r12, r20
    803a:	7b 01       	movw	r14, r22
    803c:	8c 01       	movw	r16, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:471

  p = ((p + var1 + var2) >> 8) + (((int64_t)_bme280_calib.dig_P7) << 4);
    803e:	91 01       	movw	r18, r2
    8040:	a2 01       	movw	r20, r4
    8042:	b3 01       	movw	r22, r6
    8044:	c4 01       	movw	r24, r8
    8046:	0e 94 98 6d 	call	0xdb30	; 0xdb30 <__adddi3>
    804a:	08 e0       	ldi	r16, 0x08	; 8
    804c:	0e 94 7b 6d 	call	0xdaf6	; 0xdaf6 <__ashrdi3>
    8050:	59 01       	movw	r10, r18
    8052:	6a 01       	movw	r12, r20
    8054:	7b 01       	movw	r14, r22
    8056:	e8 2f       	mov	r30, r24
    8058:	19 2f       	mov	r17, r25
    805a:	30 91 f5 10 	lds	r19, 0x10F5	; 0x8010f5 <bme280+0x2e>
    805e:	20 91 f4 10 	lds	r18, 0x10F4	; 0x8010f4 <bme280+0x2d>
    8062:	93 2f       	mov	r25, r19
    8064:	99 0f       	add	r25, r25
    8066:	99 0b       	sbc	r25, r25
    8068:	49 2f       	mov	r20, r25
    806a:	59 2f       	mov	r21, r25
    806c:	69 2f       	mov	r22, r25
    806e:	79 2f       	mov	r23, r25
    8070:	89 2f       	mov	r24, r25
    8072:	04 e0       	ldi	r16, 0x04	; 4
    8074:	0e 94 62 6d 	call	0xdac4	; 0xdac4 <__ashldi3>
    8078:	0e 2f       	mov	r16, r30
    807a:	0e 94 98 6d 	call	0xdb30	; 0xdb30 <__adddi3>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:472
  return (float)p / 256;
    807e:	0e 94 89 6b 	call	0xd712	; 0xd712 <__floatdisf>
    8082:	20 e0       	ldi	r18, 0x00	; 0
    8084:	30 e0       	ldi	r19, 0x00	; 0
    8086:	40 e8       	ldi	r20, 0x80	; 128
    8088:	5b e3       	ldi	r21, 0x3B	; 59
    808a:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
measure_BME280():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:11
		pressure = bme280.readPressure();
    808e:	60 93 30 09 	sts	0x0930, r22	; 0x800930 <pressure>
    8092:	70 93 31 09 	sts	0x0931, r23	; 0x800931 <pressure+0x1>
    8096:	80 93 32 09 	sts	0x0932, r24	; 0x800932 <pressure+0x2>
    809a:	90 93 33 09 	sts	0x0933, r25	; 0x800933 <pressure+0x3>
readHumidity():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:480
/*!
 *  @brief  Returns the humidity from the sensor
 *  @returns the humidity value read from the device
 */
float Adafruit_BME280::readHumidity(void) {
  readTemperature(); // must be done first to get t_fine
    809e:	0e 94 f9 1f 	call	0x3ff2	; 0x3ff2 <Adafruit_BME280::readTemperature() [clone .constprop.87]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:482

  int32_t adc_H = read16(BME280_REGISTER_HUMIDDATA);
    80a2:	8d ef       	ldi	r24, 0xFD	; 253
    80a4:	0e 94 95 20 	call	0x412a	; 0x412a <Adafruit_BME280::read16(unsigned char) [clone .constprop.85]>
    80a8:	b0 e0       	ldi	r27, 0x00	; 0
    80aa:	a0 e0       	ldi	r26, 0x00	; 0
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:483
  if (adc_H == 0x8000) // value in case humidity measurement was disabled
    80ac:	81 15       	cp	r24, r1
    80ae:	e0 e8       	ldi	r30, 0x80	; 128
    80b0:	9e 07       	cpc	r25, r30
    80b2:	a1 05       	cpc	r26, r1
    80b4:	b1 05       	cpc	r27, r1
    80b6:	11 f4       	brne	.+4      	; 0x80bc <doMeasure()+0xb38>
    80b8:	0c 94 6f 48 	jmp	0x90de	; 0x90de <doMeasure()+0x1b5a>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:488
    return NAN;

  int32_t v_x1_u32r;

  v_x1_u32r = (t_fine - ((int32_t)76800));
    80bc:	80 90 d6 10 	lds	r8, 0x10D6	; 0x8010d6 <bme280+0xf>
    80c0:	90 90 d7 10 	lds	r9, 0x10D7	; 0x8010d7 <bme280+0x10>
    80c4:	a0 90 d8 10 	lds	r10, 0x10D8	; 0x8010d8 <bme280+0x11>
    80c8:	b0 90 d9 10 	lds	r11, 0x10D9	; 0x8010d9 <bme280+0x12>
    80cc:	fc e2       	ldi	r31, 0x2C	; 44
    80ce:	9f 1a       	sub	r9, r31
    80d0:	f1 e0       	ldi	r31, 0x01	; 1
    80d2:	af 0a       	sbc	r10, r31
    80d4:	b1 08       	sbc	r11, r1
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:490

  v_x1_u32r = (((((adc_H << 14) - (((int32_t)_bme280_calib.dig_H4) << 20) -
    80d6:	6c 01       	movw	r12, r24
    80d8:	7d 01       	movw	r14, r26
    80da:	3e e0       	ldi	r19, 0x0E	; 14
    80dc:	cc 0c       	add	r12, r12
    80de:	dd 1c       	adc	r13, r13
    80e0:	ee 1c       	adc	r14, r14
    80e2:	ff 1c       	adc	r15, r15
    80e4:	3a 95       	dec	r19
    80e6:	d1 f7       	brne	.-12     	; 0x80dc <doMeasure()+0xb58>
    80e8:	80 91 fe 10 	lds	r24, 0x10FE	; 0x8010fe <bme280+0x37>
    80ec:	90 91 ff 10 	lds	r25, 0x10FF	; 0x8010ff <bme280+0x38>
    80f0:	09 2e       	mov	r0, r25
    80f2:	00 0c       	add	r0, r0
    80f4:	aa 0b       	sbc	r26, r26
    80f6:	bb 0b       	sbc	r27, r27
    80f8:	44 e1       	ldi	r20, 0x14	; 20
    80fa:	88 0f       	add	r24, r24
    80fc:	99 1f       	adc	r25, r25
    80fe:	aa 1f       	adc	r26, r26
    8100:	bb 1f       	adc	r27, r27
    8102:	4a 95       	dec	r20
    8104:	d1 f7       	brne	.-12     	; 0x80fa <doMeasure()+0xb76>
    8106:	c8 1a       	sub	r12, r24
    8108:	d9 0a       	sbc	r13, r25
    810a:	ea 0a       	sbc	r14, r26
    810c:	fb 0a       	sbc	r15, r27
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:491
                  (((int32_t)_bme280_calib.dig_H5) * v_x1_u32r)) +
    810e:	a0 91 00 11 	lds	r26, 0x1100	; 0x801100 <bme280+0x39>
    8112:	b0 91 01 11 	lds	r27, 0x1101	; 0x801101 <bme280+0x3a>
    8116:	a5 01       	movw	r20, r10
    8118:	94 01       	movw	r18, r8
    811a:	0e 94 3b 6a 	call	0xd476	; 0xd476 <__mulshisi3>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:490

  int32_t v_x1_u32r;

  v_x1_u32r = (t_fine - ((int32_t)76800));

  v_x1_u32r = (((((adc_H << 14) - (((int32_t)_bme280_calib.dig_H4) << 20) -
    811e:	c6 1a       	sub	r12, r22
    8120:	d7 0a       	sbc	r13, r23
    8122:	e8 0a       	sbc	r14, r24
    8124:	f9 0a       	sbc	r15, r25
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:491
                  (((int32_t)_bme280_calib.dig_H5) * v_x1_u32r)) +
    8126:	20 e4       	ldi	r18, 0x40	; 64
    8128:	d2 0e       	add	r13, r18
    812a:	e1 1c       	adc	r14, r1
    812c:	f1 1c       	adc	r15, r1
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:492
                 ((int32_t)16384)) >>
    812e:	5f e0       	ldi	r21, 0x0F	; 15
    8130:	f5 94       	asr	r15
    8132:	e7 94       	ror	r14
    8134:	d7 94       	ror	r13
    8136:	c7 94       	ror	r12
    8138:	5a 95       	dec	r21
    813a:	d1 f7       	brne	.-12     	; 0x8130 <doMeasure()+0xbac>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:495
                15) *
               (((((((v_x1_u32r * ((int32_t)_bme280_calib.dig_H6)) >> 10) *
                    (((v_x1_u32r * ((int32_t)_bme280_calib.dig_H3)) >> 11) +
    813c:	a0 91 fd 10 	lds	r26, 0x10FD	; 0x8010fd <bme280+0x36>
    8140:	b0 e0       	ldi	r27, 0x00	; 0
    8142:	a5 01       	movw	r20, r10
    8144:	94 01       	movw	r18, r8
    8146:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
    814a:	2b 01       	movw	r4, r22
    814c:	3c 01       	movw	r6, r24
    814e:	6b e0       	ldi	r22, 0x0B	; 11
    8150:	75 94       	asr	r7
    8152:	67 94       	ror	r6
    8154:	57 94       	ror	r5
    8156:	47 94       	ror	r4
    8158:	6a 95       	dec	r22
    815a:	d1 f7       	brne	.-12     	; 0x8150 <doMeasure()+0xbcc>
    815c:	30 e8       	ldi	r19, 0x80	; 128
    815e:	53 0e       	add	r5, r19
    8160:	61 1c       	adc	r6, r1
    8162:	71 1c       	adc	r7, r1
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:494

  v_x1_u32r = (((((adc_H << 14) - (((int32_t)_bme280_calib.dig_H4) << 20) -
                  (((int32_t)_bme280_calib.dig_H5) * v_x1_u32r)) +
                 ((int32_t)16384)) >>
                15) *
               (((((((v_x1_u32r * ((int32_t)_bme280_calib.dig_H6)) >> 10) *
    8164:	a0 91 02 11 	lds	r26, 0x1102	; 0x801102 <bme280+0x3b>
    8168:	0a 2e       	mov	r0, r26
    816a:	00 0c       	add	r0, r0
    816c:	bb 0b       	sbc	r27, r27
    816e:	94 01       	movw	r18, r8
    8170:	0e 94 3b 6a 	call	0xd476	; 0xd476 <__mulshisi3>
    8174:	ea e0       	ldi	r30, 0x0A	; 10
    8176:	95 95       	asr	r25
    8178:	87 95       	ror	r24
    817a:	77 95       	ror	r23
    817c:	67 95       	ror	r22
    817e:	ea 95       	dec	r30
    8180:	d1 f7       	brne	.-12     	; 0x8176 <doMeasure()+0xbf2>
    8182:	a3 01       	movw	r20, r6
    8184:	92 01       	movw	r18, r4
    8186:	0e 94 e7 6b 	call	0xd7ce	; 0xd7ce <__mulsi3>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:496
                    (((v_x1_u32r * ((int32_t)_bme280_calib.dig_H3)) >> 11) +
                     ((int32_t)32768))) >>
    818a:	9b 01       	movw	r18, r22
    818c:	ac 01       	movw	r20, r24
    818e:	fa e0       	ldi	r31, 0x0A	; 10
    8190:	55 95       	asr	r21
    8192:	47 95       	ror	r20
    8194:	37 95       	ror	r19
    8196:	27 95       	ror	r18
    8198:	fa 95       	dec	r31
    819a:	d1 f7       	brne	.-12     	; 0x8190 <doMeasure()+0xc0c>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:497
                   10) +
    819c:	40 5e       	subi	r20, 0xE0	; 224
    819e:	5f 4f       	sbci	r21, 0xFF	; 255
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:499
                  ((int32_t)2097152)) *
                     ((int32_t)_bme280_calib.dig_H2) +
    81a0:	a0 91 fb 10 	lds	r26, 0x10FB	; 0x8010fb <bme280+0x34>
    81a4:	b0 91 fc 10 	lds	r27, 0x10FC	; 0x8010fc <bme280+0x35>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:498
                15) *
               (((((((v_x1_u32r * ((int32_t)_bme280_calib.dig_H6)) >> 10) *
                    (((v_x1_u32r * ((int32_t)_bme280_calib.dig_H3)) >> 11) +
                     ((int32_t)32768))) >>
                   10) +
                  ((int32_t)2097152)) *
    81a8:	0e 94 3b 6a 	call	0xd476	; 0xd476 <__mulshisi3>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:499
                     ((int32_t)_bme280_calib.dig_H2) +
    81ac:	70 5e       	subi	r23, 0xE0	; 224
    81ae:	8f 4f       	sbci	r24, 0xFF	; 255
    81b0:	9f 4f       	sbci	r25, 0xFF	; 255
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:500
                 8192) >>
    81b2:	ae e0       	ldi	r26, 0x0E	; 14
    81b4:	95 95       	asr	r25
    81b6:	87 95       	ror	r24
    81b8:	77 95       	ror	r23
    81ba:	67 95       	ror	r22
    81bc:	aa 95       	dec	r26
    81be:	d1 f7       	brne	.-12     	; 0x81b4 <doMeasure()+0xc30>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:490

  int32_t v_x1_u32r;

  v_x1_u32r = (t_fine - ((int32_t)76800));

  v_x1_u32r = (((((adc_H << 14) - (((int32_t)_bme280_calib.dig_H4) << 20) -
    81c0:	a7 01       	movw	r20, r14
    81c2:	96 01       	movw	r18, r12
    81c4:	0e 94 e7 6b 	call	0xd7ce	; 0xd7ce <__mulsi3>
    81c8:	6b 01       	movw	r12, r22
    81ca:	7c 01       	movw	r14, r24
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:503
                  ((int32_t)2097152)) *
                     ((int32_t)_bme280_calib.dig_H2) +
                 8192) >>
                14));

  v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) *
    81cc:	bf e0       	ldi	r27, 0x0F	; 15
    81ce:	95 95       	asr	r25
    81d0:	87 95       	ror	r24
    81d2:	77 95       	ror	r23
    81d4:	67 95       	ror	r22
    81d6:	ba 95       	dec	r27
    81d8:	d1 f7       	brne	.-12     	; 0x81ce <doMeasure()+0xc4a>
    81da:	9b 01       	movw	r18, r22
    81dc:	ac 01       	movw	r20, r24
    81de:	0e 94 e7 6b 	call	0xd7ce	; 0xd7ce <__mulsi3>
    81e2:	9b 01       	movw	r18, r22
    81e4:	ac 01       	movw	r20, r24
    81e6:	17 e0       	ldi	r17, 0x07	; 7
    81e8:	55 95       	asr	r21
    81ea:	47 95       	ror	r20
    81ec:	37 95       	ror	r19
    81ee:	27 95       	ror	r18
    81f0:	1a 95       	dec	r17
    81f2:	d1 f7       	brne	.-12     	; 0x81e8 <doMeasure()+0xc64>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:504
                             ((int32_t)_bme280_calib.dig_H1)) >>
    81f4:	a0 91 fa 10 	lds	r26, 0x10FA	; 0x8010fa <bme280+0x33>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:503
                  ((int32_t)2097152)) *
                     ((int32_t)_bme280_calib.dig_H2) +
                 8192) >>
                14));

  v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) *
    81f8:	b0 e0       	ldi	r27, 0x00	; 0
    81fa:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:504
                             ((int32_t)_bme280_calib.dig_H1)) >>
    81fe:	04 e0       	ldi	r16, 0x04	; 4
    8200:	95 95       	asr	r25
    8202:	87 95       	ror	r24
    8204:	77 95       	ror	r23
    8206:	67 95       	ror	r22
    8208:	0a 95       	dec	r16
    820a:	d1 f7       	brne	.-12     	; 0x8200 <doMeasure()+0xc7c>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:507
                            4));

  v_x1_u32r = (v_x1_u32r < 0) ? 0 : v_x1_u32r;
    820c:	c6 1a       	sub	r12, r22
    820e:	d7 0a       	sbc	r13, r23
    8210:	e8 0a       	sbc	r14, r24
    8212:	f9 0a       	sbc	r15, r25
    8214:	f7 fe       	sbrs	r15, 7
    8216:	03 c0       	rjmp	.+6      	; 0x821e <doMeasure()+0xc9a>
    8218:	c1 2c       	mov	r12, r1
    821a:	d1 2c       	mov	r13, r1
    821c:	76 01       	movw	r14, r12
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:508
  v_x1_u32r = (v_x1_u32r > 419430400) ? 419430400 : v_x1_u32r;
    821e:	c7 01       	movw	r24, r14
    8220:	b6 01       	movw	r22, r12
    8222:	61 30       	cpi	r22, 0x01	; 1
    8224:	71 05       	cpc	r23, r1
    8226:	81 05       	cpc	r24, r1
    8228:	a9 e1       	ldi	r26, 0x19	; 25
    822a:	9a 07       	cpc	r25, r26
    822c:	24 f0       	brlt	.+8      	; 0x8236 <doMeasure()+0xcb2>
    822e:	60 e0       	ldi	r22, 0x00	; 0
    8230:	70 e0       	ldi	r23, 0x00	; 0
    8232:	80 e0       	ldi	r24, 0x00	; 0
    8234:	99 e1       	ldi	r25, 0x19	; 25
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:509
  float h = (v_x1_u32r >> 12);
    8236:	2c e0       	ldi	r18, 0x0C	; 12
    8238:	95 95       	asr	r25
    823a:	87 95       	ror	r24
    823c:	77 95       	ror	r23
    823e:	67 95       	ror	r22
    8240:	2a 95       	dec	r18
    8242:	d1 f7       	brne	.-12     	; 0x8238 <doMeasure()+0xcb4>
    8244:	0e 94 db 68 	call	0xd1b6	; 0xd1b6 <__floatsisf>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:510
  return h / 1024.0;
    8248:	20 e0       	ldi	r18, 0x00	; 0
    824a:	30 e0       	ldi	r19, 0x00	; 0
    824c:	40 e8       	ldi	r20, 0x80	; 128
    824e:	5a e3       	ldi	r21, 0x3A	; 58
    8250:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
measure_BME280():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:12
		humidity = bme280.readHumidity();
    8254:	0e 94 53 6b 	call	0xd6a6	; 0xd6a6 <__fixsfsi>
    8258:	70 93 53 09 	sts	0x0953, r23	; 0x800953 <humidity+0x1>
    825c:	60 93 52 09 	sts	0x0952, r22	; 0x800952 <humidity>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:13
		pressure_in_atm = pressure / 101325.0f;
    8260:	20 e8       	ldi	r18, 0x80	; 128
    8262:	36 ee       	ldi	r19, 0xE6	; 230
    8264:	45 ec       	ldi	r20, 0xC5	; 197
    8266:	57 e4       	ldi	r21, 0x47	; 71
    8268:	60 91 30 09 	lds	r22, 0x0930	; 0x800930 <pressure>
    826c:	70 91 31 09 	lds	r23, 0x0931	; 0x800931 <pressure+0x1>
    8270:	80 91 32 09 	lds	r24, 0x0932	; 0x800932 <pressure+0x2>
    8274:	90 91 33 09 	lds	r25, 0x0933	; 0x800933 <pressure+0x3>
    8278:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
    827c:	6b 01       	movw	r12, r22
    827e:	7c 01       	movw	r14, r24
    8280:	c0 92 4c 09 	sts	0x094C, r12	; 0x80094c <pressure_in_atm>
    8284:	d0 92 4d 09 	sts	0x094D, r13	; 0x80094d <pressure_in_atm+0x1>
    8288:	e0 92 4e 09 	sts	0x094E, r14	; 0x80094e <pressure_in_atm+0x2>
    828c:	f0 92 4f 09 	sts	0x094F, r15	; 0x80094f <pressure_in_atm+0x3>
check_pCO2_Pressure():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:28
	}

}

void check_pCO2_Pressure(float value) {
	if (value > pCO2_highP || value < pCO2_lowP)	_pCO2_PSampleT++;
    8290:	20 91 5b 09 	lds	r18, 0x095B	; 0x80095b <pCO2_highP>
    8294:	30 91 5c 09 	lds	r19, 0x095C	; 0x80095c <pCO2_highP+0x1>
    8298:	40 91 5d 09 	lds	r20, 0x095D	; 0x80095d <pCO2_highP+0x2>
    829c:	50 91 5e 09 	lds	r21, 0x095E	; 0x80095e <pCO2_highP+0x3>
    82a0:	0e 94 dd 6b 	call	0xd7ba	; 0xd7ba <__gesf2>
    82a4:	18 16       	cp	r1, r24
    82a6:	74 f0       	brlt	.+28     	; 0x82c4 <doMeasure()+0xd40>
    82a8:	20 91 57 09 	lds	r18, 0x0957	; 0x800957 <pCO2_lowP>
    82ac:	30 91 58 09 	lds	r19, 0x0958	; 0x800958 <pCO2_lowP+0x1>
    82b0:	40 91 59 09 	lds	r20, 0x0959	; 0x800959 <pCO2_lowP+0x2>
    82b4:	50 91 5a 09 	lds	r21, 0x095A	; 0x80095a <pCO2_lowP+0x3>
    82b8:	c7 01       	movw	r24, r14
    82ba:	b6 01       	movw	r22, r12
    82bc:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
    82c0:	87 ff       	sbrs	r24, 7
    82c2:	12 c7       	rjmp	.+3620   	; 0x90e8 <doMeasure()+0x1b64>
    82c4:	80 91 20 09 	lds	r24, 0x0920	; 0x800920 <_pCO2_PSampleT>
    82c8:	90 91 21 09 	lds	r25, 0x0921	; 0x800921 <_pCO2_PSampleT+0x1>
    82cc:	01 96       	adiw	r24, 0x01	; 1
    82ce:	90 93 21 09 	sts	0x0921, r25	; 0x800921 <_pCO2_PSampleT+0x1>
    82d2:	80 93 20 09 	sts	0x0920, r24	; 0x800920 <_pCO2_PSampleT>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:38
		{
			pumpControl(pumpPower);
			PGER.pause();
		}
	}
	if (_pCO2_PSampleT >= abs(pCO2_PSampleT)) 
    82d6:	80 91 55 09 	lds	r24, 0x0955	; 0x800955 <pCO2_PSampleT>
    82da:	90 91 56 09 	lds	r25, 0x0956	; 0x800956 <pCO2_PSampleT+0x1>
    82de:	97 ff       	sbrs	r25, 7
    82e0:	03 c0       	rjmp	.+6      	; 0x82e8 <doMeasure()+0xd64>
    82e2:	91 95       	neg	r25
    82e4:	81 95       	neg	r24
    82e6:	91 09       	sbc	r25, r1
    82e8:	20 91 20 09 	lds	r18, 0x0920	; 0x800920 <_pCO2_PSampleT>
    82ec:	30 91 21 09 	lds	r19, 0x0921	; 0x800921 <_pCO2_PSampleT+0x1>
    82f0:	28 17       	cp	r18, r24
    82f2:	39 07       	cpc	r19, r25
    82f4:	84 f0       	brlt	.+32     	; 0x8316 <doMeasure()+0xd92>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:40
	{
		waring();
    82f6:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <waring()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:41
		PGER.resume();
    82fa:	87 e9       	ldi	r24, 0x97	; 151
    82fc:	9f e0       	ldi	r25, 0x0F	; 15
    82fe:	0e 94 60 1d 	call	0x3ac0	; 0x3ac0 <BlinkControl::resume()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:42
		pumpControl(0);
    8302:	90 e0       	ldi	r25, 0x00	; 0
    8304:	80 e0       	ldi	r24, 0x00	; 0
    8306:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <pumpControl(int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:43
		Serial.println("*Pump stop");
    830a:	6c e2       	ldi	r22, 0x2C	; 44
    830c:	76 e0       	ldi	r23, 0x06	; 6
measure_BME280():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:21
	else 
	{
		pressure = NAN;
		humidity = -9999;
		pressure_in_atm = NAN;
		Serial.println("*BME280 Read Error");
    830e:	82 e5       	ldi	r24, 0x52	; 82
    8310:	9e e0       	ldi	r25, 0x0E	; 14
    8312:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
doMeasure():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:20
  updateGPSdata();
  getID();
  measure_CO2();				//Get CO2 Data									 [CO2_READ]				(valCO2)
  tsys01_get();					//Get TSYS01 Data								 [TSYS01]				(temperature)
  measure_BME280();				//Get BME280 Data								 [BME280]				(pressure,humidity)
  update_K_temp();				//Get Thermacouple Temperature  				 [Thermocouple]			(K_temperature)
    8316:	0e 94 71 2d 	call	0x5ae2	; 0x5ae2 <update_K_temp()>
getpHdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:38
	if (complete)	pHdecode(str);
	else Serial.println("pH not decode");
}
*/
void getpHdata() {
	String str = "";
    831a:	63 ea       	ldi	r22, 0xA3	; 163
    831c:	73 e0       	ldi	r23, 0x03	; 3
    831e:	ce 01       	movw	r24, r28
    8320:	8e 96       	adiw	r24, 0x2e	; 46
    8322:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:39
	str.reserve(10);
    8326:	6a e0       	ldi	r22, 0x0A	; 10
    8328:	70 e0       	ldi	r23, 0x00	; 0
    832a:	ce 01       	movw	r24, r28
    832c:	8e 96       	adiw	r24, 0x2e	; 46
    832e:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:40
	flush_pH_serial();
    8332:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <flush_pH_serial()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:42

	Atlas_pH.print('\r');
    8336:	6d e0       	ldi	r22, 0x0D	; 13
    8338:	8b e7       	ldi	r24, 0x7B	; 123
    833a:	9c e0       	ldi	r25, 0x0C	; 12
    833c:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:43
	str = waitUntilpHReturn(150);
    8340:	46 e9       	ldi	r20, 0x96	; 150
    8342:	50 e0       	ldi	r21, 0x00	; 0
    8344:	60 e0       	ldi	r22, 0x00	; 0
    8346:	70 e0       	ldi	r23, 0x00	; 0
    8348:	fe 01       	movw	r30, r28
    834a:	31 96       	adiw	r30, 0x01	; 1
    834c:	7f 01       	movw	r14, r30
    834e:	cf 01       	movw	r24, r30
    8350:	0e 94 97 31 	call	0x632e	; 0x632e <waitUntilpHReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    8354:	b7 01       	movw	r22, r14
    8356:	ce 01       	movw	r24, r28
    8358:	8e 96       	adiw	r24, 0x2e	; 46
    835a:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
getpHdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:43
    835e:	c7 01       	movw	r24, r14
    8360:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:44
	SerialDebug("wakepH:", str);
    8364:	be 01       	movw	r22, r28
    8366:	62 5d       	subi	r22, 0xD2	; 210
    8368:	7f 4f       	sbci	r23, 0xFF	; 255
    836a:	c7 01       	movw	r24, r14
    836c:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    8370:	6a e4       	ldi	r22, 0x4A	; 74
    8372:	76 e0       	ldi	r23, 0x06	; 6
    8374:	ce 01       	movw	r24, r28
    8376:	4c 96       	adiw	r24, 0x1c	; 28
    8378:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    837c:	b7 01       	movw	r22, r14
    837e:	ce 01       	movw	r24, r28
    8380:	4c 96       	adiw	r24, 0x1c	; 28
    8382:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    8386:	ce 01       	movw	r24, r28
    8388:	4c 96       	adiw	r24, 0x1c	; 28
    838a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    838e:	c7 01       	movw	r24, r14
    8390:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:46

	String s = "T,";	s += K_temperature;		s += "\r";
    8394:	67 e4       	ldi	r22, 0x47	; 71
    8396:	74 e0       	ldi	r23, 0x04	; 4
    8398:	ce 01       	movw	r24, r28
    839a:	88 96       	adiw	r24, 0x28	; 40
    839c:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
_ZN6StringpLEf():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:121
	String & operator += (unsigned char num)		{concat(num); return (*this);}
	String & operator += (int num)			{concat(num); return (*this);}
	String & operator += (unsigned int num)		{concat(num); return (*this);}
	String & operator += (long num)			{concat(num); return (*this);}
	String & operator += (unsigned long num)	{concat(num); return (*this);}
	String & operator += (float num)		{concat(num); return (*this);}
    83a0:	40 91 10 02 	lds	r20, 0x0210	; 0x800210 <K_temperature>
    83a4:	50 91 11 02 	lds	r21, 0x0211	; 0x800211 <K_temperature+0x1>
    83a8:	60 91 12 02 	lds	r22, 0x0212	; 0x800212 <K_temperature+0x2>
    83ac:	70 91 13 02 	lds	r23, 0x0213	; 0x800213 <K_temperature+0x3>
    83b0:	ce 01       	movw	r24, r28
    83b2:	88 96       	adiw	r24, 0x28	; 40
    83b4:	0e 94 5b 2a 	call	0x54b6	; 0x54b6 <String::concat(float)>
_ZN6StringpLEPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:114
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
    83b8:	66 e9       	ldi	r22, 0x96	; 150
    83ba:	78 e0       	ldi	r23, 0x08	; 8
    83bc:	ce 01       	movw	r24, r28
    83be:	88 96       	adiw	r24, 0x28	; 40
    83c0:	0e 94 0a 2b 	call	0x5614	; 0x5614 <String::concat(char const*)>
getpHdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:47
	Atlas_pH.print(s);
    83c4:	be 01       	movw	r22, r28
    83c6:	68 5d       	subi	r22, 0xD8	; 216
    83c8:	7f 4f       	sbci	r23, 0xFF	; 255
    83ca:	8b e7       	ldi	r24, 0x7B	; 123
    83cc:	9c e0       	ldi	r25, 0x0C	; 12
    83ce:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:48
	str = waitUntilpHReturn(100);
    83d2:	44 e6       	ldi	r20, 0x64	; 100
    83d4:	50 e0       	ldi	r21, 0x00	; 0
    83d6:	60 e0       	ldi	r22, 0x00	; 0
    83d8:	70 e0       	ldi	r23, 0x00	; 0
    83da:	c7 01       	movw	r24, r14
    83dc:	0e 94 97 31 	call	0x632e	; 0x632e <waitUntilpHReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    83e0:	b7 01       	movw	r22, r14
    83e2:	ce 01       	movw	r24, r28
    83e4:	8e 96       	adiw	r24, 0x2e	; 46
    83e6:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
getpHdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:48
    83ea:	c7 01       	movw	r24, r14
    83ec:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:49
	SerialDebug("sendT2pH:", str);
    83f0:	be 01       	movw	r22, r28
    83f2:	62 5d       	subi	r22, 0xD2	; 210
    83f4:	7f 4f       	sbci	r23, 0xFF	; 255
    83f6:	c7 01       	movw	r24, r14
    83f8:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    83fc:	62 e5       	ldi	r22, 0x52	; 82
    83fe:	76 e0       	ldi	r23, 0x06	; 6
    8400:	ce 01       	movw	r24, r28
    8402:	4c 96       	adiw	r24, 0x1c	; 28
    8404:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    8408:	b7 01       	movw	r22, r14
    840a:	ce 01       	movw	r24, r28
    840c:	4c 96       	adiw	r24, 0x1c	; 28
    840e:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    8412:	ce 01       	movw	r24, r28
    8414:	4c 96       	adiw	r24, 0x1c	; 28
    8416:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    841a:	c7 01       	movw	r24, r14
    841c:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:51

	Atlas_pH.print("R\r");
    8420:	6c e5       	ldi	r22, 0x5C	; 92
    8422:	76 e0       	ldi	r23, 0x06	; 6
    8424:	8b e7       	ldi	r24, 0x7B	; 123
    8426:	9c e0       	ldi	r25, 0x0C	; 12
    8428:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:52
	str = waitUntilpHReturn(800);
    842c:	40 e2       	ldi	r20, 0x20	; 32
    842e:	53 e0       	ldi	r21, 0x03	; 3
    8430:	60 e0       	ldi	r22, 0x00	; 0
    8432:	70 e0       	ldi	r23, 0x00	; 0
    8434:	c7 01       	movw	r24, r14
    8436:	0e 94 97 31 	call	0x632e	; 0x632e <waitUntilpHReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    843a:	b7 01       	movw	r22, r14
    843c:	ce 01       	movw	r24, r28
    843e:	8e 96       	adiw	r24, 0x2e	; 46
    8440:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
getpHdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:52
    8444:	c7 01       	movw	r24, r14
    8446:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:53
	pHdecode(str);
    844a:	be 01       	movw	r22, r28
    844c:	62 5d       	subi	r22, 0xD2	; 210
    844e:	7f 4f       	sbci	r23, 0xFF	; 255
    8450:	ce 01       	movw	r24, r28
    8452:	82 96       	adiw	r24, 0x22	; 34
    8454:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
pHdecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:62
	SerialDebug("sleeppH", "");
}


void pHdecode(String data) {
	SerialDebug("pHraw:", data);
    8458:	be 01       	movw	r22, r28
    845a:	6e 5d       	subi	r22, 0xDE	; 222
    845c:	7f 4f       	sbci	r23, 0xFF	; 255
    845e:	c7 01       	movw	r24, r14
    8460:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    8464:	6f e5       	ldi	r22, 0x5F	; 95
    8466:	76 e0       	ldi	r23, 0x06	; 6
    8468:	ce 01       	movw	r24, r28
    846a:	4c 96       	adiw	r24, 0x1c	; 28
    846c:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    8470:	b7 01       	movw	r22, r14
    8472:	ce 01       	movw	r24, r28
    8474:	4c 96       	adiw	r24, 0x1c	; 28
    8476:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    847a:	ce 01       	movw	r24, r28
    847c:	4c 96       	adiw	r24, 0x1c	; 28
    847e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8482:	c7 01       	movw	r24, r14
    8484:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:64
	
	if (!isDigit(data[0]))	return;
    8488:	70 e0       	ldi	r23, 0x00	; 0
    848a:	60 e0       	ldi	r22, 0x00	; 0
    848c:	ce 01       	movw	r24, r28
    848e:	82 96       	adiw	r24, 0x22	; 34
    8490:	0e 94 29 06 	call	0xc52	; 0xc52 <String::operator[](unsigned int)>
_Z7isDigiti():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WCharacter.h:85


// Checks for a digit (0 through 9).
inline boolean isDigit(int c)
{
  return ( isdigit (c) == 0 ? false : true);
    8494:	dc 01       	movw	r26, r24
    8496:	8c 91       	ld	r24, X
    8498:	08 2e       	mov	r0, r24
    849a:	00 0c       	add	r0, r0
    849c:	99 0b       	sbc	r25, r25
    849e:	c0 97       	sbiw	r24, 0x30	; 48
pHdecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:64
    84a0:	0a 97       	sbiw	r24, 0x0a	; 10
    84a2:	60 f4       	brcc	.+24     	; 0x84bc <doMeasure()+0xf38>
toFloat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:743
	return 0;
}

float String::toFloat(void) const
{
	return float(toDouble());
    84a4:	ce 01       	movw	r24, r28
    84a6:	82 96       	adiw	r24, 0x22	; 34
    84a8:	0e 94 b5 28 	call	0x516a	; 0x516a <String::toDouble() const>
pHdecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:65
	pH = data.toFloat();
    84ac:	60 93 3a 09 	sts	0x093A, r22	; 0x80093a <pH>
    84b0:	70 93 3b 09 	sts	0x093B, r23	; 0x80093b <pH+0x1>
    84b4:	80 93 3c 09 	sts	0x093C, r24	; 0x80093c <pH+0x2>
    84b8:	90 93 3d 09 	sts	0x093D, r25	; 0x80093d <pH+0x3>
getpHdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:53
	str = waitUntilpHReturn(100);
	SerialDebug("sendT2pH:", str);

	Atlas_pH.print("R\r");
	str = waitUntilpHReturn(800);
	pHdecode(str);
    84bc:	ce 01       	movw	r24, r28
    84be:	82 96       	adiw	r24, 0x22	; 34
    84c0:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:54
	SerialDebug("readpH:", str);
    84c4:	be 01       	movw	r22, r28
    84c6:	62 5d       	subi	r22, 0xD2	; 210
    84c8:	7f 4f       	sbci	r23, 0xFF	; 255
    84ca:	c7 01       	movw	r24, r14
    84cc:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    84d0:	66 e6       	ldi	r22, 0x66	; 102
    84d2:	76 e0       	ldi	r23, 0x06	; 6
    84d4:	ce 01       	movw	r24, r28
    84d6:	4c 96       	adiw	r24, 0x1c	; 28
    84d8:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    84dc:	b7 01       	movw	r22, r14
    84de:	ce 01       	movw	r24, r28
    84e0:	4c 96       	adiw	r24, 0x1c	; 28
    84e2:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    84e6:	ce 01       	movw	r24, r28
    84e8:	4c 96       	adiw	r24, 0x1c	; 28
    84ea:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    84ee:	c7 01       	movw	r24, r14
    84f0:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:56

	Atlas_pH.print("Sleep\r");
    84f4:	6e e5       	ldi	r22, 0x5E	; 94
    84f6:	74 e0       	ldi	r23, 0x04	; 4
    84f8:	8b e7       	ldi	r24, 0x7B	; 123
    84fa:	9c e0       	ldi	r25, 0x0C	; 12
    84fc:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:57
	SerialDebug("sleeppH", "");
    8500:	63 ea       	ldi	r22, 0xA3	; 163
    8502:	73 e0       	ldi	r23, 0x03	; 3
    8504:	c7 01       	movw	r24, r14
    8506:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    850a:	6e e6       	ldi	r22, 0x6E	; 110
    850c:	76 e0       	ldi	r23, 0x06	; 6
    850e:	ce 01       	movw	r24, r28
    8510:	4c 96       	adiw	r24, 0x1c	; 28
    8512:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    8516:	b7 01       	movw	r22, r14
    8518:	ce 01       	movw	r24, r28
    851a:	4c 96       	adiw	r24, 0x1c	; 28
    851c:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    8520:	ce 01       	movw	r24, r28
    8522:	4c 96       	adiw	r24, 0x1c	; 28
    8524:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8528:	c7 01       	movw	r24, r14
    852a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:46

	Atlas_pH.print('\r');
	str = waitUntilpHReturn(150);
	SerialDebug("wakepH:", str);

	String s = "T,";	s += K_temperature;		s += "\r";
    852e:	ce 01       	movw	r24, r28
    8530:	88 96       	adiw	r24, 0x28	; 40
    8532:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_pH.ino:38
	if (complete)	pHdecode(str);
	else Serial.println("pH not decode");
}
*/
void getpHdata() {
	String str = "";
    8536:	ce 01       	movw	r24, r28
    8538:	8e 96       	adiw	r24, 0x2e	; 46
    853a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
getECdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:2
void getECdata() {
	String str = "";
    853e:	63 ea       	ldi	r22, 0xA3	; 163
    8540:	73 e0       	ldi	r23, 0x03	; 3
    8542:	ce 01       	movw	r24, r28
    8544:	8e 96       	adiw	r24, 0x2e	; 46
    8546:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:3
	str.reserve(10);
    854a:	6a e0       	ldi	r22, 0x0A	; 10
    854c:	70 e0       	ldi	r23, 0x00	; 0
    854e:	ce 01       	movw	r24, r28
    8550:	8e 96       	adiw	r24, 0x2e	; 46
    8552:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:4
	flush_EC_serial();
    8556:	0e 94 2e 1e 	call	0x3c5c	; 0x3c5c <flush_EC_serial()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:6

	Atlas_EC.print('\r');
    855a:	6d e0       	ldi	r22, 0x0D	; 13
    855c:	88 e1       	ldi	r24, 0x18	; 24
    855e:	9d e0       	ldi	r25, 0x0D	; 13
    8560:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:7
	str = waitUntilECReturn(150);
    8564:	46 e9       	ldi	r20, 0x96	; 150
    8566:	50 e0       	ldi	r21, 0x00	; 0
    8568:	60 e0       	ldi	r22, 0x00	; 0
    856a:	70 e0       	ldi	r23, 0x00	; 0
    856c:	c7 01       	movw	r24, r14
    856e:	0e 94 3d 33 	call	0x667a	; 0x667a <waitUntilECReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String & String::operator = (String &&rval)
{
	if (this != &rval) move(rval);
    8572:	b7 01       	movw	r22, r14
    8574:	ce 01       	movw	r24, r28
    8576:	8e 96       	adiw	r24, 0x2e	; 46
    8578:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
getECdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:7
    857c:	c7 01       	movw	r24, r14
    857e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:8
	SerialDebug("wakeEC:", str);
    8582:	be 01       	movw	r22, r28
    8584:	62 5d       	subi	r22, 0xD2	; 210
    8586:	7f 4f       	sbci	r23, 0xFF	; 255
    8588:	c7 01       	movw	r24, r14
    858a:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    858e:	66 e7       	ldi	r22, 0x76	; 118
    8590:	76 e0       	ldi	r23, 0x06	; 6
    8592:	ce 01       	movw	r24, r28
    8594:	4c 96       	adiw	r24, 0x1c	; 28
    8596:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    859a:	b7 01       	movw	r22, r14
    859c:	ce 01       	movw	r24, r28
    859e:	4c 96       	adiw	r24, 0x1c	; 28
    85a0:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    85a4:	ce 01       	movw	r24, r28
    85a6:	4c 96       	adiw	r24, 0x1c	; 28
    85a8:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    85ac:	c7 01       	movw	r24, r14
    85ae:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:10

	String s = "T,";	s += K_temperature;		s += "\r";
    85b2:	67 e4       	ldi	r22, 0x47	; 71
    85b4:	74 e0       	ldi	r23, 0x04	; 4
    85b6:	ce 01       	movw	r24, r28
    85b8:	88 96       	adiw	r24, 0x28	; 40
    85ba:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
_ZN6StringpLEf():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:121
	String & operator += (unsigned char num)		{concat(num); return (*this);}
	String & operator += (int num)			{concat(num); return (*this);}
	String & operator += (unsigned int num)		{concat(num); return (*this);}
	String & operator += (long num)			{concat(num); return (*this);}
	String & operator += (unsigned long num)	{concat(num); return (*this);}
	String & operator += (float num)		{concat(num); return (*this);}
    85be:	40 91 10 02 	lds	r20, 0x0210	; 0x800210 <K_temperature>
    85c2:	50 91 11 02 	lds	r21, 0x0211	; 0x800211 <K_temperature+0x1>
    85c6:	60 91 12 02 	lds	r22, 0x0212	; 0x800212 <K_temperature+0x2>
    85ca:	70 91 13 02 	lds	r23, 0x0213	; 0x800213 <K_temperature+0x3>
    85ce:	ce 01       	movw	r24, r28
    85d0:	88 96       	adiw	r24, 0x28	; 40
    85d2:	0e 94 5b 2a 	call	0x54b6	; 0x54b6 <String::concat(float)>
_ZN6StringpLEPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:114
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
    85d6:	66 e9       	ldi	r22, 0x96	; 150
    85d8:	78 e0       	ldi	r23, 0x08	; 8
    85da:	ce 01       	movw	r24, r28
    85dc:	88 96       	adiw	r24, 0x28	; 40
    85de:	0e 94 0a 2b 	call	0x5614	; 0x5614 <String::concat(char const*)>
getECdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:11
	Atlas_EC.print(s);
    85e2:	be 01       	movw	r22, r28
    85e4:	68 5d       	subi	r22, 0xD8	; 216
    85e6:	7f 4f       	sbci	r23, 0xFF	; 255
    85e8:	88 e1       	ldi	r24, 0x18	; 24
    85ea:	9d e0       	ldi	r25, 0x0D	; 13
    85ec:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:12
	str = waitUntilECReturn(100);
    85f0:	44 e6       	ldi	r20, 0x64	; 100
    85f2:	50 e0       	ldi	r21, 0x00	; 0
    85f4:	60 e0       	ldi	r22, 0x00	; 0
    85f6:	70 e0       	ldi	r23, 0x00	; 0
    85f8:	c7 01       	movw	r24, r14
    85fa:	0e 94 3d 33 	call	0x667a	; 0x667a <waitUntilECReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    85fe:	b7 01       	movw	r22, r14
    8600:	ce 01       	movw	r24, r28
    8602:	8e 96       	adiw	r24, 0x2e	; 46
    8604:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
getECdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:12
    8608:	c7 01       	movw	r24, r14
    860a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:13
	SerialDebug("sendT2EC:", str);
    860e:	be 01       	movw	r22, r28
    8610:	62 5d       	subi	r22, 0xD2	; 210
    8612:	7f 4f       	sbci	r23, 0xFF	; 255
    8614:	c7 01       	movw	r24, r14
    8616:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    861a:	6e e6       	ldi	r22, 0x6E	; 110
    861c:	74 e0       	ldi	r23, 0x04	; 4
    861e:	ce 01       	movw	r24, r28
    8620:	4c 96       	adiw	r24, 0x1c	; 28
    8622:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    8626:	b7 01       	movw	r22, r14
    8628:	ce 01       	movw	r24, r28
    862a:	4c 96       	adiw	r24, 0x1c	; 28
    862c:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    8630:	ce 01       	movw	r24, r28
    8632:	4c 96       	adiw	r24, 0x1c	; 28
    8634:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8638:	c7 01       	movw	r24, r14
    863a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:15

	Atlas_EC.print("R\r");
    863e:	6c e5       	ldi	r22, 0x5C	; 92
    8640:	76 e0       	ldi	r23, 0x06	; 6
    8642:	88 e1       	ldi	r24, 0x18	; 24
    8644:	9d e0       	ldi	r25, 0x0D	; 13
    8646:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:16
	str = waitUntilECReturn(800);
    864a:	40 e2       	ldi	r20, 0x20	; 32
    864c:	53 e0       	ldi	r21, 0x03	; 3
    864e:	60 e0       	ldi	r22, 0x00	; 0
    8650:	70 e0       	ldi	r23, 0x00	; 0
    8652:	c7 01       	movw	r24, r14
    8654:	0e 94 3d 33 	call	0x667a	; 0x667a <waitUntilECReturn(unsigned long)>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
    8658:	b7 01       	movw	r22, r14
    865a:	ce 01       	movw	r24, r28
    865c:	8e 96       	adiw	r24, 0x2e	; 46
    865e:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
getECdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:16
    8662:	c7 01       	movw	r24, r14
    8664:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:17
	ECdecode(str);
    8668:	be 01       	movw	r22, r28
    866a:	62 5d       	subi	r22, 0xD2	; 210
    866c:	7f 4f       	sbci	r23, 0xFF	; 255
    866e:	ce 01       	movw	r24, r28
    8670:	82 96       	adiw	r24, 0x22	; 34
    8672:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
ECdecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:26
	SerialDebug("sleepEC", "");
}

void ECdecode(String data) {
	
	SerialDebug("ECraw:", data);
    8676:	be 01       	movw	r22, r28
    8678:	6e 5d       	subi	r22, 0xDE	; 222
    867a:	7f 4f       	sbci	r23, 0xFF	; 255
    867c:	c7 01       	movw	r24, r14
    867e:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    8682:	6e e7       	ldi	r22, 0x7E	; 126
    8684:	76 e0       	ldi	r23, 0x06	; 6
    8686:	ce 01       	movw	r24, r28
    8688:	4c 96       	adiw	r24, 0x1c	; 28
    868a:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    868e:	b7 01       	movw	r22, r14
    8690:	ce 01       	movw	r24, r28
    8692:	4c 96       	adiw	r24, 0x1c	; 28
    8694:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    8698:	ce 01       	movw	r24, r28
    869a:	4c 96       	adiw	r24, 0x1c	; 28
    869c:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    86a0:	c7 01       	movw	r24, r14
    86a2:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:27
	if (!isDigit(data[0])) return;
    86a6:	70 e0       	ldi	r23, 0x00	; 0
    86a8:	60 e0       	ldi	r22, 0x00	; 0
    86aa:	ce 01       	movw	r24, r28
    86ac:	82 96       	adiw	r24, 0x22	; 34
    86ae:	0e 94 29 06 	call	0xc52	; 0xc52 <String::operator[](unsigned int)>
_Z7isDigiti():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WCharacter.h:85
    86b2:	fc 01       	movw	r30, r24
    86b4:	80 81       	ld	r24, Z
    86b6:	08 2e       	mov	r0, r24
    86b8:	00 0c       	add	r0, r0
    86ba:	99 0b       	sbc	r25, r25
    86bc:	c0 97       	sbiw	r24, 0x30	; 48
ECdecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:27
    86be:	0a 97       	sbiw	r24, 0x0a	; 10
    86c0:	08 f0       	brcs	.+2      	; 0x86c4 <doMeasure()+0x1140>
    86c2:	5a c0       	rjmp	.+180    	; 0x8778 <doMeasure()+0x11f4>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:29

	int len = data.length() + 1;
    86c4:	ce a0       	ldd	r12, Y+38	; 0x26
    86c6:	df a0       	ldd	r13, Y+39	; 0x27
    86c8:	ff ef       	ldi	r31, 0xFF	; 255
    86ca:	cf 1a       	sub	r12, r31
    86cc:	df 0a       	sbc	r13, r31
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:31
	char* str_arr = 0;
	str_arr = (char*)malloc(len * sizeof(char));
    86ce:	c6 01       	movw	r24, r12
    86d0:	0e 94 d8 62 	call	0xc5b0	; 0xc5b0 <malloc>
    86d4:	8c 01       	movw	r16, r24
getBytes():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:539
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
	if (!bufsize || !buf) return;
    86d6:	c1 14       	cp	r12, r1
    86d8:	d1 04       	cpc	r13, r1
    86da:	41 f0       	breq	.+16     	; 0x86ec <doMeasure()+0x1168>
    86dc:	00 97       	sbiw	r24, 0x00	; 0
    86de:	31 f0       	breq	.+12     	; 0x86ec <doMeasure()+0x1168>
    86e0:	a6 01       	movw	r20, r12
    86e2:	bc 01       	movw	r22, r24
    86e4:	ce 01       	movw	r24, r28
    86e6:	82 96       	adiw	r24, 0x22	; 34
    86e8:	0e 94 48 25 	call	0x4a90	; 0x4a90 <String::getBytes(unsigned char*, unsigned int, unsigned int) const [clone .part.9] [clone .constprop.178]>
ECdecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:36
	data.toCharArray(str_arr, len);
	//Separate the serial command to command and data by ','
	char *_ec, *_tds, *_sal, *_grav;                        //char pointer used in string parsing

	  _ec = strtok(str_arr, ",");							//let's pars the array at each comma
    86ec:	6a ef       	ldi	r22, 0xFA	; 250
    86ee:	77 e0       	ldi	r23, 0x07	; 7
    86f0:	c8 01       	movw	r24, r16
    86f2:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    86f6:	4c 01       	movw	r8, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:37
	 _tds = strtok(NULL, ",");                              //let's pars the array at each comma
    86f8:	6a ef       	ldi	r22, 0xFA	; 250
    86fa:	77 e0       	ldi	r23, 0x07	; 7
    86fc:	90 e0       	ldi	r25, 0x00	; 0
    86fe:	80 e0       	ldi	r24, 0x00	; 0
    8700:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    8704:	5c 01       	movw	r10, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:38
	 _sal = strtok(NULL, ",");                              //let's pars the array at each comma
    8706:	6a ef       	ldi	r22, 0xFA	; 250
    8708:	77 e0       	ldi	r23, 0x07	; 7
    870a:	90 e0       	ldi	r25, 0x00	; 0
    870c:	80 e0       	ldi	r24, 0x00	; 0
    870e:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    8712:	6c 01       	movw	r12, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:39
	_grav = strtok(NULL, ",");                              //let's pars the array at each comma
    8714:	6a ef       	ldi	r22, 0xFA	; 250
    8716:	77 e0       	ldi	r23, 0x07	; 7
    8718:	90 e0       	ldi	r25, 0x00	; 0
    871a:	80 e0       	ldi	r24, 0x00	; 0
    871c:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    8720:	3c 01       	movw	r6, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:45

	//  EC_i = atol(_ec);                                     //uncomment this line to convert the char to a float
	// TDS_i = atol(_tds);
	// SAL_f = atof(_sal);
	//GRAV_f = atof(_grav);
	EC = atof(_ec);
    8722:	c4 01       	movw	r24, r8
    8724:	0e 94 fd 63 	call	0xc7fa	; 0xc7fa <atof>
    8728:	60 93 3e 09 	sts	0x093E, r22	; 0x80093e <EC>
    872c:	70 93 3f 09 	sts	0x093F, r23	; 0x80093f <EC+0x1>
    8730:	80 93 40 09 	sts	0x0940, r24	; 0x800940 <EC+0x2>
    8734:	90 93 41 09 	sts	0x0941, r25	; 0x800941 <EC+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:46
	TDS = atoi(_tds);
    8738:	c5 01       	movw	r24, r10
    873a:	0e 94 01 64 	call	0xc802	; 0xc802 <atoi>
    873e:	90 93 2b 09 	sts	0x092B, r25	; 0x80092b <TDS+0x1>
    8742:	80 93 2a 09 	sts	0x092A, r24	; 0x80092a <TDS>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:47
	SAL = atof(_sal);
    8746:	c6 01       	movw	r24, r12
    8748:	0e 94 fd 63 	call	0xc7fa	; 0xc7fa <atof>
    874c:	60 93 42 09 	sts	0x0942, r22	; 0x800942 <SAL>
    8750:	70 93 43 09 	sts	0x0943, r23	; 0x800943 <SAL+0x1>
    8754:	80 93 44 09 	sts	0x0944, r24	; 0x800944 <SAL+0x2>
    8758:	90 93 45 09 	sts	0x0945, r25	; 0x800945 <SAL+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:48
	GRAV = atof(_grav);
    875c:	c3 01       	movw	r24, r6
    875e:	0e 94 fd 63 	call	0xc7fa	; 0xc7fa <atof>
    8762:	60 93 2c 09 	sts	0x092C, r22	; 0x80092c <GRAV>
    8766:	70 93 2d 09 	sts	0x092D, r23	; 0x80092d <GRAV+0x1>
    876a:	80 93 2e 09 	sts	0x092E, r24	; 0x80092e <GRAV+0x2>
    876e:	90 93 2f 09 	sts	0x092F, r25	; 0x80092f <GRAV+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:49
	free(str_arr);
    8772:	c8 01       	movw	r24, r16
    8774:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
getECdata():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:17
	str = waitUntilECReturn(100);
	SerialDebug("sendT2EC:", str);

	Atlas_EC.print("R\r");
	str = waitUntilECReturn(800);
	ECdecode(str);
    8778:	ce 01       	movw	r24, r28
    877a:	82 96       	adiw	r24, 0x22	; 34
    877c:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:18
	SerialDebug("readEC:", str);
    8780:	be 01       	movw	r22, r28
    8782:	62 5d       	subi	r22, 0xD2	; 210
    8784:	7f 4f       	sbci	r23, 0xFF	; 255
    8786:	c7 01       	movw	r24, r14
    8788:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    878c:	65 e8       	ldi	r22, 0x85	; 133
    878e:	76 e0       	ldi	r23, 0x06	; 6
    8790:	ce 01       	movw	r24, r28
    8792:	4c 96       	adiw	r24, 0x1c	; 28
    8794:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    8798:	b7 01       	movw	r22, r14
    879a:	ce 01       	movw	r24, r28
    879c:	4c 96       	adiw	r24, 0x1c	; 28
    879e:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    87a2:	ce 01       	movw	r24, r28
    87a4:	4c 96       	adiw	r24, 0x1c	; 28
    87a6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    87aa:	c7 01       	movw	r24, r14
    87ac:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:20

	Atlas_EC.print("Sleep\r");
    87b0:	6e e5       	ldi	r22, 0x5E	; 94
    87b2:	74 e0       	ldi	r23, 0x04	; 4
    87b4:	88 e1       	ldi	r24, 0x18	; 24
    87b6:	9d e0       	ldi	r25, 0x0D	; 13
    87b8:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:21
	SerialDebug("sleepEC", "");
    87bc:	63 ea       	ldi	r22, 0xA3	; 163
    87be:	73 e0       	ldi	r23, 0x03	; 3
    87c0:	c7 01       	movw	r24, r14
    87c2:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    87c6:	6d e8       	ldi	r22, 0x8D	; 141
    87c8:	76 e0       	ldi	r23, 0x06	; 6
    87ca:	ce 01       	movw	r24, r28
    87cc:	4c 96       	adiw	r24, 0x1c	; 28
    87ce:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    87d2:	b7 01       	movw	r22, r14
    87d4:	ce 01       	movw	r24, r28
    87d6:	4c 96       	adiw	r24, 0x1c	; 28
    87d8:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    87dc:	ce 01       	movw	r24, r28
    87de:	4c 96       	adiw	r24, 0x1c	; 28
    87e0:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    87e4:	c7 01       	movw	r24, r14
    87e6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:10

	Atlas_EC.print('\r');
	str = waitUntilECReturn(150);
	SerialDebug("wakeEC:", str);

	String s = "T,";	s += K_temperature;		s += "\r";
    87ea:	ce 01       	movw	r24, r28
    87ec:	88 96       	adiw	r24, 0x28	; 40
    87ee:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Atlas_Conductivity.ino:2
void getECdata() {
	String str = "";
    87f2:	ce 01       	movw	r24, r28
    87f4:	8e 96       	adiw	r24, 0x2e	; 46
    87f6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    87fa:	03 e0       	ldi	r16, 0x03	; 3
    87fc:	10 e0       	ldi	r17, 0x00	; 0
doMeasure():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:3
float GetBatteryVoltage()
{
	float value = 0.0f;
    87fe:	81 2c       	mov	r8, r1
    8800:	91 2c       	mov	r9, r1
    8802:	54 01       	movw	r10, r8
analogRead():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:70
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    8804:	95 e4       	ldi	r25, 0x45	; 69
    8806:	d9 2e       	mov	r13, r25
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:60
#endif

#if defined(ADCSRB) && defined(MUX5)
	// the MUX5 bit of ADCSRB selects whether we're reading from channels
	// 0 to 7 (MUX5 low) or 8 to 15 (MUX5 high).
	ADCSRB = (ADCSRB & ~(1 << MUX5)) | (((pin >> 3) & 0x01) << MUX5);
    8808:	80 91 7b 00 	lds	r24, 0x007B	; 0x80007b <__TEXT_REGION_LENGTH__+0x70007b>
    880c:	88 60       	ori	r24, 0x08	; 8
    880e:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <__TEXT_REGION_LENGTH__+0x70007b>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:70
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    8812:	d0 92 7c 00 	sts	0x007C, r13	; 0x80007c <__TEXT_REGION_LENGTH__+0x70007c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:79
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    8816:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
    881a:	80 64       	ori	r24, 0x40	; 64
    881c:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:82

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    8820:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
    8824:	86 fd       	sbrc	r24, 6
    8826:	fc cf       	rjmp	.-8      	; 0x8820 <doMeasure()+0x129c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:88

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    8828:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:89
	high = ADCH;
    882c:	60 91 79 00 	lds	r22, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring_analog.c:97
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    8830:	76 2f       	mov	r23, r22
    8832:	68 2f       	mov	r22, r24
GetBatteryVoltage():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:4
	for (int i = 0; i < 3; i++) value += (float)analogRead(batteryV_pin);
    8834:	07 2e       	mov	r0, r23
    8836:	00 0c       	add	r0, r0
    8838:	88 0b       	sbc	r24, r24
    883a:	99 0b       	sbc	r25, r25
    883c:	0e 94 db 68 	call	0xd1b6	; 0xd1b6 <__floatsisf>
    8840:	9b 01       	movw	r18, r22
    8842:	ac 01       	movw	r20, r24
    8844:	c5 01       	movw	r24, r10
    8846:	b4 01       	movw	r22, r8
    8848:	0e 94 75 6a 	call	0xd4ea	; 0xd4ea <__addsf3>
    884c:	4b 01       	movw	r8, r22
    884e:	5c 01       	movw	r10, r24
    8850:	01 50       	subi	r16, 0x01	; 1
    8852:	11 09       	sbc	r17, r1
    8854:	c9 f6       	brne	.-78     	; 0x8808 <doMeasure()+0x1284>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:5
	value = value * 30.0f;
    8856:	20 e0       	ldi	r18, 0x00	; 0
    8858:	30 e0       	ldi	r19, 0x00	; 0
    885a:	40 ef       	ldi	r20, 0xF0	; 240
    885c:	51 e4       	ldi	r21, 0x41	; 65
    885e:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:6
	value = value / 1023.0f;
    8862:	20 e0       	ldi	r18, 0x00	; 0
    8864:	30 ec       	ldi	r19, 0xC0	; 192
    8866:	4f e7       	ldi	r20, 0x7F	; 127
    8868:	54 e4       	ldi	r21, 0x44	; 68
    886a:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:7
	value /= 3.0f;
    886e:	20 e0       	ldi	r18, 0x00	; 0
    8870:	30 e0       	ldi	r19, 0x00	; 0
    8872:	40 e4       	ldi	r20, 0x40	; 64
    8874:	50 e4       	ldi	r21, 0x40	; 64
    8876:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
    887a:	9b 01       	movw	r18, r22
    887c:	ac 01       	movw	r20, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:8
	value = value * voltage_slope;
    887e:	60 91 22 09 	lds	r22, 0x0922	; 0x800922 <voltage_slope>
    8882:	70 91 23 09 	lds	r23, 0x0923	; 0x800923 <voltage_slope+0x1>
    8886:	80 91 24 09 	lds	r24, 0x0924	; 0x800924 <voltage_slope+0x2>
    888a:	90 91 25 09 	lds	r25, 0x0925	; 0x800925 <voltage_slope+0x3>
    888e:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
MeasureBatteryVoltage():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:17
	return value;

}

void MeasureBatteryVoltage() {
	voltage = GetBatteryVoltage();
    8892:	60 93 26 09 	sts	0x0926, r22	; 0x800926 <voltage>
    8896:	70 93 27 09 	sts	0x0927, r23	; 0x800927 <voltage+0x1>
    889a:	80 93 28 09 	sts	0x0928, r24	; 0x800928 <voltage+0x2>
    889e:	90 93 29 09 	sts	0x0929, r25	; 0x800929 <voltage+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:18
	if (VoltageInPercent() > 20)	battery.off();
    88a2:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <VoltageInPercent()>
    88a6:	45 97       	sbiw	r24, 0x15	; 21
    88a8:	24 f0       	brlt	.+8      	; 0x88b2 <doMeasure()+0x132e>
    88aa:	82 e7       	ldi	r24, 0x72	; 114
    88ac:	90 e1       	ldi	r25, 0x10	; 16
    88ae:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BatteryCheck.ino:19
	if (VoltageInPercent() <= 10)	battery.resume();
    88b2:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <VoltageInPercent()>
    88b6:	0b 97       	sbiw	r24, 0x0b	; 11
    88b8:	24 f4       	brge	.+8      	; 0x88c2 <doMeasure()+0x133e>
    88ba:	82 e7       	ldi	r24, 0x72	; 114
    88bc:	90 e1       	ldi	r25, 0x10	; 16
    88be:	0e 94 60 1d 	call	0x3ac0	; 0x3ac0 <BlinkControl::resume()>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:31
  //SDIO.off();
}


void do_SD() {
	if (!SD_alive)	SD_checking();
    88c2:	80 91 19 02 	lds	r24, 0x0219	; 0x800219 <SD_alive>
    88c6:	81 11       	cpse	r24, r1
    88c8:	02 c0       	rjmp	.+4      	; 0x88ce <doMeasure()+0x134a>
    88ca:	0e 94 57 27 	call	0x4eae	; 0x4eae <SD_checking()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:32
	if (!SD_alive)	return;
    88ce:	80 91 19 02 	lds	r24, 0x0219	; 0x800219 <SD_alive>
    88d2:	88 23       	and	r24, r24
    88d4:	09 f4       	brne	.+2      	; 0x88d8 <doMeasure()+0x1354>
    88d6:	c1 c2       	rjmp	.+1410   	; 0x8e5a <doMeasure()+0x18d6>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:34

	if (last_day != day) 
    88d8:	80 91 27 0c 	lds	r24, 0x0C27	; 0x800c27 <day>
    88dc:	90 91 28 0c 	lds	r25, 0x0C28	; 0x800c28 <day+0x1>
    88e0:	20 91 da 09 	lds	r18, 0x09DA	; 0x8009da <last_day>
    88e4:	30 91 db 09 	lds	r19, 0x09DB	; 0x8009db <last_day+0x1>
    88e8:	28 17       	cp	r18, r24
    88ea:	39 07       	cpc	r19, r25
    88ec:	41 f0       	breq	.+16     	; 0x88fe <doMeasure()+0x137a>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:36
	{
		last_day = day;
    88ee:	90 93 db 09 	sts	0x09DB, r25	; 0x8009db <last_day+0x1>
    88f2:	80 93 da 09 	sts	0x09DA, r24	; 0x8009da <last_day>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:37
		getFilename(filename);
    88f6:	0e 94 6b 25 	call	0x4ad6	; 0x4ad6 <getFilename(char*) [clone .constprop.135]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:38
		File_check_exists();
    88fa:	0e 94 1e 38 	call	0x703c	; 0x703c <File_check_exists()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:41
	}

	String temp = String("");
    88fe:	63 ea       	ldi	r22, 0xA3	; 163
    8900:	73 e0       	ldi	r23, 0x03	; 3
    8902:	ce 01       	movw	r24, r28
    8904:	8a 5b       	subi	r24, 0xBA	; 186
    8906:	9f 4f       	sbci	r25, 0xFF	; 255
    8908:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:42
	temp.reserve(170);
    890c:	6a ea       	ldi	r22, 0xAA	; 170
    890e:	70 e0       	ldi	r23, 0x00	; 0
    8910:	ce 01       	movw	r24, r28
    8912:	8a 5b       	subi	r24, 0xBA	; 186
    8914:	9f 4f       	sbci	r25, 0xFF	; 255
    8916:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:43
	temp += String("") + device_ID + "," + String(year, DEC) + "/" + String(month, DEC) + "/" + String(day, DEC) + "," + String(hour, DEC) + ":" + String(minute, DEC) + ":" + String(second, DEC) + ",";
    891a:	60 91 38 09 	lds	r22, 0x0938	; 0x800938 <second>
    891e:	70 91 39 09 	lds	r23, 0x0939	; 0x800939 <second+0x1>
    8922:	ce 01       	movw	r24, r28
    8924:	80 5c       	subi	r24, 0xC0	; 192
    8926:	9f 4f       	sbci	r25, 0xFF	; 255
    8928:	0e 94 46 2b 	call	0x568c	; 0x568c <String::String(int, unsigned char) [clone .constprop.124]>
    892c:	60 91 36 09 	lds	r22, 0x0936	; 0x800936 <minute>
    8930:	70 91 37 09 	lds	r23, 0x0937	; 0x800937 <minute+0x1>
    8934:	ce 01       	movw	r24, r28
    8936:	ca 96       	adiw	r24, 0x3a	; 58
    8938:	0e 94 46 2b 	call	0x568c	; 0x568c <String::String(int, unsigned char) [clone .constprop.124]>
    893c:	60 91 34 09 	lds	r22, 0x0934	; 0x800934 <hour>
    8940:	70 91 35 09 	lds	r23, 0x0935	; 0x800935 <hour+0x1>
    8944:	ce 01       	movw	r24, r28
    8946:	c4 96       	adiw	r24, 0x34	; 52
    8948:	0e 94 46 2b 	call	0x568c	; 0x568c <String::String(int, unsigned char) [clone .constprop.124]>
    894c:	60 91 27 0c 	lds	r22, 0x0C27	; 0x800c27 <day>
    8950:	70 91 28 0c 	lds	r23, 0x0C28	; 0x800c28 <day+0x1>
    8954:	ce 01       	movw	r24, r28
    8956:	8e 96       	adiw	r24, 0x2e	; 46
    8958:	0e 94 46 2b 	call	0x568c	; 0x568c <String::String(int, unsigned char) [clone .constprop.124]>
    895c:	60 91 25 0c 	lds	r22, 0x0C25	; 0x800c25 <month>
    8960:	70 91 26 0c 	lds	r23, 0x0C26	; 0x800c26 <month+0x1>
    8964:	ce 01       	movw	r24, r28
    8966:	88 96       	adiw	r24, 0x28	; 40
    8968:	0e 94 46 2b 	call	0x568c	; 0x568c <String::String(int, unsigned char) [clone .constprop.124]>
    896c:	60 91 23 0c 	lds	r22, 0x0C23	; 0x800c23 <year>
    8970:	70 91 24 0c 	lds	r23, 0x0C24	; 0x800c24 <year+0x1>
    8974:	ce 01       	movw	r24, r28
    8976:	82 96       	adiw	r24, 0x22	; 34
    8978:	0e 94 46 2b 	call	0x568c	; 0x568c <String::String(int, unsigned char) [clone .constprop.124]>
    897c:	00 91 21 0c 	lds	r16, 0x0C21	; 0x800c21 <device_ID>
    8980:	10 91 22 0c 	lds	r17, 0x0C22	; 0x800c22 <device_ID+0x1>
    8984:	63 ea       	ldi	r22, 0xA3	; 163
    8986:	73 e0       	ldi	r23, 0x03	; 3
    8988:	c7 01       	movw	r24, r14
    898a:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
_ZN15StringSumHelperC2ERK6String():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:216
};

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
    898e:	b7 01       	movw	r22, r14
    8990:	ce 01       	movw	r24, r28
    8992:	4c 96       	adiw	r24, 0x1c	; 28
    8994:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
operator+():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:384
}

StringSumHelper & operator + (const StringSumHelper &lhs, int num)
{
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(num)) a.invalidate();
    8998:	b8 01       	movw	r22, r16
    899a:	ce 01       	movw	r24, r28
    899c:	4c 96       	adiw	r24, 0x1c	; 28
    899e:	0e 94 8c 2a 	call	0x5518	; 0x5518 <String::concat(int)>
    89a2:	81 11       	cpse	r24, r1
    89a4:	04 c0       	rjmp	.+8      	; 0x89ae <doMeasure()+0x142a>
    89a6:	ce 01       	movw	r24, r28
    89a8:	4c 96       	adiw	r24, 0x1c	; 28
    89aa:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <String::invalidate()>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:43
    89ae:	6a ef       	ldi	r22, 0xFA	; 250
    89b0:	77 e0       	ldi	r23, 0x07	; 7
    89b2:	ce 01       	movw	r24, r28
    89b4:	4c 96       	adiw	r24, 0x1c	; 28
    89b6:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    89ba:	be 01       	movw	r22, r28
    89bc:	6e 5d       	subi	r22, 0xDE	; 222
    89be:	7f 4f       	sbci	r23, 0xFF	; 255
    89c0:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    89c4:	6f e7       	ldi	r22, 0x7F	; 127
    89c6:	74 e0       	ldi	r23, 0x04	; 4
    89c8:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    89cc:	be 01       	movw	r22, r28
    89ce:	68 5d       	subi	r22, 0xD8	; 216
    89d0:	7f 4f       	sbci	r23, 0xFF	; 255
    89d2:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    89d6:	6f e7       	ldi	r22, 0x7F	; 127
    89d8:	74 e0       	ldi	r23, 0x04	; 4
    89da:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    89de:	be 01       	movw	r22, r28
    89e0:	62 5d       	subi	r22, 0xD2	; 210
    89e2:	7f 4f       	sbci	r23, 0xFF	; 255
    89e4:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    89e8:	6a ef       	ldi	r22, 0xFA	; 250
    89ea:	77 e0       	ldi	r23, 0x07	; 7
    89ec:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    89f0:	be 01       	movw	r22, r28
    89f2:	6c 5c       	subi	r22, 0xCC	; 204
    89f4:	7f 4f       	sbci	r23, 0xFF	; 255
    89f6:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    89fa:	6c e6       	ldi	r22, 0x6C	; 108
    89fc:	74 e0       	ldi	r23, 0x04	; 4
    89fe:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8a02:	be 01       	movw	r22, r28
    8a04:	66 5c       	subi	r22, 0xC6	; 198
    8a06:	7f 4f       	sbci	r23, 0xFF	; 255
    8a08:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8a0c:	6c e6       	ldi	r22, 0x6C	; 108
    8a0e:	74 e0       	ldi	r23, 0x04	; 4
    8a10:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8a14:	be 01       	movw	r22, r28
    8a16:	60 5c       	subi	r22, 0xC0	; 192
    8a18:	7f 4f       	sbci	r23, 0xFF	; 255
    8a1a:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8a1e:	6a ef       	ldi	r22, 0xFA	; 250
    8a20:	77 e0       	ldi	r23, 0x07	; 7
    8a22:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
_ZN6StringpLERKS_():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:113
	unsigned char concat(double num);
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
    8a26:	bc 01       	movw	r22, r24
    8a28:	ce 01       	movw	r24, r28
    8a2a:	8a 5b       	subi	r24, 0xBA	; 186
    8a2c:	9f 4f       	sbci	r25, 0xFF	; 255
    8a2e:	0e 94 14 2b 	call	0x5628	; 0x5628 <String::concat(String const&)>
_ZN15StringSumHelperD2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    8a32:	ce 01       	movw	r24, r28
    8a34:	4c 96       	adiw	r24, 0x1c	; 28
    8a36:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:43
    8a3a:	c7 01       	movw	r24, r14
    8a3c:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8a40:	ce 01       	movw	r24, r28
    8a42:	82 96       	adiw	r24, 0x22	; 34
    8a44:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8a48:	ce 01       	movw	r24, r28
    8a4a:	88 96       	adiw	r24, 0x28	; 40
    8a4c:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8a50:	ce 01       	movw	r24, r28
    8a52:	8e 96       	adiw	r24, 0x2e	; 46
    8a54:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8a58:	ce 01       	movw	r24, r28
    8a5a:	c4 96       	adiw	r24, 0x34	; 52
    8a5c:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8a60:	ce 01       	movw	r24, r28
    8a62:	ca 96       	adiw	r24, 0x3a	; 58
    8a64:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8a68:	ce 01       	movw	r24, r28
    8a6a:	80 5c       	subi	r24, 0xC0	; 192
    8a6c:	9f 4f       	sbci	r25, 0xFF	; 255
    8a6e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:44
	temp += String("") + String(temperature, 4) + "," + String(K_temperature, 4) + "," + String(pressure, 2) + "," + String(humidity) + "," + valCO2 + ",";
    8a72:	c0 90 50 09 	lds	r12, 0x0950	; 0x800950 <valCO2>
    8a76:	d0 90 51 09 	lds	r13, 0x0951	; 0x800951 <valCO2+0x1>
    8a7a:	60 91 52 09 	lds	r22, 0x0952	; 0x800952 <humidity>
    8a7e:	70 91 53 09 	lds	r23, 0x0953	; 0x800953 <humidity+0x1>
    8a82:	ce 01       	movw	r24, r28
    8a84:	c4 96       	adiw	r24, 0x34	; 52
    8a86:	0e 94 46 2b 	call	0x568c	; 0x568c <String::String(int, unsigned char) [clone .constprop.124]>
    8a8a:	40 91 30 09 	lds	r20, 0x0930	; 0x800930 <pressure>
    8a8e:	50 91 31 09 	lds	r21, 0x0931	; 0x800931 <pressure+0x1>
    8a92:	60 91 32 09 	lds	r22, 0x0932	; 0x800932 <pressure+0x2>
    8a96:	70 91 33 09 	lds	r23, 0x0933	; 0x800933 <pressure+0x3>
    8a9a:	22 e0       	ldi	r18, 0x02	; 2
    8a9c:	ce 01       	movw	r24, r28
    8a9e:	8e 96       	adiw	r24, 0x2e	; 46
    8aa0:	0e 94 c9 2b 	call	0x5792	; 0x5792 <String::String(float, unsigned char)>
    8aa4:	40 91 10 02 	lds	r20, 0x0210	; 0x800210 <K_temperature>
    8aa8:	50 91 11 02 	lds	r21, 0x0211	; 0x800211 <K_temperature+0x1>
    8aac:	60 91 12 02 	lds	r22, 0x0212	; 0x800212 <K_temperature+0x2>
    8ab0:	70 91 13 02 	lds	r23, 0x0213	; 0x800213 <K_temperature+0x3>
    8ab4:	24 e0       	ldi	r18, 0x04	; 4
    8ab6:	ce 01       	movw	r24, r28
    8ab8:	88 96       	adiw	r24, 0x28	; 40
    8aba:	0e 94 c9 2b 	call	0x5792	; 0x5792 <String::String(float, unsigned char)>
    8abe:	40 91 48 09 	lds	r20, 0x0948	; 0x800948 <temperature>
    8ac2:	50 91 49 09 	lds	r21, 0x0949	; 0x800949 <temperature+0x1>
    8ac6:	60 91 4a 09 	lds	r22, 0x094A	; 0x80094a <temperature+0x2>
    8aca:	70 91 4b 09 	lds	r23, 0x094B	; 0x80094b <temperature+0x3>
    8ace:	24 e0       	ldi	r18, 0x04	; 4
    8ad0:	ce 01       	movw	r24, r28
    8ad2:	82 96       	adiw	r24, 0x22	; 34
    8ad4:	0e 94 c9 2b 	call	0x5792	; 0x5792 <String::String(float, unsigned char)>
    8ad8:	63 ea       	ldi	r22, 0xA3	; 163
    8ada:	73 e0       	ldi	r23, 0x03	; 3
    8adc:	c7 01       	movw	r24, r14
    8ade:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
_ZN15StringSumHelperC2ERK6String():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:216
{
public:
	StringSumHelper(const String &s) : String(s) {}
    8ae2:	b7 01       	movw	r22, r14
    8ae4:	ce 01       	movw	r24, r28
    8ae6:	4c 96       	adiw	r24, 0x1c	; 28
    8ae8:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:44
    8aec:	be 01       	movw	r22, r28
    8aee:	6e 5d       	subi	r22, 0xDE	; 222
    8af0:	7f 4f       	sbci	r23, 0xFF	; 255
    8af2:	ce 01       	movw	r24, r28
    8af4:	4c 96       	adiw	r24, 0x1c	; 28
    8af6:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8afa:	6a ef       	ldi	r22, 0xFA	; 250
    8afc:	77 e0       	ldi	r23, 0x07	; 7
    8afe:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8b02:	be 01       	movw	r22, r28
    8b04:	68 5d       	subi	r22, 0xD8	; 216
    8b06:	7f 4f       	sbci	r23, 0xFF	; 255
    8b08:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8b0c:	6a ef       	ldi	r22, 0xFA	; 250
    8b0e:	77 e0       	ldi	r23, 0x07	; 7
    8b10:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8b14:	be 01       	movw	r22, r28
    8b16:	62 5d       	subi	r22, 0xD2	; 210
    8b18:	7f 4f       	sbci	r23, 0xFF	; 255
    8b1a:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8b1e:	6a ef       	ldi	r22, 0xFA	; 250
    8b20:	77 e0       	ldi	r23, 0x07	; 7
    8b22:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8b26:	be 01       	movw	r22, r28
    8b28:	6c 5c       	subi	r22, 0xCC	; 204
    8b2a:	7f 4f       	sbci	r23, 0xFF	; 255
    8b2c:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8b30:	6a ef       	ldi	r22, 0xFA	; 250
    8b32:	77 e0       	ldi	r23, 0x07	; 7
    8b34:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8b38:	8c 01       	movw	r16, r24
operator+():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:384
    8b3a:	b6 01       	movw	r22, r12
    8b3c:	0e 94 8c 2a 	call	0x5518	; 0x5518 <String::concat(int)>
    8b40:	81 11       	cpse	r24, r1
    8b42:	03 c0       	rjmp	.+6      	; 0x8b4a <doMeasure()+0x15c6>
    8b44:	c8 01       	movw	r24, r16
    8b46:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <String::invalidate()>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:44
    8b4a:	6a ef       	ldi	r22, 0xFA	; 250
    8b4c:	77 e0       	ldi	r23, 0x07	; 7
    8b4e:	c8 01       	movw	r24, r16
    8b50:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
_ZN6StringpLERKS_():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:113
	unsigned char concat(double num);
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
    8b54:	bc 01       	movw	r22, r24
    8b56:	ce 01       	movw	r24, r28
    8b58:	8a 5b       	subi	r24, 0xBA	; 186
    8b5a:	9f 4f       	sbci	r25, 0xFF	; 255
    8b5c:	0e 94 14 2b 	call	0x5628	; 0x5628 <String::concat(String const&)>
_ZN15StringSumHelperD2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    8b60:	ce 01       	movw	r24, r28
    8b62:	4c 96       	adiw	r24, 0x1c	; 28
    8b64:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:44
    8b68:	c7 01       	movw	r24, r14
    8b6a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8b6e:	ce 01       	movw	r24, r28
    8b70:	82 96       	adiw	r24, 0x22	; 34
    8b72:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8b76:	ce 01       	movw	r24, r28
    8b78:	88 96       	adiw	r24, 0x28	; 40
    8b7a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8b7e:	ce 01       	movw	r24, r28
    8b80:	8e 96       	adiw	r24, 0x2e	; 46
    8b82:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8b86:	ce 01       	movw	r24, r28
    8b88:	c4 96       	adiw	r24, 0x34	; 52
    8b8a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:45
	temp += String("") + flat + "," + flon + "," + GPS_datetime + ",";
    8b8e:	63 ea       	ldi	r22, 0xA3	; 163
    8b90:	73 e0       	ldi	r23, 0x03	; 3
    8b92:	c7 01       	movw	r24, r14
    8b94:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
_ZN15StringSumHelperC2ERK6String():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:216
{
public:
	StringSumHelper(const String &s) : String(s) {}
    8b98:	b7 01       	movw	r22, r14
    8b9a:	ce 01       	movw	r24, r28
    8b9c:	4c 96       	adiw	r24, 0x1c	; 28
    8b9e:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:45
    8ba2:	6f e7       	ldi	r22, 0x7F	; 127
    8ba4:	71 e1       	ldi	r23, 0x11	; 17
    8ba6:	ce 01       	movw	r24, r28
    8ba8:	4c 96       	adiw	r24, 0x1c	; 28
    8baa:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8bae:	6a ef       	ldi	r22, 0xFA	; 250
    8bb0:	77 e0       	ldi	r23, 0x07	; 7
    8bb2:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8bb6:	69 e7       	ldi	r22, 0x79	; 121
    8bb8:	71 e1       	ldi	r23, 0x11	; 17
    8bba:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8bbe:	6a ef       	ldi	r22, 0xFA	; 250
    8bc0:	77 e0       	ldi	r23, 0x07	; 7
    8bc2:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8bc6:	63 e7       	ldi	r22, 0x73	; 115
    8bc8:	71 e1       	ldi	r23, 0x11	; 17
    8bca:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8bce:	6a ef       	ldi	r22, 0xFA	; 250
    8bd0:	77 e0       	ldi	r23, 0x07	; 7
    8bd2:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
_ZN6StringpLERKS_():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:113
	unsigned char concat(double num);
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
    8bd6:	bc 01       	movw	r22, r24
    8bd8:	ce 01       	movw	r24, r28
    8bda:	8a 5b       	subi	r24, 0xBA	; 186
    8bdc:	9f 4f       	sbci	r25, 0xFF	; 255
    8bde:	0e 94 14 2b 	call	0x5628	; 0x5628 <String::concat(String const&)>
_ZN15StringSumHelperD2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    8be2:	ce 01       	movw	r24, r28
    8be4:	4c 96       	adiw	r24, 0x1c	; 28
    8be6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:45
    8bea:	c7 01       	movw	r24, r14
    8bec:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:47
	//temp += String("") + EC_i + "," + TDS_i + "," + String(SAL_f, 2) + "," + String(GRAV_f, 3) + "," + String(pH, 3) + ",";
	temp += String("") + String(EC, 2) + "," + TDS + "," + String(SAL, 2) + "," + String(GRAV, 3) + "," + String(pH, 3) + ",";
    8bf0:	40 91 3a 09 	lds	r20, 0x093A	; 0x80093a <pH>
    8bf4:	50 91 3b 09 	lds	r21, 0x093B	; 0x80093b <pH+0x1>
    8bf8:	60 91 3c 09 	lds	r22, 0x093C	; 0x80093c <pH+0x2>
    8bfc:	70 91 3d 09 	lds	r23, 0x093D	; 0x80093d <pH+0x3>
    8c00:	23 e0       	ldi	r18, 0x03	; 3
    8c02:	ce 01       	movw	r24, r28
    8c04:	ca 96       	adiw	r24, 0x3a	; 58
    8c06:	0e 94 c9 2b 	call	0x5792	; 0x5792 <String::String(float, unsigned char)>
    8c0a:	40 91 2c 09 	lds	r20, 0x092C	; 0x80092c <GRAV>
    8c0e:	50 91 2d 09 	lds	r21, 0x092D	; 0x80092d <GRAV+0x1>
    8c12:	60 91 2e 09 	lds	r22, 0x092E	; 0x80092e <GRAV+0x2>
    8c16:	70 91 2f 09 	lds	r23, 0x092F	; 0x80092f <GRAV+0x3>
    8c1a:	23 e0       	ldi	r18, 0x03	; 3
    8c1c:	ce 01       	movw	r24, r28
    8c1e:	c4 96       	adiw	r24, 0x34	; 52
    8c20:	0e 94 c9 2b 	call	0x5792	; 0x5792 <String::String(float, unsigned char)>
    8c24:	40 91 42 09 	lds	r20, 0x0942	; 0x800942 <SAL>
    8c28:	50 91 43 09 	lds	r21, 0x0943	; 0x800943 <SAL+0x1>
    8c2c:	60 91 44 09 	lds	r22, 0x0944	; 0x800944 <SAL+0x2>
    8c30:	70 91 45 09 	lds	r23, 0x0945	; 0x800945 <SAL+0x3>
    8c34:	22 e0       	ldi	r18, 0x02	; 2
    8c36:	ce 01       	movw	r24, r28
    8c38:	8e 96       	adiw	r24, 0x2e	; 46
    8c3a:	0e 94 c9 2b 	call	0x5792	; 0x5792 <String::String(float, unsigned char)>
    8c3e:	c0 90 2a 09 	lds	r12, 0x092A	; 0x80092a <TDS>
    8c42:	d0 90 2b 09 	lds	r13, 0x092B	; 0x80092b <TDS+0x1>
    8c46:	40 91 3e 09 	lds	r20, 0x093E	; 0x80093e <EC>
    8c4a:	50 91 3f 09 	lds	r21, 0x093F	; 0x80093f <EC+0x1>
    8c4e:	60 91 40 09 	lds	r22, 0x0940	; 0x800940 <EC+0x2>
    8c52:	70 91 41 09 	lds	r23, 0x0941	; 0x800941 <EC+0x3>
    8c56:	22 e0       	ldi	r18, 0x02	; 2
    8c58:	ce 01       	movw	r24, r28
    8c5a:	88 96       	adiw	r24, 0x28	; 40
    8c5c:	0e 94 c9 2b 	call	0x5792	; 0x5792 <String::String(float, unsigned char)>
    8c60:	63 ea       	ldi	r22, 0xA3	; 163
    8c62:	73 e0       	ldi	r23, 0x03	; 3
    8c64:	ce 01       	movw	r24, r28
    8c66:	4c 96       	adiw	r24, 0x1c	; 28
    8c68:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
_ZN15StringSumHelperC2ERK6String():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:216
{
public:
	StringSumHelper(const String &s) : String(s) {}
    8c6c:	be 01       	movw	r22, r28
    8c6e:	64 5e       	subi	r22, 0xE4	; 228
    8c70:	7f 4f       	sbci	r23, 0xFF	; 255
    8c72:	ce 01       	movw	r24, r28
    8c74:	82 96       	adiw	r24, 0x22	; 34
    8c76:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:47
    8c7a:	be 01       	movw	r22, r28
    8c7c:	68 5d       	subi	r22, 0xD8	; 216
    8c7e:	7f 4f       	sbci	r23, 0xFF	; 255
    8c80:	ce 01       	movw	r24, r28
    8c82:	82 96       	adiw	r24, 0x22	; 34
    8c84:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8c88:	6a ef       	ldi	r22, 0xFA	; 250
    8c8a:	77 e0       	ldi	r23, 0x07	; 7
    8c8c:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8c90:	8c 01       	movw	r16, r24
utoa():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include/stdlib.h:527
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__utoa_ncheck (unsigned int, char *, unsigned char);
	return __utoa_ncheck (__val, __s, __radix);
    8c92:	4a e0       	ldi	r20, 0x0A	; 10
    8c94:	b7 01       	movw	r22, r14
    8c96:	c6 01       	movw	r24, r12
    8c98:	0e 94 da 64 	call	0xc9b4	; 0xc9b4 <__utoa_ncheck>
concat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:306

unsigned char String::concat(unsigned int num)
{
	char buf[1 + 3 * sizeof(unsigned int)];
	utoa(num, buf, 10);
	return concat(buf, strlen(buf));
    8c9c:	f7 01       	movw	r30, r14
    8c9e:	01 90       	ld	r0, Z+
    8ca0:	00 20       	and	r0, r0
    8ca2:	e9 f7       	brne	.-6      	; 0x8c9e <doMeasure()+0x171a>
    8ca4:	31 97       	sbiw	r30, 0x01	; 1
    8ca6:	af 01       	movw	r20, r30
    8ca8:	4e 19       	sub	r20, r14
    8caa:	5f 09       	sbc	r21, r15
    8cac:	b7 01       	movw	r22, r14
    8cae:	c8 01       	movw	r24, r16
    8cb0:	0e 94 06 2a 	call	0x540c	; 0x540c <String::concat(char const*, unsigned int)>
operator+():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:391
}

StringSumHelper & operator + (const StringSumHelper &lhs, unsigned int num)
{
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(num)) a.invalidate();
    8cb4:	81 11       	cpse	r24, r1
    8cb6:	03 c0       	rjmp	.+6      	; 0x8cbe <doMeasure()+0x173a>
    8cb8:	c8 01       	movw	r24, r16
    8cba:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <String::invalidate()>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:47
    8cbe:	6a ef       	ldi	r22, 0xFA	; 250
    8cc0:	77 e0       	ldi	r23, 0x07	; 7
    8cc2:	c8 01       	movw	r24, r16
    8cc4:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8cc8:	be 01       	movw	r22, r28
    8cca:	62 5d       	subi	r22, 0xD2	; 210
    8ccc:	7f 4f       	sbci	r23, 0xFF	; 255
    8cce:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8cd2:	6a ef       	ldi	r22, 0xFA	; 250
    8cd4:	77 e0       	ldi	r23, 0x07	; 7
    8cd6:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8cda:	be 01       	movw	r22, r28
    8cdc:	6c 5c       	subi	r22, 0xCC	; 204
    8cde:	7f 4f       	sbci	r23, 0xFF	; 255
    8ce0:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8ce4:	6a ef       	ldi	r22, 0xFA	; 250
    8ce6:	77 e0       	ldi	r23, 0x07	; 7
    8ce8:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    8cec:	be 01       	movw	r22, r28
    8cee:	66 5c       	subi	r22, 0xC6	; 198
    8cf0:	7f 4f       	sbci	r23, 0xFF	; 255
    8cf2:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8cf6:	6a ef       	ldi	r22, 0xFA	; 250
    8cf8:	77 e0       	ldi	r23, 0x07	; 7
    8cfa:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
_ZN6StringpLERKS_():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:113
	unsigned char concat(double num);
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
    8cfe:	bc 01       	movw	r22, r24
    8d00:	ce 01       	movw	r24, r28
    8d02:	8a 5b       	subi	r24, 0xBA	; 186
    8d04:	9f 4f       	sbci	r25, 0xFF	; 255
    8d06:	0e 94 14 2b 	call	0x5628	; 0x5628 <String::concat(String const&)>
_ZN15StringSumHelperD2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    8d0a:	ce 01       	movw	r24, r28
    8d0c:	82 96       	adiw	r24, 0x22	; 34
    8d0e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:47
    8d12:	ce 01       	movw	r24, r28
    8d14:	4c 96       	adiw	r24, 0x1c	; 28
    8d16:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8d1a:	ce 01       	movw	r24, r28
    8d1c:	88 96       	adiw	r24, 0x28	; 40
    8d1e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8d22:	ce 01       	movw	r24, r28
    8d24:	8e 96       	adiw	r24, 0x2e	; 46
    8d26:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8d2a:	ce 01       	movw	r24, r28
    8d2c:	c4 96       	adiw	r24, 0x34	; 52
    8d2e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    8d32:	ce 01       	movw	r24, r28
    8d34:	ca 96       	adiw	r24, 0x3a	; 58
    8d36:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
_ZN6StringpLERKS_():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:113
	unsigned char concat(double num);
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
    8d3a:	66 e0       	ldi	r22, 0x06	; 6
    8d3c:	71 e1       	ldi	r23, 0x11	; 17
    8d3e:	ce 01       	movw	r24, r28
    8d40:	8a 5b       	subi	r24, 0xBA	; 186
    8d42:	9f 4f       	sbci	r25, 0xFF	; 255
    8d44:	0e 94 14 2b 	call	0x5628	; 0x5628 <String::concat(String const&)>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:49
	temp += K30Serial;
	temp += "," + String(fault, HEX) + ",";
    8d48:	60 91 5f 09 	lds	r22, 0x095F	; 0x80095f <fault>
    8d4c:	ce 01       	movw	r24, r28
    8d4e:	4c 96       	adiw	r24, 0x1c	; 28
    8d50:	0e 94 72 2b 	call	0x56e4	; 0x56e4 <String::String(unsigned char, unsigned char) [clone .constprop.111]>
_ZN15StringSumHelperC2EPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:217

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    8d54:	6a ef       	ldi	r22, 0xFA	; 250
    8d56:	77 e0       	ldi	r23, 0x07	; 7
    8d58:	c7 01       	movw	r24, r14
    8d5a:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:49
    8d5e:	be 01       	movw	r22, r28
    8d60:	64 5e       	subi	r22, 0xE4	; 228
    8d62:	7f 4f       	sbci	r23, 0xFF	; 255
    8d64:	c7 01       	movw	r24, r14
    8d66:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    8d6a:	6a ef       	ldi	r22, 0xFA	; 250
    8d6c:	77 e0       	ldi	r23, 0x07	; 7
    8d6e:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
_ZN6StringpLERKS_():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:113
	unsigned char concat(double num);
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
    8d72:	bc 01       	movw	r22, r24
    8d74:	ce 01       	movw	r24, r28
    8d76:	8a 5b       	subi	r24, 0xBA	; 186
    8d78:	9f 4f       	sbci	r25, 0xFF	; 255
    8d7a:	0e 94 14 2b 	call	0x5628	; 0x5628 <String::concat(String const&)>
_ZN15StringSumHelperD2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    8d7e:	c7 01       	movw	r24, r14
    8d80:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:49
    8d84:	ce 01       	movw	r24, r28
    8d86:	4c 96       	adiw	r24, 0x1c	; 28
    8d88:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:51
	//temp += noFault ? ",T," : ",F,";
	temp += String(voltage);
    8d8c:	40 91 26 09 	lds	r20, 0x0926	; 0x800926 <voltage>
    8d90:	50 91 27 09 	lds	r21, 0x0927	; 0x800927 <voltage+0x1>
    8d94:	60 91 28 09 	lds	r22, 0x0928	; 0x800928 <voltage+0x2>
    8d98:	70 91 29 09 	lds	r23, 0x0929	; 0x800929 <voltage+0x3>
    8d9c:	22 e0       	ldi	r18, 0x02	; 2
    8d9e:	c7 01       	movw	r24, r14
    8da0:	0e 94 c9 2b 	call	0x5792	; 0x5792 <String::String(float, unsigned char)>
_ZN6StringpLERKS_():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:113
	unsigned char concat(double num);
	unsigned char concat(const __FlashStringHelper * str);

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
    8da4:	b7 01       	movw	r22, r14
    8da6:	ce 01       	movw	r24, r28
    8da8:	8a 5b       	subi	r24, 0xBA	; 186
    8daa:	9f 4f       	sbci	r25, 0xFF	; 255
    8dac:	0e 94 14 2b 	call	0x5628	; 0x5628 <String::concat(String const&)>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:51
    8db0:	c7 01       	movw	r24, r14
    8db2:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
_ZN6StringpLEPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:114
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
    8db6:	6a ef       	ldi	r22, 0xFA	; 250
    8db8:	77 e0       	ldi	r23, 0x07	; 7
    8dba:	ce 01       	movw	r24, r28
    8dbc:	8a 5b       	subi	r24, 0xBA	; 186
    8dbe:	9f 4f       	sbci	r25, 0xFF	; 255
    8dc0:	0e 94 0a 2b 	call	0x5614	; 0x5614 <String::concat(char const*)>
freeMemory():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SRam_Check.ino:13
int freeMemory() {
	char top;
#ifdef __arm__
	return &top - reinterpret_cast<char*>(sbrk(0));
#elif defined(CORE_TEENSY) || (ARDUINO > 103 && ARDUINO != 151)
	return &top - __brkval;
    8dc4:	80 91 6a 13 	lds	r24, 0x136A	; 0x80136a <__brkval>
    8dc8:	90 91 6b 13 	lds	r25, 0x136B	; 0x80136b <__brkval+0x1>
    8dcc:	b7 01       	movw	r22, r14
    8dce:	68 1b       	sub	r22, r24
    8dd0:	79 0b       	sbc	r23, r25
_ZN6StringpLEi():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:117
	String & operator += (char c)			{concat(c); return (*this);}
	String & operator += (unsigned char num)		{concat(num); return (*this);}
	String & operator += (int num)			{concat(num); return (*this);}
    8dd2:	ce 01       	movw	r24, r28
    8dd4:	8a 5b       	subi	r24, 0xBA	; 186
    8dd6:	9f 4f       	sbci	r25, 0xFF	; 255
    8dd8:	0e 94 8c 2a 	call	0x5518	; 0x5518 <String::concat(int)>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:55
	temp += ",";
	temp += freeMemory();

	myFile = SD.open(filename, FILE_WRITE);
    8ddc:	c7 01       	movw	r24, r14
    8dde:	0e 94 26 37 	call	0x6e4c	; 0x6e4c <SDLib::SDClass::open(char const*, unsigned char) [clone .constprop.149]>
    8de2:	c7 01       	movw	r24, r14
    8de4:	0e 94 c3 03 	call	0x786	; 0x786 <SDLib::File::operator=(SDLib::File&&) [clone .constprop.162]>
operator 2():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:163
    */
  }
}

File::operator bool() {
  if (_file) {
    8de8:	e0 91 25 11 	lds	r30, 0x1125	; 0x801125 <myFile+0x19>
    8dec:	f0 91 26 11 	lds	r31, 0x1126	; 0x801126 <myFile+0x1a>
    8df0:	30 97       	sbiw	r30, 0x00	; 0
    8df2:	09 f4       	brne	.+2      	; 0x8df6 <doMeasure()+0x1872>
    8df4:	aa c1       	rjmp	.+852    	; 0x914a <doMeasure()+0x1bc6>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:56
	if (myFile) 
    8df6:	85 81       	ldd	r24, Z+5	; 0x05
    8df8:	88 23       	and	r24, r24
    8dfa:	09 f4       	brne	.+2      	; 0x8dfe <doMeasure()+0x187a>
    8dfc:	a6 c1       	rjmp	.+844    	; 0x914a <doMeasure()+0x1bc6>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:58
	{
		myFile.println(temp);
    8dfe:	be 01       	movw	r22, r28
    8e00:	6a 5b       	subi	r22, 0xBA	; 186
    8e02:	7f 4f       	sbci	r23, 0xFF	; 255
    8e04:	8c e0       	ldi	r24, 0x0C	; 12
    8e06:	91 e1       	ldi	r25, 0x11	; 17
    8e08:	0e 94 4e 28 	call	0x509c	; 0x509c <Print::println(String const&)>
close():
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:149
  }
  return _file->fileSize();
}

void File::close() {
  if (_file) {
    8e0c:	80 91 25 11 	lds	r24, 0x1125	; 0x801125 <myFile+0x19>
    8e10:	90 91 26 11 	lds	r25, 0x1126	; 0x801126 <myFile+0x1a>
    8e14:	00 97       	sbiw	r24, 0x00	; 0
    8e16:	61 f0       	breq	.+24     	; 0x8e30 <doMeasure()+0x18ac>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:150
    _file->close();
    8e18:	0e 94 9e 16 	call	0x2d3c	; 0x2d3c <SdFile::close()>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:151
    free(_file);
    8e1c:	80 91 25 11 	lds	r24, 0x1125	; 0x801125 <myFile+0x19>
    8e20:	90 91 26 11 	lds	r25, 0x1126	; 0x801126 <myFile+0x1a>
    8e24:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
D:\USER\Documents\Arduino\libraries\SD\src/File.cpp:152
    _file = 0;
    8e28:	10 92 26 11 	sts	0x1126, r1	; 0x801126 <myFile+0x1a>
    8e2c:	10 92 25 11 	sts	0x1125, r1	; 0x801125 <myFile+0x19>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:68
		waring();
		SD_alive = false;
	}
	myFile.close();
	//if (EC_dry_btnEvt || EC_high_btnEvt || EC_low_btnEvt || ph_4_btnEvt || ph_7_btnEvt || ph_10_btnEvt || k_cal_btnEvt)		EventLog();
	Serial.println(temp);
    8e30:	be 01       	movw	r22, r28
    8e32:	6a 5b       	subi	r22, 0xBA	; 186
    8e34:	7f 4f       	sbci	r23, 0xFF	; 255
    8e36:	82 e5       	ldi	r24, 0x52	; 82
    8e38:	9e e0       	ldi	r25, 0x0E	; 14
    8e3a:	0e 94 4e 28 	call	0x509c	; 0x509c <Print::println(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:69
	if (SD_alive) {
    8e3e:	80 91 19 02 	lds	r24, 0x0219	; 0x800219 <SD_alive>
    8e42:	88 23       	and	r24, r24
    8e44:	09 f4       	brne	.+2      	; 0x8e48 <doMeasure()+0x18c4>
    8e46:	8a c1       	rjmp	.+788    	; 0x915c <doMeasure()+0x1bd8>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:70
		SDIO.off();
    8e48:	89 e2       	ldi	r24, 0x29	; 41
    8e4a:	90 e1       	ldi	r25, 0x10	; 16
    8e4c:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:41
		last_day = day;
		getFilename(filename);
		File_check_exists();
	}

	String temp = String("");
    8e50:	ce 01       	movw	r24, r28
    8e52:	8a 5b       	subi	r24, 0xBA	; 186
    8e54:	9f 4f       	sbci	r25, 0xFF	; 255
    8e56:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
LCD_update_main():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:15


void LCD_update_main() {

///Row 0
		update_time_info();
    8e5a:	0e 94 58 30 	call	0x60b0	; 0x60b0 <update_time_info()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:16
		lcd.setCursor(18, 0);
    8e5e:	60 e0       	ldi	r22, 0x00	; 0
    8e60:	82 e1       	ldi	r24, 0x12	; 18
    8e62:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:17
		if (VoltageInPercent() >= 100) lcd.print("Fu");
    8e66:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <VoltageInPercent()>
    8e6a:	84 36       	cpi	r24, 0x64	; 100
    8e6c:	91 05       	cpc	r25, r1
    8e6e:	0c f4       	brge	.+2      	; 0x8e72 <doMeasure()+0x18ee>
    8e70:	9c c1       	rjmp	.+824    	; 0x91aa <doMeasure()+0x1c26>
    8e72:	65 e9       	ldi	r22, 0x95	; 149
    8e74:	76 e0       	ldi	r23, 0x06	; 6
    8e76:	8b eb       	ldi	r24, 0xBB	; 187
    8e78:	90 e1       	ldi	r25, 0x10	; 16
    8e7a:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:22
		else lcd.print(inttostring(VoltageInPercent(), 2));
		//if (!RTC_alive) {			lcd.write(3);		}
		//lcd.print(gps_valid ? "G" : "-");
///Row 1
		LCDUpdateRow1();
    8e7e:	0e 94 4a 31 	call	0x6294	; 0x6294 <LCDUpdateRow1()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:23
		lcd.setCursor(17, 1);
    8e82:	61 e0       	ldi	r22, 0x01	; 1
    8e84:	81 e1       	ldi	r24, 0x11	; 17
    8e86:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:24
		lcd.write(7);
    8e8a:	67 e0       	ldi	r22, 0x07	; 7
    8e8c:	8b eb       	ldi	r24, 0xBB	; 187
    8e8e:	90 e1       	ldi	r25, 0x10	; 16
    8e90:	0e 94 f0 22 	call	0x45e0	; 0x45e0 <LiquidCrystal_I2C::write(unsigned char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:25
		lcd.print(inttostring(humidity, 2));
    8e94:	60 91 52 09 	lds	r22, 0x0952	; 0x800952 <humidity>
    8e98:	70 91 53 09 	lds	r23, 0x0953	; 0x800953 <humidity+0x1>
    8e9c:	42 e0       	ldi	r20, 0x02	; 2
    8e9e:	50 e0       	ldi	r21, 0x00	; 0
    8ea0:	c7 01       	movw	r24, r14
    8ea2:	0e 94 f1 2d 	call	0x5be2	; 0x5be2 <inttostring(int, int)>
    8ea6:	b7 01       	movw	r22, r14
    8ea8:	8b eb       	ldi	r24, 0xBB	; 187
    8eaa:	90 e1       	ldi	r25, 0x10	; 16
    8eac:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    8eb0:	c7 01       	movw	r24, r14
    8eb2:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:27
///Row 2
		lcd.setCursor(0, 2);
    8eb6:	62 e0       	ldi	r22, 0x02	; 2
    8eb8:	80 e0       	ldi	r24, 0x00	; 0
    8eba:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:28
		lcd.write(2);
    8ebe:	62 e0       	ldi	r22, 0x02	; 2
    8ec0:	8b eb       	ldi	r24, 0xBB	; 187
    8ec2:	90 e1       	ldi	r25, 0x10	; 16
    8ec4:	0e 94 f0 22 	call	0x45e0	; 0x45e0 <LiquidCrystal_I2C::write(unsigned char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:29
		lcd.print(inttostring(valCO2, 5));
    8ec8:	60 91 50 09 	lds	r22, 0x0950	; 0x800950 <valCO2>
    8ecc:	70 91 51 09 	lds	r23, 0x0951	; 0x800951 <valCO2+0x1>
    8ed0:	45 e0       	ldi	r20, 0x05	; 5
    8ed2:	50 e0       	ldi	r21, 0x00	; 0
    8ed4:	c7 01       	movw	r24, r14
    8ed6:	0e 94 f1 2d 	call	0x5be2	; 0x5be2 <inttostring(int, int)>
    8eda:	b7 01       	movw	r22, r14
    8edc:	8b eb       	ldi	r24, 0xBB	; 187
    8ede:	90 e1       	ldi	r25, 0x10	; 16
    8ee0:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    8ee4:	c7 01       	movw	r24, r14
    8ee6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:31

		lcd.setCursor(7, 2);
    8eea:	62 e0       	ldi	r22, 0x02	; 2
    8eec:	87 e0       	ldi	r24, 0x07	; 7
    8eee:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:32
		lcd.write(6);
    8ef2:	66 e0       	ldi	r22, 0x06	; 6
    8ef4:	8b eb       	ldi	r24, 0xBB	; 187
    8ef6:	90 e1       	ldi	r25, 0x10	; 16
    8ef8:	0e 94 f0 22 	call	0x45e0	; 0x45e0 <LiquidCrystal_I2C::write(unsigned char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:34
		//lcd_qFprint(pressure_in_atm, 3, 8, 2);
		lcd.print(floattostring(pressure_in_atm, 1, 3));
    8efc:	40 91 4c 09 	lds	r20, 0x094C	; 0x80094c <pressure_in_atm>
    8f00:	50 91 4d 09 	lds	r21, 0x094D	; 0x80094d <pressure_in_atm+0x1>
    8f04:	60 91 4e 09 	lds	r22, 0x094E	; 0x80094e <pressure_in_atm+0x2>
    8f08:	70 91 4f 09 	lds	r23, 0x094F	; 0x80094f <pressure_in_atm+0x3>
    8f0c:	03 e0       	ldi	r16, 0x03	; 3
    8f0e:	10 e0       	ldi	r17, 0x00	; 0
    8f10:	21 e0       	ldi	r18, 0x01	; 1
    8f12:	30 e0       	ldi	r19, 0x00	; 0
    8f14:	c7 01       	movw	r24, r14
    8f16:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <floattostring(float, int, int)>
    8f1a:	b7 01       	movw	r22, r14
    8f1c:	8b eb       	ldi	r24, 0xBB	; 187
    8f1e:	90 e1       	ldi	r25, 0x10	; 16
    8f20:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    8f24:	c7 01       	movw	r24, r14
    8f26:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:36

		lcd.setCursor(14, 2);
    8f2a:	62 e0       	ldi	r22, 0x02	; 2
    8f2c:	8e e0       	ldi	r24, 0x0E	; 14
    8f2e:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:37
		lcd.write(4);
    8f32:	64 e0       	ldi	r22, 0x04	; 4
    8f34:	8b eb       	ldi	r24, 0xBB	; 187
    8f36:	90 e1       	ldi	r25, 0x10	; 16
    8f38:	0e 94 f0 22 	call	0x45e0	; 0x45e0 <LiquidCrystal_I2C::write(unsigned char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:38
		lcd.print(floattostring(temperature, 2, 2));
    8f3c:	40 91 48 09 	lds	r20, 0x0948	; 0x800948 <temperature>
    8f40:	50 91 49 09 	lds	r21, 0x0949	; 0x800949 <temperature+0x1>
    8f44:	60 91 4a 09 	lds	r22, 0x094A	; 0x80094a <temperature+0x2>
    8f48:	70 91 4b 09 	lds	r23, 0x094B	; 0x80094b <temperature+0x3>
    8f4c:	02 e0       	ldi	r16, 0x02	; 2
    8f4e:	10 e0       	ldi	r17, 0x00	; 0
    8f50:	22 e0       	ldi	r18, 0x02	; 2
    8f52:	30 e0       	ldi	r19, 0x00	; 0
    8f54:	c7 01       	movw	r24, r14
    8f56:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <floattostring(float, int, int)>
    8f5a:	b7 01       	movw	r22, r14
    8f5c:	8b eb       	ldi	r24, 0xBB	; 187
    8f5e:	90 e1       	ldi	r25, 0x10	; 16
    8f60:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    8f64:	c7 01       	movw	r24, r14
    8f66:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:41
		//lcd_qFprint(temperature, 2, 15, 2);
///ROW 3
		lcd.setCursor(6, 3);
    8f6a:	63 e0       	ldi	r22, 0x03	; 3
    8f6c:	86 e0       	ldi	r24, 0x06	; 6
    8f6e:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:42
		lcd.print(" ");
    8f72:	6c e8       	ldi	r22, 0x8C	; 140
    8f74:	77 e0       	ldi	r23, 0x07	; 7
    8f76:	8b eb       	ldi	r24, 0xBB	; 187
    8f78:	90 e1       	ldi	r25, 0x10	; 16
    8f7a:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:43
		lcd.setCursor(0, 3);
    8f7e:	63 e0       	ldi	r22, 0x03	; 3
    8f80:	80 e0       	ldi	r24, 0x00	; 0
    8f82:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:46
		//judge is EC or EP
		//lcd.createChar(3, (bool)ec_print ? EP_Stand : EC_Stand);
		lcd.write(3);
    8f86:	63 e0       	ldi	r22, 0x03	; 3
    8f88:	8b eb       	ldi	r24, 0xBB	; 187
    8f8a:	90 e1       	ldi	r25, 0x10	; 16
    8f8c:	0e 94 f0 22 	call	0x45e0	; 0x45e0 <LiquidCrystal_I2C::write(unsigned char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:47
		if ((bool)ec_print) 
    8f90:	80 91 46 09 	lds	r24, 0x0946	; 0x800946 <ec_print>
    8f94:	90 91 47 09 	lds	r25, 0x0947	; 0x800947 <ec_print+0x1>
    8f98:	89 2b       	or	r24, r25
    8f9a:	09 f4       	brne	.+2      	; 0x8f9e <doMeasure()+0x1a1a>
    8f9c:	15 c1       	rjmp	.+554    	; 0x91c8 <doMeasure()+0x1c44>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:49
		{
			if (SAL < 10.0f )	lcd.print(floattostring(SAL, 1, 3));
    8f9e:	80 90 42 09 	lds	r8, 0x0942	; 0x800942 <SAL>
    8fa2:	90 90 43 09 	lds	r9, 0x0943	; 0x800943 <SAL+0x1>
    8fa6:	a0 90 44 09 	lds	r10, 0x0944	; 0x800944 <SAL+0x2>
    8faa:	b0 90 45 09 	lds	r11, 0x0945	; 0x800945 <SAL+0x3>
    8fae:	20 e0       	ldi	r18, 0x00	; 0
    8fb0:	30 e0       	ldi	r19, 0x00	; 0
    8fb2:	40 e2       	ldi	r20, 0x20	; 32
    8fb4:	51 e4       	ldi	r21, 0x41	; 65
    8fb6:	c5 01       	movw	r24, r10
    8fb8:	b4 01       	movw	r22, r8
    8fba:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
    8fbe:	03 e0       	ldi	r16, 0x03	; 3
    8fc0:	10 e0       	ldi	r17, 0x00	; 0
    8fc2:	21 e0       	ldi	r18, 0x01	; 1
    8fc4:	30 e0       	ldi	r19, 0x00	; 0
    8fc6:	87 fd       	sbrc	r24, 7
    8fc8:	04 c0       	rjmp	.+8      	; 0x8fd2 <doMeasure()+0x1a4e>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:50
			else				lcd.print(floattostring(SAL, 2, 2));
    8fca:	02 e0       	ldi	r16, 0x02	; 2
    8fcc:	10 e0       	ldi	r17, 0x00	; 0
    8fce:	22 e0       	ldi	r18, 0x02	; 2
    8fd0:	30 e0       	ldi	r19, 0x00	; 0
    8fd2:	b5 01       	movw	r22, r10
    8fd4:	a4 01       	movw	r20, r8
    8fd6:	c7 01       	movw	r24, r14
    8fd8:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <floattostring(float, int, int)>
    8fdc:	b7 01       	movw	r22, r14
    8fde:	8b eb       	ldi	r24, 0xBB	; 187
    8fe0:	90 e1       	ldi	r25, 0x10	; 16
    8fe2:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    8fe6:	c7 01       	movw	r24, r14
    8fe8:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:64
				lcd.print("h");
			}
				//lcd.print(longtostring(EC, 5));
		}

		lcd.setCursor(7, 3);
    8fec:	63 e0       	ldi	r22, 0x03	; 3
    8fee:	87 e0       	ldi	r24, 0x07	; 7
    8ff0:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:65
		lcd.write(1);
    8ff4:	61 e0       	ldi	r22, 0x01	; 1
    8ff6:	8b eb       	ldi	r24, 0xBB	; 187
    8ff8:	90 e1       	ldi	r25, 0x10	; 16
    8ffa:	0e 94 f0 22 	call	0x45e0	; 0x45e0 <LiquidCrystal_I2C::write(unsigned char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:66
		lcd.print(floattostring(pH, 1, 3));
    8ffe:	40 91 3a 09 	lds	r20, 0x093A	; 0x80093a <pH>
    9002:	50 91 3b 09 	lds	r21, 0x093B	; 0x80093b <pH+0x1>
    9006:	60 91 3c 09 	lds	r22, 0x093C	; 0x80093c <pH+0x2>
    900a:	70 91 3d 09 	lds	r23, 0x093D	; 0x80093d <pH+0x3>
    900e:	03 e0       	ldi	r16, 0x03	; 3
    9010:	10 e0       	ldi	r17, 0x00	; 0
    9012:	21 e0       	ldi	r18, 0x01	; 1
    9014:	30 e0       	ldi	r19, 0x00	; 0
    9016:	c7 01       	movw	r24, r14
    9018:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <floattostring(float, int, int)>
    901c:	b7 01       	movw	r22, r14
    901e:	8b eb       	ldi	r24, 0xBB	; 187
    9020:	90 e1       	ldi	r25, 0x10	; 16
    9022:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    9026:	c7 01       	movw	r24, r14
    9028:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:68

		lcd.setCursor(14, 3);
    902c:	63 e0       	ldi	r22, 0x03	; 3
    902e:	8e e0       	ldi	r24, 0x0E	; 14
    9030:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:69
		lcd.write(5);
    9034:	65 e0       	ldi	r22, 0x05	; 5
    9036:	8b eb       	ldi	r24, 0xBB	; 187
    9038:	90 e1       	ldi	r25, 0x10	; 16
    903a:	0e 94 f0 22 	call	0x45e0	; 0x45e0 <LiquidCrystal_I2C::write(unsigned char)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:70
		lcd.print(floattostring(K_temperature, 2, 2));
    903e:	40 91 10 02 	lds	r20, 0x0210	; 0x800210 <K_temperature>
    9042:	50 91 11 02 	lds	r21, 0x0211	; 0x800211 <K_temperature+0x1>
    9046:	60 91 12 02 	lds	r22, 0x0212	; 0x800212 <K_temperature+0x2>
    904a:	70 91 13 02 	lds	r23, 0x0213	; 0x800213 <K_temperature+0x3>
    904e:	02 e0       	ldi	r16, 0x02	; 2
    9050:	10 e0       	ldi	r17, 0x00	; 0
    9052:	22 e0       	ldi	r18, 0x02	; 2
    9054:	30 e0       	ldi	r19, 0x00	; 0
    9056:	c7 01       	movw	r24, r14
    9058:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <floattostring(float, int, int)>
    905c:	b7 01       	movw	r22, r14
    905e:	8b eb       	ldi	r24, 0xBB	; 187
    9060:	90 e1       	ldi	r25, 0x10	; 16
    9062:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    9066:	c7 01       	movw	r24, r14
    9068:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
doMeasure():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:27
  getECdata();
  MeasureBatteryVoltage();
  do_SD();						//Write Data into SD Card						 [SD_DATA]
  LCD_update_main();			//Update LCD Data								 [LCD]
  //SDIO.off();
}
    906c:	ca 59       	subi	r28, 0x9A	; 154
    906e:	df 4f       	sbci	r29, 0xFF	; 255
    9070:	0f b6       	in	r0, 0x3f	; 63
    9072:	f8 94       	cli
    9074:	de bf       	out	0x3e, r29	; 62
    9076:	0f be       	out	0x3f, r0	; 63
    9078:	cd bf       	out	0x3d, r28	; 61
    907a:	df 91       	pop	r29
    907c:	cf 91       	pop	r28
    907e:	1f 91       	pop	r17
    9080:	0f 91       	pop	r16
    9082:	ff 90       	pop	r15
    9084:	ef 90       	pop	r14
    9086:	df 90       	pop	r13
    9088:	cf 90       	pop	r12
    908a:	bf 90       	pop	r11
    908c:	af 90       	pop	r10
    908e:	9f 90       	pop	r9
    9090:	8f 90       	pop	r8
    9092:	7f 90       	pop	r7
    9094:	6f 90       	pop	r6
    9096:	5f 90       	pop	r5
    9098:	4f 90       	pop	r4
    909a:	3f 90       	pop	r3
    909c:	2f 90       	pop	r2
    909e:	08 95       	ret
tsys01_get():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/TSYS01.ino:14
	}
	else {
		temperature = NAN;
    90a0:	80 e0       	ldi	r24, 0x00	; 0
    90a2:	90 e0       	ldi	r25, 0x00	; 0
    90a4:	a0 ec       	ldi	r26, 0xC0	; 192
    90a6:	bf e7       	ldi	r27, 0x7F	; 127
    90a8:	80 93 48 09 	sts	0x0948, r24	; 0x800948 <temperature>
    90ac:	90 93 49 09 	sts	0x0949, r25	; 0x800949 <temperature+0x1>
    90b0:	a0 93 4a 09 	sts	0x094A, r26	; 0x80094a <temperature+0x2>
    90b4:	b0 93 4b 09 	sts	0x094B, r27	; 0x80094b <temperature+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/TSYS01.ino:15
		Serial.println("*TSYS01 Read Error");
    90b8:	69 e1       	ldi	r22, 0x19	; 25
    90ba:	76 e0       	ldi	r23, 0x06	; 6
    90bc:	82 e5       	ldi	r24, 0x52	; 82
    90be:	9e e0       	ldi	r25, 0x0E	; 14
    90c0:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
    90c4:	0c 94 e8 3d 	jmp	0x7bd0	; 0x7bd0 <doMeasure()+0x64c>
doMeasure():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:451

  readTemperature(); // must be done first to get t_fine

  int32_t adc_P = read24(BME280_REGISTER_PRESSUREDATA);
  if (adc_P == 0x800000) // value in case pressure measurement was disabled
    return NAN;
    90c8:	60 e0       	ldi	r22, 0x00	; 0
    90ca:	70 e0       	ldi	r23, 0x00	; 0
    90cc:	80 ec       	ldi	r24, 0xC0	; 192
    90ce:	9f e7       	ldi	r25, 0x7F	; 127
    90d0:	0c 94 47 40 	jmp	0x808e	; 0x808e <doMeasure()+0xb0a>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:464
         ((var1 * (int64_t)_bme280_calib.dig_P2) << 12);
  var1 =
      (((((int64_t)1) << 47) + var1)) * ((int64_t)_bme280_calib.dig_P1) >> 33;

  if (var1 == 0) {
    return 0; // avoid exception caused by division by zero
    90d4:	60 e0       	ldi	r22, 0x00	; 0
    90d6:	70 e0       	ldi	r23, 0x00	; 0
    90d8:	cb 01       	movw	r24, r22
    90da:	0c 94 47 40 	jmp	0x808e	; 0x808e <doMeasure()+0xb0a>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:484
float Adafruit_BME280::readHumidity(void) {
  readTemperature(); // must be done first to get t_fine

  int32_t adc_H = read16(BME280_REGISTER_HUMIDDATA);
  if (adc_H == 0x8000) // value in case humidity measurement was disabled
    return NAN;
    90de:	60 e0       	ldi	r22, 0x00	; 0
    90e0:	70 e0       	ldi	r23, 0x00	; 0
    90e2:	80 ec       	ldi	r24, 0xC0	; 192
    90e4:	9f e7       	ldi	r25, 0x7F	; 127
    90e6:	b6 c8       	rjmp	.-3732   	; 0x8254 <doMeasure()+0xcd0>
check_pCO2_Pressure():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:31

void check_pCO2_Pressure(float value) {
	if (value > pCO2_highP || value < pCO2_lowP)	_pCO2_PSampleT++;
	else
	{
		_pCO2_PSampleT = 0;
    90e8:	10 92 21 09 	sts	0x0921, r1	; 0x800921 <_pCO2_PSampleT+0x1>
    90ec:	10 92 20 09 	sts	0x0920, r1	; 0x800920 <_pCO2_PSampleT>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:32
		if (pCO2_PRecoverMode) 
    90f0:	80 91 54 09 	lds	r24, 0x0954	; 0x800954 <pCO2_PRecoverMode>
    90f4:	88 23       	and	r24, r24
    90f6:	09 f4       	brne	.+2      	; 0x90fa <doMeasure()+0x1b76>
    90f8:	ee c8       	rjmp	.-3620   	; 0x82d6 <doMeasure()+0xd52>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:34
		{
			pumpControl(pumpPower);
    90fa:	80 91 dc 09 	lds	r24, 0x09DC	; 0x8009dc <pumpPower>
    90fe:	90 91 dd 09 	lds	r25, 0x09DD	; 0x8009dd <pumpPower+0x1>
    9102:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <pumpControl(int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:35
			PGER.pause();
    9106:	87 e9       	ldi	r24, 0x97	; 151
    9108:	9f e0       	ldi	r25, 0x0F	; 15
    910a:	0e 94 c4 23 	call	0x4788	; 0x4788 <BlinkControl::pause()>
    910e:	e3 c8       	rjmp	.-3642   	; 0x82d6 <doMeasure()+0xd52>
measure_BME280():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:18
		pressure_in_atm = pressure / 101325.0f;
		check_pCO2_Pressure(pressure_in_atm);
	}
	else 
	{
		pressure = NAN;
    9110:	80 e0       	ldi	r24, 0x00	; 0
    9112:	90 e0       	ldi	r25, 0x00	; 0
    9114:	a0 ec       	ldi	r26, 0xC0	; 192
    9116:	bf e7       	ldi	r27, 0x7F	; 127
    9118:	80 93 30 09 	sts	0x0930, r24	; 0x800930 <pressure>
    911c:	90 93 31 09 	sts	0x0931, r25	; 0x800931 <pressure+0x1>
    9120:	a0 93 32 09 	sts	0x0932, r26	; 0x800932 <pressure+0x2>
    9124:	b0 93 33 09 	sts	0x0933, r27	; 0x800933 <pressure+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:19
		humidity = -9999;
    9128:	21 ef       	ldi	r18, 0xF1	; 241
    912a:	38 ed       	ldi	r19, 0xD8	; 216
    912c:	30 93 53 09 	sts	0x0953, r19	; 0x800953 <humidity+0x1>
    9130:	20 93 52 09 	sts	0x0952, r18	; 0x800952 <humidity>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:20
		pressure_in_atm = NAN;
    9134:	80 93 4c 09 	sts	0x094C, r24	; 0x80094c <pressure_in_atm>
    9138:	90 93 4d 09 	sts	0x094D, r25	; 0x80094d <pressure_in_atm+0x1>
    913c:	a0 93 4e 09 	sts	0x094E, r26	; 0x80094e <pressure_in_atm+0x2>
    9140:	b0 93 4f 09 	sts	0x094F, r27	; 0x80094f <pressure_in_atm+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:21
		Serial.println("*BME280 Read Error");
    9144:	67 e3       	ldi	r22, 0x37	; 55
    9146:	76 e0       	ldi	r23, 0x06	; 6
    9148:	e2 c8       	rjmp	.-3644   	; 0x830e <doMeasure()+0xd8a>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:62
	{
		myFile.println(temp);
	}
	else 
	{
		Serial.println(F("Unable To Access SD Card"));
    914a:	89 ea       	ldi	r24, 0xA9	; 169
    914c:	93 e0       	ldi	r25, 0x03	; 3
    914e:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <Print::println(__FlashStringHelper const*) [clone .constprop.71]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:63
		waring();
    9152:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <waring()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:64
		SD_alive = false;
    9156:	10 92 19 02 	sts	0x0219, r1	; 0x800219 <SD_alive>
    915a:	58 ce       	rjmp	.-848    	; 0x8e0c <doMeasure()+0x1888>
clearBlink():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:273
  this->_breatheInterval = round(duration / this->_brightStepMax);
  this->_state = BC_STATE_PULSE;
}

void BlinkControl::clearBlink() {
  this->_offOne();
    915c:	89 e2       	ldi	r24, 0x29	; 41
    915e:	90 e1       	ldi	r25, 0x10	; 16
    9160:	0e 94 8d 23 	call	0x471a	; 0x471a <BlinkControl::_offOne()>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:274
  delete[] this->_blinkTiming;
    9164:	80 91 5f 10 	lds	r24, 0x105F	; 0x80105f <SDIO+0x36>
    9168:	90 91 60 10 	lds	r25, 0x1060	; 0x801060 <SDIO+0x37>
    916c:	00 97       	sbiw	r24, 0x00	; 0
    916e:	11 f0       	breq	.+4      	; 0x9174 <doMeasure()+0x1bf0>
operator delete():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/new.cpp:35
  (void)size;
  return ptr;
}

void operator delete(void * ptr) {
  free(ptr);
    9170:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
clearBlink():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:275
  this->_timingCount = 0;
    9174:	10 92 62 10 	sts	0x1062, r1	; 0x801062 <SDIO+0x39>
    9178:	10 92 61 10 	sts	0x1061, r1	; 0x801061 <SDIO+0x38>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:276
  this->_pinOn = false;
    917c:	10 92 69 10 	sts	0x1069, r1	; 0x801069 <SDIO+0x40>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:277
  this->_prevState = BC_STATE_OFF;
    9180:	10 92 2c 10 	sts	0x102C, r1	; 0x80102c <SDIO+0x3>
    9184:	10 92 2b 10 	sts	0x102B, r1	; 0x80102b <SDIO+0x2>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:278
  this->_state = BC_STATE_OFF;
    9188:	10 92 2a 10 	sts	0x102A, r1	; 0x80102a <SDIO+0x1>
    918c:	10 92 29 10 	sts	0x1029, r1	; 0x801029 <SDIO>
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:279
  this->_lastAction = 0;
    9190:	10 92 65 10 	sts	0x1065, r1	; 0x801065 <SDIO+0x3c>
    9194:	10 92 66 10 	sts	0x1066, r1	; 0x801066 <SDIO+0x3d>
    9198:	10 92 67 10 	sts	0x1067, r1	; 0x801067 <SDIO+0x3e>
    919c:	10 92 68 10 	sts	0x1068, r1	; 0x801068 <SDIO+0x3f>
do_SD():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SD_DATA.ino:74
	if (SD_alive) {
		SDIO.off();
	}
	else {
		SDIO.clearBlink();
		SDIO.fastBlinking();
    91a0:	89 e2       	ldi	r24, 0x29	; 41
    91a2:	90 e1       	ldi	r25, 0x10	; 16
    91a4:	0e 94 41 25 	call	0x4a82	; 0x4a82 <BlinkControl::fastBlinking()>
    91a8:	53 ce       	rjmp	.-858    	; 0x8e50 <doMeasure()+0x18cc>
LCD_update_main():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:18

///Row 0
		update_time_info();
		lcd.setCursor(18, 0);
		if (VoltageInPercent() >= 100) lcd.print("Fu");
		else lcd.print(inttostring(VoltageInPercent(), 2));
    91aa:	42 e0       	ldi	r20, 0x02	; 2
    91ac:	50 e0       	ldi	r21, 0x00	; 0
    91ae:	bc 01       	movw	r22, r24
    91b0:	c7 01       	movw	r24, r14
    91b2:	0e 94 f1 2d 	call	0x5be2	; 0x5be2 <inttostring(int, int)>
    91b6:	b7 01       	movw	r22, r14
    91b8:	8b eb       	ldi	r24, 0xBB	; 187
    91ba:	90 e1       	ldi	r25, 0x10	; 16
    91bc:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    91c0:	c7 01       	movw	r24, r14
    91c2:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    91c6:	5b ce       	rjmp	.-842    	; 0x8e7e <doMeasure()+0x18fa>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:54
			if (SAL < 10.0f )	lcd.print(floattostring(SAL, 1, 3));
			else				lcd.print(floattostring(SAL, 2, 2));
		}
		else
		{
			if		(EC < 100.0f)	lcd.print(floattostring(EC, 2, 2));
    91c8:	80 90 3e 09 	lds	r8, 0x093E	; 0x80093e <EC>
    91cc:	90 90 3f 09 	lds	r9, 0x093F	; 0x80093f <EC+0x1>
    91d0:	a0 90 40 09 	lds	r10, 0x0940	; 0x800940 <EC+0x2>
    91d4:	b0 90 41 09 	lds	r11, 0x0941	; 0x800941 <EC+0x3>
    91d8:	20 e0       	ldi	r18, 0x00	; 0
    91da:	30 e0       	ldi	r19, 0x00	; 0
    91dc:	48 ec       	ldi	r20, 0xC8	; 200
    91de:	52 e4       	ldi	r21, 0x42	; 66
    91e0:	c5 01       	movw	r24, r10
    91e2:	b4 01       	movw	r22, r8
    91e4:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
    91e8:	87 fd       	sbrc	r24, 7
    91ea:	ef ce       	rjmp	.-546    	; 0x8fca <doMeasure()+0x1a46>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:55
			else if (EC < 1000.0f)	lcd.print(floattostring(EC, 3, 1));
    91ec:	20 e0       	ldi	r18, 0x00	; 0
    91ee:	30 e0       	ldi	r19, 0x00	; 0
    91f0:	4a e7       	ldi	r20, 0x7A	; 122
    91f2:	54 e4       	ldi	r21, 0x44	; 68
    91f4:	c5 01       	movw	r24, r10
    91f6:	b4 01       	movw	r22, r8
    91f8:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
    91fc:	01 e0       	ldi	r16, 0x01	; 1
    91fe:	10 e0       	ldi	r17, 0x00	; 0
    9200:	23 e0       	ldi	r18, 0x03	; 3
    9202:	30 e0       	ldi	r19, 0x00	; 0
    9204:	87 fd       	sbrc	r24, 7
    9206:	e5 ce       	rjmp	.-566    	; 0x8fd2 <doMeasure()+0x1a4e>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:56
			else if	(EC < 99999.0f)	lcd.print(longtostring((long)EC, 5));
    9208:	20 e8       	ldi	r18, 0x80	; 128
    920a:	3f e4       	ldi	r19, 0x4F	; 79
    920c:	43 ec       	ldi	r20, 0xC3	; 195
    920e:	57 e4       	ldi	r21, 0x47	; 71
    9210:	c5 01       	movw	r24, r10
    9212:	b4 01       	movw	r22, r8
    9214:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
    9218:	87 ff       	sbrs	r24, 7
    921a:	40 c0       	rjmp	.+128    	; 0x929c <doMeasure()+0x1d18>
    921c:	c5 01       	movw	r24, r10
    921e:	b4 01       	movw	r22, r8
    9220:	0e 94 53 6b 	call	0xd6a6	; 0xd6a6 <__fixsfsi>
    9224:	4b 01       	movw	r8, r22
    9226:	5c 01       	movw	r10, r24
longtostring():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:36
}

String longtostring(long value, int integer) {
	char* str = 0;
	char* format = "%0ld";
	format[1] = (char)(integer + '0');
    9228:	88 e9       	ldi	r24, 0x98	; 152
    922a:	c8 2e       	mov	r12, r24
    922c:	86 e0       	ldi	r24, 0x06	; 6
    922e:	d8 2e       	mov	r13, r24
    9230:	85 e3       	ldi	r24, 0x35	; 53
    9232:	80 93 99 06 	sts	0x0699, r24	; 0x800699 <keys+0x354>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:38
	int len = integer + 1;
	str = (char*)malloc(len * sizeof(char));
    9236:	86 e0       	ldi	r24, 0x06	; 6
    9238:	90 e0       	ldi	r25, 0x00	; 0
    923a:	0e 94 d8 62 	call	0xc5b0	; 0xc5b0 <malloc>
    923e:	8c 01       	movw	r16, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:39
	if (value == -9999) for (int i = 0; i < len - 1; i++) str[i] = '-';
    9240:	21 ef       	ldi	r18, 0xF1	; 241
    9242:	82 16       	cp	r8, r18
    9244:	28 ed       	ldi	r18, 0xD8	; 216
    9246:	92 06       	cpc	r9, r18
    9248:	2f ef       	ldi	r18, 0xFF	; 255
    924a:	a2 06       	cpc	r10, r18
    924c:	b2 06       	cpc	r11, r18
    924e:	b1 f4       	brne	.+44     	; 0x927c <doMeasure()+0x1cf8>
    9250:	8d e2       	ldi	r24, 0x2D	; 45
    9252:	d8 01       	movw	r26, r16
    9254:	8c 93       	st	X, r24
    9256:	11 96       	adiw	r26, 0x01	; 1
    9258:	8c 93       	st	X, r24
    925a:	11 97       	sbiw	r26, 0x01	; 1
    925c:	12 96       	adiw	r26, 0x02	; 2
    925e:	8c 93       	st	X, r24
    9260:	12 97       	sbiw	r26, 0x02	; 2
    9262:	13 96       	adiw	r26, 0x03	; 3
    9264:	8c 93       	st	X, r24
    9266:	13 97       	sbiw	r26, 0x03	; 3
    9268:	14 96       	adiw	r26, 0x04	; 4
    926a:	8c 93       	st	X, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:41
	else sprintf(str, format, value);
	String s = String(str);
    926c:	b8 01       	movw	r22, r16
    926e:	c7 01       	movw	r24, r14
    9270:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:42
	free(str);
    9274:	c8 01       	movw	r24, r16
    9276:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
    927a:	b0 ce       	rjmp	.-672    	; 0x8fdc <doMeasure()+0x1a58>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:40
	char* format = "%0ld";
	format[1] = (char)(integer + '0');
	int len = integer + 1;
	str = (char*)malloc(len * sizeof(char));
	if (value == -9999) for (int i = 0; i < len - 1; i++) str[i] = '-';
	else sprintf(str, format, value);
    927c:	bf 92       	push	r11
    927e:	af 92       	push	r10
    9280:	9f 92       	push	r9
    9282:	8f 92       	push	r8
    9284:	df 92       	push	r13
    9286:	cf 92       	push	r12
    9288:	1f 93       	push	r17
    928a:	8f 93       	push	r24
    928c:	0e 94 de 6e 	call	0xddbc	; 0xddbc <sprintf>
    9290:	0f b6       	in	r0, 0x3f	; 63
    9292:	f8 94       	cli
    9294:	de bf       	out	0x3e, r29	; 62
    9296:	0f be       	out	0x3f, r0	; 63
    9298:	cd bf       	out	0x3d, r28	; 61
    929a:	e8 cf       	rjmp	.-48     	; 0x926c <doMeasure()+0x1ce8>
LCD_update_main():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:58
			else {
				lcd.print(inttostring(EC / 100, 4));
    929c:	20 e0       	ldi	r18, 0x00	; 0
    929e:	30 e0       	ldi	r19, 0x00	; 0
    92a0:	48 ec       	ldi	r20, 0xC8	; 200
    92a2:	52 e4       	ldi	r21, 0x42	; 66
    92a4:	c5 01       	movw	r24, r10
    92a6:	b4 01       	movw	r22, r8
    92a8:	0e 94 e1 6a 	call	0xd5c2	; 0xd5c2 <__divsf3>
    92ac:	0e 94 53 6b 	call	0xd6a6	; 0xd6a6 <__fixsfsi>
    92b0:	44 e0       	ldi	r20, 0x04	; 4
    92b2:	50 e0       	ldi	r21, 0x00	; 0
    92b4:	c7 01       	movw	r24, r14
    92b6:	0e 94 f1 2d 	call	0x5be2	; 0x5be2 <inttostring(int, int)>
    92ba:	b7 01       	movw	r22, r14
    92bc:	8b eb       	ldi	r24, 0xBB	; 187
    92be:	90 e1       	ldi	r25, 0x10	; 16
    92c0:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    92c4:	c7 01       	movw	r24, r14
    92c6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:59
				lcd.print("h");
    92ca:	6d eb       	ldi	r22, 0xBD	; 189
    92cc:	77 e0       	ldi	r23, 0x07	; 7
    92ce:	8b eb       	ldi	r24, 0xBB	; 187
    92d0:	90 e1       	ldi	r25, 0x10	; 16
    92d2:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
    92d6:	8a ce       	rjmp	.-748    	; 0x8fec <doMeasure()+0x1a68>

000092d8 <EERef::update(unsigned char)>:
update():
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }
    
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    92d8:	ff 92       	push	r15
    92da:	0f 93       	push	r16
    92dc:	1f 93       	push	r17
    92de:	cf 93       	push	r28
    92e0:	df 93       	push	r29
    92e2:	ec 01       	movw	r28, r24
    92e4:	f6 2e       	mov	r15, r22
operator*():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:42

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    92e6:	08 81       	ld	r16, Y
    92e8:	19 81       	ldd	r17, Y+1	; 0x01
    92ea:	c8 01       	movw	r24, r16
    92ec:	0e 94 fb 69 	call	0xd3f6	; 0xd3f6 <eeprom_read_byte>
update():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:59
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }
    
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    92f0:	f8 16       	cp	r15, r24
    92f2:	21 f0       	breq	.+8      	; 0x92fc <EERef::update(unsigned char)+0x24>
_ZN5EERefaSEh():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:47
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
    operator uint8_t() const             { return **this; }
    
    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
    92f4:	6f 2d       	mov	r22, r15
    92f6:	c8 01       	movw	r24, r16
    92f8:	0e 94 03 6a 	call	0xd406	; 0xd406 <eeprom_write_byte>
update():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:59
    EERef &operator &=( uint8_t in )     { return *this = **this & in; }
    EERef &operator |=( uint8_t in )     { return *this = **this | in; }
    EERef &operator <<=( uint8_t in )    { return *this = **this << in; }
    EERef &operator >>=( uint8_t in )    { return *this = **this >> in; }
    
    EERef &update( uint8_t in )          { return  in != *this ? *this = in : *this; }
    92fc:	ce 01       	movw	r24, r28
    92fe:	df 91       	pop	r29
    9300:	cf 91       	pop	r28
    9302:	1f 91       	pop	r17
    9304:	0f 91       	pop	r16
    9306:	ff 90       	pop	r15
    9308:	08 95       	ret

0000930a <bool UpdateEEP<bool>(int, bool) [clone .constprop.51]>:
UpdateEEP():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:66

template <class T> bool UpdateEEP(int addr, const T value)
    930a:	1f 93       	push	r17
    930c:	cf 93       	push	r28
    930e:	df 93       	push	r29
    9310:	00 d0       	rcall	.+0      	; 0x9312 <bool UpdateEEP<bool>(int, bool) [clone .constprop.51]+0x8>
    9312:	1f 92       	push	r1
    9314:	cd b7       	in	r28, 0x3d	; 61
    9316:	de b7       	in	r29, 0x3e	; 62
    9318:	18 2f       	mov	r17, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:68
{
	int temp = 0;
    931a:	1c 82       	std	Y+4, r1	; 0x04
    931c:	1b 82       	std	Y+3, r1	; 0x03
_ZN11EEPROMClass3putIbEERKT_iS3_.isra.26():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:140
    }
    
    template< typename T > const T &put( int idx, const T &t ){
        EEPtr e = idx;
        const uint8_t *ptr = (const uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  (*e).update( *ptr++ );
    931e:	80 e6       	ldi	r24, 0x60	; 96
    9320:	90 e0       	ldi	r25, 0x00	; 0
    9322:	9a 83       	std	Y+2, r25	; 0x02
    9324:	89 83       	std	Y+1, r24	; 0x01
    9326:	61 2f       	mov	r22, r17
    9328:	ce 01       	movw	r24, r28
    932a:	01 96       	adiw	r24, 0x01	; 1
    932c:	0e 94 6c 49 	call	0x92d8	; 0x92d8 <EERef::update(unsigned char)>
UpdateEEP():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:70
	EEPROM.put(addr, value);
	EEPROM.get(addr, temp);
    9330:	be 01       	movw	r22, r28
    9332:	6d 5f       	subi	r22, 0xFD	; 253
    9334:	7f 4f       	sbci	r23, 0xFF	; 255
    9336:	80 e6       	ldi	r24, 0x60	; 96
    9338:	90 e0       	ldi	r25, 0x00	; 0
    933a:	0e 94 6a 39 	call	0x72d4	; 0x72d4 <int& EEPROMClass::get<int>(int, int&) [clone .isra.23]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:71
	return temp == value;
    933e:	81 e0       	ldi	r24, 0x01	; 1
    9340:	2b 81       	ldd	r18, Y+3	; 0x03
    9342:	3c 81       	ldd	r19, Y+4	; 0x04
    9344:	12 17       	cp	r17, r18
    9346:	13 06       	cpc	r1, r19
    9348:	09 f0       	breq	.+2      	; 0x934c <bool UpdateEEP<bool>(int, bool) [clone .constprop.51]+0x42>
    934a:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:72
}
    934c:	0f 90       	pop	r0
    934e:	0f 90       	pop	r0
    9350:	0f 90       	pop	r0
    9352:	0f 90       	pop	r0
    9354:	df 91       	pop	r29
    9356:	cf 91       	pop	r28
    9358:	1f 91       	pop	r17
    935a:	08 95       	ret

0000935c <bool UpdateEEP<long>(int, long) [clone .constprop.50]>:
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:66
		Serial.print(pCO2_PRecoverMode);
		Serial.print("\n");
	}
}

template <class T> bool UpdateEEP(int addr, const T value)
    935c:	ef 92       	push	r14
    935e:	ff 92       	push	r15
    9360:	0f 93       	push	r16
    9362:	1f 93       	push	r17
    9364:	cf 93       	push	r28
    9366:	df 93       	push	r29
    9368:	00 d0       	rcall	.+0      	; 0x936a <bool UpdateEEP<long>(int, long) [clone .constprop.50]+0xe>
    936a:	00 d0       	rcall	.+0      	; 0x936c <bool UpdateEEP<long>(int, long) [clone .constprop.50]+0x10>
    936c:	1f 92       	push	r1
    936e:	1f 92       	push	r1
    9370:	cd b7       	in	r28, 0x3d	; 61
    9372:	de b7       	in	r29, 0x3e	; 62
    9374:	6d 83       	std	Y+5, r22	; 0x05
    9376:	7e 83       	std	Y+6, r23	; 0x06
    9378:	8f 83       	std	Y+7, r24	; 0x07
    937a:	98 87       	std	Y+8, r25	; 0x08
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:68
{
	int temp = 0;
    937c:	1c 82       	std	Y+4, r1	; 0x04
    937e:	1b 82       	std	Y+3, r1	; 0x03
    9380:	7e 01       	movw	r14, r28
    9382:	85 e0       	ldi	r24, 0x05	; 5
    9384:	e8 0e       	add	r14, r24
    9386:	f1 1c       	adc	r15, r1
    9388:	06 e0       	ldi	r16, 0x06	; 6
    938a:	10 e0       	ldi	r17, 0x00	; 0
_ZN11EEPROMClass3putIlEERKT_iS3_.isra.27():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:140
    938c:	1a 83       	std	Y+2, r17	; 0x02
    938e:	09 83       	std	Y+1, r16	; 0x01
    9390:	f7 01       	movw	r30, r14
    9392:	61 91       	ld	r22, Z+
    9394:	7f 01       	movw	r14, r30
    9396:	ce 01       	movw	r24, r28
    9398:	01 96       	adiw	r24, 0x01	; 1
    939a:	0e 94 6c 49 	call	0x92d8	; 0x92d8 <EERef::update(unsigned char)>
    939e:	0f 5f       	subi	r16, 0xFF	; 255
    93a0:	1f 4f       	sbci	r17, 0xFF	; 255
    93a2:	0a 30       	cpi	r16, 0x0A	; 10
    93a4:	11 05       	cpc	r17, r1
    93a6:	91 f7       	brne	.-28     	; 0x938c <bool UpdateEEP<long>(int, long) [clone .constprop.50]+0x30>
UpdateEEP():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:70
	EEPROM.put(addr, value);
	EEPROM.get(addr, temp);
    93a8:	be 01       	movw	r22, r28
    93aa:	6d 5f       	subi	r22, 0xFD	; 253
    93ac:	7f 4f       	sbci	r23, 0xFF	; 255
    93ae:	86 e0       	ldi	r24, 0x06	; 6
    93b0:	90 e0       	ldi	r25, 0x00	; 0
    93b2:	0e 94 6a 39 	call	0x72d4	; 0x72d4 <int& EEPROMClass::get<int>(int, int&) [clone .isra.23]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:71
	return temp == value;
    93b6:	4b 81       	ldd	r20, Y+3	; 0x03
    93b8:	5c 81       	ldd	r21, Y+4	; 0x04
    93ba:	05 2e       	mov	r0, r21
    93bc:	00 0c       	add	r0, r0
    93be:	66 0b       	sbc	r22, r22
    93c0:	77 0b       	sbc	r23, r23
    93c2:	81 e0       	ldi	r24, 0x01	; 1
    93c4:	0d 81       	ldd	r16, Y+5	; 0x05
    93c6:	1e 81       	ldd	r17, Y+6	; 0x06
    93c8:	2f 81       	ldd	r18, Y+7	; 0x07
    93ca:	38 85       	ldd	r19, Y+8	; 0x08
    93cc:	04 17       	cp	r16, r20
    93ce:	15 07       	cpc	r17, r21
    93d0:	26 07       	cpc	r18, r22
    93d2:	37 07       	cpc	r19, r23
    93d4:	09 f0       	breq	.+2      	; 0x93d8 <bool UpdateEEP<long>(int, long) [clone .constprop.50]+0x7c>
    93d6:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:72
}
    93d8:	28 96       	adiw	r28, 0x08	; 8
    93da:	0f b6       	in	r0, 0x3f	; 63
    93dc:	f8 94       	cli
    93de:	de bf       	out	0x3e, r29	; 62
    93e0:	0f be       	out	0x3f, r0	; 63
    93e2:	cd bf       	out	0x3d, r28	; 61
    93e4:	df 91       	pop	r29
    93e6:	cf 91       	pop	r28
    93e8:	1f 91       	pop	r17
    93ea:	0f 91       	pop	r16
    93ec:	ff 90       	pop	r15
    93ee:	ef 90       	pop	r14
    93f0:	08 95       	ret

000093f2 <bool UpdateEEP<int>(int, int)>:
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:66
		Serial.print(pCO2_PRecoverMode);
		Serial.print("\n");
	}
}

template <class T> bool UpdateEEP(int addr, const T value)
    93f2:	ef 92       	push	r14
    93f4:	ff 92       	push	r15
    93f6:	0f 93       	push	r16
    93f8:	1f 93       	push	r17
    93fa:	cf 93       	push	r28
    93fc:	df 93       	push	r29
    93fe:	00 d0       	rcall	.+0      	; 0x9400 <bool UpdateEEP<int>(int, int)+0xe>
    9400:	1f 92       	push	r1
    9402:	cd b7       	in	r28, 0x3d	; 61
    9404:	de b7       	in	r29, 0x3e	; 62
    9406:	7c 01       	movw	r14, r24
    9408:	8b 01       	movw	r16, r22
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:68
{
	int temp = 0;
    940a:	1c 82       	std	Y+4, r1	; 0x04
    940c:	1b 82       	std	Y+3, r1	; 0x03
_ZN11EEPROMClass3putIiEERKT_iS3_.isra.25():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:140
    940e:	9a 83       	std	Y+2, r25	; 0x02
    9410:	89 83       	std	Y+1, r24	; 0x01
    9412:	ce 01       	movw	r24, r28
    9414:	01 96       	adiw	r24, 0x01	; 1
    9416:	0e 94 6c 49 	call	0x92d8	; 0x92d8 <EERef::update(unsigned char)>
_ZN5EEPtrppEv():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:100
    //Iterator functionality.
    bool operator!=( const EEPtr &ptr ) { return index != ptr.index; }
    EERef operator*()                   { return index; }
    
    /** Prefix & Postfix increment/decrement **/
    EEPtr& operator++()                 { return ++index, *this; }
    941a:	c7 01       	movw	r24, r14
    941c:	01 96       	adiw	r24, 0x01	; 1
_ZN11EEPROMClass3putIiEERKT_iS3_.isra.25():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:140
    }
    
    template< typename T > const T &put( int idx, const T &t ){
        EEPtr e = idx;
        const uint8_t *ptr = (const uint8_t*) &t;
        for( int count = sizeof(T) ; count ; --count, ++e )  (*e).update( *ptr++ );
    941e:	9a 83       	std	Y+2, r25	; 0x02
    9420:	89 83       	std	Y+1, r24	; 0x01
    9422:	61 2f       	mov	r22, r17
    9424:	ce 01       	movw	r24, r28
    9426:	01 96       	adiw	r24, 0x01	; 1
    9428:	0e 94 6c 49 	call	0x92d8	; 0x92d8 <EERef::update(unsigned char)>
UpdateEEP():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:70
	EEPROM.put(addr, value);
	EEPROM.get(addr, temp);
    942c:	be 01       	movw	r22, r28
    942e:	6d 5f       	subi	r22, 0xFD	; 253
    9430:	7f 4f       	sbci	r23, 0xFF	; 255
    9432:	c7 01       	movw	r24, r14
    9434:	0e 94 6a 39 	call	0x72d4	; 0x72d4 <int& EEPROMClass::get<int>(int, int&) [clone .isra.23]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:71
	return temp == value;
    9438:	81 e0       	ldi	r24, 0x01	; 1
    943a:	2b 81       	ldd	r18, Y+3	; 0x03
    943c:	3c 81       	ldd	r19, Y+4	; 0x04
    943e:	20 17       	cp	r18, r16
    9440:	31 07       	cpc	r19, r17
    9442:	09 f0       	breq	.+2      	; 0x9446 <bool UpdateEEP<int>(int, int)+0x54>
    9444:	80 e0       	ldi	r24, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:72
}
    9446:	0f 90       	pop	r0
    9448:	0f 90       	pop	r0
    944a:	0f 90       	pop	r0
    944c:	0f 90       	pop	r0
    944e:	df 91       	pop	r29
    9450:	cf 91       	pop	r28
    9452:	1f 91       	pop	r17
    9454:	0f 91       	pop	r16
    9456:	ff 90       	pop	r15
    9458:	ef 90       	pop	r14
    945a:	08 95       	ret

0000945c <bool UpdateEEP<float>(int, float)>:
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:66
		Serial.print(pCO2_PRecoverMode);
		Serial.print("\n");
	}
}

template <class T> bool UpdateEEP(int addr, const T value)
    945c:	af 92       	push	r10
    945e:	bf 92       	push	r11
    9460:	cf 92       	push	r12
    9462:	df 92       	push	r13
    9464:	ef 92       	push	r14
    9466:	ff 92       	push	r15
    9468:	0f 93       	push	r16
    946a:	1f 93       	push	r17
    946c:	cf 93       	push	r28
    946e:	df 93       	push	r29
    9470:	00 d0       	rcall	.+0      	; 0x9472 <bool UpdateEEP<float>(int, float)+0x16>
    9472:	00 d0       	rcall	.+0      	; 0x9474 <bool UpdateEEP<float>(int, float)+0x18>
    9474:	1f 92       	push	r1
    9476:	1f 92       	push	r1
    9478:	cd b7       	in	r28, 0x3d	; 61
    947a:	de b7       	in	r29, 0x3e	; 62
    947c:	7c 01       	movw	r14, r24
    947e:	4d 83       	std	Y+5, r20	; 0x05
    9480:	5e 83       	std	Y+6, r21	; 0x06
    9482:	6f 83       	std	Y+7, r22	; 0x07
    9484:	78 87       	std	Y+8, r23	; 0x08
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:68
{
	int temp = 0;
    9486:	1c 82       	std	Y+4, r1	; 0x04
    9488:	1b 82       	std	Y+3, r1	; 0x03
    948a:	6e 01       	movw	r12, r28
    948c:	89 e0       	ldi	r24, 0x09	; 9
    948e:	c8 0e       	add	r12, r24
    9490:	d1 1c       	adc	r13, r1
    9492:	8e 01       	movw	r16, r28
    9494:	0b 5f       	subi	r16, 0xFB	; 251
    9496:	1f 4f       	sbci	r17, 0xFF	; 255
_ZN11EEPROMClass3putIfEERKT_iS3_.isra.22():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\EEPROM\src/EEPROM.h:140
    9498:	57 01       	movw	r10, r14
    949a:	a0 1a       	sub	r10, r16
    949c:	b1 0a       	sbc	r11, r17
    949e:	c5 01       	movw	r24, r10
    94a0:	80 0f       	add	r24, r16
    94a2:	91 1f       	adc	r25, r17
    94a4:	9a 83       	std	Y+2, r25	; 0x02
    94a6:	89 83       	std	Y+1, r24	; 0x01
    94a8:	f8 01       	movw	r30, r16
    94aa:	61 91       	ld	r22, Z+
    94ac:	8f 01       	movw	r16, r30
    94ae:	ce 01       	movw	r24, r28
    94b0:	01 96       	adiw	r24, 0x01	; 1
    94b2:	0e 94 6c 49 	call	0x92d8	; 0x92d8 <EERef::update(unsigned char)>
    94b6:	0c 15       	cp	r16, r12
    94b8:	1d 05       	cpc	r17, r13
    94ba:	89 f7       	brne	.-30     	; 0x949e <bool UpdateEEP<float>(int, float)+0x42>
UpdateEEP():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:70
	EEPROM.put(addr, value);
	EEPROM.get(addr, temp);
    94bc:	be 01       	movw	r22, r28
    94be:	6d 5f       	subi	r22, 0xFD	; 253
    94c0:	7f 4f       	sbci	r23, 0xFF	; 255
    94c2:	c7 01       	movw	r24, r14
    94c4:	0e 94 6a 39 	call	0x72d4	; 0x72d4 <int& EEPROMClass::get<int>(int, int&) [clone .isra.23]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:71
	return temp == value;
    94c8:	6b 81       	ldd	r22, Y+3	; 0x03
    94ca:	7c 81       	ldd	r23, Y+4	; 0x04
    94cc:	07 2e       	mov	r0, r23
    94ce:	00 0c       	add	r0, r0
    94d0:	88 0b       	sbc	r24, r24
    94d2:	99 0b       	sbc	r25, r25
    94d4:	0e 94 db 68 	call	0xd1b6	; 0xd1b6 <__floatsisf>
    94d8:	11 e0       	ldi	r17, 0x01	; 1
    94da:	2d 81       	ldd	r18, Y+5	; 0x05
    94dc:	3e 81       	ldd	r19, Y+6	; 0x06
    94de:	4f 81       	ldd	r20, Y+7	; 0x07
    94e0:	58 85       	ldd	r21, Y+8	; 0x08
    94e2:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
    94e6:	81 11       	cpse	r24, r1
    94e8:	10 e0       	ldi	r17, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/EEPROM.ino:72
}
    94ea:	81 2f       	mov	r24, r17
    94ec:	28 96       	adiw	r28, 0x08	; 8
    94ee:	0f b6       	in	r0, 0x3f	; 63
    94f0:	f8 94       	cli
    94f2:	de bf       	out	0x3e, r29	; 62
    94f4:	0f be       	out	0x3f, r0	; 63
    94f6:	cd bf       	out	0x3d, r28	; 61
    94f8:	df 91       	pop	r29
    94fa:	cf 91       	pop	r28
    94fc:	1f 91       	pop	r17
    94fe:	0f 91       	pop	r16
    9500:	ff 90       	pop	r15
    9502:	ef 90       	pop	r14
    9504:	df 90       	pop	r13
    9506:	cf 90       	pop	r12
    9508:	bf 90       	pop	r11
    950a:	af 90       	pop	r10
    950c:	08 95       	ret

0000950e <calibrateThermo(float)>:
calibrateThermo():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:36
	Atlas_EC.print(s);
	Atlas_pH.print(s);
 }


void calibrateThermo(float target) {
    950e:	cf 92       	push	r12
    9510:	df 92       	push	r13
    9512:	ef 92       	push	r14
    9514:	ff 92       	push	r15
    9516:	6b 01       	movw	r12, r22
    9518:	7c 01       	movw	r14, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:37
  K_temperature = max.readThermocoupleTemperature();
    951a:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <Adafruit_MAX31856::readThermocoupleTemperature() [clone .constprop.94]>
    951e:	9b 01       	movw	r18, r22
    9520:	ac 01       	movw	r20, r24
    9522:	20 93 10 02 	sts	0x0210, r18	; 0x800210 <K_temperature>
    9526:	30 93 11 02 	sts	0x0211, r19	; 0x800211 <K_temperature+0x1>
    952a:	40 93 12 02 	sts	0x0212, r20	; 0x800212 <K_temperature+0x2>
    952e:	50 93 13 02 	sts	0x0213, r21	; 0x800213 <K_temperature+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:38
  k_cal = target - K_temperature;
    9532:	c7 01       	movw	r24, r14
    9534:	b6 01       	movw	r22, r12
    9536:	0e 94 74 6a 	call	0xd4e8	; 0xd4e8 <__subsf3>
    953a:	ab 01       	movw	r20, r22
    953c:	bc 01       	movw	r22, r24
    953e:	40 93 60 09 	sts	0x0960, r20	; 0x800960 <k_cal>
    9542:	50 93 61 09 	sts	0x0961, r21	; 0x800961 <k_cal+0x1>
    9546:	60 93 62 09 	sts	0x0962, r22	; 0x800962 <k_cal+0x2>
    954a:	70 93 63 09 	sts	0x0963, r23	; 0x800963 <k_cal+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:39
  UpdateEEP(k_cal_addr, k_cal);
    954e:	82 e0       	ldi	r24, 0x02	; 2
    9550:	90 e0       	ldi	r25, 0x00	; 0
    9552:	0e 94 2e 4a 	call	0x945c	; 0x945c <bool UpdateEEP<float>(int, float)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:40
  lcd.setCursor(15, 3);
    9556:	63 e0       	ldi	r22, 0x03	; 3
    9558:	8f e0       	ldi	r24, 0x0F	; 15
    955a:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:41
  if (target == 25.00)	lcd.print("-S25.");
    955e:	20 e0       	ldi	r18, 0x00	; 0
    9560:	30 e0       	ldi	r19, 0x00	; 0
    9562:	48 ec       	ldi	r20, 0xC8	; 200
    9564:	51 e4       	ldi	r21, 0x41	; 65
    9566:	c7 01       	movw	r24, r14
    9568:	b6 01       	movw	r22, r12
    956a:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
    956e:	6d e9       	ldi	r22, 0x9D	; 157
    9570:	76 e0       	ldi	r23, 0x06	; 6
    9572:	88 23       	and	r24, r24
    9574:	11 f0       	breq	.+4      	; 0x957a <calibrateThermo(float)+0x6c>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:42
  else lcd.print("-User");
    9576:	63 ea       	ldi	r22, 0xA3	; 163
    9578:	76 e0       	ldi	r23, 0x06	; 6
    957a:	8b eb       	ldi	r24, 0xBB	; 187
    957c:	90 e1       	ldi	r25, 0x10	; 16
    957e:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:43
  lcd.setCursor(0, 1);
    9582:	61 e0       	ldi	r22, 0x01	; 1
    9584:	80 e0       	ldi	r24, 0x00	; 0
    9586:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:44
  lcd.print("K Cal to ");
    958a:	69 ea       	ldi	r22, 0xA9	; 169
    958c:	76 e0       	ldi	r23, 0x06	; 6
    958e:	8b eb       	ldi	r24, 0xBB	; 187
    9590:	90 e1       	ldi	r25, 0x10	; 16
    9592:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:45
  lcd_qFprint(k_cal, 2, 9, 1);
    9596:	c0 90 60 09 	lds	r12, 0x0960	; 0x800960 <k_cal>
    959a:	d0 90 61 09 	lds	r13, 0x0961	; 0x800961 <k_cal+0x1>
    959e:	e0 90 62 09 	lds	r14, 0x0962	; 0x800962 <k_cal+0x2>
    95a2:	f0 90 63 09 	lds	r15, 0x0963	; 0x800963 <k_cal+0x3>
lcd_qFprint():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:7
	lcd.setCursor(column, row);
	lcd.print(s);
}

void lcd_qFprint(float k, float num, int column, int row) {
	lcd.setCursor(column, row);
    95a6:	61 e0       	ldi	r22, 0x01	; 1
    95a8:	89 e0       	ldi	r24, 0x09	; 9
    95aa:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:8
	isnan(k) ? lcd.print("-----") : lcd.print(k, num);
    95ae:	a7 01       	movw	r20, r14
    95b0:	96 01       	movw	r18, r12
    95b2:	c7 01       	movw	r24, r14
    95b4:	b6 01       	movw	r22, r12
    95b6:	0e 94 e2 6b 	call	0xd7c4	; 0xd7c4 <__unordsf2>
    95ba:	88 23       	and	r24, r24
    95bc:	51 f0       	breq	.+20     	; 0x95d2 <calibrateThermo(float)+0xc4>
    95be:	6f ef       	ldi	r22, 0xFF	; 255
    95c0:	75 e0       	ldi	r23, 0x05	; 5
    95c2:	8b eb       	ldi	r24, 0xBB	; 187
    95c4:	90 e1       	ldi	r25, 0x10	; 16
calibrateThermo():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:47
  k_cal_btnEvt = true;
}
    95c6:	ff 90       	pop	r15
    95c8:	ef 90       	pop	r14
    95ca:	df 90       	pop	r13
    95cc:	cf 90       	pop	r12
lcd_qFprint():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/LCD.ino:8
    95ce:	0c 94 7d 28 	jmp	0x50fa	; 0x50fa <Print::print(char const*)>
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:111
    95d2:	22 e0       	ldi	r18, 0x02	; 2
    95d4:	b7 01       	movw	r22, r14
    95d6:	a6 01       	movw	r20, r12
    95d8:	8b eb       	ldi	r24, 0xBB	; 187
    95da:	90 e1       	ldi	r25, 0x10	; 16
calibrateThermo():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Thermocouple.ino:47
    95dc:	ff 90       	pop	r15
    95de:	ef 90       	pop	r14
    95e0:	df 90       	pop	r13
    95e2:	cf 90       	pop	r12
print():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Print.cpp:111
    95e4:	0c 94 58 26 	jmp	0x4cb0	; 0x4cb0 <Print::printFloat(double, unsigned char)>

000095e8 <SerialDecode(String)>:
SerialDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:2
bool SerialDecode(String strIn)
{
    95e8:	4f 92       	push	r4
    95ea:	5f 92       	push	r5
    95ec:	6f 92       	push	r6
    95ee:	7f 92       	push	r7
    95f0:	8f 92       	push	r8
    95f2:	9f 92       	push	r9
    95f4:	af 92       	push	r10
    95f6:	bf 92       	push	r11
    95f8:	cf 92       	push	r12
    95fa:	df 92       	push	r13
    95fc:	ef 92       	push	r14
    95fe:	ff 92       	push	r15
    9600:	0f 93       	push	r16
    9602:	1f 93       	push	r17
    9604:	cf 93       	push	r28
    9606:	df 93       	push	r29
    9608:	cd b7       	in	r28, 0x3d	; 61
    960a:	de b7       	in	r29, 0x3e	; 62
    960c:	62 97       	sbiw	r28, 0x12	; 18
    960e:	0f b6       	in	r0, 0x3f	; 63
    9610:	f8 94       	cli
    9612:	de bf       	out	0x3e, r29	; 62
    9614:	0f be       	out	0x3f, r0	; 63
    9616:	cd bf       	out	0x3d, r28	; 61
    9618:	5c 01       	movw	r10, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:6
	bool result = true;
	//Serial Command format = [command],[data]\r
	//First, check is there only contain one comma...
	int len = strIn.length() + 1;
    961a:	dc 01       	movw	r26, r24
    961c:	14 96       	adiw	r26, 0x04	; 4
    961e:	0d 91       	ld	r16, X+
    9620:	1c 91       	ld	r17, X
    9622:	0f 5f       	subi	r16, 0xFF	; 255
    9624:	1f 4f       	sbci	r17, 0xFF	; 255
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:8
	int comma_count = 0;
	for (int i = 0; i < len; i++)
    9626:	f1 2c       	mov	r15, r1
    9628:	e1 2c       	mov	r14, r1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:7
{
	bool result = true;
	//Serial Command format = [command],[data]\r
	//First, check is there only contain one comma...
	int len = strIn.length() + 1;
	int comma_count = 0;
    962a:	d1 2c       	mov	r13, r1
    962c:	c1 2c       	mov	r12, r1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:8
	for (int i = 0; i < len; i++)
    962e:	e0 16       	cp	r14, r16
    9630:	f1 06       	cpc	r15, r17
    9632:	5c f5       	brge	.+86     	; 0x968a <SerialDecode(String)+0xa2>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:10
	{
		if (strIn[i] == ',') comma_count++;
    9634:	b7 01       	movw	r22, r14
    9636:	c5 01       	movw	r24, r10
    9638:	0e 94 29 06 	call	0xc52	; 0xc52 <String::operator[](unsigned int)>
    963c:	fc 01       	movw	r30, r24
    963e:	80 81       	ld	r24, Z
    9640:	8c 32       	cpi	r24, 0x2C	; 44
    9642:	f9 f4       	brne	.+62     	; 0x9682 <SerialDecode(String)+0x9a>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:11
		if (comma_count > 1) return false;
    9644:	ca 94       	dec	r12
    9646:	cd 28       	or	r12, r13
    9648:	c9 f4       	brne	.+50     	; 0x967c <SerialDecode(String)+0x94>
    964a:	10 e0       	ldi	r17, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:160
			Serial.println("*failed");
			result = false;
	}
	free(str_arr);
	return result;
}
    964c:	81 2f       	mov	r24, r17
    964e:	62 96       	adiw	r28, 0x12	; 18
    9650:	0f b6       	in	r0, 0x3f	; 63
    9652:	f8 94       	cli
    9654:	de bf       	out	0x3e, r29	; 62
    9656:	0f be       	out	0x3f, r0	; 63
    9658:	cd bf       	out	0x3d, r28	; 61
    965a:	df 91       	pop	r29
    965c:	cf 91       	pop	r28
    965e:	1f 91       	pop	r17
    9660:	0f 91       	pop	r16
    9662:	ff 90       	pop	r15
    9664:	ef 90       	pop	r14
    9666:	df 90       	pop	r13
    9668:	cf 90       	pop	r12
    966a:	bf 90       	pop	r11
    966c:	af 90       	pop	r10
    966e:	9f 90       	pop	r9
    9670:	8f 90       	pop	r8
    9672:	7f 90       	pop	r7
    9674:	6f 90       	pop	r6
    9676:	5f 90       	pop	r5
    9678:	4f 90       	pop	r4
    967a:	08 95       	ret
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:11
	int len = strIn.length() + 1;
	int comma_count = 0;
	for (int i = 0; i < len; i++)
	{
		if (strIn[i] == ',') comma_count++;
		if (comma_count > 1) return false;
    967c:	cc 24       	eor	r12, r12
    967e:	c3 94       	inc	r12
    9680:	d1 2c       	mov	r13, r1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:8
	bool result = true;
	//Serial Command format = [command],[data]\r
	//First, check is there only contain one comma...
	int len = strIn.length() + 1;
	int comma_count = 0;
	for (int i = 0; i < len; i++)
    9682:	7f ef       	ldi	r23, 0xFF	; 255
    9684:	e7 1a       	sub	r14, r23
    9686:	f7 0a       	sbc	r15, r23
    9688:	d2 cf       	rjmp	.-92     	; 0x962e <SerialDecode(String)+0x46>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:13
	{
		if (strIn[i] == ',') comma_count++;
		if (comma_count > 1) return false;
	}
	if (comma_count == 0) return false;
    968a:	cd 28       	or	r12, r13
    968c:	f1 f2       	breq	.-68     	; 0x964a <SerialDecode(String)+0x62>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:19
	//bool returnvalue = true;

	//we make a char array, which size = 0
	char* str_arr = 0;
	//resize the array to fit the input serial command length
	str_arr = (char*)malloc(len * sizeof(char));
    968e:	c8 01       	movw	r24, r16
    9690:	0e 94 d8 62 	call	0xc5b0	; 0xc5b0 <malloc>
    9694:	6c 01       	movw	r12, r24
getBytes():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:539
	return buffer[index];
}

void String::getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index) const
{
	if (!bufsize || !buf) return;
    9696:	01 15       	cp	r16, r1
    9698:	11 05       	cpc	r17, r1
    969a:	39 f0       	breq	.+14     	; 0x96aa <SerialDecode(String)+0xc2>
    969c:	00 97       	sbiw	r24, 0x00	; 0
    969e:	29 f0       	breq	.+10     	; 0x96aa <SerialDecode(String)+0xc2>
    96a0:	a8 01       	movw	r20, r16
    96a2:	bc 01       	movw	r22, r24
    96a4:	c5 01       	movw	r24, r10
    96a6:	0e 94 48 25 	call	0x4a90	; 0x4a90 <String::getBytes(unsigned char*, unsigned int, unsigned int) const [clone .part.9] [clone .constprop.178]>
SerialDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:25
	//convert the string to a char array
	strIn.toCharArray(str_arr, len);
	//Separate the serial command to command and data by ','
	char* command;
	char* data;
	command = strtok(str_arr, ",");
    96aa:	6a ef       	ldi	r22, 0xFA	; 250
    96ac:	77 e0       	ldi	r23, 0x07	; 7
    96ae:	c6 01       	movw	r24, r12
    96b0:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    96b4:	5c 01       	movw	r10, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:26
	data = strtok(NULL, ",");
    96b6:	6a ef       	ldi	r22, 0xFA	; 250
    96b8:	77 e0       	ldi	r23, 0x07	; 7
    96ba:	90 e0       	ldi	r25, 0x00	; 0
    96bc:	80 e0       	ldi	r24, 0x00	; 0
    96be:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    96c2:	f8 2e       	mov	r15, r24
    96c4:	09 2f       	mov	r16, r25
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:28
	//Print out the separated data for checking
	if (DEBUG || debugMode) {
    96c6:	80 91 fa 09 	lds	r24, 0x09FA	; 0x8009fa <debugMode>
    96ca:	88 23       	and	r24, r24
    96cc:	b9 f0       	breq	.+46     	; 0x96fc <SerialDecode(String)+0x114>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:29
		Serial.print("INPUT COMMAND = ");
    96ce:	63 eb       	ldi	r22, 0xB3	; 179
    96d0:	76 e0       	ldi	r23, 0x06	; 6
    96d2:	82 e5       	ldi	r24, 0x52	; 82
    96d4:	9e e0       	ldi	r25, 0x0E	; 14
    96d6:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:30
		Serial.println(command);
    96da:	b5 01       	movw	r22, r10
    96dc:	82 e5       	ldi	r24, 0x52	; 82
    96de:	9e e0       	ldi	r25, 0x0E	; 14
    96e0:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:31
		Serial.print("DATA = ");
    96e4:	64 ec       	ldi	r22, 0xC4	; 196
    96e6:	76 e0       	ldi	r23, 0x06	; 6
    96e8:	82 e5       	ldi	r24, 0x52	; 82
    96ea:	9e e0       	ldi	r25, 0x0E	; 14
    96ec:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:32
		Serial.println(data);
    96f0:	6f 2d       	mov	r22, r15
    96f2:	70 2f       	mov	r23, r16
    96f4:	82 e5       	ldi	r24, 0x52	; 82
    96f6:	9e e0       	ldi	r25, 0x0E	; 14
    96f8:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:36
	}
	//resetRow1.start();
	//Start to judge the command and data
	switch (command[0])
    96fc:	d5 01       	movw	r26, r10
    96fe:	ec 91       	ld	r30, X
    9700:	e3 54       	subi	r30, 0x43	; 67
    9702:	e4 31       	cpi	r30, 0x14	; 20
    9704:	08 f0       	brcs	.+2      	; 0x9708 <SerialDecode(String)+0x120>
    9706:	b1 c1       	rjmp	.+866    	; 0x9a6a <SerialDecode(String)+0x482>
    9708:	0e 2e       	mov	r0, r30
    970a:	00 0c       	add	r0, r0
    970c:	ff 0b       	sbc	r31, r31
    970e:	88 27       	eor	r24, r24
    9710:	e3 57       	subi	r30, 0x73	; 115
    9712:	f4 4b       	sbci	r31, 0xB4	; 180
    9714:	8f 4f       	sbci	r24, 0xFF	; 255
    9716:	0c 94 2b 6c 	jmp	0xd856	; 0xd856 <__tablejump2__>
    971a:	bb 4b       	sbci	r27, 0xBB	; 187
    971c:	c6 4b       	sbci	r28, 0xB6	; 182
    971e:	35 4d       	sbci	r19, 0xD5	; 213
    9720:	35 4d       	sbci	r19, 0xD5	; 213
    9722:	d7 4b       	sbci	r29, 0xB7	; 183
    9724:	35 4d       	sbci	r19, 0xD5	; 213
    9726:	3c 4c       	sbci	r19, 0xCC	; 204
    9728:	35 4d       	sbci	r19, 0xD5	; 213
    972a:	5b 4c       	sbci	r21, 0xCB	; 203
    972c:	35 4d       	sbci	r19, 0xD5	; 213
    972e:	62 4c       	sbci	r22, 0xC2	; 194
    9730:	35 4d       	sbci	r19, 0xD5	; 213
    9732:	35 4d       	sbci	r19, 0xD5	; 213
    9734:	7e 4c       	sbci	r23, 0xCE	; 206
    9736:	35 4d       	sbci	r19, 0xD5	; 213
    9738:	35 4d       	sbci	r19, 0xD5	; 213
    973a:	ba 4c       	sbci	r27, 0xCA	; 202
    973c:	a1 4b       	sbci	r26, 0xB1	; 177
    973e:	35 4d       	sbci	r19, 0xD5	; 213
    9740:	12 4d       	sbci	r17, 0xD2	; 210
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:130
		///Time settimg command, format = T,[yyyy]-[MM]-[dd] [hh]:[mm]:[ss]\r
		case 'T'://no wrong data input protection
		{
			///we check is there 2 '-' and 2 ':'
			int hyphen = 0, colon = 0;
			for (int i = 0; i < strlen(data); i++)
    9742:	af 2d       	mov	r26, r15
    9744:	b0 2f       	mov	r27, r16
    9746:	fd 01       	movw	r30, r26
    9748:	01 90       	ld	r0, Z+
    974a:	00 20       	and	r0, r0
    974c:	e9 f7       	brne	.-6      	; 0x9748 <SerialDecode(String)+0x160>
    974e:	31 97       	sbiw	r30, 0x01	; 1
    9750:	ea 1b       	sub	r30, r26
    9752:	fb 0b       	sbc	r31, r27
    9754:	ea 0f       	add	r30, r26
    9756:	fb 1f       	adc	r31, r27
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:129
		break;
		///Time settimg command, format = T,[yyyy]-[MM]-[dd] [hh]:[mm]:[ss]\r
		case 'T'://no wrong data input protection
		{
			///we check is there 2 '-' and 2 ':'
			int hyphen = 0, colon = 0;
    9758:	90 e0       	ldi	r25, 0x00	; 0
    975a:	80 e0       	ldi	r24, 0x00	; 0
    975c:	30 e0       	ldi	r19, 0x00	; 0
    975e:	20 e0       	ldi	r18, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:130
			for (int i = 0; i < strlen(data); i++)
    9760:	ea 17       	cp	r30, r26
    9762:	fb 07       	cpc	r31, r27
    9764:	09 f4       	brne	.+2      	; 0x9768 <SerialDecode(String)+0x180>
    9766:	19 c1       	rjmp	.+562    	; 0x999a <SerialDecode(String)+0x3b2>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:132
			{
				if (data[i] == '-')	hyphen++;
    9768:	4d 91       	ld	r20, X+
    976a:	4d 32       	cpi	r20, 0x2D	; 45
    976c:	09 f0       	breq	.+2      	; 0x9770 <SerialDecode(String)+0x188>
    976e:	10 c1       	rjmp	.+544    	; 0x9990 <SerialDecode(String)+0x3a8>
    9770:	2f 5f       	subi	r18, 0xFF	; 255
    9772:	3f 4f       	sbci	r19, 0xFF	; 255
    9774:	f5 cf       	rjmp	.-22     	; 0x9760 <SerialDecode(String)+0x178>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:41
	switch (command[0])
	{
		///Set battery voltage slope
		case 'C':
		{
			float value = atof(data);
    9776:	8f 2d       	mov	r24, r15
    9778:	90 2f       	mov	r25, r16
    977a:	0e 94 fd 63 	call	0xc7fa	; 0xc7fa <atof>
    977e:	ab 01       	movw	r20, r22
    9780:	bc 01       	movw	r22, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:42
			UpdateEEP(voltage_slope_addr, value);
    9782:	84 e2       	ldi	r24, 0x24	; 36
    9784:	90 e0       	ldi	r25, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:150
			cVmin = strtok(data, "-");
			cVmax = strtok(NULL, "-");
			tempmin = atof(cVmin);
			tempmax = atof(cVmax);
			UpdateEEP(voltage_min_addr, tempmin);
			UpdateEEP(voltage_max_addr, tempmax);
    9786:	0e 94 2e 4a 	call	0x945c	; 0x945c <bool UpdateEEP<float>(int, float)>
    978a:	73 c0       	rjmp	.+230    	; 0x9872 <SerialDecode(String)+0x28a>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:50
		break;
		///Set ID, format = D,[ID]\r
		case 'D':
		{
			int temp = 0;
			int IDs = atoi(data);
    978c:	8f 2d       	mov	r24, r15
    978e:	90 2f       	mov	r25, r16
    9790:	0e 94 01 64 	call	0xc802	; 0xc802 <atoi>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:51
			UpdateEEP(IDAddress, IDs);
    9794:	bc 01       	movw	r22, r24
    9796:	90 e0       	ldi	r25, 0x00	; 0
    9798:	80 e0       	ldi	r24, 0x00	; 0
    979a:	0e 94 f9 49 	call	0x93f2	; 0x93f2 <bool UpdateEEP<int>(int, int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:52
			PrintEEPParameter();
    979e:	0e 94 7e 39 	call	0x72fc	; 0x72fc <PrintEEPParameter()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:53
			getFilename(filename);
    97a2:	0e 94 6b 25 	call	0x4ad6	; 0x4ad6 <getFilename(char*) [clone .constprop.135]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:54
			File_check_exists();
    97a6:	0e 94 1e 38 	call	0x703c	; 0x703c <File_check_exists()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:3
bool SerialDecode(String strIn)
{
	bool result = true;
    97aa:	11 e0       	ldi	r17, 0x01	; 1
    97ac:	a3 c0       	rjmp	.+326    	; 0x98f4 <SerialDecode(String)+0x30c>
setPGuardbystr():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:53
	//Separate the serial command to command and data by ';'
	char* chr_high;
	char* chr_low;
	char* chr_times;
	char* chr_mode;
	chr_low = strtok(strIn, ";");
    97ae:	6c ec       	ldi	r22, 0xCC	; 204
    97b0:	76 e0       	ldi	r23, 0x06	; 6
    97b2:	8f 2d       	mov	r24, r15
    97b4:	90 2f       	mov	r25, r16
    97b6:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    97ba:	5c 01       	movw	r10, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:54
	chr_high = strtok(NULL, ";");
    97bc:	6c ec       	ldi	r22, 0xCC	; 204
    97be:	76 e0       	ldi	r23, 0x06	; 6
    97c0:	90 e0       	ldi	r25, 0x00	; 0
    97c2:	80 e0       	ldi	r24, 0x00	; 0
    97c4:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    97c8:	4c 01       	movw	r8, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:55
	chr_times = strtok(NULL, ";");
    97ca:	6c ec       	ldi	r22, 0xCC	; 204
    97cc:	76 e0       	ldi	r23, 0x06	; 6
    97ce:	90 e0       	ldi	r25, 0x00	; 0
    97d0:	80 e0       	ldi	r24, 0x00	; 0
    97d2:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    97d6:	7c 01       	movw	r14, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:56
	chr_mode = strtok(NULL, ";");
    97d8:	6c ec       	ldi	r22, 0xCC	; 204
    97da:	76 e0       	ldi	r23, 0x06	; 6
    97dc:	90 e0       	ldi	r25, 0x00	; 0
    97de:	80 e0       	ldi	r24, 0x00	; 0
    97e0:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    97e4:	8c 01       	movw	r16, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:57
	pCO2_highP = atof(chr_high);
    97e6:	c4 01       	movw	r24, r8
    97e8:	0e 94 fd 63 	call	0xc7fa	; 0xc7fa <atof>
    97ec:	60 93 5b 09 	sts	0x095B, r22	; 0x80095b <pCO2_highP>
    97f0:	70 93 5c 09 	sts	0x095C, r23	; 0x80095c <pCO2_highP+0x1>
    97f4:	80 93 5d 09 	sts	0x095D, r24	; 0x80095d <pCO2_highP+0x2>
    97f8:	90 93 5e 09 	sts	0x095E, r25	; 0x80095e <pCO2_highP+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:58
	pCO2_lowP = atof(chr_low);
    97fc:	c5 01       	movw	r24, r10
    97fe:	0e 94 fd 63 	call	0xc7fa	; 0xc7fa <atof>
    9802:	4b 01       	movw	r8, r22
    9804:	5c 01       	movw	r10, r24
    9806:	80 92 57 09 	sts	0x0957, r8	; 0x800957 <pCO2_lowP>
    980a:	90 92 58 09 	sts	0x0958, r9	; 0x800958 <pCO2_lowP+0x1>
    980e:	a0 92 59 09 	sts	0x0959, r10	; 0x800959 <pCO2_lowP+0x2>
    9812:	b0 92 5a 09 	sts	0x095A, r11	; 0x80095a <pCO2_lowP+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:59
	pCO2_PSampleT = atoi(chr_times);
    9816:	c7 01       	movw	r24, r14
    9818:	0e 94 01 64 	call	0xc802	; 0xc802 <atoi>
    981c:	90 93 56 09 	sts	0x0956, r25	; 0x800956 <pCO2_PSampleT+0x1>
    9820:	80 93 55 09 	sts	0x0955, r24	; 0x800955 <pCO2_PSampleT>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:60
	pCO2_PRecoverMode = (bool)atoi(chr_mode);
    9824:	c8 01       	movw	r24, r16
    9826:	0e 94 01 64 	call	0xc802	; 0xc802 <atoi>
    982a:	21 e0       	ldi	r18, 0x01	; 1
    982c:	89 2b       	or	r24, r25
    982e:	09 f4       	brne	.+2      	; 0x9832 <SerialDecode(String)+0x24a>
    9830:	20 e0       	ldi	r18, 0x00	; 0
    9832:	20 93 54 09 	sts	0x0954, r18	; 0x800954 <pCO2_PRecoverMode>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:61
	UpdateEEP(pCO2_lowP_addr, pCO2_lowP);
    9836:	b5 01       	movw	r22, r10
    9838:	a4 01       	movw	r20, r8
    983a:	80 e5       	ldi	r24, 0x50	; 80
    983c:	90 e0       	ldi	r25, 0x00	; 0
    983e:	0e 94 2e 4a 	call	0x945c	; 0x945c <bool UpdateEEP<float>(int, float)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:62
	UpdateEEP(pCO2_highP_addr, pCO2_highP);
    9842:	40 91 5b 09 	lds	r20, 0x095B	; 0x80095b <pCO2_highP>
    9846:	50 91 5c 09 	lds	r21, 0x095C	; 0x80095c <pCO2_highP+0x1>
    984a:	60 91 5d 09 	lds	r22, 0x095D	; 0x80095d <pCO2_highP+0x2>
    984e:	70 91 5e 09 	lds	r23, 0x095E	; 0x80095e <pCO2_highP+0x3>
    9852:	86 e5       	ldi	r24, 0x56	; 86
    9854:	90 e0       	ldi	r25, 0x00	; 0
    9856:	0e 94 2e 4a 	call	0x945c	; 0x945c <bool UpdateEEP<float>(int, float)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:63
	UpdateEEP(pCO2_PSampleT_addr, pCO2_PSampleT);
    985a:	60 91 55 09 	lds	r22, 0x0955	; 0x800955 <pCO2_PSampleT>
    985e:	70 91 56 09 	lds	r23, 0x0956	; 0x800956 <pCO2_PSampleT+0x1>
    9862:	8c e5       	ldi	r24, 0x5C	; 92
    9864:	90 e0       	ldi	r25, 0x00	; 0
    9866:	0e 94 f9 49 	call	0x93f2	; 0x93f2 <bool UpdateEEP<int>(int, int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/BME280.ino:64
	UpdateEEP(pCO2_PRecoverMode_addr, pCO2_PRecoverMode);
    986a:	80 91 54 09 	lds	r24, 0x0954	; 0x800954 <pCO2_PRecoverMode>
    986e:	0e 94 85 49 	call	0x930a	; 0x930a <bool UpdateEEP<bool>(int, bool) [clone .constprop.51]>
SerialDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:151
			cVmax = strtok(NULL, "-");
			tempmin = atof(cVmin);
			tempmax = atof(cVmax);
			UpdateEEP(voltage_min_addr, tempmin);
			UpdateEEP(voltage_max_addr, tempmax);
			PrintEEPParameter();
    9872:	0e 94 7e 39 	call	0x72fc	; 0x72fc <PrintEEPParameter()>
    9876:	99 cf       	rjmp	.-206    	; 0x97aa <SerialDecode(String)+0x1c2>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:66
		}
		break;
		///Measurement Interval command, format = I,[sec]\r
		case 'I':
		{
			long new_interval = atoi(data) * 1000;
    9878:	8f 2d       	mov	r24, r15
    987a:	90 2f       	mov	r25, r16
    987c:	0e 94 01 64 	call	0xc802	; 0xc802 <atoi>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:67
			if (atoi(data) >= 10)
    9880:	8a 30       	cpi	r24, 0x0A	; 10
    9882:	91 05       	cpc	r25, r1
    9884:	84 f0       	brlt	.+32     	; 0x98a6 <SerialDecode(String)+0x2be>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:66
		}
		break;
		///Measurement Interval command, format = I,[sec]\r
		case 'I':
		{
			long new_interval = atoi(data) * 1000;
    9886:	28 ee       	ldi	r18, 0xE8	; 232
    9888:	33 e0       	ldi	r19, 0x03	; 3
    988a:	82 9f       	mul	r24, r18
    988c:	b0 01       	movw	r22, r0
    988e:	83 9f       	mul	r24, r19
    9890:	70 0d       	add	r23, r0
    9892:	92 9f       	mul	r25, r18
    9894:	70 0d       	add	r23, r0
    9896:	11 24       	eor	r1, r1
    9898:	07 2e       	mov	r0, r23
    989a:	00 0c       	add	r0, r0
    989c:	88 0b       	sbc	r24, r24
    989e:	99 0b       	sbc	r25, r25
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:69
			if (atoi(data) >= 10)
			{
				UpdateEEP(interval_addr, new_interval);
    98a0:	0e 94 ae 49 	call	0x935c	; 0x935c <bool UpdateEEP<long>(int, long) [clone .constprop.50]>
    98a4:	e6 cf       	rjmp	.-52     	; 0x9872 <SerialDecode(String)+0x28a>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:73
				PrintEEPParameter();
			}
			else {
				Serial.println("Wrong Interval Setting, Interval Should >= 10 sec");
    98a6:	6e ec       	ldi	r22, 0xCE	; 206
    98a8:	76 e0       	ldi	r23, 0x06	; 6
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:155
			UpdateEEP(voltage_max_addr, tempmax);
			PrintEEPParameter();
		}
		break;
		default:
			Serial.println("*failed");
    98aa:	82 e5       	ldi	r24, 0x52	; 82
    98ac:	9e e0       	ldi	r25, 0x0E	; 14
    98ae:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:113
				Serial.println("Power Saving Mode OFF");
				lcd.backlight();
			}
			else
			{
				result = false;
    98b2:	10 e0       	ldi	r17, 0x00	; 0
    98b4:	1f c0       	rjmp	.+62     	; 0x98f4 <SerialDecode(String)+0x30c>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:81
		}
		break;
		///Thermocouple calibration, format = K,[temperature]\r
		case 'K':
		{
			calibrateThermo(atof(data));
    98b6:	8f 2d       	mov	r24, r15
    98b8:	90 2f       	mov	r25, r16
    98ba:	0e 94 fd 63 	call	0xc7fa	; 0xc7fa <atof>
    98be:	0e 94 87 4a 	call	0x950e	; 0x950e <calibrateThermo(float)>
    98c2:	d7 cf       	rjmp	.-82     	; 0x9872 <SerialDecode(String)+0x28a>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:88
		}
		break;
		///Set pump speed, format = M,[value]\r
		case 'M':
		{
			int pwmvalue = atoi(data);
    98c4:	8f 2d       	mov	r24, r15
    98c6:	90 2f       	mov	r25, r16
    98c8:	0e 94 01 64 	call	0xc802	; 0xc802 <atoi>
    98cc:	7c 01       	movw	r14, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:89
			if (pwmvalue > 100 || pwmvalue < 0) result = false;
    98ce:	11 e0       	ldi	r17, 0x01	; 1
    98d0:	85 36       	cpi	r24, 0x65	; 101
    98d2:	91 05       	cpc	r25, r1
    98d4:	08 f0       	brcs	.+2      	; 0x98d8 <SerialDecode(String)+0x2f0>
    98d6:	10 e0       	ldi	r17, 0x00	; 0
updatePumpValue():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:11
}

void updatePumpValue(int value) {
	UpdateEEP(pumpPower_addr, value);
    98d8:	b7 01       	movw	r22, r14
    98da:	82 e1       	ldi	r24, 0x12	; 18
    98dc:	90 e0       	ldi	r25, 0x00	; 0
    98de:	0e 94 f9 49 	call	0x93f2	; 0x93f2 <bool UpdateEEP<int>(int, int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:12
	pumpPower = value;
    98e2:	f0 92 dd 09 	sts	0x09DD, r15	; 0x8009dd <pumpPower+0x1>
    98e6:	e0 92 dc 09 	sts	0x09DC, r14	; 0x8009dc <pumpPower>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:13
	PrintEEPParameter();
    98ea:	0e 94 7e 39 	call	0x72fc	; 0x72fc <PrintEEPParameter()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:14
	pumpControl(value);
    98ee:	c7 01       	movw	r24, r14
    98f0:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <pumpControl(int)>
SerialDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:158
		break;
		default:
			Serial.println("*failed");
			result = false;
	}
	free(str_arr);
    98f4:	c6 01       	movw	r24, r12
    98f6:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
    98fa:	a8 ce       	rjmp	.-688    	; 0x964c <SerialDecode(String)+0x64>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:96
		}
		break;
		///Power saving mode. format = P,[on(1)/off(0)]\r
		case 'P':
		{
			if (atoi(data) == 1)
    98fc:	8f 2d       	mov	r24, r15
    98fe:	90 2f       	mov	r25, r16
    9900:	0e 94 01 64 	call	0xc802	; 0xc802 <atoi>
    9904:	81 30       	cpi	r24, 0x01	; 1
    9906:	91 05       	cpc	r25, r1
    9908:	01 f5       	brne	.+64     	; 0x994a <SerialDecode(String)+0x362>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:98
			{
				UpdateEEP(power_addr, 1);
    990a:	61 e0       	ldi	r22, 0x01	; 1
    990c:	70 e0       	ldi	r23, 0x00	; 0
    990e:	8a e0       	ldi	r24, 0x0A	; 10
    9910:	90 e0       	ldi	r25, 0x00	; 0
    9912:	0e 94 f9 49 	call	0x93f2	; 0x93f2 <bool UpdateEEP<int>(int, int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:99
				PrintEEPParameter();
    9916:	0e 94 7e 39 	call	0x72fc	; 0x72fc <PrintEEPParameter()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:100
				lasttime_powersaving = millis();
    991a:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    991e:	60 93 ec 09 	sts	0x09EC, r22	; 0x8009ec <lasttime_powersaving>
    9922:	70 93 ed 09 	sts	0x09ED, r23	; 0x8009ed <lasttime_powersaving+0x1>
    9926:	80 93 ee 09 	sts	0x09EE, r24	; 0x8009ee <lasttime_powersaving+0x2>
    992a:	90 93 ef 09 	sts	0x09EF, r25	; 0x8009ef <lasttime_powersaving+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:101
				Serial.println("Power Saving Mode ON");
    992e:	60 e0       	ldi	r22, 0x00	; 0
    9930:	77 e0       	ldi	r23, 0x07	; 7
    9932:	82 e5       	ldi	r24, 0x52	; 82
    9934:	9e e0       	ldi	r25, 0x0E	; 14
    9936:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
noBacklight():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:219

// Turn the (optional) backlight off/on
void LiquidCrystal_I2C::noBacklight(void) {
	_backlightval=LCD_NOBACKLIGHT;
    993a:	10 92 c6 10 	sts	0x10C6, r1	; 0x8010c6 <lcd+0xb>
backlight():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:225
	expanderWrite(0);
}

void LiquidCrystal_I2C::backlight(void) {
	_backlightval=LCD_BACKLIGHT;
	expanderWrite(0);
    993e:	60 e0       	ldi	r22, 0x00	; 0
    9940:	8b eb       	ldi	r24, 0xBB	; 187
    9942:	90 e1       	ldi	r25, 0x10	; 16
    9944:	0e 94 46 1d 	call	0x3a8c	; 0x3a8c <LiquidCrystal_I2C::expanderWrite(unsigned char)>
    9948:	30 cf       	rjmp	.-416    	; 0x97aa <SerialDecode(String)+0x1c2>
SerialDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:104
				lcd.noBacklight();
			}
			else if (atoi(data) == 0)
    994a:	89 2b       	or	r24, r25
    994c:	09 f0       	breq	.+2      	; 0x9950 <SerialDecode(String)+0x368>
    994e:	b1 cf       	rjmp	.-158    	; 0x98b2 <SerialDecode(String)+0x2ca>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:106
			{
				UpdateEEP(power_addr, 0);
    9950:	70 e0       	ldi	r23, 0x00	; 0
    9952:	60 e0       	ldi	r22, 0x00	; 0
    9954:	8a e0       	ldi	r24, 0x0A	; 10
    9956:	90 e0       	ldi	r25, 0x00	; 0
    9958:	0e 94 f9 49 	call	0x93f2	; 0x93f2 <bool UpdateEEP<int>(int, int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:107
				PrintEEPParameter();
    995c:	0e 94 7e 39 	call	0x72fc	; 0x72fc <PrintEEPParameter()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:108
				Serial.println("Power Saving Mode OFF");
    9960:	65 e1       	ldi	r22, 0x15	; 21
    9962:	77 e0       	ldi	r23, 0x07	; 7
    9964:	82 e5       	ldi	r24, 0x52	; 82
    9966:	9e e0       	ldi	r25, 0x0E	; 14
    9968:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
backlight():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:224
	_backlightval=LCD_NOBACKLIGHT;
	expanderWrite(0);
}

void LiquidCrystal_I2C::backlight(void) {
	_backlightval=LCD_BACKLIGHT;
    996c:	88 e0       	ldi	r24, 0x08	; 8
    996e:	80 93 c6 10 	sts	0x10C6, r24	; 0x8010c6 <lcd+0xb>
    9972:	e5 cf       	rjmp	.-54     	; 0x993e <SerialDecode(String)+0x356>
SerialDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:120
		}
		break;
		///Set EC printing mode
		case 'S':
		{
			int value = atoi(data) % 2;
    9974:	8f 2d       	mov	r24, r15
    9976:	90 2f       	mov	r25, r16
    9978:	0e 94 01 64 	call	0xc802	; 0xc802 <atoi>
    997c:	62 e0       	ldi	r22, 0x02	; 2
    997e:	70 e0       	ldi	r23, 0x00	; 0
    9980:	0e 94 17 6c 	call	0xd82e	; 0xd82e <__divmodhi4>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:121
			UpdateEEP(ec_print_addr, value);
    9984:	bc 01       	movw	r22, r24
    9986:	88 e4       	ldi	r24, 0x48	; 72
    9988:	90 e0       	ldi	r25, 0x00	; 0
    998a:	0e 94 f9 49 	call	0x93f2	; 0x93f2 <bool UpdateEEP<int>(int, int)>
    998e:	71 cf       	rjmp	.-286    	; 0x9872 <SerialDecode(String)+0x28a>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:133
			///we check is there 2 '-' and 2 ':'
			int hyphen = 0, colon = 0;
			for (int i = 0; i < strlen(data); i++)
			{
				if (data[i] == '-')	hyphen++;
				if (data[i] == ':')	colon++;
    9990:	4a 33       	cpi	r20, 0x3A	; 58
    9992:	09 f0       	breq	.+2      	; 0x9996 <SerialDecode(String)+0x3ae>
    9994:	e5 ce       	rjmp	.-566    	; 0x9760 <SerialDecode(String)+0x178>
    9996:	01 96       	adiw	r24, 0x01	; 1
    9998:	e3 ce       	rjmp	.-570    	; 0x9760 <SerialDecode(String)+0x178>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:135
			}
			if (hyphen != 2 || colon != 2) result = false;
    999a:	22 30       	cpi	r18, 0x02	; 2
    999c:	31 05       	cpc	r19, r1
    999e:	19 f4       	brne	.+6      	; 0x99a6 <SerialDecode(String)+0x3be>
    99a0:	11 e0       	ldi	r17, 0x01	; 1
    99a2:	02 97       	sbiw	r24, 0x02	; 2
    99a4:	09 f0       	breq	.+2      	; 0x99a8 <SerialDecode(String)+0x3c0>
    99a6:	10 e0       	ldi	r17, 0x00	; 0
str2datetime():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:43

DateTime str2datetime(const char* data) {
	int _Year, _Month, _Day, _Hour, _Minute, _Second;
	sscanf(data, "%d-%d-%d %d:%d:%d", &_Year, &_Month, &_Day, &_Hour, &_Minute, &_Second);
    99a8:	ce 01       	movw	r24, r28
    99aa:	07 96       	adiw	r24, 0x07	; 7
    99ac:	9f 93       	push	r25
    99ae:	8f 93       	push	r24
    99b0:	02 96       	adiw	r24, 0x02	; 2
    99b2:	9f 93       	push	r25
    99b4:	8f 93       	push	r24
    99b6:	02 96       	adiw	r24, 0x02	; 2
    99b8:	9f 93       	push	r25
    99ba:	8f 93       	push	r24
    99bc:	02 96       	adiw	r24, 0x02	; 2
    99be:	9f 93       	push	r25
    99c0:	8f 93       	push	r24
    99c2:	02 96       	adiw	r24, 0x02	; 2
    99c4:	9f 93       	push	r25
    99c6:	8f 93       	push	r24
    99c8:	02 96       	adiw	r24, 0x02	; 2
    99ca:	9f 93       	push	r25
    99cc:	8f 93       	push	r24
    99ce:	8b e2       	ldi	r24, 0x2B	; 43
    99d0:	97 e0       	ldi	r25, 0x07	; 7
    99d2:	9f 93       	push	r25
    99d4:	8f 93       	push	r24
    99d6:	0f 93       	push	r16
    99d8:	ff 92       	push	r15
    99da:	0e 94 0e 6f 	call	0xde1c	; 0xde1c <sscanf>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:44
	DateTime value = DateTime(_Year, _Month, _Day, _Hour, _Minute, _Second);
    99de:	2f 81       	ldd	r18, Y+7	; 0x07
    99e0:	39 85       	ldd	r19, Y+9	; 0x09
    99e2:	4b 85       	ldd	r20, Y+11	; 0x0b
    99e4:	5d 85       	ldd	r21, Y+13	; 0x0d
    99e6:	6f 85       	ldd	r22, Y+15	; 0x0f
    99e8:	89 89       	ldd	r24, Y+17	; 0x11
    99ea:	9a 89       	ldd	r25, Y+18	; 0x12
__base_ctor ():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:225
    @param hour,min,sec Hour (0--23), minute (0--59) and second (0--59).
*/
/**************************************************************************/
DateTime::DateTime(uint16_t year, uint8_t month, uint8_t day, uint8_t hour,
                   uint8_t min, uint8_t sec) {
  if (year >= 2000U)
    99ec:	0f b6       	in	r0, 0x3f	; 63
    99ee:	f8 94       	cli
    99f0:	de bf       	out	0x3e, r29	; 62
    99f2:	0f be       	out	0x3f, r0	; 63
    99f4:	cd bf       	out	0x3d, r28	; 61
    99f6:	80 3d       	cpi	r24, 0xD0	; 208
    99f8:	f7 e0       	ldi	r31, 0x07	; 7
    99fa:	9f 07       	cpc	r25, r31
    99fc:	10 f0       	brcs	.+4      	; 0x9a02 <SerialDecode(String)+0x41a>
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:226
    year -= 2000U;
    99fe:	80 5d       	subi	r24, 0xD0	; 208
    9a00:	97 40       	sbci	r25, 0x07	; 7
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:227
  yOff = year;
    9a02:	89 83       	std	Y+1, r24	; 0x01
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:228
  m = month;
    9a04:	6a 83       	std	Y+2, r22	; 0x02
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:229
  d = day;
    9a06:	5b 83       	std	Y+3, r21	; 0x03
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:230
  hh = hour;
    9a08:	4c 83       	std	Y+4, r20	; 0x04
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:231
  mm = min;
    9a0a:	3d 83       	std	Y+5, r19	; 0x05
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:232
  ss = sec;
    9a0c:	2e 83       	std	Y+6, r18	; 0x06
SerialDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:136
			RTC.adjust(str2datetime(data));
    9a0e:	ce 01       	movw	r24, r28
    9a10:	01 96       	adiw	r24, 0x01	; 1
    9a12:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <RTC_DS3231::adjust(DateTime const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:137
			Serial.println("Time Adjust Success");
    9a16:	6d e3       	ldi	r22, 0x3D	; 61
    9a18:	77 e0       	ldi	r23, 0x07	; 7
    9a1a:	82 e5       	ldi	r24, 0x52	; 82
    9a1c:	9e e0       	ldi	r25, 0x0E	; 14
    9a1e:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
    9a22:	68 cf       	rjmp	.-304    	; 0x98f4 <SerialDecode(String)+0x30c>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:145
		///Set min and max voltage for input, formate = V,[min]-[max]\r
		case 'V':
		{
			float tempmin, tempmax;
			char *cVmin, *cVmax;
			cVmin = strtok(data, "-");
    9a24:	6b e7       	ldi	r22, 0x7B	; 123
    9a26:	75 e0       	ldi	r23, 0x05	; 5
    9a28:	8f 2d       	mov	r24, r15
    9a2a:	90 2f       	mov	r25, r16
    9a2c:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    9a30:	7c 01       	movw	r14, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:146
			cVmax = strtok(NULL, "-");
    9a32:	6b e7       	ldi	r22, 0x7B	; 123
    9a34:	75 e0       	ldi	r23, 0x05	; 5
    9a36:	90 e0       	ldi	r25, 0x00	; 0
    9a38:	80 e0       	ldi	r24, 0x00	; 0
    9a3a:	0e 94 56 64 	call	0xc8ac	; 0xc8ac <strtok>
    9a3e:	8c 01       	movw	r16, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:147
			tempmin = atof(cVmin);
    9a40:	c7 01       	movw	r24, r14
    9a42:	0e 94 fd 63 	call	0xc7fa	; 0xc7fa <atof>
    9a46:	2b 01       	movw	r4, r22
    9a48:	3c 01       	movw	r6, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:148
			tempmax = atof(cVmax);
    9a4a:	c8 01       	movw	r24, r16
    9a4c:	0e 94 fd 63 	call	0xc7fa	; 0xc7fa <atof>
    9a50:	4b 01       	movw	r8, r22
    9a52:	5c 01       	movw	r10, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:149
			UpdateEEP(voltage_min_addr, tempmin);
    9a54:	b3 01       	movw	r22, r6
    9a56:	a2 01       	movw	r20, r4
    9a58:	88 e1       	ldi	r24, 0x18	; 24
    9a5a:	90 e0       	ldi	r25, 0x00	; 0
    9a5c:	0e 94 2e 4a 	call	0x945c	; 0x945c <bool UpdateEEP<float>(int, float)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:150
			UpdateEEP(voltage_max_addr, tempmax);
    9a60:	b5 01       	movw	r22, r10
    9a62:	a4 01       	movw	r20, r8
    9a64:	8e e1       	ldi	r24, 0x1E	; 30
    9a66:	90 e0       	ldi	r25, 0x00	; 0
    9a68:	8e ce       	rjmp	.-740    	; 0x9786 <SerialDecode(String)+0x19e>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SerialDecode.ino:155
			PrintEEPParameter();
		}
		break;
		default:
			Serial.println("*failed");
    9a6a:	61 e5       	ldi	r22, 0x51	; 81
    9a6c:	77 e0       	ldi	r23, 0x07	; 7
    9a6e:	1d cf       	rjmp	.-454    	; 0x98aa <SerialDecode(String)+0x2c2>

00009a70 <__vector_13>:
__vector_13():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:539
#endif


#ifdef USE_TIMER2
ISR(TIMER2_COMPA_vect)
{
    9a70:	1f 92       	push	r1
    9a72:	0f 92       	push	r0
    9a74:	0f b6       	in	r0, 0x3f	; 63
    9a76:	0f 92       	push	r0
    9a78:	11 24       	eor	r1, r1
    9a7a:	0b b6       	in	r0, 0x3b	; 59
    9a7c:	0f 92       	push	r0
    9a7e:	2f 93       	push	r18
    9a80:	3f 93       	push	r19
    9a82:	4f 93       	push	r20
    9a84:	5f 93       	push	r21
    9a86:	6f 93       	push	r22
    9a88:	7f 93       	push	r23
    9a8a:	8f 93       	push	r24
    9a8c:	9f 93       	push	r25
    9a8e:	af 93       	push	r26
    9a90:	bf 93       	push	r27
    9a92:	ef 93       	push	r30
    9a94:	ff 93       	push	r31
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:541

  if (timer2_toggle_count != 0)
    9a96:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <timer2_toggle_count>
    9a9a:	90 91 12 0c 	lds	r25, 0x0C12	; 0x800c12 <timer2_toggle_count+0x1>
    9a9e:	a0 91 13 0c 	lds	r26, 0x0C13	; 0x800c13 <timer2_toggle_count+0x2>
    9aa2:	b0 91 14 0c 	lds	r27, 0x0C14	; 0x800c14 <timer2_toggle_count+0x3>
    9aa6:	89 2b       	or	r24, r25
    9aa8:	8a 2b       	or	r24, r26
    9aaa:	8b 2b       	or	r24, r27
    9aac:	e1 f1       	breq	.+120    	; 0x9b26 <__vector_13+0xb6>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:544
  {
    // toggle the pin
    *timer2_pin_port ^= timer2_pin_mask;
    9aae:	90 91 00 0c 	lds	r25, 0x0C00	; 0x800c00 <timer2_pin_mask>
    9ab2:	e0 91 01 0c 	lds	r30, 0x0C01	; 0x800c01 <timer2_pin_port>
    9ab6:	f0 91 02 0c 	lds	r31, 0x0C02	; 0x800c02 <timer2_pin_port+0x1>
    9aba:	80 81       	ld	r24, Z
    9abc:	89 27       	eor	r24, r25
    9abe:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:546

    if (timer2_toggle_count > 0)
    9ac0:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <timer2_toggle_count>
    9ac4:	90 91 12 0c 	lds	r25, 0x0C12	; 0x800c12 <timer2_toggle_count+0x1>
    9ac8:	a0 91 13 0c 	lds	r26, 0x0C13	; 0x800c13 <timer2_toggle_count+0x2>
    9acc:	b0 91 14 0c 	lds	r27, 0x0C14	; 0x800c14 <timer2_toggle_count+0x3>
    9ad0:	18 16       	cp	r1, r24
    9ad2:	19 06       	cpc	r1, r25
    9ad4:	1a 06       	cpc	r1, r26
    9ad6:	1b 06       	cpc	r1, r27
    9ad8:	9c f4       	brge	.+38     	; 0x9b00 <__vector_13+0x90>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:547
      timer2_toggle_count--;
    9ada:	80 91 11 0c 	lds	r24, 0x0C11	; 0x800c11 <timer2_toggle_count>
    9ade:	90 91 12 0c 	lds	r25, 0x0C12	; 0x800c12 <timer2_toggle_count+0x1>
    9ae2:	a0 91 13 0c 	lds	r26, 0x0C13	; 0x800c13 <timer2_toggle_count+0x2>
    9ae6:	b0 91 14 0c 	lds	r27, 0x0C14	; 0x800c14 <timer2_toggle_count+0x3>
    9aea:	01 97       	sbiw	r24, 0x01	; 1
    9aec:	a1 09       	sbc	r26, r1
    9aee:	b1 09       	sbc	r27, r1
    9af0:	80 93 11 0c 	sts	0x0C11, r24	; 0x800c11 <timer2_toggle_count>
    9af4:	90 93 12 0c 	sts	0x0C12, r25	; 0x800c12 <timer2_toggle_count+0x1>
    9af8:	a0 93 13 0c 	sts	0x0C13, r26	; 0x800c13 <timer2_toggle_count+0x2>
    9afc:	b0 93 14 0c 	sts	0x0C14, r27	; 0x800c14 <timer2_toggle_count+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:558
    // XXX: this assumes timer 2 is always the first one used.
    noTone(tone_pins[0]);
//    disableTimer(2);
//    *timer2_pin_port &= ~(timer2_pin_mask);  // keep pin low after stop
  }
}
    9b00:	ff 91       	pop	r31
    9b02:	ef 91       	pop	r30
    9b04:	bf 91       	pop	r27
    9b06:	af 91       	pop	r26
    9b08:	9f 91       	pop	r25
    9b0a:	8f 91       	pop	r24
    9b0c:	7f 91       	pop	r23
    9b0e:	6f 91       	pop	r22
    9b10:	5f 91       	pop	r21
    9b12:	4f 91       	pop	r20
    9b14:	3f 91       	pop	r19
    9b16:	2f 91       	pop	r18
    9b18:	0f 90       	pop	r0
    9b1a:	0b be       	out	0x3b, r0	; 59
    9b1c:	0f 90       	pop	r0
    9b1e:	0f be       	out	0x3f, r0	; 63
    9b20:	0f 90       	pop	r0
    9b22:	1f 90       	pop	r1
    9b24:	18 95       	reti
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:554
  else
  {
    // need to call noTone() so that the tone_pins[] entry is reset, so the
    // timer gets initialized next time we call tone().
    // XXX: this assumes timer 2 is always the first one used.
    noTone(tone_pins[0]);
    9b26:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <tone_pins>
noTone():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:486
{
  int8_t _timer = -1;
  
  for (int i = 0; i < AVAILABLE_TONE_PINS; i++) {
    if (tone_pins[i] == _pin) {
      _timer = pgm_read_byte(tone_pin_to_timer_PGM + i);
    9b2a:	ef e7       	ldi	r30, 0x7F	; 127
    9b2c:	f6 e0       	ldi	r31, 0x06	; 6
    9b2e:	e4 91       	lpm	r30, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:487
      tone_pins[i] = 255;
    9b30:	9f ef       	ldi	r25, 0xFF	; 255
    9b32:	90 93 8d 02 	sts	0x028D, r25	; 0x80028d <tone_pins>
disableTimer():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:428
// XXX: this function only works properly for timer 2 (the only one we use
// currently).  for the others, it should end the tone, but won't restore
// proper PWM functionality for the timer.
void disableTimer(uint8_t _timer)
{
  switch (_timer)
    9b36:	e2 30       	cpi	r30, 0x02	; 2
    9b38:	e9 f0       	breq	.+58     	; 0x9b74 <__vector_13+0x104>
    9b3a:	40 f4       	brcc	.+16     	; 0x9b4c <__vector_13+0xdc>
    9b3c:	ee 23       	and	r30, r30
    9b3e:	89 f0       	breq	.+34     	; 0x9b62 <__vector_13+0xf2>
    9b40:	e1 30       	cpi	r30, 0x01	; 1
    9b42:	91 f0       	breq	.+36     	; 0x9b68 <__vector_13+0xf8>
noTone():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:494
    }
  }
  
  disableTimer(_timer);

  digitalWrite(_pin, 0);
    9b44:	60 e0       	ldi	r22, 0x00	; 0
    9b46:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
    9b4a:	da cf       	rjmp	.-76     	; 0x9b00 <__vector_13+0x90>
disableTimer():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:428
// XXX: this function only works properly for timer 2 (the only one we use
// currently).  for the others, it should end the tone, but won't restore
// proper PWM functionality for the timer.
void disableTimer(uint8_t _timer)
{
  switch (_timer)
    9b4c:	e4 30       	cpi	r30, 0x04	; 4
    9b4e:	49 f1       	breq	.+82     	; 0x9ba2 <__vector_13+0x132>
    9b50:	10 f1       	brcs	.+68     	; 0x9b96 <__vector_13+0x126>
    9b52:	e5 30       	cpi	r30, 0x05	; 5
    9b54:	b9 f7       	brne	.-18     	; 0x9b44 <__vector_13+0xd4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:473
      break;
#endif

#if defined(TIMSK5) && defined(OCIE5A)
    case 5:
      bitWrite(TIMSK5, OCIE5A, 0);
    9b56:	90 91 73 00 	lds	r25, 0x0073	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
    9b5a:	9d 7f       	andi	r25, 0xFD	; 253
    9b5c:	90 93 73 00 	sts	0x0073, r25	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
    9b60:	f1 cf       	rjmp	.-30     	; 0x9b44 <__vector_13+0xd4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:432
{
  switch (_timer)
  {
    case 0:
      #if defined(TIMSK0)
        TIMSK0 = 0;
    9b62:	10 92 6e 00 	sts	0x006E, r1	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    9b66:	ee cf       	rjmp	.-36     	; 0x9b44 <__vector_13+0xd4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:440
      #endif
      break;

#if defined(TIMSK1) && defined(OCIE1A)
    case 1:
      bitWrite(TIMSK1, OCIE1A, 0);
    9b68:	90 91 6f 00 	lds	r25, 0x006F	; 0x80006f <__TEXT_REGION_LENGTH__+0x70006f>
    9b6c:	9d 7f       	andi	r25, 0xFD	; 253
    9b6e:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <__TEXT_REGION_LENGTH__+0x70006f>
    9b72:	e8 cf       	rjmp	.-48     	; 0x9b44 <__vector_13+0xd4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:446
      break;
#endif

    case 2:
      #if defined(TIMSK2) && defined(OCIE2A)
        bitWrite(TIMSK2, OCIE2A, 0); // disable interrupt
    9b74:	90 91 70 00 	lds	r25, 0x0070	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
    9b78:	9d 7f       	andi	r25, 0xFD	; 253
    9b7a:	90 93 70 00 	sts	0x0070, r25	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:449
      #endif
      #if defined(TCCR2A) && defined(WGM20)
        TCCR2A = (1 << WGM20);
    9b7e:	91 e0       	ldi	r25, 0x01	; 1
    9b80:	90 93 b0 00 	sts	0x00B0, r25	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:452
      #endif
      #if defined(TCCR2B) && defined(CS22)
        TCCR2B = (TCCR2B & 0b11111000) | (1 << CS22);
    9b84:	90 91 b1 00 	lds	r25, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    9b88:	98 7f       	andi	r25, 0xF8	; 248
    9b8a:	94 60       	ori	r25, 0x04	; 4
    9b8c:	90 93 b1 00 	sts	0x00B1, r25	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:455
      #endif
      #if defined(OCR2A)
        OCR2A = 0;
    9b90:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7000b3>
    9b94:	d7 cf       	rjmp	.-82     	; 0x9b44 <__vector_13+0xd4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:461
      #endif
      break;

#if defined(TIMSK3) && defined(OCIE3A)
    case 3:
      bitWrite(TIMSK3, OCIE3A, 0);
    9b96:	90 91 71 00 	lds	r25, 0x0071	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
    9b9a:	9d 7f       	andi	r25, 0xFD	; 253
    9b9c:	90 93 71 00 	sts	0x0071, r25	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
    9ba0:	d1 cf       	rjmp	.-94     	; 0x9b44 <__vector_13+0xd4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/Tone.cpp:467
      break;
#endif

#if defined(TIMSK4) && defined(OCIE4A)
    case 4:
      bitWrite(TIMSK4, OCIE4A, 0);
    9ba2:	90 91 72 00 	lds	r25, 0x0072	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
    9ba6:	9d 7f       	andi	r25, 0xFD	; 253
    9ba8:	90 93 72 00 	sts	0x0072, r25	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
    9bac:	cb cf       	rjmp	.-106    	; 0x9b44 <__vector_13+0xd4>

00009bae <__vector_55>:
__vector_55():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial3.cpp:45
{
  Serial3._rx_complete_irq();
}

ISR(USART3_UDRE_vect)
{
    9bae:	1f 92       	push	r1
    9bb0:	0f 92       	push	r0
    9bb2:	0f b6       	in	r0, 0x3f	; 63
    9bb4:	0f 92       	push	r0
    9bb6:	11 24       	eor	r1, r1
    9bb8:	0b b6       	in	r0, 0x3b	; 59
    9bba:	0f 92       	push	r0
    9bbc:	2f 93       	push	r18
    9bbe:	3f 93       	push	r19
    9bc0:	4f 93       	push	r20
    9bc2:	5f 93       	push	r21
    9bc4:	6f 93       	push	r22
    9bc6:	7f 93       	push	r23
    9bc8:	8f 93       	push	r24
    9bca:	9f 93       	push	r25
    9bcc:	af 93       	push	r26
    9bce:	bf 93       	push	r27
    9bd0:	ef 93       	push	r30
    9bd2:	ff 93       	push	r31
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial3.cpp:46
  Serial3._tx_udr_empty_irq();
    9bd4:	8b e7       	ldi	r24, 0x7B	; 123
    9bd6:	9c e0       	ldi	r25, 0x0C	; 12
    9bd8:	0e 94 20 07 	call	0xe40	; 0xe40 <HardwareSerial::_tx_udr_empty_irq()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial3.cpp:47
}
    9bdc:	ff 91       	pop	r31
    9bde:	ef 91       	pop	r30
    9be0:	bf 91       	pop	r27
    9be2:	af 91       	pop	r26
    9be4:	9f 91       	pop	r25
    9be6:	8f 91       	pop	r24
    9be8:	7f 91       	pop	r23
    9bea:	6f 91       	pop	r22
    9bec:	5f 91       	pop	r21
    9bee:	4f 91       	pop	r20
    9bf0:	3f 91       	pop	r19
    9bf2:	2f 91       	pop	r18
    9bf4:	0f 90       	pop	r0
    9bf6:	0b be       	out	0x3b, r0	; 59
    9bf8:	0f 90       	pop	r0
    9bfa:	0f be       	out	0x3f, r0	; 63
    9bfc:	0f 90       	pop	r0
    9bfe:	1f 90       	pop	r1
    9c00:	18 95       	reti

00009c02 <__vector_54>:
__vector_54():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial3.cpp:40
// first place.

#if defined(HAVE_HWSERIAL3)

ISR(USART3_RX_vect)
{
    9c02:	1f 92       	push	r1
    9c04:	0f 92       	push	r0
    9c06:	0f b6       	in	r0, 0x3f	; 63
    9c08:	0f 92       	push	r0
    9c0a:	11 24       	eor	r1, r1
    9c0c:	0b b6       	in	r0, 0x3b	; 59
    9c0e:	0f 92       	push	r0
    9c10:	2f 93       	push	r18
    9c12:	3f 93       	push	r19
    9c14:	4f 93       	push	r20
    9c16:	5f 93       	push	r21
    9c18:	6f 93       	push	r22
    9c1a:	7f 93       	push	r23
    9c1c:	8f 93       	push	r24
    9c1e:	9f 93       	push	r25
    9c20:	af 93       	push	r26
    9c22:	bf 93       	push	r27
    9c24:	ef 93       	push	r30
    9c26:	ff 93       	push	r31
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial3.cpp:41
  Serial3._rx_complete_irq();
    9c28:	8b e7       	ldi	r24, 0x7B	; 123
    9c2a:	9c e0       	ldi	r25, 0x0C	; 12
    9c2c:	0e 94 a2 06 	call	0xd44	; 0xd44 <HardwareSerial::_rx_complete_irq()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial3.cpp:42
}
    9c30:	ff 91       	pop	r31
    9c32:	ef 91       	pop	r30
    9c34:	bf 91       	pop	r27
    9c36:	af 91       	pop	r26
    9c38:	9f 91       	pop	r25
    9c3a:	8f 91       	pop	r24
    9c3c:	7f 91       	pop	r23
    9c3e:	6f 91       	pop	r22
    9c40:	5f 91       	pop	r21
    9c42:	4f 91       	pop	r20
    9c44:	3f 91       	pop	r19
    9c46:	2f 91       	pop	r18
    9c48:	0f 90       	pop	r0
    9c4a:	0b be       	out	0x3b, r0	; 59
    9c4c:	0f 90       	pop	r0
    9c4e:	0f be       	out	0x3f, r0	; 63
    9c50:	0f 90       	pop	r0
    9c52:	1f 90       	pop	r1
    9c54:	18 95       	reti

00009c56 <__vector_52>:
__vector_52():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial2.cpp:45
{
  Serial2._rx_complete_irq();
}

ISR(USART2_UDRE_vect)
{
    9c56:	1f 92       	push	r1
    9c58:	0f 92       	push	r0
    9c5a:	0f b6       	in	r0, 0x3f	; 63
    9c5c:	0f 92       	push	r0
    9c5e:	11 24       	eor	r1, r1
    9c60:	0b b6       	in	r0, 0x3b	; 59
    9c62:	0f 92       	push	r0
    9c64:	2f 93       	push	r18
    9c66:	3f 93       	push	r19
    9c68:	4f 93       	push	r20
    9c6a:	5f 93       	push	r21
    9c6c:	6f 93       	push	r22
    9c6e:	7f 93       	push	r23
    9c70:	8f 93       	push	r24
    9c72:	9f 93       	push	r25
    9c74:	af 93       	push	r26
    9c76:	bf 93       	push	r27
    9c78:	ef 93       	push	r30
    9c7a:	ff 93       	push	r31
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial2.cpp:46
  Serial2._tx_udr_empty_irq();
    9c7c:	88 e1       	ldi	r24, 0x18	; 24
    9c7e:	9d e0       	ldi	r25, 0x0D	; 13
    9c80:	0e 94 20 07 	call	0xe40	; 0xe40 <HardwareSerial::_tx_udr_empty_irq()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial2.cpp:47
}
    9c84:	ff 91       	pop	r31
    9c86:	ef 91       	pop	r30
    9c88:	bf 91       	pop	r27
    9c8a:	af 91       	pop	r26
    9c8c:	9f 91       	pop	r25
    9c8e:	8f 91       	pop	r24
    9c90:	7f 91       	pop	r23
    9c92:	6f 91       	pop	r22
    9c94:	5f 91       	pop	r21
    9c96:	4f 91       	pop	r20
    9c98:	3f 91       	pop	r19
    9c9a:	2f 91       	pop	r18
    9c9c:	0f 90       	pop	r0
    9c9e:	0b be       	out	0x3b, r0	; 59
    9ca0:	0f 90       	pop	r0
    9ca2:	0f be       	out	0x3f, r0	; 63
    9ca4:	0f 90       	pop	r0
    9ca6:	1f 90       	pop	r1
    9ca8:	18 95       	reti

00009caa <__vector_51>:
__vector_51():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial2.cpp:40
// first place.

#if defined(HAVE_HWSERIAL2)

ISR(USART2_RX_vect)
{
    9caa:	1f 92       	push	r1
    9cac:	0f 92       	push	r0
    9cae:	0f b6       	in	r0, 0x3f	; 63
    9cb0:	0f 92       	push	r0
    9cb2:	11 24       	eor	r1, r1
    9cb4:	0b b6       	in	r0, 0x3b	; 59
    9cb6:	0f 92       	push	r0
    9cb8:	2f 93       	push	r18
    9cba:	3f 93       	push	r19
    9cbc:	4f 93       	push	r20
    9cbe:	5f 93       	push	r21
    9cc0:	6f 93       	push	r22
    9cc2:	7f 93       	push	r23
    9cc4:	8f 93       	push	r24
    9cc6:	9f 93       	push	r25
    9cc8:	af 93       	push	r26
    9cca:	bf 93       	push	r27
    9ccc:	ef 93       	push	r30
    9cce:	ff 93       	push	r31
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial2.cpp:41
  Serial2._rx_complete_irq();
    9cd0:	88 e1       	ldi	r24, 0x18	; 24
    9cd2:	9d e0       	ldi	r25, 0x0D	; 13
    9cd4:	0e 94 a2 06 	call	0xd44	; 0xd44 <HardwareSerial::_rx_complete_irq()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial2.cpp:42
}
    9cd8:	ff 91       	pop	r31
    9cda:	ef 91       	pop	r30
    9cdc:	bf 91       	pop	r27
    9cde:	af 91       	pop	r26
    9ce0:	9f 91       	pop	r25
    9ce2:	8f 91       	pop	r24
    9ce4:	7f 91       	pop	r23
    9ce6:	6f 91       	pop	r22
    9ce8:	5f 91       	pop	r21
    9cea:	4f 91       	pop	r20
    9cec:	3f 91       	pop	r19
    9cee:	2f 91       	pop	r18
    9cf0:	0f 90       	pop	r0
    9cf2:	0b be       	out	0x3b, r0	; 59
    9cf4:	0f 90       	pop	r0
    9cf6:	0f be       	out	0x3f, r0	; 63
    9cf8:	0f 90       	pop	r0
    9cfa:	1f 90       	pop	r1
    9cfc:	18 95       	reti

00009cfe <__vector_37>:
__vector_37():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial1.cpp:57
#elif defined(USART1_UDRE_vect)
ISR(USART1_UDRE_vect)
#else
#error "Don't know what the Data Register Empty vector is called for Serial1"
#endif
{
    9cfe:	1f 92       	push	r1
    9d00:	0f 92       	push	r0
    9d02:	0f b6       	in	r0, 0x3f	; 63
    9d04:	0f 92       	push	r0
    9d06:	11 24       	eor	r1, r1
    9d08:	0b b6       	in	r0, 0x3b	; 59
    9d0a:	0f 92       	push	r0
    9d0c:	2f 93       	push	r18
    9d0e:	3f 93       	push	r19
    9d10:	4f 93       	push	r20
    9d12:	5f 93       	push	r21
    9d14:	6f 93       	push	r22
    9d16:	7f 93       	push	r23
    9d18:	8f 93       	push	r24
    9d1a:	9f 93       	push	r25
    9d1c:	af 93       	push	r26
    9d1e:	bf 93       	push	r27
    9d20:	ef 93       	push	r30
    9d22:	ff 93       	push	r31
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial1.cpp:58
  Serial1._tx_udr_empty_irq();
    9d24:	85 eb       	ldi	r24, 0xB5	; 181
    9d26:	9d e0       	ldi	r25, 0x0D	; 13
    9d28:	0e 94 20 07 	call	0xe40	; 0xe40 <HardwareSerial::_tx_udr_empty_irq()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial1.cpp:59
}
    9d2c:	ff 91       	pop	r31
    9d2e:	ef 91       	pop	r30
    9d30:	bf 91       	pop	r27
    9d32:	af 91       	pop	r26
    9d34:	9f 91       	pop	r25
    9d36:	8f 91       	pop	r24
    9d38:	7f 91       	pop	r23
    9d3a:	6f 91       	pop	r22
    9d3c:	5f 91       	pop	r21
    9d3e:	4f 91       	pop	r20
    9d40:	3f 91       	pop	r19
    9d42:	2f 91       	pop	r18
    9d44:	0f 90       	pop	r0
    9d46:	0b be       	out	0x3b, r0	; 59
    9d48:	0f 90       	pop	r0
    9d4a:	0f be       	out	0x3f, r0	; 63
    9d4c:	0f 90       	pop	r0
    9d4e:	1f 90       	pop	r1
    9d50:	18 95       	reti

00009d52 <__vector_36>:
__vector_36():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial1.cpp:46
#elif defined(USART1_RX_vect)
ISR(USART1_RX_vect)
#else
#error "Don't know what the Data Register Empty vector is called for Serial1"
#endif
{
    9d52:	1f 92       	push	r1
    9d54:	0f 92       	push	r0
    9d56:	0f b6       	in	r0, 0x3f	; 63
    9d58:	0f 92       	push	r0
    9d5a:	11 24       	eor	r1, r1
    9d5c:	0b b6       	in	r0, 0x3b	; 59
    9d5e:	0f 92       	push	r0
    9d60:	2f 93       	push	r18
    9d62:	3f 93       	push	r19
    9d64:	4f 93       	push	r20
    9d66:	5f 93       	push	r21
    9d68:	6f 93       	push	r22
    9d6a:	7f 93       	push	r23
    9d6c:	8f 93       	push	r24
    9d6e:	9f 93       	push	r25
    9d70:	af 93       	push	r26
    9d72:	bf 93       	push	r27
    9d74:	ef 93       	push	r30
    9d76:	ff 93       	push	r31
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial1.cpp:47
  Serial1._rx_complete_irq();
    9d78:	85 eb       	ldi	r24, 0xB5	; 181
    9d7a:	9d e0       	ldi	r25, 0x0D	; 13
    9d7c:	0e 94 a2 06 	call	0xd44	; 0xd44 <HardwareSerial::_rx_complete_irq()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial1.cpp:48
}
    9d80:	ff 91       	pop	r31
    9d82:	ef 91       	pop	r30
    9d84:	bf 91       	pop	r27
    9d86:	af 91       	pop	r26
    9d88:	9f 91       	pop	r25
    9d8a:	8f 91       	pop	r24
    9d8c:	7f 91       	pop	r23
    9d8e:	6f 91       	pop	r22
    9d90:	5f 91       	pop	r21
    9d92:	4f 91       	pop	r20
    9d94:	3f 91       	pop	r19
    9d96:	2f 91       	pop	r18
    9d98:	0f 90       	pop	r0
    9d9a:	0b be       	out	0x3b, r0	; 59
    9d9c:	0f 90       	pop	r0
    9d9e:	0f be       	out	0x3f, r0	; 63
    9da0:	0f 90       	pop	r0
    9da2:	1f 90       	pop	r1
    9da4:	18 95       	reti

00009da6 <__vector_26>:
__vector_26():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial0.cpp:63
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    9da6:	1f 92       	push	r1
    9da8:	0f 92       	push	r0
    9daa:	0f b6       	in	r0, 0x3f	; 63
    9dac:	0f 92       	push	r0
    9dae:	11 24       	eor	r1, r1
    9db0:	0b b6       	in	r0, 0x3b	; 59
    9db2:	0f 92       	push	r0
    9db4:	2f 93       	push	r18
    9db6:	3f 93       	push	r19
    9db8:	4f 93       	push	r20
    9dba:	5f 93       	push	r21
    9dbc:	6f 93       	push	r22
    9dbe:	7f 93       	push	r23
    9dc0:	8f 93       	push	r24
    9dc2:	9f 93       	push	r25
    9dc4:	af 93       	push	r26
    9dc6:	bf 93       	push	r27
    9dc8:	ef 93       	push	r30
    9dca:	ff 93       	push	r31
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial0.cpp:64
  Serial._tx_udr_empty_irq();
    9dcc:	82 e5       	ldi	r24, 0x52	; 82
    9dce:	9e e0       	ldi	r25, 0x0E	; 14
    9dd0:	0e 94 20 07 	call	0xe40	; 0xe40 <HardwareSerial::_tx_udr_empty_irq()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial0.cpp:65
}
    9dd4:	ff 91       	pop	r31
    9dd6:	ef 91       	pop	r30
    9dd8:	bf 91       	pop	r27
    9dda:	af 91       	pop	r26
    9ddc:	9f 91       	pop	r25
    9dde:	8f 91       	pop	r24
    9de0:	7f 91       	pop	r23
    9de2:	6f 91       	pop	r22
    9de4:	5f 91       	pop	r21
    9de6:	4f 91       	pop	r20
    9de8:	3f 91       	pop	r19
    9dea:	2f 91       	pop	r18
    9dec:	0f 90       	pop	r0
    9dee:	0b be       	out	0x3b, r0	; 59
    9df0:	0f 90       	pop	r0
    9df2:	0f be       	out	0x3f, r0	; 63
    9df4:	0f 90       	pop	r0
    9df6:	1f 90       	pop	r1
    9df8:	18 95       	reti

00009dfa <__vector_25>:
__vector_25():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial0.cpp:48
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    9dfa:	1f 92       	push	r1
    9dfc:	0f 92       	push	r0
    9dfe:	0f b6       	in	r0, 0x3f	; 63
    9e00:	0f 92       	push	r0
    9e02:	11 24       	eor	r1, r1
    9e04:	0b b6       	in	r0, 0x3b	; 59
    9e06:	0f 92       	push	r0
    9e08:	2f 93       	push	r18
    9e0a:	3f 93       	push	r19
    9e0c:	4f 93       	push	r20
    9e0e:	5f 93       	push	r21
    9e10:	6f 93       	push	r22
    9e12:	7f 93       	push	r23
    9e14:	8f 93       	push	r24
    9e16:	9f 93       	push	r25
    9e18:	af 93       	push	r26
    9e1a:	bf 93       	push	r27
    9e1c:	ef 93       	push	r30
    9e1e:	ff 93       	push	r31
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial0.cpp:49
    Serial._rx_complete_irq();
    9e20:	82 e5       	ldi	r24, 0x52	; 82
    9e22:	9e e0       	ldi	r25, 0x0E	; 14
    9e24:	0e 94 a2 06 	call	0xd44	; 0xd44 <HardwareSerial::_rx_complete_irq()>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial0.cpp:50
  }
    9e28:	ff 91       	pop	r31
    9e2a:	ef 91       	pop	r30
    9e2c:	bf 91       	pop	r27
    9e2e:	af 91       	pop	r26
    9e30:	9f 91       	pop	r25
    9e32:	8f 91       	pop	r24
    9e34:	7f 91       	pop	r23
    9e36:	6f 91       	pop	r22
    9e38:	5f 91       	pop	r21
    9e3a:	4f 91       	pop	r20
    9e3c:	3f 91       	pop	r19
    9e3e:	2f 91       	pop	r18
    9e40:	0f 90       	pop	r0
    9e42:	0b be       	out	0x3b, r0	; 59
    9e44:	0f 90       	pop	r0
    9e46:	0f be       	out	0x3f, r0	; 63
    9e48:	0f 90       	pop	r0
    9e4a:	1f 90       	pop	r1
    9e4c:	18 95       	reti

00009e4e <__vector_23>:
__vector_23():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:47
#if defined(TIM0_OVF_vect)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
    9e4e:	1f 92       	push	r1
    9e50:	0f 92       	push	r0
    9e52:	0f b6       	in	r0, 0x3f	; 63
    9e54:	0f 92       	push	r0
    9e56:	11 24       	eor	r1, r1
    9e58:	2f 93       	push	r18
    9e5a:	3f 93       	push	r19
    9e5c:	8f 93       	push	r24
    9e5e:	9f 93       	push	r25
    9e60:	af 93       	push	r26
    9e62:	bf 93       	push	r27
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:50
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
    9e64:	80 91 d2 09 	lds	r24, 0x09D2	; 0x8009d2 <timer0_millis>
    9e68:	90 91 d3 09 	lds	r25, 0x09D3	; 0x8009d3 <timer0_millis+0x1>
    9e6c:	a0 91 d4 09 	lds	r26, 0x09D4	; 0x8009d4 <timer0_millis+0x2>
    9e70:	b0 91 d5 09 	lds	r27, 0x09D5	; 0x8009d5 <timer0_millis+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:51
	unsigned char f = timer0_fract;
    9e74:	30 91 d1 09 	lds	r19, 0x09D1	; 0x8009d1 <timer0_fract>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:54

	m += MILLIS_INC;
	f += FRACT_INC;
    9e78:	23 e0       	ldi	r18, 0x03	; 3
    9e7a:	23 0f       	add	r18, r19
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:55
	if (f >= FRACT_MAX) {
    9e7c:	2d 37       	cpi	r18, 0x7D	; 125
    9e7e:	58 f5       	brcc	.+86     	; 0x9ed6 <__vector_23+0x88>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:53
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
    9e80:	01 96       	adiw	r24, 0x01	; 1
    9e82:	a1 1d       	adc	r26, r1
    9e84:	b1 1d       	adc	r27, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:60
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
		m += 1;
	}

	timer0_fract = f;
    9e86:	20 93 d1 09 	sts	0x09D1, r18	; 0x8009d1 <timer0_fract>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:61
	timer0_millis = m;
    9e8a:	80 93 d2 09 	sts	0x09D2, r24	; 0x8009d2 <timer0_millis>
    9e8e:	90 93 d3 09 	sts	0x09D3, r25	; 0x8009d3 <timer0_millis+0x1>
    9e92:	a0 93 d4 09 	sts	0x09D4, r26	; 0x8009d4 <timer0_millis+0x2>
    9e96:	b0 93 d5 09 	sts	0x09D5, r27	; 0x8009d5 <timer0_millis+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:62
	timer0_overflow_count++;
    9e9a:	80 91 d6 09 	lds	r24, 0x09D6	; 0x8009d6 <timer0_overflow_count>
    9e9e:	90 91 d7 09 	lds	r25, 0x09D7	; 0x8009d7 <timer0_overflow_count+0x1>
    9ea2:	a0 91 d8 09 	lds	r26, 0x09D8	; 0x8009d8 <timer0_overflow_count+0x2>
    9ea6:	b0 91 d9 09 	lds	r27, 0x09D9	; 0x8009d9 <timer0_overflow_count+0x3>
    9eaa:	01 96       	adiw	r24, 0x01	; 1
    9eac:	a1 1d       	adc	r26, r1
    9eae:	b1 1d       	adc	r27, r1
    9eb0:	80 93 d6 09 	sts	0x09D6, r24	; 0x8009d6 <timer0_overflow_count>
    9eb4:	90 93 d7 09 	sts	0x09D7, r25	; 0x8009d7 <timer0_overflow_count+0x1>
    9eb8:	a0 93 d8 09 	sts	0x09D8, r26	; 0x8009d8 <timer0_overflow_count+0x2>
    9ebc:	b0 93 d9 09 	sts	0x09D9, r27	; 0x8009d9 <timer0_overflow_count+0x3>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:63
}
    9ec0:	bf 91       	pop	r27
    9ec2:	af 91       	pop	r26
    9ec4:	9f 91       	pop	r25
    9ec6:	8f 91       	pop	r24
    9ec8:	3f 91       	pop	r19
    9eca:	2f 91       	pop	r18
    9ecc:	0f 90       	pop	r0
    9ece:	0f be       	out	0x3f, r0	; 63
    9ed0:	0f 90       	pop	r0
    9ed2:	1f 90       	pop	r1
    9ed4:	18 95       	reti
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:56
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
    9ed6:	26 e8       	ldi	r18, 0x86	; 134
    9ed8:	23 0f       	add	r18, r19
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:57
		m += 1;
    9eda:	02 96       	adiw	r24, 0x02	; 2
    9edc:	a1 1d       	adc	r26, r1
    9ede:	b1 1d       	adc	r27, r1
    9ee0:	d2 cf       	rjmp	.-92     	; 0x9e86 <__vector_23+0x38>

00009ee2 <__vector_12>:
__vector_12():
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:14
#include <avr/wdt.h>

#include "WatchdogAVR.h"

// Define watchdog timer interrupt.
ISR(WDT_vect) {
    9ee2:	1f 92       	push	r1
    9ee4:	0f 92       	push	r0
    9ee6:	0f b6       	in	r0, 0x3f	; 63
    9ee8:	0f 92       	push	r0
    9eea:	11 24       	eor	r1, r1
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:17
  // Nothing needs to be done, however interrupt handler must be defined to
  // prevent a reset.
}
    9eec:	0f 90       	pop	r0
    9eee:	0f be       	out	0x3f, r0	; 63
    9ef0:	0f 90       	pop	r0
    9ef2:	1f 90       	pop	r1
    9ef4:	18 95       	reti

00009ef6 <__vector_10>:
__vector_9():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SoftwareSerial\src/SoftwareSerial.cpp:229
  }
}

#if defined(PCINT0_vect)
ISR(PCINT0_vect)
{
    9ef6:	1f 92       	push	r1
    9ef8:	0f 92       	push	r0
    9efa:	0f b6       	in	r0, 0x3f	; 63
    9efc:	0f 92       	push	r0
    9efe:	11 24       	eor	r1, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\SoftwareSerial\src/SoftwareSerial.cpp:231
  SoftwareSerial::handle_interrupt();
}
    9f00:	0f 90       	pop	r0
    9f02:	0f be       	out	0x3f, r0	; 63
    9f04:	0f 90       	pop	r0
    9f06:	1f 90       	pop	r1
    9f08:	18 95       	reti

00009f0a <__vector_39>:
__vector_39():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:504
  }
  return(flag);
}

ISR(TWI_vect)
{
    9f0a:	1f 92       	push	r1
    9f0c:	0f 92       	push	r0
    9f0e:	0f b6       	in	r0, 0x3f	; 63
    9f10:	0f 92       	push	r0
    9f12:	11 24       	eor	r1, r1
    9f14:	0b b6       	in	r0, 0x3b	; 59
    9f16:	0f 92       	push	r0
    9f18:	2f 93       	push	r18
    9f1a:	3f 93       	push	r19
    9f1c:	4f 93       	push	r20
    9f1e:	5f 93       	push	r21
    9f20:	6f 93       	push	r22
    9f22:	7f 93       	push	r23
    9f24:	8f 93       	push	r24
    9f26:	9f 93       	push	r25
    9f28:	af 93       	push	r26
    9f2a:	bf 93       	push	r27
    9f2c:	ef 93       	push	r30
    9f2e:	ff 93       	push	r31
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:505
  switch(TW_STATUS){
    9f30:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    9f34:	88 7f       	andi	r24, 0xF8	; 248
    9f36:	80 36       	cpi	r24, 0x60	; 96
    9f38:	09 f4       	brne	.+2      	; 0x9f3c <__vector_39+0x32>
    9f3a:	4d c0       	rjmp	.+154    	; 0x9fd6 <__vector_39+0xcc>
    9f3c:	08 f0       	brcs	.+2      	; 0x9f40 <__vector_39+0x36>
    9f3e:	40 c0       	rjmp	.+128    	; 0x9fc0 <__vector_39+0xb6>
    9f40:	88 32       	cpi	r24, 0x28	; 40
    9f42:	09 f4       	brne	.+2      	; 0x9f46 <__vector_39+0x3c>
    9f44:	a9 c0       	rjmp	.+338    	; 0xa098 <__vector_39+0x18e>
    9f46:	28 f5       	brcc	.+74     	; 0x9f92 <__vector_39+0x88>
    9f48:	80 31       	cpi	r24, 0x10	; 16
    9f4a:	09 f4       	brne	.+2      	; 0x9f4e <__vector_39+0x44>
    9f4c:	9d c0       	rjmp	.+314    	; 0xa088 <__vector_39+0x17e>
    9f4e:	c8 f4       	brcc	.+50     	; 0x9f82 <__vector_39+0x78>
    9f50:	88 23       	and	r24, r24
    9f52:	09 f4       	brne	.+2      	; 0x9f56 <__vector_39+0x4c>
    9f54:	fb c0       	rjmp	.+502    	; 0xa14c <__vector_39+0x242>
    9f56:	88 30       	cpi	r24, 0x08	; 8
    9f58:	09 f4       	brne	.+2      	; 0x9f5c <__vector_39+0x52>
    9f5a:	96 c0       	rjmp	.+300    	; 0xa088 <__vector_39+0x17e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:666
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
      twi_stop();
      break;
  }
}
    9f5c:	ff 91       	pop	r31
    9f5e:	ef 91       	pop	r30
    9f60:	bf 91       	pop	r27
    9f62:	af 91       	pop	r26
    9f64:	9f 91       	pop	r25
    9f66:	8f 91       	pop	r24
    9f68:	7f 91       	pop	r23
    9f6a:	6f 91       	pop	r22
    9f6c:	5f 91       	pop	r21
    9f6e:	4f 91       	pop	r20
    9f70:	3f 91       	pop	r19
    9f72:	2f 91       	pop	r18
    9f74:	0f 90       	pop	r0
    9f76:	0b be       	out	0x3b, r0	; 59
    9f78:	0f 90       	pop	r0
    9f7a:	0f be       	out	0x3f, r0	; 63
    9f7c:	0f 90       	pop	r0
    9f7e:	1f 90       	pop	r1
    9f80:	18 95       	reti
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:505
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    9f82:	88 31       	cpi	r24, 0x18	; 24
    9f84:	09 f4       	brne	.+2      	; 0x9f88 <__vector_39+0x7e>
    9f86:	88 c0       	rjmp	.+272    	; 0xa098 <__vector_39+0x18e>
    9f88:	80 32       	cpi	r24, 0x20	; 32
    9f8a:	41 f7       	brne	.-48     	; 0x9f5c <__vector_39+0x52>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:540
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
    9f8c:	80 93 4d 0c 	sts	0x0C4D, r24	; 0x800c4d <twi_error>
    9f90:	14 c0       	rjmp	.+40     	; 0x9fba <__vector_39+0xb0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:505
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    9f92:	80 34       	cpi	r24, 0x40	; 64
    9f94:	09 f4       	brne	.+2      	; 0x9f98 <__vector_39+0x8e>
    9f96:	9d c0       	rjmp	.+314    	; 0xa0d2 <__vector_39+0x1c8>
    9f98:	40 f4       	brcc	.+16     	; 0x9faa <__vector_39+0xa0>
    9f9a:	80 33       	cpi	r24, 0x30	; 48
    9f9c:	b9 f3       	breq	.-18     	; 0x9f8c <__vector_39+0x82>
    9f9e:	88 33       	cpi	r24, 0x38	; 56
    9fa0:	e9 f6       	brne	.-70     	; 0x9f5c <__vector_39+0x52>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:544
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
    9fa2:	80 93 4d 0c 	sts	0x0C4D, r24	; 0x800c4d <twi_error>
twi_reply():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:397
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    9fa6:	85 ec       	ldi	r24, 0xC5	; 197
    9fa8:	b0 c0       	rjmp	.+352    	; 0xa10a <__vector_39+0x200>
__vector_39():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:505
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    9faa:	80 35       	cpi	r24, 0x50	; 80
    9fac:	09 f4       	brne	.+2      	; 0x9fb0 <__vector_39+0xa6>
    9fae:	85 c0       	rjmp	.+266    	; 0xa0ba <__vector_39+0x1b0>
    9fb0:	88 35       	cpi	r24, 0x58	; 88
    9fb2:	09 f4       	brne	.+2      	; 0x9fb6 <__vector_39+0xac>
    9fb4:	96 c0       	rjmp	.+300    	; 0xa0e2 <__vector_39+0x1d8>
    9fb6:	88 34       	cpi	r24, 0x48	; 72
    9fb8:	89 f6       	brne	.-94     	; 0x9f5c <__vector_39+0x52>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:663
    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
      twi_stop();
    9fba:	0e 94 02 39 	call	0x7204	; 0x7204 <twi_stop>
    9fbe:	ce cf       	rjmp	.-100    	; 0x9f5c <__vector_39+0x52>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:505
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    9fc0:	88 39       	cpi	r24, 0x98	; 152
    9fc2:	09 f4       	brne	.+2      	; 0x9fc6 <__vector_39+0xbc>
    9fc4:	8c c0       	rjmp	.+280    	; 0xa0de <__vector_39+0x1d4>
    9fc6:	38 f5       	brcc	.+78     	; 0xa016 <__vector_39+0x10c>
    9fc8:	88 37       	cpi	r24, 0x78	; 120
    9fca:	29 f0       	breq	.+10     	; 0x9fd6 <__vector_39+0xcc>
    9fcc:	50 f4       	brcc	.+20     	; 0x9fe2 <__vector_39+0xd8>
    9fce:	88 36       	cpi	r24, 0x68	; 104
    9fd0:	11 f0       	breq	.+4      	; 0x9fd6 <__vector_39+0xcc>
    9fd2:	80 37       	cpi	r24, 0x70	; 112
    9fd4:	19 f6       	brne	.-122    	; 0x9f5c <__vector_39+0x52>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:586
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
    9fd6:	83 e0       	ldi	r24, 0x03	; 3
    9fd8:	80 93 4f 0c 	sts	0x0C4F, r24	; 0x800c4f <twi_state>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:588
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
    9fdc:	10 92 c7 09 	sts	0x09C7, r1	; 0x8009c7 <twi_rxBufferIndex>
    9fe0:	57 c0       	rjmp	.+174    	; 0xa090 <__vector_39+0x186>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:505
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    9fe2:	88 38       	cpi	r24, 0x88	; 136
    9fe4:	09 f4       	brne	.+2      	; 0x9fe8 <__vector_39+0xde>
    9fe6:	7b c0       	rjmp	.+246    	; 0xa0de <__vector_39+0x1d4>
    9fe8:	80 39       	cpi	r24, 0x90	; 144
    9fea:	19 f0       	breq	.+6      	; 0x9ff2 <__vector_39+0xe8>
    9fec:	80 38       	cpi	r24, 0x80	; 128
    9fee:	09 f0       	breq	.+2      	; 0x9ff2 <__vector_39+0xe8>
    9ff0:	b5 cf       	rjmp	.-150    	; 0x9f5c <__vector_39+0x52>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:594
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    9ff2:	80 91 c7 09 	lds	r24, 0x09C7	; 0x8009c7 <twi_rxBufferIndex>
    9ff6:	80 32       	cpi	r24, 0x20	; 32
    9ff8:	08 f0       	brcs	.+2      	; 0x9ffc <__vector_39+0xf2>
    9ffa:	71 c0       	rjmp	.+226    	; 0xa0de <__vector_39+0x1d4>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:596
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
    9ffc:	e0 91 c7 09 	lds	r30, 0x09C7	; 0x8009c7 <twi_rxBufferIndex>
    a000:	81 e0       	ldi	r24, 0x01	; 1
    a002:	8e 0f       	add	r24, r30
    a004:	80 93 c7 09 	sts	0x09C7, r24	; 0x8009c7 <twi_rxBufferIndex>
    a008:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    a00c:	f0 e0       	ldi	r31, 0x00	; 0
    a00e:	e9 55       	subi	r30, 0x59	; 89
    a010:	f6 4f       	sbci	r31, 0xF6	; 246
    a012:	80 83       	st	Z, r24
    a014:	3d c0       	rjmp	.+122    	; 0xa090 <__vector_39+0x186>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:505
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    a016:	80 3b       	cpi	r24, 0xB0	; 176
    a018:	39 f0       	breq	.+14     	; 0xa028 <__vector_39+0x11e>
    a01a:	e0 f4       	brcc	.+56     	; 0xa054 <__vector_39+0x14a>
    a01c:	80 3a       	cpi	r24, 0xA0	; 160
    a01e:	09 f4       	brne	.+2      	; 0xa022 <__vector_39+0x118>
    a020:	79 c0       	rjmp	.+242    	; 0xa114 <__vector_39+0x20a>
    a022:	88 3a       	cpi	r24, 0xA8	; 168
    a024:	09 f0       	breq	.+2      	; 0xa028 <__vector_39+0x11e>
    a026:	9a cf       	rjmp	.-204    	; 0x9f5c <__vector_39+0x52>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:625
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
    a028:	84 e0       	ldi	r24, 0x04	; 4
    a02a:	80 93 4f 0c 	sts	0x0C4F, r24	; 0x800c4f <twi_state>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:627
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
    a02e:	10 92 a6 09 	sts	0x09A6, r1	; 0x8009a6 <twi_txBufferIndex>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:629
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
    a032:	10 92 a5 09 	sts	0x09A5, r1	; 0x8009a5 <twi_txBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:632
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
    a036:	e0 91 1f 0c 	lds	r30, 0x0C1F	; 0x800c1f <twi_onSlaveTransmit>
    a03a:	f0 91 20 0c 	lds	r31, 0x0C20	; 0x800c20 <twi_onSlaveTransmit+0x1>
    a03e:	19 95       	eicall
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:634
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
    a040:	80 91 a5 09 	lds	r24, 0x09A5	; 0x8009a5 <twi_txBufferLength>
    a044:	81 11       	cpse	r24, r1
    a046:	0f c0       	rjmp	.+30     	; 0xa066 <__vector_39+0x15c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:635
        twi_txBufferLength = 1;
    a048:	81 e0       	ldi	r24, 0x01	; 1
    a04a:	80 93 a5 09 	sts	0x09A5, r24	; 0x8009a5 <twi_txBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:636
        twi_txBuffer[0] = 0x00;
    a04e:	10 92 85 09 	sts	0x0985, r1	; 0x800985 <twi_txBuffer>
    a052:	09 c0       	rjmp	.+18     	; 0xa066 <__vector_39+0x15c>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:505
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
    a054:	80 3c       	cpi	r24, 0xC0	; 192
    a056:	09 f4       	brne	.+2      	; 0xa05a <__vector_39+0x150>
    a058:	a6 cf       	rjmp	.-180    	; 0x9fa6 <__vector_39+0x9c>
    a05a:	88 3c       	cpi	r24, 0xC8	; 200
    a05c:	09 f4       	brne	.+2      	; 0xa060 <__vector_39+0x156>
    a05e:	a3 cf       	rjmp	.-186    	; 0x9fa6 <__vector_39+0x9c>
    a060:	88 3b       	cpi	r24, 0xB8	; 184
    a062:	09 f0       	breq	.+2      	; 0xa066 <__vector_39+0x15c>
    a064:	7b cf       	rjmp	.-266    	; 0x9f5c <__vector_39+0x52>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:642
      }
      __attribute__ ((fallthrough));		  
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
    a066:	e0 91 a6 09 	lds	r30, 0x09A6	; 0x8009a6 <twi_txBufferIndex>
    a06a:	81 e0       	ldi	r24, 0x01	; 1
    a06c:	8e 0f       	add	r24, r30
    a06e:	80 93 a6 09 	sts	0x09A6, r24	; 0x8009a6 <twi_txBufferIndex>
    a072:	f0 e0       	ldi	r31, 0x00	; 0
    a074:	eb 57       	subi	r30, 0x7B	; 123
    a076:	f6 4f       	sbci	r31, 0xF6	; 246
    a078:	80 81       	ld	r24, Z
    a07a:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:644
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    a07e:	90 91 a6 09 	lds	r25, 0x09A6	; 0x8009a6 <twi_txBufferIndex>
    a082:	80 91 a5 09 	lds	r24, 0x09A5	; 0x8009a5 <twi_txBufferLength>
    a086:	29 c0       	rjmp	.+82     	; 0xa0da <__vector_39+0x1d0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:510
  switch(TW_STATUS){
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
    a088:	80 91 4a 0c 	lds	r24, 0x0C4A	; 0x800c4a <twi_slarw>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:520
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    a08c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
twi_reply():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:397
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    a090:	85 ec       	ldi	r24, 0xC5	; 197
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:399
  }else{
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    a092:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    a096:	62 cf       	rjmp	.-316    	; 0x9f5c <__vector_39+0x52>
__vector_39():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:518

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
    a098:	90 91 4c 0c 	lds	r25, 0x0C4C	; 0x800c4c <twi_masterBufferIndex>
    a09c:	80 91 4b 0c 	lds	r24, 0x0C4B	; 0x800c4b <twi_masterBufferLength>
    a0a0:	98 17       	cp	r25, r24
    a0a2:	58 f5       	brcc	.+86     	; 0xa0fa <__vector_39+0x1f0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:520
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
    a0a4:	e0 91 4c 0c 	lds	r30, 0x0C4C	; 0x800c4c <twi_masterBufferIndex>
    a0a8:	81 e0       	ldi	r24, 0x01	; 1
    a0aa:	8e 0f       	add	r24, r30
    a0ac:	80 93 4c 0c 	sts	0x0C4C, r24	; 0x800c4c <twi_masterBufferIndex>
    a0b0:	f0 e0       	ldi	r31, 0x00	; 0
    a0b2:	e7 5d       	subi	r30, 0xD7	; 215
    a0b4:	f3 4f       	sbci	r31, 0xF3	; 243
    a0b6:	80 81       	ld	r24, Z
    a0b8:	e9 cf       	rjmp	.-46     	; 0xa08c <__vector_39+0x182>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:551
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    a0ba:	e0 91 4c 0c 	lds	r30, 0x0C4C	; 0x800c4c <twi_masterBufferIndex>
    a0be:	81 e0       	ldi	r24, 0x01	; 1
    a0c0:	8e 0f       	add	r24, r30
    a0c2:	80 93 4c 0c 	sts	0x0C4C, r24	; 0x800c4c <twi_masterBufferIndex>
    a0c6:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    a0ca:	f0 e0       	ldi	r31, 0x00	; 0
    a0cc:	e7 5d       	subi	r30, 0xD7	; 215
    a0ce:	f3 4f       	sbci	r31, 0xF3	; 243
    a0d0:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:555
      __attribute__ ((fallthrough));
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    a0d2:	90 91 4c 0c 	lds	r25, 0x0C4C	; 0x800c4c <twi_masterBufferIndex>
    a0d6:	80 91 4b 0c 	lds	r24, 0x0C4B	; 0x800c4b <twi_masterBufferLength>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:644
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    a0da:	98 17       	cp	r25, r24
    a0dc:	c8 f2       	brcs	.-78     	; 0xa090 <__vector_39+0x186>
twi_reply():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:399
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    a0de:	85 e8       	ldi	r24, 0x85	; 133
    a0e0:	d8 cf       	rjmp	.-80     	; 0xa092 <__vector_39+0x188>
__vector_39():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:563
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    a0e2:	e0 91 4c 0c 	lds	r30, 0x0C4C	; 0x800c4c <twi_masterBufferIndex>
    a0e6:	81 e0       	ldi	r24, 0x01	; 1
    a0e8:	8e 0f       	add	r24, r30
    a0ea:	80 93 4c 0c 	sts	0x0C4C, r24	; 0x800c4c <twi_masterBufferIndex>
    a0ee:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    a0f2:	f0 e0       	ldi	r31, 0x00	; 0
    a0f4:	e7 5d       	subi	r30, 0xD7	; 215
    a0f6:	f3 4f       	sbci	r31, 0xF3	; 243
    a0f8:	80 83       	st	Z, r24
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:564
      if (twi_sendStop){
    a0fa:	80 91 4e 0c 	lds	r24, 0x0C4E	; 0x800c4e <twi_sendStop>
    a0fe:	81 11       	cpse	r24, r1
    a100:	5c cf       	rjmp	.-328    	; 0x9fba <__vector_39+0xb0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:567
        twi_stop();
      } else {
        twi_inRepStart = true;	// we're gonna send the START
    a102:	81 e0       	ldi	r24, 0x01	; 1
    a104:	80 93 49 0c 	sts	0x0C49, r24	; 0x800c49 <twi_inRepStart>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:571
        // don't enable the interrupt. We'll generate the start, but we
        // avoid handling the interrupt until we're in the next transaction,
        // at the point where we would normally issue the start.
        TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    a108:	84 ea       	ldi	r24, 0xA4	; 164
twi_reply():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:397
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    a10a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
__vector_39():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:655
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    a10e:	10 92 4f 0c 	sts	0x0C4F, r1	; 0x800c4f <twi_state>
    a112:	24 cf       	rjmp	.-440    	; 0x9f5c <__vector_39+0x52>
twi_releaseBus():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:444
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    a114:	85 ec       	ldi	r24, 0xC5	; 197
    a116:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:447

  // update twi state
  twi_state = TWI_READY;
    a11a:	10 92 4f 0c 	sts	0x0C4F, r1	; 0x800c4f <twi_state>
__vector_39():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:607
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
    a11e:	80 91 c7 09 	lds	r24, 0x09C7	; 0x8009c7 <twi_rxBufferIndex>
    a122:	80 32       	cpi	r24, 0x20	; 32
    a124:	30 f4       	brcc	.+12     	; 0xa132 <__vector_39+0x228>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:608
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    a126:	e0 91 c7 09 	lds	r30, 0x09C7	; 0x8009c7 <twi_rxBufferIndex>
    a12a:	f0 e0       	ldi	r31, 0x00	; 0
    a12c:	e9 55       	subi	r30, 0x59	; 89
    a12e:	f6 4f       	sbci	r31, 0xF6	; 246
    a130:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:611
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    a132:	60 91 c7 09 	lds	r22, 0x09C7	; 0x8009c7 <twi_rxBufferIndex>
    a136:	70 e0       	ldi	r23, 0x00	; 0
    a138:	e0 91 1d 0c 	lds	r30, 0x0C1D	; 0x800c1d <twi_onSlaveReceive>
    a13c:	f0 91 1e 0c 	lds	r31, 0x0C1E	; 0x800c1e <twi_onSlaveReceive+0x1>
    a140:	87 ea       	ldi	r24, 0xA7	; 167
    a142:	99 e0       	ldi	r25, 0x09	; 9
    a144:	19 95       	eicall
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:613
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    a146:	10 92 c7 09 	sts	0x09C7, r1	; 0x8009c7 <twi_rxBufferIndex>
    a14a:	08 cf       	rjmp	.-496    	; 0x9f5c <__vector_39+0x52>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src\utility/twi.c:662

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    a14c:	10 92 4d 0c 	sts	0x0C4D, r1	; 0x800c4d <twi_error>
    a150:	34 cf       	rjmp	.-408    	; 0x9fba <__vector_39+0xb0>

0000a152 <BlinkControl::BlinkControl(int)>:
__base_ctor ():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:30
 * 
 */
#include "Arduino.h"
#include "BlinkControl.h"

BlinkControl::BlinkControl(int pin) {
    a152:	0f 93       	push	r16
    a154:	1f 93       	push	r17
    a156:	cf 93       	push	r28
    a158:	df 93       	push	r29
    a15a:	ec 01       	movw	r28, r24
    a15c:	86 2f       	mov	r24, r22
    a15e:	19 82       	std	Y+1, r1	; 0x01
    a160:	18 82       	st	Y, r1
    a162:	1b 82       	std	Y+3, r1	; 0x03
    a164:	1a 82       	std	Y+2, r1	; 0x02
    a166:	28 e0       	ldi	r18, 0x08	; 8
    a168:	30 e0       	ldi	r19, 0x00	; 0
    a16a:	39 87       	std	Y+9, r19	; 0x09
    a16c:	28 87       	std	Y+8, r18	; 0x08
    a16e:	00 91 a9 02 	lds	r16, 0x02A9	; 0x8002a9 <__malloc_margin+0x2>
    a172:	10 91 aa 02 	lds	r17, 0x02AA	; 0x8002aa <__malloc_margin+0x3>
    a176:	20 91 ab 02 	lds	r18, 0x02AB	; 0x8002ab <__malloc_margin+0x4>
    a17a:	30 91 ac 02 	lds	r19, 0x02AC	; 0x8002ac <__malloc_margin+0x5>
    a17e:	0a 87       	std	Y+10, r16	; 0x0a
    a180:	1b 87       	std	Y+11, r17	; 0x0b
    a182:	2c 87       	std	Y+12, r18	; 0x0c
    a184:	3d 87       	std	Y+13, r19	; 0x0d
    a186:	98 e0       	ldi	r25, 0x08	; 8
    a188:	ed ea       	ldi	r30, 0xAD	; 173
    a18a:	f2 e0       	ldi	r31, 0x02	; 2
    a18c:	de 01       	movw	r26, r28
    a18e:	1e 96       	adiw	r26, 0x0e	; 14
    a190:	01 90       	ld	r0, Z+
    a192:	0d 92       	st	X+, r0
    a194:	9a 95       	dec	r25
    a196:	e1 f7       	brne	.-8      	; 0xa190 <BlinkControl::BlinkControl(int)+0x3e>
    a198:	9c e0       	ldi	r25, 0x0C	; 12
    a19a:	e5 eb       	ldi	r30, 0xB5	; 181
    a19c:	f2 e0       	ldi	r31, 0x02	; 2
    a19e:	de 01       	movw	r26, r28
    a1a0:	56 96       	adiw	r26, 0x16	; 22
    a1a2:	01 90       	ld	r0, Z+
    a1a4:	0d 92       	st	X+, r0
    a1a6:	9a 95       	dec	r25
    a1a8:	e1 f7       	brne	.-8      	; 0xa1a2 <BlinkControl::BlinkControl(int)+0x50>
    a1aa:	90 e1       	ldi	r25, 0x10	; 16
    a1ac:	e1 ec       	ldi	r30, 0xC1	; 193
    a1ae:	f2 e0       	ldi	r31, 0x02	; 2
    a1b0:	de 01       	movw	r26, r28
    a1b2:	92 96       	adiw	r26, 0x22	; 34
    a1b4:	01 90       	ld	r0, Z+
    a1b6:	0d 92       	st	X+, r0
    a1b8:	9a 95       	dec	r25
    a1ba:	e1 f7       	brne	.-8      	; 0xa1b4 <BlinkControl::BlinkControl(int)+0x62>
    a1bc:	00 91 d1 02 	lds	r16, 0x02D1	; 0x8002d1 <__malloc_margin+0x2a>
    a1c0:	10 91 d2 02 	lds	r17, 0x02D2	; 0x8002d2 <__malloc_margin+0x2b>
    a1c4:	20 91 d3 02 	lds	r18, 0x02D3	; 0x8002d3 <__malloc_margin+0x2c>
    a1c8:	30 91 d4 02 	lds	r19, 0x02D4	; 0x8002d4 <__malloc_margin+0x2d>
    a1cc:	0a ab       	std	Y+50, r16	; 0x32
    a1ce:	1b ab       	std	Y+51, r17	; 0x33
    a1d0:	2c ab       	std	Y+52, r18	; 0x34
    a1d2:	3d ab       	std	Y+53, r19	; 0x35
    a1d4:	19 ae       	std	Y+57, r1	; 0x39
    a1d6:	18 ae       	std	Y+56, r1	; 0x38
    a1d8:	1b ae       	std	Y+59, r1	; 0x3b
    a1da:	1a ae       	std	Y+58, r1	; 0x3a
    a1dc:	1c ae       	std	Y+60, r1	; 0x3c
    a1de:	1d ae       	std	Y+61, r1	; 0x3d
    a1e0:	1e ae       	std	Y+62, r1	; 0x3e
    a1e2:	1f ae       	std	Y+63, r1	; 0x3f
    a1e4:	fe 01       	movw	r30, r28
    a1e6:	e0 5c       	subi	r30, 0xC0	; 192
    a1e8:	ff 4f       	sbci	r31, 0xFF	; 255
    a1ea:	10 82       	st	Z, r1
    a1ec:	33 96       	adiw	r30, 0x03	; 3
    a1ee:	21 e0       	ldi	r18, 0x01	; 1
    a1f0:	30 e0       	ldi	r19, 0x00	; 0
    a1f2:	31 83       	std	Z+1, r19	; 0x01
    a1f4:	20 83       	st	Z, r18
    a1f6:	32 96       	adiw	r30, 0x02	; 2
    a1f8:	11 82       	std	Z+1, r1	; 0x01
    a1fa:	10 82       	st	Z, r1
    a1fc:	32 96       	adiw	r30, 0x02	; 2
    a1fe:	2f ef       	ldi	r18, 0xFF	; 255
    a200:	30 e0       	ldi	r19, 0x00	; 0
    a202:	31 83       	std	Z+1, r19	; 0x01
    a204:	20 83       	st	Z, r18
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:31
  this->_pin = pin;
    a206:	6c 83       	std	Y+4, r22	; 0x04
    a208:	7d 83       	std	Y+5, r23	; 0x05
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:32
  pinMode(this->_pin, OUTPUT);
    a20a:	61 e0       	ldi	r22, 0x01	; 1
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:33
}
    a20c:	df 91       	pop	r29
    a20e:	cf 91       	pop	r28
    a210:	1f 91       	pop	r17
    a212:	0f 91       	pop	r16
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:32
#include "Arduino.h"
#include "BlinkControl.h"

BlinkControl::BlinkControl(int pin) {
  this->_pin = pin;
  pinMode(this->_pin, OUTPUT);
    a214:	0c 94 08 09 	jmp	0x1210	; 0x1210 <pinMode>

0000a218 <global constructors keyed to 65535_0_Drifter_Mega_V3.0.cpp.o.6099>:
_GLOBAL__I_65535_0_Drifter_Mega_V3.0.cpp.o.6099():
    a218:	cf 92       	push	r12
    a21a:	df 92       	push	r13
    a21c:	ef 92       	push	r14
    a21e:	ff 92       	push	r15
    a220:	0f 93       	push	r16
    a222:	1f 93       	push	r17
    a224:	cf 93       	push	r28
    a226:	df 93       	push	r29
    a228:	eb e7       	ldi	r30, 0x7B	; 123
    a22a:	fc e0       	ldi	r31, 0x0C	; 12
    a22c:	13 82       	std	Z+3, r1	; 0x03
    a22e:	12 82       	std	Z+2, r1	; 0x02
    a230:	88 ee       	ldi	r24, 0xE8	; 232
    a232:	c8 2e       	mov	r12, r24
    a234:	83 e0       	ldi	r24, 0x03	; 3
    a236:	d8 2e       	mov	r13, r24
    a238:	e1 2c       	mov	r14, r1
    a23a:	f1 2c       	mov	r15, r1
    a23c:	c4 82       	std	Z+4, r12	; 0x04
    a23e:	d5 82       	std	Z+5, r13	; 0x05
    a240:	e6 82       	std	Z+6, r14	; 0x06
    a242:	f7 82       	std	Z+7, r15	; 0x07
    a244:	8b ef       	ldi	r24, 0xFB	; 251
    a246:	92 e0       	ldi	r25, 0x02	; 2
    a248:	91 83       	std	Z+1, r25	; 0x01
    a24a:	80 83       	st	Z, r24
    a24c:	25 e3       	ldi	r18, 0x35	; 53
    a24e:	31 e0       	ldi	r19, 0x01	; 1
    a250:	35 87       	std	Z+13, r19	; 0x0d
    a252:	24 87       	std	Z+12, r18	; 0x0c
    a254:	24 e3       	ldi	r18, 0x34	; 52
    a256:	31 e0       	ldi	r19, 0x01	; 1
    a258:	37 87       	std	Z+15, r19	; 0x0f
    a25a:	26 87       	std	Z+14, r18	; 0x0e
    a25c:	20 e3       	ldi	r18, 0x30	; 48
    a25e:	31 e0       	ldi	r19, 0x01	; 1
    a260:	31 8b       	std	Z+17, r19	; 0x11
    a262:	20 8b       	std	Z+16, r18	; 0x10
    a264:	21 e3       	ldi	r18, 0x31	; 49
    a266:	31 e0       	ldi	r19, 0x01	; 1
    a268:	33 8b       	std	Z+19, r19	; 0x13
    a26a:	22 8b       	std	Z+18, r18	; 0x12
    a26c:	22 e3       	ldi	r18, 0x32	; 50
    a26e:	31 e0       	ldi	r19, 0x01	; 1
    a270:	35 8b       	std	Z+21, r19	; 0x15
    a272:	24 8b       	std	Z+20, r18	; 0x14
    a274:	26 e3       	ldi	r18, 0x36	; 54
    a276:	31 e0       	ldi	r19, 0x01	; 1
    a278:	37 8b       	std	Z+23, r19	; 0x17
    a27a:	26 8b       	std	Z+22, r18	; 0x16
    a27c:	11 8e       	std	Z+25, r1	; 0x19
    a27e:	12 8e       	std	Z+26, r1	; 0x1a
    a280:	13 8e       	std	Z+27, r1	; 0x1b
    a282:	14 8e       	std	Z+28, r1	; 0x1c
    a284:	e8 e1       	ldi	r30, 0x18	; 24
    a286:	fd e0       	ldi	r31, 0x0D	; 13
    a288:	13 82       	std	Z+3, r1	; 0x03
    a28a:	12 82       	std	Z+2, r1	; 0x02
    a28c:	c4 82       	std	Z+4, r12	; 0x04
    a28e:	d5 82       	std	Z+5, r13	; 0x05
    a290:	e6 82       	std	Z+6, r14	; 0x06
    a292:	f7 82       	std	Z+7, r15	; 0x07
    a294:	91 83       	std	Z+1, r25	; 0x01
    a296:	80 83       	st	Z, r24
    a298:	25 ed       	ldi	r18, 0xD5	; 213
    a29a:	30 e0       	ldi	r19, 0x00	; 0
    a29c:	35 87       	std	Z+13, r19	; 0x0d
    a29e:	24 87       	std	Z+12, r18	; 0x0c
    a2a0:	24 ed       	ldi	r18, 0xD4	; 212
    a2a2:	30 e0       	ldi	r19, 0x00	; 0
    a2a4:	37 87       	std	Z+15, r19	; 0x0f
    a2a6:	26 87       	std	Z+14, r18	; 0x0e
    a2a8:	20 ed       	ldi	r18, 0xD0	; 208
    a2aa:	30 e0       	ldi	r19, 0x00	; 0
    a2ac:	31 8b       	std	Z+17, r19	; 0x11
    a2ae:	20 8b       	std	Z+16, r18	; 0x10
    a2b0:	21 ed       	ldi	r18, 0xD1	; 209
    a2b2:	30 e0       	ldi	r19, 0x00	; 0
    a2b4:	33 8b       	std	Z+19, r19	; 0x13
    a2b6:	22 8b       	std	Z+18, r18	; 0x12
    a2b8:	22 ed       	ldi	r18, 0xD2	; 210
    a2ba:	30 e0       	ldi	r19, 0x00	; 0
    a2bc:	35 8b       	std	Z+21, r19	; 0x15
    a2be:	24 8b       	std	Z+20, r18	; 0x14
    a2c0:	26 ed       	ldi	r18, 0xD6	; 214
    a2c2:	30 e0       	ldi	r19, 0x00	; 0
    a2c4:	37 8b       	std	Z+23, r19	; 0x17
    a2c6:	26 8b       	std	Z+22, r18	; 0x16
    a2c8:	11 8e       	std	Z+25, r1	; 0x19
    a2ca:	12 8e       	std	Z+26, r1	; 0x1a
    a2cc:	13 8e       	std	Z+27, r1	; 0x1b
    a2ce:	14 8e       	std	Z+28, r1	; 0x1c
    a2d0:	e5 eb       	ldi	r30, 0xB5	; 181
    a2d2:	fd e0       	ldi	r31, 0x0D	; 13
    a2d4:	13 82       	std	Z+3, r1	; 0x03
    a2d6:	12 82       	std	Z+2, r1	; 0x02
    a2d8:	c4 82       	std	Z+4, r12	; 0x04
    a2da:	d5 82       	std	Z+5, r13	; 0x05
    a2dc:	e6 82       	std	Z+6, r14	; 0x06
    a2de:	f7 82       	std	Z+7, r15	; 0x07
    a2e0:	91 83       	std	Z+1, r25	; 0x01
    a2e2:	80 83       	st	Z, r24
    a2e4:	2d ec       	ldi	r18, 0xCD	; 205
    a2e6:	30 e0       	ldi	r19, 0x00	; 0
    a2e8:	35 87       	std	Z+13, r19	; 0x0d
    a2ea:	24 87       	std	Z+12, r18	; 0x0c
    a2ec:	2c ec       	ldi	r18, 0xCC	; 204
    a2ee:	30 e0       	ldi	r19, 0x00	; 0
    a2f0:	37 87       	std	Z+15, r19	; 0x0f
    a2f2:	26 87       	std	Z+14, r18	; 0x0e
    a2f4:	28 ec       	ldi	r18, 0xC8	; 200
    a2f6:	30 e0       	ldi	r19, 0x00	; 0
    a2f8:	31 8b       	std	Z+17, r19	; 0x11
    a2fa:	20 8b       	std	Z+16, r18	; 0x10
    a2fc:	29 ec       	ldi	r18, 0xC9	; 201
    a2fe:	30 e0       	ldi	r19, 0x00	; 0
    a300:	33 8b       	std	Z+19, r19	; 0x13
    a302:	22 8b       	std	Z+18, r18	; 0x12
    a304:	2a ec       	ldi	r18, 0xCA	; 202
    a306:	30 e0       	ldi	r19, 0x00	; 0
    a308:	35 8b       	std	Z+21, r19	; 0x15
    a30a:	24 8b       	std	Z+20, r18	; 0x14
    a30c:	2e ec       	ldi	r18, 0xCE	; 206
    a30e:	30 e0       	ldi	r19, 0x00	; 0
    a310:	37 8b       	std	Z+23, r19	; 0x17
    a312:	26 8b       	std	Z+22, r18	; 0x16
    a314:	11 8e       	std	Z+25, r1	; 0x19
    a316:	12 8e       	std	Z+26, r1	; 0x1a
    a318:	13 8e       	std	Z+27, r1	; 0x1b
    a31a:	14 8e       	std	Z+28, r1	; 0x1c
    a31c:	e2 e5       	ldi	r30, 0x52	; 82
    a31e:	fe e0       	ldi	r31, 0x0E	; 14
    a320:	13 82       	std	Z+3, r1	; 0x03
    a322:	12 82       	std	Z+2, r1	; 0x02
    a324:	c4 82       	std	Z+4, r12	; 0x04
    a326:	d5 82       	std	Z+5, r13	; 0x05
    a328:	e6 82       	std	Z+6, r14	; 0x06
    a32a:	f7 82       	std	Z+7, r15	; 0x07
    a32c:	91 83       	std	Z+1, r25	; 0x01
    a32e:	80 83       	st	Z, r24
    a330:	85 ec       	ldi	r24, 0xC5	; 197
    a332:	90 e0       	ldi	r25, 0x00	; 0
    a334:	95 87       	std	Z+13, r25	; 0x0d
    a336:	84 87       	std	Z+12, r24	; 0x0c
    a338:	84 ec       	ldi	r24, 0xC4	; 196
    a33a:	90 e0       	ldi	r25, 0x00	; 0
    a33c:	97 87       	std	Z+15, r25	; 0x0f
    a33e:	86 87       	std	Z+14, r24	; 0x0e
    a340:	80 ec       	ldi	r24, 0xC0	; 192
    a342:	90 e0       	ldi	r25, 0x00	; 0
    a344:	91 8b       	std	Z+17, r25	; 0x11
    a346:	80 8b       	std	Z+16, r24	; 0x10
    a348:	81 ec       	ldi	r24, 0xC1	; 193
    a34a:	90 e0       	ldi	r25, 0x00	; 0
    a34c:	93 8b       	std	Z+19, r25	; 0x13
    a34e:	82 8b       	std	Z+18, r24	; 0x12
    a350:	82 ec       	ldi	r24, 0xC2	; 194
    a352:	90 e0       	ldi	r25, 0x00	; 0
    a354:	95 8b       	std	Z+21, r25	; 0x15
    a356:	84 8b       	std	Z+20, r24	; 0x14
    a358:	86 ec       	ldi	r24, 0xC6	; 198
    a35a:	90 e0       	ldi	r25, 0x00	; 0
    a35c:	97 8b       	std	Z+23, r25	; 0x17
    a35e:	86 8b       	std	Z+22, r24	; 0x16
    a360:	11 8e       	std	Z+25, r1	; 0x19
    a362:	12 8e       	std	Z+26, r1	; 0x1a
    a364:	13 8e       	std	Z+27, r1	; 0x1b
    a366:	14 8e       	std	Z+28, r1	; 0x1c
    a368:	8f ef       	ldi	r24, 0xFF	; 255
    a36a:	9f ef       	ldi	r25, 0xFF	; 255
    a36c:	90 93 f0 0e 	sts	0x0EF0, r25	; 0x800ef0 <Watchdog+0x1>
    a370:	80 93 ef 0e 	sts	0x0EEF, r24	; 0x800eef <Watchdog>
    a374:	e1 ef       	ldi	r30, 0xF1	; 241
    a376:	fe e0       	ldi	r31, 0x0E	; 14
    a378:	80 e5       	ldi	r24, 0x50	; 80
    a37a:	80 83       	st	Z, r24
    a37c:	11 82       	std	Z+1, r1	; 0x01
    a37e:	e3 ef       	ldi	r30, 0xF3	; 243
    a380:	fe e0       	ldi	r31, 0x0E	; 14
    a382:	15 82       	std	Z+5, r1	; 0x05
    a384:	16 82       	std	Z+6, r1	; 0x06
    a386:	11 86       	std	Z+9, r1	; 0x09
    a388:	13 86       	std	Z+11, r1	; 0x0b
    a38a:	82 e0       	ldi	r24, 0x02	; 2
    a38c:	90 e0       	ldi	r25, 0x00	; 0
    a38e:	a0 e0       	ldi	r26, 0x00	; 0
    a390:	b0 e0       	ldi	r27, 0x00	; 0
    a392:	84 87       	std	Z+12, r24	; 0x0c
    a394:	95 87       	std	Z+13, r25	; 0x0d
    a396:	a6 87       	std	Z+14, r26	; 0x0e
    a398:	b7 87       	std	Z+15, r27	; 0x0f
    a39a:	13 a2       	std	Z+35, r1	; 0x23
    a39c:	15 a6       	std	Z+45, r1	; 0x2d
    a39e:	14 a6       	std	Z+44, r1	; 0x2c
    a3a0:	8d e0       	ldi	r24, 0x0D	; 13
    a3a2:	93 e0       	ldi	r25, 0x03	; 3
    a3a4:	93 a7       	std	Z+43, r25	; 0x2b
    a3a6:	82 a7       	std	Z+42, r24	; 0x2a
    a3a8:	17 a6       	std	Z+47, r1	; 0x2f
    a3aa:	ec e3       	ldi	r30, 0x3C	; 60
    a3ac:	ff e0       	ldi	r31, 0x0F	; 15
    a3ae:	13 82       	std	Z+3, r1	; 0x03
    a3b0:	12 82       	std	Z+2, r1	; 0x02
    a3b2:	c4 82       	std	Z+4, r12	; 0x04
    a3b4:	d5 82       	std	Z+5, r13	; 0x05
    a3b6:	e6 82       	std	Z+6, r14	; 0x06
    a3b8:	f7 82       	std	Z+7, r15	; 0x07
    a3ba:	89 e1       	ldi	r24, 0x19	; 25
    a3bc:	93 e0       	ldi	r25, 0x03	; 3
    a3be:	91 83       	std	Z+1, r25	; 0x01
    a3c0:	80 83       	st	Z, r24
    a3c2:	e0 e6       	ldi	r30, 0x60	; 96
    a3c4:	f2 e1       	ldi	r31, 0x12	; 18
    a3c6:	80 e0       	ldi	r24, 0x00	; 0
    a3c8:	91 e0       	ldi	r25, 0x01	; 1
    a3ca:	df 01       	movw	r26, r30
    a3cc:	9c 01       	movw	r18, r24
    a3ce:	1d 92       	st	X+, r1
    a3d0:	21 50       	subi	r18, 0x01	; 1
    a3d2:	30 40       	sbci	r19, 0x00	; 0
    a3d4:	e1 f7       	brne	.-8      	; 0xa3ce <global constructors keyed to 65535_0_Drifter_Mega_V3.0.cpp.o.6099+0x1b6>
    a3d6:	e8 e5       	ldi	r30, 0x58	; 88
    a3d8:	f2 e1       	ldi	r31, 0x12	; 18
    a3da:	10 92 61 13 	sts	0x1361, r1	; 0x801361 <customKeypad+0x109>
    a3de:	10 92 60 13 	sts	0x1360, r1	; 0x801360 <customKeypad+0x108>
    a3e2:	10 92 63 13 	sts	0x1363, r1	; 0x801363 <customKeypad+0x10b>
    a3e6:	10 92 62 13 	sts	0x1362, r1	; 0x801362 <customKeypad+0x10a>
    a3ea:	85 e4       	ldi	r24, 0x45	; 69
    a3ec:	93 e0       	ldi	r25, 0x03	; 3
    a3ee:	91 83       	std	Z+1, r25	; 0x01
    a3f0:	80 83       	st	Z, r24
    a3f2:	8f e9       	ldi	r24, 0x9F	; 159
    a3f4:	92 e0       	ldi	r25, 0x02	; 2
    a3f6:	93 83       	std	Z+3, r25	; 0x03
    a3f8:	82 83       	std	Z+2, r24	; 0x02
    a3fa:	8b e9       	ldi	r24, 0x9B	; 155
    a3fc:	92 e0       	ldi	r25, 0x02	; 2
    a3fe:	95 83       	std	Z+5, r25	; 0x05
    a400:	84 83       	std	Z+4, r24	; 0x04
    a402:	84 e0       	ldi	r24, 0x04	; 4
    a404:	90 e0       	ldi	r25, 0x00	; 0
    a406:	90 93 65 13 	sts	0x1365, r25	; 0x801365 <customKeypad+0x10d>
    a40a:	80 93 64 13 	sts	0x1364, r24	; 0x801364 <customKeypad+0x10c>
    a40e:	90 93 67 13 	sts	0x1367, r25	; 0x801367 <customKeypad+0x10f>
    a412:	80 93 66 13 	sts	0x1366, r24	; 0x801366 <customKeypad+0x10e>
    a416:	17 82       	std	Z+7, r1	; 0x07
    a418:	16 82       	std	Z+6, r1	; 0x06
    a41a:	e2 e3       	ldi	r30, 0x32	; 50
    a41c:	f2 e1       	ldi	r31, 0x12	; 18
    a41e:	81 e0       	ldi	r24, 0x01	; 1
    a420:	90 e0       	ldi	r25, 0x00	; 0
    a422:	a0 e0       	ldi	r26, 0x00	; 0
    a424:	b0 e0       	ldi	r27, 0x00	; 0
    a426:	80 83       	st	Z, r24
    a428:	91 83       	std	Z+1, r25	; 0x01
    a42a:	a2 83       	std	Z+2, r26	; 0x02
    a42c:	b3 83       	std	Z+3, r27	; 0x03
    a42e:	14 82       	std	Z+4, r1	; 0x04
    a430:	15 82       	std	Z+5, r1	; 0x05
    a432:	16 82       	std	Z+6, r1	; 0x06
    a434:	17 82       	std	Z+7, r1	; 0x07
    a436:	10 86       	std	Z+8, r1	; 0x08
    a438:	11 86       	std	Z+9, r1	; 0x09
    a43a:	12 86       	std	Z+10, r1	; 0x0a
    a43c:	13 86       	std	Z+11, r1	; 0x0b
    a43e:	10 8a       	std	Z+16, r1	; 0x10
    a440:	11 8a       	std	Z+17, r1	; 0x11
    a442:	12 8a       	std	Z+18, r1	; 0x12
    a444:	13 8a       	std	Z+19, r1	; 0x13
    a446:	10 8e       	std	Z+24, r1	; 0x18
    a448:	81 8f       	std	Z+25, r24	; 0x19
    a44a:	15 a2       	std	Z+37, r1	; 0x25
    a44c:	14 a2       	std	Z+36, r1	; 0x24
    a44e:	14 86       	std	Z+12, r1	; 0x0c
    a450:	15 86       	std	Z+13, r1	; 0x0d
    a452:	16 86       	std	Z+14, r1	; 0x0e
    a454:	17 86       	std	Z+15, r1	; 0x0f
    a456:	e5 e8       	ldi	r30, 0x85	; 133
    a458:	f1 e1       	ldi	r31, 0x11	; 17
    a45a:	10 82       	st	Z, r1
    a45c:	11 82       	std	Z+1, r1	; 0x01
    a45e:	13 82       	std	Z+3, r1	; 0x03
    a460:	12 82       	std	Z+2, r1	; 0x02
    a462:	14 82       	std	Z+4, r1	; 0x04
    a464:	15 82       	std	Z+5, r1	; 0x05
    a466:	16 82       	std	Z+6, r1	; 0x06
    a468:	17 82       	std	Z+7, r1	; 0x07
    a46a:	10 86       	std	Z+8, r1	; 0x08
    a46c:	12 86       	std	Z+10, r1	; 0x0a
    a46e:	11 86       	std	Z+9, r1	; 0x09
    a470:	13 86       	std	Z+11, r1	; 0x0b
    a472:	14 86       	std	Z+12, r1	; 0x0c
    a474:	15 86       	std	Z+13, r1	; 0x0d
    a476:	16 86       	std	Z+14, r1	; 0x0e
    a478:	17 86       	std	Z+15, r1	; 0x0f
    a47a:	11 8a       	std	Z+17, r1	; 0x11
    a47c:	10 8a       	std	Z+16, r1	; 0x10
    a47e:	12 8a       	std	Z+18, r1	; 0x12
    a480:	13 8a       	std	Z+19, r1	; 0x13
    a482:	14 8a       	std	Z+20, r1	; 0x14
    a484:	15 8a       	std	Z+21, r1	; 0x15
    a486:	16 8a       	std	Z+22, r1	; 0x16
    a488:	10 8e       	std	Z+24, r1	; 0x18
    a48a:	17 8a       	std	Z+23, r1	; 0x17
    a48c:	11 8e       	std	Z+25, r1	; 0x19
    a48e:	12 8e       	std	Z+26, r1	; 0x1a
    a490:	13 8e       	std	Z+27, r1	; 0x1b
    a492:	14 8e       	std	Z+28, r1	; 0x1c
    a494:	15 8e       	std	Z+29, r1	; 0x1d
    a496:	12 a2       	std	Z+34, r1	; 0x22
    a498:	13 a2       	std	Z+35, r1	; 0x23
    a49a:	14 a2       	std	Z+36, r1	; 0x24
    a49c:	15 a2       	std	Z+37, r1	; 0x25
    a49e:	16 a2       	std	Z+38, r1	; 0x26
    a4a0:	17 a2       	std	Z+39, r1	; 0x27
    a4a2:	10 aa       	std	Z+48, r1	; 0x30
    a4a4:	11 aa       	std	Z+49, r1	; 0x31
    a4a6:	12 aa       	std	Z+50, r1	; 0x32
    a4a8:	13 aa       	std	Z+51, r1	; 0x33
    a4aa:	14 aa       	std	Z+52, r1	; 0x34
    a4ac:	15 aa       	std	Z+53, r1	; 0x35
    a4ae:	16 ae       	std	Z+62, r1	; 0x3e
    a4b0:	17 ae       	std	Z+63, r1	; 0x3f
    a4b2:	10 92 c9 11 	sts	0x11C9, r1	; 0x8011c9 <gps+0x44>
    a4b6:	10 92 ca 11 	sts	0x11CA, r1	; 0x8011ca <gps+0x45>
    a4ba:	10 92 cb 11 	sts	0x11CB, r1	; 0x8011cb <gps+0x46>
    a4be:	10 92 cc 11 	sts	0x11CC, r1	; 0x8011cc <gps+0x47>
    a4c2:	10 92 d1 11 	sts	0x11D1, r1	; 0x8011d1 <gps+0x4c>
    a4c6:	10 92 d2 11 	sts	0x11D2, r1	; 0x8011d2 <gps+0x4d>
    a4ca:	10 92 d7 11 	sts	0x11D7, r1	; 0x8011d7 <gps+0x52>
    a4ce:	10 92 d8 11 	sts	0x11D8, r1	; 0x8011d8 <gps+0x53>
    a4d2:	10 92 d9 11 	sts	0x11D9, r1	; 0x8011d9 <gps+0x54>
    a4d6:	10 92 da 11 	sts	0x11DA, r1	; 0x8011da <gps+0x55>
    a4da:	10 92 df 11 	sts	0x11DF, r1	; 0x8011df <gps+0x5a>
    a4de:	10 92 e0 11 	sts	0x11E0, r1	; 0x8011e0 <gps+0x5b>
    a4e2:	10 92 e5 11 	sts	0x11E5, r1	; 0x8011e5 <gps+0x60>
    a4e6:	10 92 e6 11 	sts	0x11E6, r1	; 0x8011e6 <gps+0x61>
    a4ea:	10 92 e7 11 	sts	0x11E7, r1	; 0x8011e7 <gps+0x62>
    a4ee:	10 92 e8 11 	sts	0x11E8, r1	; 0x8011e8 <gps+0x63>
    a4f2:	10 92 ed 11 	sts	0x11ED, r1	; 0x8011ed <gps+0x68>
    a4f6:	10 92 ee 11 	sts	0x11EE, r1	; 0x8011ee <gps+0x69>
    a4fa:	10 92 f3 11 	sts	0x11F3, r1	; 0x8011f3 <gps+0x6e>
    a4fe:	10 92 f4 11 	sts	0x11F4, r1	; 0x8011f4 <gps+0x6f>
    a502:	10 92 f5 11 	sts	0x11F5, r1	; 0x8011f5 <gps+0x70>
    a506:	10 92 f6 11 	sts	0x11F6, r1	; 0x8011f6 <gps+0x71>
    a50a:	10 92 fb 11 	sts	0x11FB, r1	; 0x8011fb <gps+0x76>
    a50e:	10 92 fc 11 	sts	0x11FC, r1	; 0x8011fc <gps+0x77>
    a512:	10 92 01 12 	sts	0x1201, r1	; 0x801201 <gps+0x7c>
    a516:	10 92 02 12 	sts	0x1202, r1	; 0x801202 <gps+0x7d>
    a51a:	10 92 03 12 	sts	0x1203, r1	; 0x801203 <gps+0x7e>
    a51e:	10 92 04 12 	sts	0x1204, r1	; 0x801204 <gps+0x7f>
    a522:	10 92 09 12 	sts	0x1209, r1	; 0x801209 <gps+0x84>
    a526:	10 92 0a 12 	sts	0x120A, r1	; 0x80120a <gps+0x85>
    a52a:	82 e0       	ldi	r24, 0x02	; 2
    a52c:	80 93 1a 12 	sts	0x121A, r24	; 0x80121a <gps+0x95>
    a530:	10 92 1b 12 	sts	0x121B, r1	; 0x80121b <gps+0x96>
    a534:	10 92 1c 12 	sts	0x121C, r1	; 0x80121c <gps+0x97>
    a538:	10 92 1d 12 	sts	0x121D, r1	; 0x80121d <gps+0x98>
    a53c:	10 92 1f 12 	sts	0x121F, r1	; 0x80121f <gps+0x9a>
    a540:	10 92 1e 12 	sts	0x121E, r1	; 0x80121e <gps+0x99>
    a544:	10 92 21 12 	sts	0x1221, r1	; 0x801221 <gps+0x9c>
    a548:	10 92 20 12 	sts	0x1220, r1	; 0x801220 <gps+0x9b>
    a54c:	10 92 22 12 	sts	0x1222, r1	; 0x801222 <gps+0x9d>
    a550:	10 92 23 12 	sts	0x1223, r1	; 0x801223 <gps+0x9e>
    a554:	10 92 24 12 	sts	0x1224, r1	; 0x801224 <gps+0x9f>
    a558:	10 92 25 12 	sts	0x1225, r1	; 0x801225 <gps+0xa0>
    a55c:	10 92 26 12 	sts	0x1226, r1	; 0x801226 <gps+0xa1>
    a560:	10 92 27 12 	sts	0x1227, r1	; 0x801227 <gps+0xa2>
    a564:	10 92 28 12 	sts	0x1228, r1	; 0x801228 <gps+0xa3>
    a568:	10 92 29 12 	sts	0x1229, r1	; 0x801229 <gps+0xa4>
    a56c:	10 92 2a 12 	sts	0x122A, r1	; 0x80122a <gps+0xa5>
    a570:	10 92 2b 12 	sts	0x122B, r1	; 0x80122b <gps+0xa6>
    a574:	10 92 2c 12 	sts	0x122C, r1	; 0x80122c <gps+0xa7>
    a578:	10 92 2d 12 	sts	0x122D, r1	; 0x80122d <gps+0xa8>
    a57c:	10 92 2e 12 	sts	0x122E, r1	; 0x80122e <gps+0xa9>
    a580:	10 92 2f 12 	sts	0x122F, r1	; 0x80122f <gps+0xaa>
    a584:	10 92 30 12 	sts	0x1230, r1	; 0x801230 <gps+0xab>
    a588:	10 92 31 12 	sts	0x1231, r1	; 0x801231 <gps+0xac>
    a58c:	10 92 0b 12 	sts	0x120B, r1	; 0x80120b <gps+0x86>
    a590:	63 ea       	ldi	r22, 0xA3	; 163
    a592:	73 e0       	ldi	r23, 0x03	; 3
    a594:	8f e7       	ldi	r24, 0x7F	; 127
    a596:	91 e1       	ldi	r25, 0x11	; 17
    a598:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    a59c:	63 ea       	ldi	r22, 0xA3	; 163
    a59e:	73 e0       	ldi	r23, 0x03	; 3
    a5a0:	89 e7       	ldi	r24, 0x79	; 121
    a5a2:	91 e1       	ldi	r25, 0x11	; 17
    a5a4:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    a5a8:	63 ea       	ldi	r22, 0xA3	; 163
    a5aa:	73 e0       	ldi	r23, 0x03	; 3
    a5ac:	83 e7       	ldi	r24, 0x73	; 115
    a5ae:	91 e1       	ldi	r25, 0x11	; 17
    a5b0:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    a5b4:	c4 e5       	ldi	r28, 0x54	; 84
    a5b6:	d1 e1       	ldi	r29, 0x11	; 17
    a5b8:	85 e3       	ldi	r24, 0x35	; 53
    a5ba:	8b 87       	std	Y+11, r24	; 0x0b
    a5bc:	1f ef       	ldi	r17, 0xFF	; 255
    a5be:	1e 87       	std	Y+14, r17	; 0x0e
    a5c0:	1d 87       	std	Y+13, r17	; 0x0d
    a5c2:	1c 87       	std	Y+12, r17	; 0x0c
    a5c4:	83 e5       	ldi	r24, 0x53	; 83
    a5c6:	91 e1       	ldi	r25, 0x11	; 17
    a5c8:	99 83       	std	Y+1, r25	; 0x01
    a5ca:	88 83       	st	Y, r24
    a5cc:	1b 8e       	std	Y+27, r1	; 0x1b
    a5ce:	82 e0       	ldi	r24, 0x02	; 2
    a5d0:	90 e0       	ldi	r25, 0x00	; 0
    a5d2:	0e 94 d8 62 	call	0xc5b0	; 0xc5b0 <malloc>
    a5d6:	25 e5       	ldi	r18, 0x55	; 85
    a5d8:	dc 01       	movw	r26, r24
    a5da:	2c 93       	st	X, r18
    a5dc:	11 96       	adiw	r26, 0x01	; 1
    a5de:	1c 92       	st	X, r1
    a5e0:	9b 83       	std	Y+3, r25	; 0x03
    a5e2:	8a 83       	std	Y+2, r24	; 0x02
    a5e4:	80 e4       	ldi	r24, 0x40	; 64
    a5e6:	92 e4       	ldi	r25, 0x42	; 66
    a5e8:	af e0       	ldi	r26, 0x0F	; 15
    a5ea:	b0 e0       	ldi	r27, 0x00	; 0
    a5ec:	8c 83       	std	Y+4, r24	; 0x04
    a5ee:	9d 83       	std	Y+5, r25	; 0x05
    a5f0:	ae 83       	std	Y+6, r26	; 0x06
    a5f2:	bf 83       	std	Y+7, r27	; 0x07
    a5f4:	81 e0       	ldi	r24, 0x01	; 1
    a5f6:	90 e0       	ldi	r25, 0x00	; 0
    a5f8:	99 87       	std	Y+9, r25	; 0x09
    a5fa:	88 87       	std	Y+8, r24	; 0x08
    a5fc:	04 e0       	ldi	r16, 0x04	; 4
    a5fe:	0a 87       	std	Y+10, r16	; 0x0a
    a600:	1c 8e       	std	Y+28, r1	; 0x1c
    a602:	cd e2       	ldi	r28, 0x2D	; 45
    a604:	d1 e1       	ldi	r29, 0x11	; 17
    a606:	87 e7       	ldi	r24, 0x77	; 119
    a608:	88 83       	st	Y, r24
    a60a:	84 e1       	ldi	r24, 0x14	; 20
    a60c:	e3 ee       	ldi	r30, 0xE3	; 227
    a60e:	f2 e0       	ldi	r31, 0x02	; 2
    a610:	ae e2       	ldi	r26, 0x2E	; 46
    a612:	b1 e1       	ldi	r27, 0x11	; 17
    a614:	01 90       	ld	r0, Z+
    a616:	0d 92       	st	X+, r0
    a618:	8a 95       	dec	r24
    a61a:	e1 f7       	brne	.-8      	; 0xa614 <global constructors keyed to 65535_0_Drifter_Mega_V3.0.cpp.o.6099+0x3fc>
    a61c:	1d a2       	std	Y+37, r1	; 0x25
    a61e:	63 ea       	ldi	r22, 0xA3	; 163
    a620:	73 e0       	ldi	r23, 0x03	; 3
    a622:	87 e2       	ldi	r24, 0x27	; 39
    a624:	91 e1       	ldi	r25, 0x11	; 17
    a626:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    a62a:	ec e0       	ldi	r30, 0x0C	; 12
    a62c:	f1 e1       	ldi	r31, 0x11	; 17
    a62e:	13 82       	std	Z+3, r1	; 0x03
    a630:	12 82       	std	Z+2, r1	; 0x02
    a632:	c4 82       	std	Z+4, r12	; 0x04
    a634:	d5 82       	std	Z+5, r13	; 0x05
    a636:	e6 82       	std	Z+6, r14	; 0x06
    a638:	f7 82       	std	Z+7, r15	; 0x07
    a63a:	87 e3       	ldi	r24, 0x37	; 55
    a63c:	93 e0       	ldi	r25, 0x03	; 3
    a63e:	91 83       	std	Z+1, r25	; 0x01
    a640:	80 83       	st	Z, r24
    a642:	12 8e       	std	Z+26, r1	; 0x1a
    a644:	11 8e       	std	Z+25, r1	; 0x19
    a646:	14 86       	std	Z+12, r1	; 0x0c
    a648:	63 ea       	ldi	r22, 0xA3	; 163
    a64a:	73 e0       	ldi	r23, 0x03	; 3
    a64c:	86 e0       	ldi	r24, 0x06	; 6
    a64e:	91 e1       	ldi	r25, 0x11	; 17
    a650:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    a654:	e7 ec       	ldi	r30, 0xC7	; 199
    a656:	f0 e1       	ldi	r31, 0x10	; 16
    a658:	15 82       	std	Z+5, r1	; 0x05
    a65a:	14 82       	std	Z+4, r1	; 0x04
    a65c:	17 82       	std	Z+7, r1	; 0x07
    a65e:	16 82       	std	Z+6, r1	; 0x06
    a660:	11 86       	std	Z+9, r1	; 0x09
    a662:	10 86       	std	Z+8, r1	; 0x08
    a664:	13 8b       	std	Z+19, r17	; 0x13
    a666:	14 8b       	std	Z+20, r17	; 0x14
    a668:	15 8b       	std	Z+21, r17	; 0x15
    a66a:	16 8b       	std	Z+22, r17	; 0x16
    a66c:	17 8a       	std	Z+23, r1	; 0x17
    a66e:	10 8e       	std	Z+24, r1	; 0x18
    a670:	11 8e       	std	Z+25, r1	; 0x19
    a672:	12 8e       	std	Z+26, r1	; 0x1a
    a674:	eb eb       	ldi	r30, 0xBB	; 187
    a676:	f0 e1       	ldi	r31, 0x10	; 16
    a678:	13 82       	std	Z+3, r1	; 0x03
    a67a:	12 82       	std	Z+2, r1	; 0x02
    a67c:	8b e2       	ldi	r24, 0x2B	; 43
    a67e:	93 e0       	ldi	r25, 0x03	; 3
    a680:	91 83       	std	Z+1, r25	; 0x01
    a682:	80 83       	st	Z, r24
    a684:	87 e2       	ldi	r24, 0x27	; 39
    a686:	84 83       	std	Z+4, r24	; 0x04
    a688:	84 e1       	ldi	r24, 0x14	; 20
    a68a:	81 87       	std	Z+9, r24	; 0x09
    a68c:	02 87       	std	Z+10, r16	; 0x0a
    a68e:	13 86       	std	Z+11, r1	; 0x0b
    a690:	6b e1       	ldi	r22, 0x1B	; 27
    a692:	70 e0       	ldi	r23, 0x00	; 0
    a694:	82 e7       	ldi	r24, 0x72	; 114
    a696:	90 e1       	ldi	r25, 0x10	; 16
    a698:	0e 94 a9 50 	call	0xa152	; 0xa152 <BlinkControl::BlinkControl(int)>
    a69c:	6d e1       	ldi	r22, 0x1D	; 29
    a69e:	70 e0       	ldi	r23, 0x00	; 0
    a6a0:	89 e2       	ldi	r24, 0x29	; 41
    a6a2:	90 e1       	ldi	r25, 0x10	; 16
    a6a4:	0e 94 a9 50 	call	0xa152	; 0xa152 <BlinkControl::BlinkControl(int)>
    a6a8:	6f e1       	ldi	r22, 0x1F	; 31
    a6aa:	70 e0       	ldi	r23, 0x00	; 0
    a6ac:	80 ee       	ldi	r24, 0xE0	; 224
    a6ae:	9f e0       	ldi	r25, 0x0F	; 15
    a6b0:	0e 94 a9 50 	call	0xa152	; 0xa152 <BlinkControl::BlinkControl(int)>
    a6b4:	61 e2       	ldi	r22, 0x21	; 33
    a6b6:	70 e0       	ldi	r23, 0x00	; 0
    a6b8:	87 e9       	ldi	r24, 0x97	; 151
    a6ba:	9f e0       	ldi	r25, 0x0F	; 15
    a6bc:	0e 94 a9 50 	call	0xa152	; 0xa152 <BlinkControl::BlinkControl(int)>
    a6c0:	63 e2       	ldi	r22, 0x23	; 35
    a6c2:	70 e0       	ldi	r23, 0x00	; 0
    a6c4:	8e e4       	ldi	r24, 0x4E	; 78
    a6c6:	9f e0       	ldi	r25, 0x0F	; 15
    a6c8:	0e 94 a9 50 	call	0xa152	; 0xa152 <BlinkControl::BlinkControl(int)>
    a6cc:	63 ea       	ldi	r22, 0xA3	; 163
    a6ce:	73 e0       	ldi	r23, 0x03	; 3
    a6d0:	88 e4       	ldi	r24, 0x48	; 72
    a6d2:	9f e0       	ldi	r25, 0x0F	; 15
    a6d4:	df 91       	pop	r29
    a6d6:	cf 91       	pop	r28
    a6d8:	1f 91       	pop	r17
    a6da:	0f 91       	pop	r16
    a6dc:	ff 90       	pop	r15
    a6de:	ef 90       	pop	r14
    a6e0:	df 90       	pop	r13
    a6e2:	cf 90       	pop	r12
    a6e4:	0c 94 1f 2c 	jmp	0x583e	; 0x583e <String::String(char const*)>

0000a6e8 <main>:
main():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/main.cpp:34

void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
    a6e8:	cf 93       	push	r28
    a6ea:	df 93       	push	r29
    a6ec:	cd b7       	in	r28, 0x3d	; 61
    a6ee:	de b7       	in	r29, 0x3e	; 62
    a6f0:	aa 97       	sbiw	r28, 0x2a	; 42
    a6f2:	0f b6       	in	r0, 0x3f	; 63
    a6f4:	f8 94       	cli
    a6f6:	de bf       	out	0x3e, r29	; 62
    a6f8:	0f be       	out	0x3f, r0	; 63
    a6fa:	cd bf       	out	0x3d, r28	; 61
init():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:245

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    a6fc:	78 94       	sei
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:251
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    a6fe:	84 b5       	in	r24, 0x24	; 36
    a700:	82 60       	ori	r24, 0x02	; 2
    a702:	84 bd       	out	0x24, r24	; 36
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:252
	sbi(TCCR0A, WGM00);
    a704:	84 b5       	in	r24, 0x24	; 36
    a706:	81 60       	ori	r24, 0x01	; 1
    a708:	84 bd       	out	0x24, r24	; 36
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:265
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    a70a:	85 b5       	in	r24, 0x25	; 37
    a70c:	82 60       	ori	r24, 0x02	; 2
    a70e:	85 bd       	out	0x25, r24	; 37
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:266
	sbi(TCCR0B, CS00);
    a710:	85 b5       	in	r24, 0x25	; 37
    a712:	81 60       	ori	r24, 0x01	; 1
    a714:	85 bd       	out	0x25, r24	; 37
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:279

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    a716:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    a71a:	81 60       	ori	r24, 0x01	; 1
    a71c:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:290
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    a720:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:293

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    a724:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
    a728:	82 60       	ori	r24, 0x02	; 2
    a72a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:295
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    a72e:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
    a732:	81 60       	ori	r24, 0x01	; 1
    a734:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:305
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    a738:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    a73c:	81 60       	ori	r24, 0x01	; 1
    a73e:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:312

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    a742:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
    a746:	84 60       	ori	r24, 0x04	; 4
    a748:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__TEXT_REGION_LENGTH__+0x7000b1>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:321

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    a74c:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
    a750:	81 60       	ori	r24, 0x01	; 1
    a752:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7000b0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:327
//#else
	// Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
    a756:	80 91 91 00 	lds	r24, 0x0091	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    a75a:	82 60       	ori	r24, 0x02	; 2
    a75c:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:328
	sbi(TCCR3B, CS30);
    a760:	80 91 91 00 	lds	r24, 0x0091	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    a764:	81 60       	ori	r24, 0x01	; 1
    a766:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:329
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
    a76a:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
    a76e:	81 60       	ori	r24, 0x01	; 1
    a770:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:341
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
#else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */
#if defined(TCCR4B) && defined(CS41) && defined(WGM40)
	sbi(TCCR4B, CS41);		// set timer 4 prescale factor to 64
    a774:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
    a778:	82 60       	ori	r24, 0x02	; 2
    a77a:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:342
	sbi(TCCR4B, CS40);
    a77e:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
    a782:	81 60       	ori	r24, 0x01	; 1
    a784:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:343
	sbi(TCCR4A, WGM40);		// put timer 4 in 8-bit phase correct pwm mode
    a788:	80 91 a0 00 	lds	r24, 0x00A0	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
    a78c:	81 60       	ori	r24, 0x01	; 1
    a78e:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:348
#endif
#endif /* end timer4 block for ATMEGA1280/2560 and similar */	

#if defined(TCCR5B) && defined(CS51) && defined(WGM50)
	sbi(TCCR5B, CS51);		// set timer 5 prescale factor to 64
    a792:	80 91 21 01 	lds	r24, 0x0121	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
    a796:	82 60       	ori	r24, 0x02	; 2
    a798:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:349
	sbi(TCCR5B, CS50);
    a79c:	80 91 21 01 	lds	r24, 0x0121	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
    a7a0:	81 60       	ori	r24, 0x01	; 1
    a7a2:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:350
	sbi(TCCR5A, WGM50);		// put timer 5 in 8-bit phase correct pwm mode
    a7a6:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
    a7aa:	81 60       	ori	r24, 0x01	; 1
    a7ac:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:356
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    a7b0:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
    a7b4:	84 60       	ori	r24, 0x04	; 4
    a7b6:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:357
		sbi(ADCSRA, ADPS1);
    a7ba:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
    a7be:	82 60       	ori	r24, 0x02	; 2
    a7c0:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:358
		sbi(ADCSRA, ADPS0);
    a7c4:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
    a7c8:	81 60       	ori	r24, 0x01	; 1
    a7ca:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:381
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    a7ce:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
    a7d2:	80 68       	ori	r24, 0x80	; 128
    a7d4:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x70007a>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:390
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    a7d8:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:303
#define batteryV_pin A13

void(*resetFunc) (void) = 0; //declare reset function @ address 0

void setup() {
	strSerial.reserve(50);
    a7dc:	62 e3       	ldi	r22, 0x32	; 50
    a7de:	70 e0       	ldi	r23, 0x00	; 0
    a7e0:	88 e4       	ldi	r24, 0x48	; 72
    a7e2:	9f e0       	ldi	r25, 0x0F	; 15
    a7e4:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:304
	strEC.reserve(20);                           //set aside some bytes for receiving data from Atlas Scientific product
    a7e8:	64 e1       	ldi	r22, 0x14	; 20
    a7ea:	70 e0       	ldi	r23, 0x00	; 0
    a7ec:	87 e2       	ldi	r24, 0x27	; 39
    a7ee:	91 e1       	ldi	r25, 0x11	; 17
    a7f0:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:306
	//strpH.reserve(20);                        //set aside some bytes for receiving data from Atlas Scientific product
	K30Serial.reserve(10);
    a7f4:	6a e0       	ldi	r22, 0x0A	; 10
    a7f6:	70 e0       	ldi	r23, 0x00	; 0
    a7f8:	86 e0       	ldi	r24, 0x06	; 6
    a7fa:	91 e1       	ldi	r25, 0x11	; 17
    a7fc:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:307
	flat.reserve(15);
    a800:	6f e0       	ldi	r22, 0x0F	; 15
    a802:	70 e0       	ldi	r23, 0x00	; 0
    a804:	8f e7       	ldi	r24, 0x7F	; 127
    a806:	91 e1       	ldi	r25, 0x11	; 17
    a808:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:308
	flon.reserve(15);
    a80c:	6f e0       	ldi	r22, 0x0F	; 15
    a80e:	70 e0       	ldi	r23, 0x00	; 0
    a810:	89 e7       	ldi	r24, 0x79	; 121
    a812:	91 e1       	ldi	r25, 0x11	; 17
    a814:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:309
	GPS_datetime.reserve(25);
    a818:	69 e1       	ldi	r22, 0x19	; 25
    a81a:	70 e0       	ldi	r23, 0x00	; 0
    a81c:	83 e7       	ldi	r24, 0x73	; 115
    a81e:	91 e1       	ldi	r25, 0x11	; 17
    a820:	0e 94 de 29 	call	0x53bc	; 0x53bc <String::reserve(unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:311

	pinMode(buzzerpin, OUTPUT);
    a824:	61 e0       	ldi	r22, 0x01	; 1
    a826:	8d e2       	ldi	r24, 0x2D	; 45
    a828:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:312
	pinMode(MAX31856FT, INPUT);
    a82c:	60 e0       	ldi	r22, 0x00	; 0
    a82e:	8e e2       	ldi	r24, 0x2E	; 46
    a830:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:313
	pinMode(MAX31856DR, INPUT);
    a834:	60 e0       	ldi	r22, 0x00	; 0
    a836:	8f e2       	ldi	r24, 0x2F	; 47
    a838:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:314
	pinMode(MAX31856PW, OUTPUT);
    a83c:	61 e0       	ldi	r22, 0x01	; 1
    a83e:	81 e3       	ldi	r24, 0x31	; 49
    a840:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:315
	digitalWrite(MAX31856PW, HIGH);
    a844:	61 e0       	ldi	r22, 0x01	; 1
    a846:	81 e3       	ldi	r24, 0x31	; 49
    a848:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:316
	pinMode(pump_pin, OUTPUT);
    a84c:	61 e0       	ldi	r22, 0x01	; 1
    a84e:	86 e0       	ldi	r24, 0x06	; 6
    a850:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:317
	digitalWrite(pump_pin, LOW);
    a854:	60 e0       	ldi	r22, 0x00	; 0
    a856:	86 e0       	ldi	r24, 0x06	; 6
    a858:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:318
	pinMode(batteryV_pin, INPUT);
    a85c:	60 e0       	ldi	r22, 0x00	; 0
    a85e:	83 e4       	ldi	r24, 0x43	; 67
    a860:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:321

	//Set pin6 PWM to Fast PMW mode (62kHz), affect to pin 6,7,8
	TCCR4A = 0xA9;
    a864:	89 ea       	ldi	r24, 0xA9	; 169
    a866:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:322
	TCCR4B = 0x09;
    a86a:	89 e0       	ldi	r24, 0x09	; 9
    a86c:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
begin():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.h:121
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    a870:	40 e0       	ldi	r20, 0x00	; 0
    a872:	52 ec       	ldi	r21, 0xC2	; 194
    a874:	61 e0       	ldi	r22, 0x01	; 1
    a876:	70 e0       	ldi	r23, 0x00	; 0
    a878:	82 e5       	ldi	r24, 0x52	; 82
    a87a:	9e e0       	ldi	r25, 0x0E	; 14
    a87c:	0e 94 7f 03 	call	0x6fe	; 0x6fe <HardwareSerial::begin(unsigned long, unsigned char) [clone .constprop.170]>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:325

	Serial.begin(SERIAL_BAUD);
	while (Serial.available() > 0) Serial.read();
    a880:	82 e5       	ldi	r24, 0x52	; 82
    a882:	9e e0       	ldi	r25, 0x0E	; 14
    a884:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <HardwareSerial::available()>
    a888:	18 16       	cp	r1, r24
    a88a:	19 06       	cpc	r1, r25
    a88c:	2c f4       	brge	.+10     	; 0xa898 <main+0x1b0>
    a88e:	82 e5       	ldi	r24, 0x52	; 82
    a890:	9e e0       	ldi	r25, 0x0E	; 14
    a892:	0e 94 ca 06 	call	0xd94	; 0xd94 <HardwareSerial::read()>
    a896:	f4 cf       	rjmp	.-24     	; 0xa880 <main+0x198>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:326
	Wire.begin();
    a898:	0e 94 a5 1a 	call	0x354a	; 0x354a <TwoWire::begin() [clone .constprop.113]>
init_priv():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:61
	init_priv();
}

void LiquidCrystal_I2C::init_priv()
{
	Wire.begin();
    a89c:	0e 94 a5 1a 	call	0x354a	; 0x354a <TwoWire::begin() [clone .constprop.113]>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:62
	_displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
    a8a0:	10 92 c0 10 	sts	0x10C0, r1	; 0x8010c0 <lcd+0x5>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:63
	begin(_cols, _rows);  
    a8a4:	80 91 c5 10 	lds	r24, 0x10C5	; 0x8010c5 <lcd+0xa>
begin():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:67
}

void LiquidCrystal_I2C::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {
	if (lines > 1) {
    a8a8:	82 30       	cpi	r24, 0x02	; 2
    a8aa:	18 f0       	brcs	.+6      	; 0xa8b2 <main+0x1ca>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:68
		_displayfunction |= LCD_2LINE;
    a8ac:	98 e0       	ldi	r25, 0x08	; 8
    a8ae:	90 93 c0 10 	sts	0x10C0, r25	; 0x8010c0 <lcd+0x5>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:70
	}
	_numlines = lines;
    a8b2:	80 93 c3 10 	sts	0x10C3, r24	; 0x8010c3 <lcd+0x8>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:80
	}

	// SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
	// according to datasheet, we need at least 40ms after power rises above 2.7V
	// before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50
	delay(50); 
    a8b6:	62 e3       	ldi	r22, 0x32	; 50
    a8b8:	70 e0       	ldi	r23, 0x00	; 0
    a8ba:	80 e0       	ldi	r24, 0x00	; 0
    a8bc:	90 e0       	ldi	r25, 0x00	; 0
    a8be:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:83
  
	// Now we pull both RS and R/W low to begin commands
	expanderWrite(_backlightval);	// reset expanderand turn backlight off (Bit 8 =1)
    a8c2:	60 91 c6 10 	lds	r22, 0x10C6	; 0x8010c6 <lcd+0xb>
    a8c6:	8b eb       	ldi	r24, 0xBB	; 187
    a8c8:	90 e1       	ldi	r25, 0x10	; 16
    a8ca:	0e 94 46 1d 	call	0x3a8c	; 0x3a8c <LiquidCrystal_I2C::expanderWrite(unsigned char)>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:84
	delay(1000);
    a8ce:	68 ee       	ldi	r22, 0xE8	; 232
    a8d0:	73 e0       	ldi	r23, 0x03	; 3
    a8d2:	80 e0       	ldi	r24, 0x00	; 0
    a8d4:	90 e0       	ldi	r25, 0x00	; 0
    a8d6:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:91
  	//put the LCD into 4 bit mode
	// this is according to the hitachi HD44780 datasheet
	// figure 24, pg 46
	
	  // we start in 8bit mode, try to set 4 bit mode
   write4bits(0x03 << 4);
    a8da:	60 e3       	ldi	r22, 0x30	; 48
    a8dc:	8b eb       	ldi	r24, 0xBB	; 187
    a8de:	90 e1       	ldi	r25, 0x10	; 16
    a8e0:	0e 94 83 22 	call	0x4506	; 0x4506 <LiquidCrystal_I2C::write4bits(unsigned char)>
delayMicroseconds():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:234
	

#endif

	// busy wait
	__asm__ __volatile__ (
    a8e4:	0b e4       	ldi	r16, 0x4B	; 75
    a8e6:	16 e4       	ldi	r17, 0x46	; 70
    a8e8:	c8 01       	movw	r24, r16
    a8ea:	01 97       	sbiw	r24, 0x01	; 1
    a8ec:	f1 f7       	brne	.-4      	; 0xa8ea <main+0x202>
begin():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:95
   delayMicroseconds(4500); // wait min 4.1ms
   
   // second try
   write4bits(0x03 << 4);
    a8ee:	60 e3       	ldi	r22, 0x30	; 48
    a8f0:	8b eb       	ldi	r24, 0xBB	; 187
    a8f2:	90 e1       	ldi	r25, 0x10	; 16
    a8f4:	0e 94 83 22 	call	0x4506	; 0x4506 <LiquidCrystal_I2C::write4bits(unsigned char)>
delayMicroseconds():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:234
    a8f8:	c8 01       	movw	r24, r16
    a8fa:	01 97       	sbiw	r24, 0x01	; 1
    a8fc:	f1 f7       	brne	.-4      	; 0xa8fa <main+0x212>
begin():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:99
   delayMicroseconds(4500); // wait min 4.1ms
   
   // third go!
   write4bits(0x03 << 4); 
    a8fe:	60 e3       	ldi	r22, 0x30	; 48
    a900:	8b eb       	ldi	r24, 0xBB	; 187
    a902:	90 e1       	ldi	r25, 0x10	; 16
    a904:	0e 94 83 22 	call	0x4506	; 0x4506 <LiquidCrystal_I2C::write4bits(unsigned char)>
delayMicroseconds():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:234
    a908:	83 e5       	ldi	r24, 0x53	; 83
    a90a:	92 e0       	ldi	r25, 0x02	; 2
    a90c:	01 97       	sbiw	r24, 0x01	; 1
    a90e:	f1 f7       	brne	.-4      	; 0xa90c <main+0x224>
begin():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:103
   delayMicroseconds(150);
   
   // finally, set to 4-bit interface
   write4bits(0x02 << 4); 
    a910:	60 e2       	ldi	r22, 0x20	; 32
    a912:	8b eb       	ldi	r24, 0xBB	; 187
    a914:	90 e1       	ldi	r25, 0x10	; 16
    a916:	0e 94 83 22 	call	0x4506	; 0x4506 <LiquidCrystal_I2C::write4bits(unsigned char)>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:107


	// set # lines, font size, etc.
	command(LCD_FUNCTIONSET | _displayfunction);  
    a91a:	60 91 c0 10 	lds	r22, 0x10C0	; 0x8010c0 <lcd+0x5>
    a91e:	60 62       	ori	r22, 0x20	; 32
command():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:233


/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
    a920:	40 e0       	ldi	r20, 0x00	; 0
    a922:	8b eb       	ldi	r24, 0xBB	; 187
    a924:	90 e1       	ldi	r25, 0x10	; 16
    a926:	0e 94 9c 22 	call	0x4538	; 0x4538 <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
begin():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:110

	// set # lines, font size, etc.
	command(LCD_FUNCTIONSET | _displayfunction);  
	
	// turn the display on with no cursor or blinking default
	_displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
    a92a:	84 e0       	ldi	r24, 0x04	; 4
    a92c:	80 93 c1 10 	sts	0x10C1, r24	; 0x8010c1 <lcd+0x6>
command():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:233


/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
    a930:	40 e0       	ldi	r20, 0x00	; 0
    a932:	6c e0       	ldi	r22, 0x0C	; 12
    a934:	8b eb       	ldi	r24, 0xBB	; 187
    a936:	90 e1       	ldi	r25, 0x10	; 16
    a938:	0e 94 9c 22 	call	0x4538	; 0x4538 <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
begin():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:114
	// turn the display on with no cursor or blinking default
	_displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
	display();
	
	// clear it off
	clear();
    a93c:	0e 94 e5 22 	call	0x45ca	; 0x45ca <LiquidCrystal_I2C::clear() [clone .constprop.143]>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:117
	
	// Initialize to default text direction (for roman languages)
	_displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
    a940:	82 e0       	ldi	r24, 0x02	; 2
    a942:	80 93 c2 10 	sts	0x10C2, r24	; 0x8010c2 <lcd+0x7>
command():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:233


/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystal_I2C::command(uint8_t value) {
	send(value, 0);
    a946:	40 e0       	ldi	r20, 0x00	; 0
    a948:	66 e0       	ldi	r22, 0x06	; 6
    a94a:	8b eb       	ldi	r24, 0xBB	; 187
    a94c:	90 e1       	ldi	r25, 0x10	; 16
    a94e:	0e 94 9c 22 	call	0x4538	; 0x4538 <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
    a952:	40 e0       	ldi	r20, 0x00	; 0
    a954:	62 e0       	ldi	r22, 0x02	; 2
    a956:	8b eb       	ldi	r24, 0xBB	; 187
    a958:	90 e1       	ldi	r25, 0x10	; 16
    a95a:	0e 94 9c 22 	call	0x4538	; 0x4538 <LiquidCrystal_I2C::send(unsigned char, unsigned char)>
delayMicroseconds():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/wiring.c:234
    a95e:	8b e3       	ldi	r24, 0x3B	; 59
    a960:	9f e1       	ldi	r25, 0x1F	; 31
    a962:	01 97       	sbiw	r24, 0x01	; 1
    a964:	f1 f7       	brne	.-4      	; 0xa962 <main+0x27a>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:330
	
	
	lcd.init();
	lcd.createChar(1, pH_Stand);
    a966:	61 e8       	ldi	r22, 0x81	; 129
    a968:	72 e0       	ldi	r23, 0x02	; 2
    a96a:	81 e0       	ldi	r24, 0x01	; 1
    a96c:	0e 94 f6 22 	call	0x45ec	; 0x45ec <LiquidCrystal_I2C::createChar(unsigned char, unsigned char*) [clone .constprop.164]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:331
	lcd.createChar(2, xco2);
    a970:	69 e7       	ldi	r22, 0x79	; 121
    a972:	72 e0       	ldi	r23, 0x02	; 2
    a974:	82 e0       	ldi	r24, 0x02	; 2
    a976:	0e 94 f6 22 	call	0x45ec	; 0x45ec <LiquidCrystal_I2C::createChar(unsigned char, unsigned char*) [clone .constprop.164]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:332
	lcd.createChar(3, EC_Stand);
    a97a:	61 e7       	ldi	r22, 0x71	; 113
    a97c:	72 e0       	ldi	r23, 0x02	; 2
    a97e:	83 e0       	ldi	r24, 0x03	; 3
    a980:	0e 94 f6 22 	call	0x45ec	; 0x45ec <LiquidCrystal_I2C::createChar(unsigned char, unsigned char*) [clone .constprop.164]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:333
	lcd.createChar(4, tsys01_icon);
    a984:	69 e6       	ldi	r22, 0x69	; 105
    a986:	72 e0       	ldi	r23, 0x02	; 2
    a988:	84 e0       	ldi	r24, 0x04	; 4
    a98a:	0e 94 f6 22 	call	0x45ec	; 0x45ec <LiquidCrystal_I2C::createChar(unsigned char, unsigned char*) [clone .constprop.164]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:334
	lcd.createChar(5, k_icon);
    a98e:	61 e6       	ldi	r22, 0x61	; 97
    a990:	72 e0       	ldi	r23, 0x02	; 2
    a992:	85 e0       	ldi	r24, 0x05	; 5
    a994:	0e 94 f6 22 	call	0x45ec	; 0x45ec <LiquidCrystal_I2C::createChar(unsigned char, unsigned char*) [clone .constprop.164]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:335
	lcd.createChar(6, ATM_icon);
    a998:	69 e5       	ldi	r22, 0x59	; 89
    a99a:	72 e0       	ldi	r23, 0x02	; 2
    a99c:	86 e0       	ldi	r24, 0x06	; 6
    a99e:	0e 94 f6 22 	call	0x45ec	; 0x45ec <LiquidCrystal_I2C::createChar(unsigned char, unsigned char*) [clone .constprop.164]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:336
	lcd.createChar(7, RH_icon);
    a9a2:	61 e5       	ldi	r22, 0x51	; 81
    a9a4:	72 e0       	ldi	r23, 0x02	; 2
    a9a6:	87 e0       	ldi	r24, 0x07	; 7
    a9a8:	0e 94 f6 22 	call	0x45ec	; 0x45ec <LiquidCrystal_I2C::createChar(unsigned char, unsigned char*) [clone .constprop.164]>
backlight():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:224
	_backlightval=LCD_NOBACKLIGHT;
	expanderWrite(0);
}

void LiquidCrystal_I2C::backlight(void) {
	_backlightval=LCD_BACKLIGHT;
    a9ac:	88 e0       	ldi	r24, 0x08	; 8
    a9ae:	80 93 c6 10 	sts	0x10C6, r24	; 0x8010c6 <lcd+0xb>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:225
	expanderWrite(0);
    a9b2:	60 e0       	ldi	r22, 0x00	; 0
    a9b4:	8b eb       	ldi	r24, 0xBB	; 187
    a9b6:	90 e1       	ldi	r25, 0x10	; 16
    a9b8:	0e 94 46 1d 	call	0x3a8c	; 0x3a8c <LiquidCrystal_I2C::expanderWrite(unsigned char)>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:338
	lcd.backlight();
	lcd.clear();
    a9bc:	0e 94 e5 22 	call	0x45ca	; 0x45ca <LiquidCrystal_I2C::clear() [clone .constprop.143]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:340

	LCDSerialPrint(F("LED Test"));
    a9c0:	60 ed       	ldi	r22, 0xD0	; 208
    a9c2:	75 e0       	ldi	r23, 0x05	; 5
    a9c4:	8e 01       	movw	r16, r28
    a9c6:	0f 5f       	subi	r16, 0xFF	; 255
    a9c8:	1f 4f       	sbci	r17, 0xFF	; 255
    a9ca:	c8 01       	movw	r24, r16
    a9cc:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    a9d0:	c8 01       	movw	r24, r16
    a9d2:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    a9d6:	c8 01       	movw	r24, r16
    a9d8:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:341
	battery.begin();
    a9dc:	82 e7       	ldi	r24, 0x72	; 114
    a9de:	90 e1       	ldi	r25, 0x10	; 16
    a9e0:	0e 94 f6 24 	call	0x49ec	; 0x49ec <BlinkControl::begin()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:342
	SDIO.begin(); 
    a9e4:	89 e2       	ldi	r24, 0x29	; 41
    a9e6:	90 e1       	ldi	r25, 0x10	; 16
    a9e8:	0e 94 f6 24 	call	0x49ec	; 0x49ec <BlinkControl::begin()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:343
	ThermoER.begin(); 
    a9ec:	80 ee       	ldi	r24, 0xE0	; 224
    a9ee:	9f e0       	ldi	r25, 0x0F	; 15
    a9f0:	0e 94 f6 24 	call	0x49ec	; 0x49ec <BlinkControl::begin()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:345
	//RTCER.begin(); 
	PGER.begin();
    a9f4:	87 e9       	ldi	r24, 0x97	; 151
    a9f6:	9f e0       	ldi	r25, 0x0F	; 15
    a9f8:	0e 94 f6 24 	call	0x49ec	; 0x49ec <BlinkControl::begin()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:346
	RamER.begin();
    a9fc:	8e e4       	ldi	r24, 0x4E	; 78
    a9fe:	9f e0       	ldi	r25, 0x0F	; 15
    aa00:	0e 94 f6 24 	call	0x49ec	; 0x49ec <BlinkControl::begin()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:347
	battery.on();	delay(50);	battery.off();  battery.blink3();		battery.pause();
    aa04:	82 e7       	ldi	r24, 0x72	; 114
    aa06:	90 e1       	ldi	r25, 0x10	; 16
    aa08:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <BlinkControl::on(bool) [clone .constprop.44]>
    aa0c:	62 e3       	ldi	r22, 0x32	; 50
    aa0e:	70 e0       	ldi	r23, 0x00	; 0
    aa10:	80 e0       	ldi	r24, 0x00	; 0
    aa12:	90 e0       	ldi	r25, 0x00	; 0
    aa14:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
    aa18:	82 e7       	ldi	r24, 0x72	; 114
    aa1a:	90 e1       	ldi	r25, 0x10	; 16
    aa1c:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
blink3():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:235
void BlinkControl::blink2() {
  this->blink(this->blinkTiming2, 4);
}

void BlinkControl::blink3() {
  this->blink(this->blinkTiming3, 6);
    aa20:	46 e0       	ldi	r20, 0x06	; 6
    aa22:	50 e0       	ldi	r21, 0x00	; 0
    aa24:	68 e8       	ldi	r22, 0x88	; 136
    aa26:	70 e1       	ldi	r23, 0x10	; 16
    aa28:	82 e7       	ldi	r24, 0x72	; 114
    aa2a:	90 e1       	ldi	r25, 0x10	; 16
    aa2c:	0e 94 0a 25 	call	0x4a14	; 0x4a14 <BlinkControl::blink(int*, int)>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:347
    aa30:	82 e7       	ldi	r24, 0x72	; 114
    aa32:	90 e1       	ldi	r25, 0x10	; 16
    aa34:	0e 94 c4 23 	call	0x4788	; 0x4788 <BlinkControl::pause()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:348
	SDIO.on();		delay(50);	SDIO.off();		SDIO.fastBlinking();	SDIO.pause();
    aa38:	89 e2       	ldi	r24, 0x29	; 41
    aa3a:	90 e1       	ldi	r25, 0x10	; 16
    aa3c:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <BlinkControl::on(bool) [clone .constprop.44]>
    aa40:	62 e3       	ldi	r22, 0x32	; 50
    aa42:	70 e0       	ldi	r23, 0x00	; 0
    aa44:	80 e0       	ldi	r24, 0x00	; 0
    aa46:	90 e0       	ldi	r25, 0x00	; 0
    aa48:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
    aa4c:	89 e2       	ldi	r24, 0x29	; 41
    aa4e:	90 e1       	ldi	r25, 0x10	; 16
    aa50:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
    aa54:	89 e2       	ldi	r24, 0x29	; 41
    aa56:	90 e1       	ldi	r25, 0x10	; 16
    aa58:	0e 94 41 25 	call	0x4a82	; 0x4a82 <BlinkControl::fastBlinking()>
    aa5c:	89 e2       	ldi	r24, 0x29	; 41
    aa5e:	90 e1       	ldi	r25, 0x10	; 16
    aa60:	0e 94 c4 23 	call	0x4788	; 0x4788 <BlinkControl::pause()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:349
	ThermoER.on();	delay(50);	ThermoER.off(); ThermoER.blink3();		ThermoER.pause();
    aa64:	80 ee       	ldi	r24, 0xE0	; 224
    aa66:	9f e0       	ldi	r25, 0x0F	; 15
    aa68:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <BlinkControl::on(bool) [clone .constprop.44]>
    aa6c:	62 e3       	ldi	r22, 0x32	; 50
    aa6e:	70 e0       	ldi	r23, 0x00	; 0
    aa70:	80 e0       	ldi	r24, 0x00	; 0
    aa72:	90 e0       	ldi	r25, 0x00	; 0
    aa74:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
    aa78:	80 ee       	ldi	r24, 0xE0	; 224
    aa7a:	9f e0       	ldi	r25, 0x0F	; 15
    aa7c:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
blink3():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:235
    aa80:	46 e0       	ldi	r20, 0x06	; 6
    aa82:	50 e0       	ldi	r21, 0x00	; 0
    aa84:	66 ef       	ldi	r22, 0xF6	; 246
    aa86:	7f e0       	ldi	r23, 0x0F	; 15
    aa88:	80 ee       	ldi	r24, 0xE0	; 224
    aa8a:	9f e0       	ldi	r25, 0x0F	; 15
    aa8c:	0e 94 0a 25 	call	0x4a14	; 0x4a14 <BlinkControl::blink(int*, int)>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:349
    aa90:	80 ee       	ldi	r24, 0xE0	; 224
    aa92:	9f e0       	ldi	r25, 0x0F	; 15
    aa94:	0e 94 c4 23 	call	0x4788	; 0x4788 <BlinkControl::pause()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:351
	//RTCER.on();		delay(50);	RTCER.off();	RTCER.blink3();			RTCER.pause();
	PGER.on();		delay(50);	PGER.off();		PGER.fastBlinking();	PGER.pause();
    aa98:	87 e9       	ldi	r24, 0x97	; 151
    aa9a:	9f e0       	ldi	r25, 0x0F	; 15
    aa9c:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <BlinkControl::on(bool) [clone .constprop.44]>
    aaa0:	62 e3       	ldi	r22, 0x32	; 50
    aaa2:	70 e0       	ldi	r23, 0x00	; 0
    aaa4:	80 e0       	ldi	r24, 0x00	; 0
    aaa6:	90 e0       	ldi	r25, 0x00	; 0
    aaa8:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
    aaac:	87 e9       	ldi	r24, 0x97	; 151
    aaae:	9f e0       	ldi	r25, 0x0F	; 15
    aab0:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
    aab4:	87 e9       	ldi	r24, 0x97	; 151
    aab6:	9f e0       	ldi	r25, 0x0F	; 15
    aab8:	0e 94 41 25 	call	0x4a82	; 0x4a82 <BlinkControl::fastBlinking()>
    aabc:	87 e9       	ldi	r24, 0x97	; 151
    aabe:	9f e0       	ldi	r25, 0x0F	; 15
    aac0:	0e 94 c4 23 	call	0x4788	; 0x4788 <BlinkControl::pause()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:352
	RamER.on();		delay(50);	RamER.off();	RamER.fastBlinking();	RamER.pause();
    aac4:	8e e4       	ldi	r24, 0x4E	; 78
    aac6:	9f e0       	ldi	r25, 0x0F	; 15
    aac8:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <BlinkControl::on(bool) [clone .constprop.44]>
    aacc:	62 e3       	ldi	r22, 0x32	; 50
    aace:	70 e0       	ldi	r23, 0x00	; 0
    aad0:	80 e0       	ldi	r24, 0x00	; 0
    aad2:	90 e0       	ldi	r25, 0x00	; 0
    aad4:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
    aad8:	8e e4       	ldi	r24, 0x4E	; 78
    aada:	9f e0       	ldi	r25, 0x0F	; 15
    aadc:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
    aae0:	8e e4       	ldi	r24, 0x4E	; 78
    aae2:	9f e0       	ldi	r25, 0x0F	; 15
    aae4:	0e 94 41 25 	call	0x4a82	; 0x4a82 <BlinkControl::fastBlinking()>
    aae8:	8e e4       	ldi	r24, 0x4E	; 78
    aaea:	9f e0       	ldi	r25, 0x0F	; 15
    aaec:	0e 94 c4 23 	call	0x4788	; 0x4788 <BlinkControl::pause()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:354

	LCDSerialPrint(F("Sensor Activate"));
    aaf0:	60 ec       	ldi	r22, 0xC0	; 192
    aaf2:	75 e0       	ldi	r23, 0x05	; 5
    aaf4:	c8 01       	movw	r24, r16
    aaf6:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    aafa:	c8 01       	movw	r24, r16
    aafc:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    ab00:	c8 01       	movw	r24, r16
    ab02:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
begin():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.h:121
    ab06:	40 e8       	ldi	r20, 0x80	; 128
    ab08:	55 e2       	ldi	r21, 0x25	; 37
    ab0a:	60 e0       	ldi	r22, 0x00	; 0
    ab0c:	70 e0       	ldi	r23, 0x00	; 0
    ab0e:	85 eb       	ldi	r24, 0xB5	; 181
    ab10:	9d e0       	ldi	r25, 0x0D	; 13
    ab12:	0e 94 7f 03 	call	0x6fe	; 0x6fe <HardwareSerial::begin(unsigned long, unsigned char) [clone .constprop.170]>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:89
 *    @brief  Initializes SPI bus and sets CS pin high
 *    @return Always returns true because there's no way to test success of SPI
 * init
 */
bool Adafruit_SPIDevice::begin(void) {
  pinMode(_cs, OUTPUT);
    ab16:	61 e0       	ldi	r22, 0x01	; 1
    ab18:	80 91 5f 11 	lds	r24, 0x115F	; 0x80115f <max+0xb>
    ab1c:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:90
  digitalWrite(_cs, HIGH);
    ab20:	61 e0       	ldi	r22, 0x01	; 1
    ab22:	80 91 5f 11 	lds	r24, 0x115F	; 0x80115f <max+0xb>
    ab26:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:92

  if (_spi) { // hardware SPI
    ab2a:	80 91 54 11 	lds	r24, 0x1154	; 0x801154 <max>
    ab2e:	90 91 55 11 	lds	r25, 0x1155	; 0x801155 <max+0x1>
    ab32:	89 2b       	or	r24, r25
    ab34:	09 f4       	brne	.+2      	; 0xab38 <main+0x450>
    ab36:	89 c0       	rjmp	.+274    	; 0xac4a <main+0x562>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:93
    _spi->begin();
    ab38:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <SPIClass::begin()>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:113
    if (_miso != -1) {
      pinMode(_miso, INPUT);
    }
  }

  _begun = true;
    ab3c:	81 e0       	ldi	r24, 0x01	; 1
    ab3e:	80 93 6f 11 	sts	0x116F, r24	; 0x80116f <max+0x1b>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:79
    @returns Always returns true at this time (no known way of detecting chip
   ID)
*/
/**************************************************************************/
bool Adafruit_MAX31856::begin(void) {
  initialized = spi_dev.begin();
    ab42:	80 93 70 11 	sts	0x1170, r24	; 0x801170 <max+0x1c>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:85

  if (!initialized)
    return false;

  // assert on any fault
  writeRegister8(MAX31856_MASK_REG, 0x0);
    ab46:	60 e0       	ldi	r22, 0x00	; 0
    ab48:	82 e0       	ldi	r24, 0x02	; 2
    ab4a:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:88

  // enable open circuit fault detection
  writeRegister8(MAX31856_CR0_REG, MAX31856_CR0_OCFAULT0);
    ab4e:	60 e1       	ldi	r22, 0x10	; 16
    ab50:	80 e0       	ldi	r24, 0x00	; 0
    ab52:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:91

  // set cold junction temperature offset to zero
  writeRegister8(MAX31856_CJTO_REG, 0x0);
    ab56:	60 e0       	ldi	r22, 0x00	; 0
    ab58:	89 e0       	ldi	r24, 0x09	; 9
    ab5a:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:94

  // set Type K by default
  setThermocoupleType(MAX31856_TCTYPE_K);
    ab5e:	0e 94 36 0f 	call	0x1e6c	; 0x1e6c <Adafruit_MAX31856::setThermocoupleType(max31856_thermocoupletype_t) [clone .constprop.24]>
setConversionMode():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:109
    @brief  Set temperature conversion mode
    @param mode The conversion mode
*/
/**************************************************************************/
void Adafruit_MAX31856::setConversionMode(max31856_conversion_mode_t mode) {
  conversionMode = mode;
    ab62:	10 92 72 11 	sts	0x1172, r1	; 0x801172 <max+0x1e>
    ab66:	10 92 71 11 	sts	0x1171, r1	; 0x801171 <max+0x1d>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:110
  uint8_t t = readRegister8(MAX31856_CR0_REG); // get current register value
    ab6a:	80 e0       	ldi	r24, 0x00	; 0
    ab6c:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <Adafruit_MAX31856::readRegister8(unsigned char) [clone .constprop.103]>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:111
  if (conversionMode == MAX31856_CONTINUOUS) {
    ab70:	20 91 71 11 	lds	r18, 0x1171	; 0x801171 <max+0x1d>
    ab74:	30 91 72 11 	lds	r19, 0x1172	; 0x801172 <max+0x1e>
    ab78:	68 2f       	mov	r22, r24
    ab7a:	22 30       	cpi	r18, 0x02	; 2
    ab7c:	31 05       	cpc	r19, r1
    ab7e:	09 f0       	breq	.+2      	; 0xab82 <main+0x49a>
    ab80:	88 c0       	rjmp	.+272    	; 0xac92 <main+0x5aa>
    ab82:	6f 7b       	andi	r22, 0xBF	; 191
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:113
    t |= MAX31856_CR0_AUTOCONVERT; // turn on automatic
    t &= ~MAX31856_CR0_1SHOT;      // turn off one-shot
    ab84:	60 68       	ori	r22, 0x80	; 128
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:118
  } else {
    t &= ~MAX31856_CR0_AUTOCONVERT; // turn off automatic
    t |= MAX31856_CR0_1SHOT;        // turn on one-shot
  }
  writeRegister8(MAX31856_CR0_REG, t); // write value back to register
    ab86:	80 e0       	ldi	r24, 0x00	; 0
    ab88:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:357
	ss.begin(GPS_SERIAL);
	max.begin();
	max.setThermocoupleType(MAX31856_TCTYPE_K);		//Set the type of Thermocouple
    ab8c:	0e 94 36 0f 	call	0x1e6c	; 0x1e6c <Adafruit_MAX31856::setThermocoupleType(max31856_thermocoupletype_t) [clone .constprop.24]>
setTempFaultThreshholds():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:216
  low = flow;

  fhigh *= 16;
  high = fhigh;

  writeRegister8(MAX31856_LTHFTH_REG, high >> 8);
    ab90:	66 e0       	ldi	r22, 0x06	; 6
    ab92:	85 e0       	ldi	r24, 0x05	; 5
    ab94:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:217
  writeRegister8(MAX31856_LTHFTL_REG, high);
    ab98:	60 e4       	ldi	r22, 0x40	; 64
    ab9a:	86 e0       	ldi	r24, 0x06	; 6
    ab9c:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:219

  writeRegister8(MAX31856_LTLFTH_REG, low >> 8);
    aba0:	60 e0       	ldi	r22, 0x00	; 0
    aba2:	87 e0       	ldi	r24, 0x07	; 7
    aba4:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]>
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:220
  writeRegister8(MAX31856_LTLFTL_REG, low);
    aba8:	60 ea       	ldi	r22, 0xA0	; 160
    abaa:	88 e0       	ldi	r24, 0x08	; 8
    abac:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <Adafruit_MAX31856::writeRegister8(unsigned char, unsigned char) [clone .constprop.97]>
begin():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/HardwareSerial.h:121
    abb0:	40 e8       	ldi	r20, 0x80	; 128
    abb2:	55 e2       	ldi	r21, 0x25	; 37
    abb4:	60 e0       	ldi	r22, 0x00	; 0
    abb6:	70 e0       	ldi	r23, 0x00	; 0
    abb8:	88 e1       	ldi	r24, 0x18	; 24
    abba:	9d e0       	ldi	r25, 0x0D	; 13
    abbc:	0e 94 7f 03 	call	0x6fe	; 0x6fe <HardwareSerial::begin(unsigned long, unsigned char) [clone .constprop.170]>
    abc0:	40 e8       	ldi	r20, 0x80	; 128
    abc2:	55 e2       	ldi	r21, 0x25	; 37
    abc4:	60 e0       	ldi	r22, 0x00	; 0
    abc6:	70 e0       	ldi	r23, 0x00	; 0
    abc8:	8b e7       	ldi	r24, 0x7B	; 123
    abca:	9c e0       	ldi	r25, 0x0C	; 12
    abcc:	0e 94 7f 03 	call	0x6fe	; 0x6fe <HardwareSerial::begin(unsigned long, unsigned char) [clone .constprop.170]>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:109
/*!
    @brief  set all the pin modes and set up variables.
*/
/**************************************************************************/
void Adafruit_Keypad::begin() {
  _keystates = (volatile byte *)malloc(_numRows * _numCols);
    abd0:	20 91 64 13 	lds	r18, 0x1364	; 0x801364 <customKeypad+0x10c>
    abd4:	30 91 65 13 	lds	r19, 0x1365	; 0x801365 <customKeypad+0x10d>
    abd8:	80 91 66 13 	lds	r24, 0x1366	; 0x801366 <customKeypad+0x10e>
    abdc:	90 91 67 13 	lds	r25, 0x1367	; 0x801367 <customKeypad+0x10f>
    abe0:	28 9f       	mul	r18, r24
    abe2:	70 01       	movw	r14, r0
    abe4:	29 9f       	mul	r18, r25
    abe6:	f0 0c       	add	r15, r0
    abe8:	38 9f       	mul	r19, r24
    abea:	f0 0c       	add	r15, r0
    abec:	11 24       	eor	r1, r1
    abee:	c7 01       	movw	r24, r14
    abf0:	0e 94 d8 62 	call	0xc5b0	; 0xc5b0 <malloc>
    abf4:	90 93 5f 12 	sts	0x125F, r25	; 0x80125f <customKeypad+0x7>
    abf8:	80 93 5e 12 	sts	0x125E, r24	; 0x80125e <customKeypad+0x6>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:110
  memset((void *)_keystates, 0, _numRows * _numCols);
    abfc:	a7 01       	movw	r20, r14
    abfe:	70 e0       	ldi	r23, 0x00	; 0
    ac00:	60 e0       	ldi	r22, 0x00	; 0
    ac02:	0e 94 ad 6e 	call	0xdd5a	; 0xdd5a <memset>
main():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:112

  for (int i = 0; i < _numCols; i++) {
    ac06:	f1 2c       	mov	r15, r1
    ac08:	e1 2c       	mov	r14, r1
begin():
    ac0a:	80 91 66 13 	lds	r24, 0x1366	; 0x801366 <customKeypad+0x10e>
    ac0e:	90 91 67 13 	lds	r25, 0x1367	; 0x801367 <customKeypad+0x10f>
    ac12:	e8 16       	cp	r14, r24
    ac14:	f9 06       	cpc	r15, r25
    ac16:	0c f0       	brlt	.+2      	; 0xac1a <main+0x532>
    ac18:	3f c0       	rjmp	.+126    	; 0xac98 <main+0x5b0>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:113
    pinMode(_col[i], OUTPUT);
    ac1a:	e0 91 5c 12 	lds	r30, 0x125C	; 0x80125c <customKeypad+0x4>
    ac1e:	f0 91 5d 12 	lds	r31, 0x125D	; 0x80125d <customKeypad+0x5>
    ac22:	ee 0d       	add	r30, r14
    ac24:	ff 1d       	adc	r31, r15
    ac26:	61 e0       	ldi	r22, 0x01	; 1
    ac28:	80 81       	ld	r24, Z
    ac2a:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:114
    digitalWrite(_col[i], HIGH);
    ac2e:	e0 91 5c 12 	lds	r30, 0x125C	; 0x80125c <customKeypad+0x4>
    ac32:	f0 91 5d 12 	lds	r31, 0x125D	; 0x80125d <customKeypad+0x5>
    ac36:	ee 0d       	add	r30, r14
    ac38:	ff 1d       	adc	r31, r15
    ac3a:	61 e0       	ldi	r22, 0x01	; 1
    ac3c:	80 81       	ld	r24, Z
    ac3e:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:112
/**************************************************************************/
void Adafruit_Keypad::begin() {
  _keystates = (volatile byte *)malloc(_numRows * _numCols);
  memset((void *)_keystates, 0, _numRows * _numCols);

  for (int i = 0; i < _numCols; i++) {
    ac42:	2f ef       	ldi	r18, 0xFF	; 255
    ac44:	e2 1a       	sub	r14, r18
    ac46:	f2 0a       	sbc	r15, r18
    ac48:	e0 cf       	rjmp	.-64     	; 0xac0a <main+0x522>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:95
  digitalWrite(_cs, HIGH);

  if (_spi) { // hardware SPI
    _spi->begin();
  } else {
    pinMode(_sck, OUTPUT);
    ac4a:	61 e0       	ldi	r22, 0x01	; 1
    ac4c:	80 91 60 11 	lds	r24, 0x1160	; 0x801160 <max+0xc>
    ac50:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:97

    if ((_dataMode == SPI_MODE0) || (_dataMode == SPI_MODE1)) {
    ac54:	80 91 5e 11 	lds	r24, 0x115E	; 0x80115e <max+0xa>
    ac58:	8b 7f       	andi	r24, 0xFB	; 251
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:99
      // idle low on mode 0 and 1
      digitalWrite(_sck, LOW);
    ac5a:	60 e0       	ldi	r22, 0x00	; 0
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:97
  if (_spi) { // hardware SPI
    _spi->begin();
  } else {
    pinMode(_sck, OUTPUT);

    if ((_dataMode == SPI_MODE0) || (_dataMode == SPI_MODE1)) {
    ac5c:	09 f0       	breq	.+2      	; 0xac60 <main+0x578>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:102
      // idle low on mode 0 and 1
      digitalWrite(_sck, LOW);
    } else {
      // idle high on mode 2 or 3
      digitalWrite(_sck, HIGH);
    ac5e:	61 e0       	ldi	r22, 0x01	; 1
    ac60:	80 91 60 11 	lds	r24, 0x1160	; 0x801160 <max+0xc>
    ac64:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:104
    }
    if (_mosi != -1) {
    ac68:	80 91 61 11 	lds	r24, 0x1161	; 0x801161 <max+0xd>
    ac6c:	8f 3f       	cpi	r24, 0xFF	; 255
    ac6e:	41 f0       	breq	.+16     	; 0xac80 <main+0x598>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:105
      pinMode(_mosi, OUTPUT);
    ac70:	61 e0       	ldi	r22, 0x01	; 1
    ac72:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:106
      digitalWrite(_mosi, HIGH);
    ac76:	61 e0       	ldi	r22, 0x01	; 1
    ac78:	80 91 61 11 	lds	r24, 0x1161	; 0x801161 <max+0xd>
    ac7c:	0e 94 3f 08 	call	0x107e	; 0x107e <digitalWrite>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:108
    }
    if (_miso != -1) {
    ac80:	80 91 62 11 	lds	r24, 0x1162	; 0x801162 <max+0xe>
    ac84:	8f 3f       	cpi	r24, 0xFF	; 255
    ac86:	09 f4       	brne	.+2      	; 0xac8a <main+0x5a2>
    ac88:	59 cf       	rjmp	.-334    	; 0xab3c <main+0x454>
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:109
      pinMode(_miso, INPUT);
    ac8a:	60 e0       	ldi	r22, 0x00	; 0
    ac8c:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
    ac90:	55 cf       	rjmp	.-342    	; 0xab3c <main+0x454>
setConversionMode():
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:115
  uint8_t t = readRegister8(MAX31856_CR0_REG); // get current register value
  if (conversionMode == MAX31856_CONTINUOUS) {
    t |= MAX31856_CR0_AUTOCONVERT; // turn on automatic
    t &= ~MAX31856_CR0_1SHOT;      // turn off one-shot
  } else {
    t &= ~MAX31856_CR0_AUTOCONVERT; // turn off automatic
    ac92:	6f 77       	andi	r22, 0x7F	; 127
D:\USER\Documents\Arduino\libraries\Adafruit_MAX31856_library/Adafruit_MAX31856.cpp:116
    t |= MAX31856_CR0_1SHOT;        // turn on one-shot
    ac94:	60 64       	ori	r22, 0x40	; 64
    ac96:	77 cf       	rjmp	.-274    	; 0xab86 <main+0x49e>
main():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:117
    pinMode(_col[i], OUTPUT);
    digitalWrite(_col[i], HIGH);
  }

  for (int i = 0; i < _numRows; i++) {
    ac98:	f1 2c       	mov	r15, r1
    ac9a:	e1 2c       	mov	r14, r1
begin():
    ac9c:	80 91 64 13 	lds	r24, 0x1364	; 0x801364 <customKeypad+0x10c>
    aca0:	90 91 65 13 	lds	r25, 0x1365	; 0x801365 <customKeypad+0x10d>
    aca4:	e8 16       	cp	r14, r24
    aca6:	f9 06       	cpc	r15, r25
    aca8:	74 f4       	brge	.+28     	; 0xacc6 <main+0x5de>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:118
    pinMode(_row[i], INPUT_PULLUP);
    acaa:	e0 91 5a 12 	lds	r30, 0x125A	; 0x80125a <customKeypad+0x2>
    acae:	f0 91 5b 12 	lds	r31, 0x125B	; 0x80125b <customKeypad+0x3>
    acb2:	ee 0d       	add	r30, r14
    acb4:	ff 1d       	adc	r31, r15
    acb6:	62 e0       	ldi	r22, 0x02	; 2
    acb8:	80 81       	ld	r24, Z
    acba:	0e 94 08 09 	call	0x1210	; 0x1210 <pinMode>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:117
  for (int i = 0; i < _numCols; i++) {
    pinMode(_col[i], OUTPUT);
    digitalWrite(_col[i], HIGH);
  }

  for (int i = 0; i < _numRows; i++) {
    acbe:	3f ef       	ldi	r19, 0xFF	; 255
    acc0:	e3 1a       	sub	r14, r19
    acc2:	f3 0a       	sbc	r15, r19
    acc4:	eb cf       	rjmp	.-42     	; 0xac9c <main+0x5b4>
D:\USER\Documents\Arduino\libraries\TSYS01_Arduino_Library-master\src/tsys01.cpp:30
}

/**
 * \brief Perform initial configuration. Has to be called once.
 */
void tsys01::begin(void) { Wire.begin(); }
    acc6:	0e 94 a5 1a 	call	0x354a	; 0x354a <TwoWire::begin() [clone .constprop.113]>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:84
 *   @param theWire the I2C object to use, defaults to &Wire
 *   @returns true on success, false otherwise
 */
bool Adafruit_BME280::begin(uint8_t addr, TwoWire *theWire) {
  bool status = false;
  _i2caddr = addr;
    acca:	86 e7       	ldi	r24, 0x76	; 118
    accc:	80 93 d1 10 	sts	0x10D1, r24	; 0x8010d1 <bme280+0xa>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:85
  _wire = theWire;
    acd0:	8c e3       	ldi	r24, 0x3C	; 60
    acd2:	9f e0       	ldi	r25, 0x0F	; 15
    acd4:	90 93 c8 10 	sts	0x10C8, r25	; 0x8010c8 <bme280+0x1>
    acd8:	80 93 c7 10 	sts	0x10C7, r24	; 0x8010c7 <bme280>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:86
  status = init();
    acdc:	0e 94 4f 21 	call	0x429e	; 0x429e <Adafruit_BME280::init() [clone .constprop.73]>
setCounter():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:21
{
}

void Countimer::setCounter(uint16_t hours, uint8_t minutes, uint8_t seconds, CountType countType, timer_callback onComplete)
{
	_onComplete = onComplete;
    ace0:	8f e7       	ldi	r24, 0x7F	; 127
    ace2:	98 e2       	ldi	r25, 0x28	; 40
    ace4:	90 93 49 12 	sts	0x1249, r25	; 0x801249 <resetRow1+0x17>
    ace8:	80 93 48 12 	sts	0x1248, r24	; 0x801248 <resetRow1+0x16>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:22
	_countType = countType;
    acec:	82 e0       	ldi	r24, 0x02	; 2
    acee:	90 e0       	ldi	r25, 0x00	; 0
    acf0:	90 93 57 12 	sts	0x1257, r25	; 0x801257 <resetRow1+0x25>
    acf4:	80 93 56 12 	sts	0x1256, r24	; 0x801256 <resetRow1+0x24>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:40

	if (seconds > COUNTIMER_MAX_MINUTES_SECONDS) {
		seconds = COUNTIMER_MAX_MINUTES_SECONDS;
	}

	_currentCountTime = ((hours * 3600L) + (minutes * 60L) + seconds) * 1000L;
    acf8:	88 eb       	ldi	r24, 0xB8	; 184
    acfa:	9b e0       	ldi	r25, 0x0B	; 11
    acfc:	a0 e0       	ldi	r26, 0x00	; 0
    acfe:	b0 e0       	ldi	r27, 0x00	; 0
    ad00:	80 93 3a 12 	sts	0x123A, r24	; 0x80123a <resetRow1+0x8>
    ad04:	90 93 3b 12 	sts	0x123B, r25	; 0x80123b <resetRow1+0x9>
    ad08:	a0 93 3c 12 	sts	0x123C, r26	; 0x80123c <resetRow1+0xa>
    ad0c:	b0 93 3d 12 	sts	0x123D, r27	; 0x80123d <resetRow1+0xb>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:41
	_countTime = _currentCountTime;
    ad10:	80 93 42 12 	sts	0x1242, r24	; 0x801242 <resetRow1+0x10>
    ad14:	90 93 43 12 	sts	0x1243, r25	; 0x801243 <resetRow1+0x11>
    ad18:	a0 93 44 12 	sts	0x1244, r26	; 0x801244 <resetRow1+0x12>
    ad1c:	b0 93 45 12 	sts	0x1245, r27	; 0x801245 <resetRow1+0x13>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:49
	{
		// if is count up mode, we have to start from 00:00:00;
		_currentCountTime = 0;
	}

	_startCountTime = _currentCountTime;
    ad20:	80 93 3e 12 	sts	0x123E, r24	; 0x80123e <resetRow1+0xc>
    ad24:	90 93 3f 12 	sts	0x123F, r25	; 0x80123f <resetRow1+0xd>
    ad28:	a0 93 40 12 	sts	0x1240, r26	; 0x801240 <resetRow1+0xe>
    ad2c:	b0 93 41 12 	sts	0x1241, r27	; 0x801241 <resetRow1+0xf>
setInterval():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:55

}

void Countimer::setInterval(timer_callback callback, uint32_t interval)
{
	_interval = interval;
    ad30:	88 ee       	ldi	r24, 0xE8	; 232
    ad32:	93 e0       	ldi	r25, 0x03	; 3
    ad34:	a0 e0       	ldi	r26, 0x00	; 0
    ad36:	b0 e0       	ldi	r27, 0x00	; 0
    ad38:	80 93 32 12 	sts	0x1232, r24	; 0x801232 <resetRow1>
    ad3c:	90 93 33 12 	sts	0x1233, r25	; 0x801233 <resetRow1+0x1>
    ad40:	a0 93 34 12 	sts	0x1234, r26	; 0x801234 <resetRow1+0x2>
    ad44:	b0 93 35 12 	sts	0x1235, r27	; 0x801235 <resetRow1+0x3>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:56
	_callback = callback;
    ad48:	10 92 47 12 	sts	0x1247, r1	; 0x801247 <resetRow1+0x15>
    ad4c:	10 92 46 12 	sts	0x1246, r1	; 0x801246 <resetRow1+0x14>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:366
	customKeypad.begin();
	m_tsys01.begin();
	bme280.begin(0x76, &Wire);
	resetRow1.setCounter(0, 0, 3, resetRow1.COUNT_DOWN, RemoveBTNmessage);
	resetRow1.setInterval(NULL, 1000);
	delay(50);
    ad50:	62 e3       	ldi	r22, 0x32	; 50
    ad52:	70 e0       	ldi	r23, 0x00	; 0
    ad54:	80 e0       	ldi	r24, 0x00	; 0
    ad56:	90 e0       	ldi	r25, 0x00	; 0
    ad58:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:368

	LCDSerialPrint(F("Disable partial GPS Data"));
    ad5c:	67 ea       	ldi	r22, 0xA7	; 167
    ad5e:	75 e0       	ldi	r23, 0x05	; 5
    ad60:	c8 01       	movw	r24, r16
    ad62:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    ad66:	c8 01       	movw	r24, r16
    ad68:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    ad6c:	c8 01       	movw	r24, r16
    ad6e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:369
	ss.write(GGADisable, 11);
    ad72:	4b e0       	ldi	r20, 0x0B	; 11
    ad74:	50 e0       	ldi	r21, 0x00	; 0
    ad76:	66 e4       	ldi	r22, 0x46	; 70
    ad78:	72 e0       	ldi	r23, 0x02	; 2
    ad7a:	85 eb       	ldi	r24, 0xB5	; 181
    ad7c:	9d e0       	ldi	r25, 0x0D	; 13
    ad7e:	0e 94 75 06 	call	0xcea	; 0xcea <Print::write(unsigned char const*, unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:370
	ss.write(GLLDisable, 11);
    ad82:	4b e0       	ldi	r20, 0x0B	; 11
    ad84:	50 e0       	ldi	r21, 0x00	; 0
    ad86:	6b e3       	ldi	r22, 0x3B	; 59
    ad88:	72 e0       	ldi	r23, 0x02	; 2
    ad8a:	85 eb       	ldi	r24, 0xB5	; 181
    ad8c:	9d e0       	ldi	r25, 0x0D	; 13
    ad8e:	0e 94 75 06 	call	0xcea	; 0xcea <Print::write(unsigned char const*, unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:371
	ss.write(GSADisable, 11);
    ad92:	4b e0       	ldi	r20, 0x0B	; 11
    ad94:	50 e0       	ldi	r21, 0x00	; 0
    ad96:	60 e3       	ldi	r22, 0x30	; 48
    ad98:	72 e0       	ldi	r23, 0x02	; 2
    ad9a:	85 eb       	ldi	r24, 0xB5	; 181
    ad9c:	9d e0       	ldi	r25, 0x0D	; 13
    ad9e:	0e 94 75 06 	call	0xcea	; 0xcea <Print::write(unsigned char const*, unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:372
	ss.write(GSVDisable, 11);
    ada2:	4b e0       	ldi	r20, 0x0B	; 11
    ada4:	50 e0       	ldi	r21, 0x00	; 0
    ada6:	65 e2       	ldi	r22, 0x25	; 37
    ada8:	72 e0       	ldi	r23, 0x02	; 2
    adaa:	85 eb       	ldi	r24, 0xB5	; 181
    adac:	9d e0       	ldi	r25, 0x0D	; 13
    adae:	0e 94 75 06 	call	0xcea	; 0xcea <Print::write(unsigned char const*, unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:373
	ss.write(VTGDisable, 11);
    adb2:	4b e0       	ldi	r20, 0x0B	; 11
    adb4:	50 e0       	ldi	r21, 0x00	; 0
    adb6:	6a e1       	ldi	r22, 0x1A	; 26
    adb8:	72 e0       	ldi	r23, 0x02	; 2
    adba:	85 eb       	ldi	r24, 0xB5	; 181
    adbc:	9d e0       	ldi	r25, 0x0D	; 13
    adbe:	0e 94 75 06 	call	0xcea	; 0xcea <Print::write(unsigned char const*, unsigned int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:374
	delay(50);
    adc2:	62 e3       	ldi	r22, 0x32	; 50
    adc4:	70 e0       	ldi	r23, 0x00	; 0
    adc6:	80 e0       	ldi	r24, 0x00	; 0
    adc8:	90 e0       	ldi	r25, 0x00	; 0
    adca:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:376

	LCDSerialPrint(F("Get EEPROM data"));
    adce:	67 e9       	ldi	r22, 0x97	; 151
    add0:	75 e0       	ldi	r23, 0x05	; 5
    add2:	c8 01       	movw	r24, r16
    add4:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    add8:	c8 01       	movw	r24, r16
    adda:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    adde:	c8 01       	movw	r24, r16
    ade0:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:377
	PrintEEPParameter();
    ade4:	0e 94 7e 39 	call	0x72fc	; 0x72fc <PrintEEPParameter()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:378
	delay(50);
    ade8:	62 e3       	ldi	r22, 0x32	; 50
    adea:	70 e0       	ldi	r23, 0x00	; 0
    adec:	80 e0       	ldi	r24, 0x00	; 0
    adee:	90 e0       	ldi	r25, 0x00	; 0
    adf0:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:380

	LCDSerialPrint(F("RTC Checking"));
    adf4:	6a e8       	ldi	r22, 0x8A	; 138
    adf6:	75 e0       	ldi	r23, 0x05	; 5
    adf8:	c8 01       	movw	r24, r16
    adfa:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    adfe:	c8 01       	movw	r24, r16
    ae00:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    ae04:	c8 01       	movw	r24, r16
    ae06:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
RTC_check():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:3
void RTC_check() {
	//lcd_qSprint("RTC....", 0, 0);
	RTC_alive = true;
    ae0a:	81 e0       	ldi	r24, 0x01	; 1
    ae0c:	80 93 18 02 	sts	0x0218, r24	; 0x800218 <RTC_alive>
begin():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1538
    @brief  Start I2C for the DS3231 and test succesful connection
    @return True if Wire can find DS3231 or false otherwise.
*/
/**************************************************************************/
boolean RTC_DS3231::begin(void) {
  Wire.begin();
    ae10:	0e 94 a5 1a 	call	0x354a	; 0x354a <TwoWire::begin() [clone .constprop.113]>
beginTransmission():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\libraries\Wire\src/Wire.cpp:201
  txBufferLength = 0;
}

void TwoWire::beginTransmission(int address)
{
  beginTransmission((uint8_t)address);
    ae14:	88 e6       	ldi	r24, 0x68	; 104
    ae16:	0e 94 75 03 	call	0x6ea	; 0x6ea <TwoWire::beginTransmission(unsigned char) [clone .constprop.198]>
begin():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1540
  Wire.beginTransmission(DS3231_ADDRESS);
  if (Wire.endTransmission() == 0)
    ae1a:	8c e3       	ldi	r24, 0x3C	; 60
    ae1c:	9f e0       	ldi	r25, 0x0F	; 15
    ae1e:	0e 94 18 1c 	call	0x3830	; 0x3830 <TwoWire::endTransmission()>
    ae22:	88 23       	and	r24, r24
    ae24:	41 f0       	breq	.+16     	; 0xae36 <main+0x74e>
RTC_check():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:6
	if (!RTC.begin())
	{
		Serial.println(F("RTC Not Found"));
    ae26:	87 e8       	ldi	r24, 0x87	; 135
    ae28:	94 e0       	ldi	r25, 0x04	; 4
    ae2a:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <Print::println(__FlashStringHelper const*) [clone .constprop.71]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:7
		RTC_alive = false;
    ae2e:	10 92 18 02 	sts	0x0218, r1	; 0x800218 <RTC_alive>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:8
		waring();
    ae32:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <waring()>
lostPower():
D:\USER\Documents\Arduino\libraries\RTClib/RTClib.cpp:1554
    @return True if the bit is set (oscillator stopped) or false if it is
   running
*/
/**************************************************************************/
bool RTC_DS3231::lostPower(void) {
  return (read_i2c_register(DS3231_ADDRESS, DS3231_STATUSREG) >> 7);
    ae36:	0e 94 b0 1e 	call	0x3d60	; 0x3d60 <read_i2c_register(unsigned char, unsigned char) [clone .constprop.130]>
    ae3a:	90 e0       	ldi	r25, 0x00	; 0
    ae3c:	88 0f       	add	r24, r24
    ae3e:	89 2f       	mov	r24, r25
    ae40:	88 1f       	adc	r24, r24
    ae42:	99 0b       	sbc	r25, r25
RTC_check():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:19
	#endif // DS3231
	#ifdef DS1307
	RTCrunning = RTC.isrunning();
	#endif // DS1307

	if (!RTCrunning) 
    ae44:	89 2b       	or	r24, r25
    ae46:	31 f4       	brne	.+12     	; 0xae54 <main+0x76c>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:21
		{
		Serial.println(F("!!!RTC TIME ERROW!!!.... Connect to PC to Reset"));
    ae48:	87 e5       	ldi	r24, 0x57	; 87
    ae4a:	94 e0       	ldi	r25, 0x04	; 4
    ae4c:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <Print::println(__FlashStringHelper const*) [clone .constprop.71]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/RTC.ino:23
		//RTC_alive = false;
		waring();
    ae50:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <waring()>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:382
	RTC_check();
	delay(50);
    ae54:	62 e3       	ldi	r22, 0x32	; 50
    ae56:	70 e0       	ldi	r23, 0x00	; 0
    ae58:	80 e0       	ldi	r24, 0x00	; 0
    ae5a:	90 e0       	ldi	r25, 0x00	; 0
    ae5c:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:384

	LCDSerialPrint(F("SD Checking"));
    ae60:	6e e7       	ldi	r22, 0x7E	; 126
    ae62:	75 e0       	ldi	r23, 0x05	; 5
    ae64:	c8 01       	movw	r24, r16
    ae66:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    ae6a:	c8 01       	movw	r24, r16
    ae6c:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    ae70:	c8 01       	movw	r24, r16
    ae72:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:385
	SD_checking();
    ae76:	0e 94 57 27 	call	0x4eae	; 0x4eae <SD_checking()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:386
	delay(50);
    ae7a:	62 e3       	ldi	r22, 0x32	; 50
    ae7c:	70 e0       	ldi	r23, 0x00	; 0
    ae7e:	80 e0       	ldi	r24, 0x00	; 0
    ae80:	90 e0       	ldi	r25, 0x00	; 0
    ae82:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:388

	if (SD_alive && RTC_alive)  {		LCDSerialPrint(F("SD and RTC Pass"));		delay(50);	}
    ae86:	80 91 19 02 	lds	r24, 0x0219	; 0x800219 <SD_alive>
    ae8a:	88 23       	and	r24, r24
    ae8c:	09 f4       	brne	.+2      	; 0xae90 <main+0x7a8>
    ae8e:	da c1       	rjmp	.+948    	; 0xb244 <main+0xb5c>
    ae90:	80 91 18 02 	lds	r24, 0x0218	; 0x800218 <RTC_alive>
    ae94:	88 23       	and	r24, r24
    ae96:	09 f4       	brne	.+2      	; 0xae9a <main+0x7b2>
    ae98:	d5 c1       	rjmp	.+938    	; 0xb244 <main+0xb5c>
    ae9a:	6e e6       	ldi	r22, 0x6E	; 110
    ae9c:	75 e0       	ldi	r23, 0x05	; 5
    ae9e:	c8 01       	movw	r24, r16
    aea0:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    aea4:	c8 01       	movw	r24, r16
    aea6:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    aeaa:	c8 01       	movw	r24, r16
    aeac:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    aeb0:	62 e3       	ldi	r22, 0x32	; 50
    aeb2:	70 e0       	ldi	r23, 0x00	; 0
    aeb4:	80 e0       	ldi	r24, 0x00	; 0
    aeb6:	90 e0       	ldi	r25, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:389
	else						{		LCDSerialPrint(F("SD or RTC error"));		delay(500);	}
    aeb8:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:391

	lcd.setCursor(0, 0);
    aebc:	60 e0       	ldi	r22, 0x00	; 0
    aebe:	80 e0       	ldi	r24, 0x00	; 0
    aec0:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:392
	lcd.print(F("Biochemistry    Buoy"));
    aec4:	69 e4       	ldi	r22, 0x49	; 73
    aec6:	75 e0       	ldi	r23, 0x05	; 5
    aec8:	8b eb       	ldi	r24, 0xBB	; 187
    aeca:	90 e1       	ldi	r25, 0x10	; 16
    aecc:	0e 94 51 06 	call	0xca2	; 0xca2 <Print::print(__FlashStringHelper const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:393
	lcd.setCursor(0, 1);
    aed0:	61 e0       	ldi	r22, 0x01	; 1
    aed2:	80 e0       	ldi	r24, 0x00	; 0
    aed4:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:394
	lcd.print(F("Data Collecting Syst"));
    aed8:	64 e3       	ldi	r22, 0x34	; 52
    aeda:	75 e0       	ldi	r23, 0x05	; 5
    aedc:	8b eb       	ldi	r24, 0xBB	; 187
    aede:	90 e1       	ldi	r25, 0x10	; 16
    aee0:	0e 94 51 06 	call	0xca2	; 0xca2 <Print::print(__FlashStringHelper const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:395
	lcd.setCursor(0, 2);
    aee4:	62 e0       	ldi	r22, 0x02	; 2
    aee6:	80 e0       	ldi	r24, 0x00	; 0
    aee8:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:396
	lcd.print(Drifter_Ver);
    aeec:	69 e5       	ldi	r22, 0x59	; 89
    aeee:	77 e0       	ldi	r23, 0x07	; 7
    aef0:	8b eb       	ldi	r24, 0xBB	; 187
    aef2:	90 e1       	ldi	r25, 0x10	; 16
    aef4:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:397
	lcd.setCursor(0, 3);
    aef8:	63 e0       	ldi	r22, 0x03	; 3
    aefa:	80 e0       	ldi	r24, 0x00	; 0
    aefc:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:398
	lcd.print(F("Device ID = "));
    af00:	67 e2       	ldi	r22, 0x27	; 39
    af02:	75 e0       	ldi	r23, 0x05	; 5
    af04:	8b eb       	ldi	r24, 0xBB	; 187
    af06:	90 e1       	ldi	r25, 0x10	; 16
    af08:	0e 94 51 06 	call	0xca2	; 0xca2 <Print::print(__FlashStringHelper const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:399
	lcd.print(device_ID);
    af0c:	60 91 21 0c 	lds	r22, 0x0C21	; 0x800c21 <device_ID>
    af10:	70 91 22 0c 	lds	r23, 0x0C22	; 0x800c22 <device_ID+0x1>
    af14:	8b eb       	ldi	r24, 0xBB	; 187
    af16:	90 e1       	ldi	r25, 0x10	; 16
    af18:	0e 94 22 26 	call	0x4c44	; 0x4c44 <Print::print(int, int) [clone .constprop.175]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:400
	delay(1000);
    af1c:	68 ee       	ldi	r22, 0xE8	; 232
    af1e:	73 e0       	ldi	r23, 0x03	; 3
    af20:	80 e0       	ldi	r24, 0x00	; 0
    af22:	90 e0       	ldi	r25, 0x00	; 0
    af24:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:401
	LCDSerialPrint(F("Open pump"));
    af28:	6d e1       	ldi	r22, 0x1D	; 29
    af2a:	75 e0       	ldi	r23, 0x05	; 5
    af2c:	c8 01       	movw	r24, r16
    af2e:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    af32:	c8 01       	movw	r24, r16
    af34:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    af38:	c8 01       	movw	r24, r16
    af3a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:402
	pumpControl(pumpPower);
    af3e:	80 91 dc 09 	lds	r24, 0x09DC	; 0x8009dc <pumpPower>
    af42:	90 91 dd 09 	lds	r25, 0x09DD	; 0x8009dd <pumpPower+0x1>
    af46:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <pumpControl(int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:403
	delay(50);
    af4a:	62 e3       	ldi	r22, 0x32	; 50
    af4c:	70 e0       	ldi	r23, 0x00	; 0
    af4e:	80 e0       	ldi	r24, 0x00	; 0
    af50:	90 e0       	ldi	r25, 0x00	; 0
    af52:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:404
	if (powerSaving) {
    af56:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <powerSaving>
    af5a:	88 23       	and	r24, r24
    af5c:	71 f1       	breq	.+92     	; 0xafba <main+0x8d2>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:405
		Serial.println(F("Waring! Power Saving ON, LCD's LED will shutdown after booting!"));
    af5e:	8d ed       	ldi	r24, 0xDD	; 221
    af60:	94 e0       	ldi	r25, 0x04	; 4
    af62:	0e 94 c3 25 	call	0x4b86	; 0x4b86 <Print::println(__FlashStringHelper const*) [clone .constprop.71]>
notice():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/tone_function.ino:2
void notice() {
	tone(buzzerpin, 50, 100);
    af66:	44 e6       	ldi	r20, 0x64	; 100
    af68:	50 e0       	ldi	r21, 0x00	; 0
    af6a:	60 e0       	ldi	r22, 0x00	; 0
    af6c:	70 e0       	ldi	r23, 0x00	; 0
    af6e:	82 e3       	ldi	r24, 0x32	; 50
    af70:	90 e0       	ldi	r25, 0x00	; 0
    af72:	0e 94 44 09 	call	0x1288	; 0x1288 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:407
		notice();
		LCDSerialPrint(F("POWER SAVING ON"));
    af76:	6d ec       	ldi	r22, 0xCD	; 205
    af78:	74 e0       	ldi	r23, 0x04	; 4
    af7a:	c8 01       	movw	r24, r16
    af7c:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    af80:	c8 01       	movw	r24, r16
    af82:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    af86:	c8 01       	movw	r24, r16
    af88:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:408
		delay(500);
    af8c:	64 ef       	ldi	r22, 0xF4	; 244
    af8e:	71 e0       	ldi	r23, 0x01	; 1
    af90:	80 e0       	ldi	r24, 0x00	; 0
    af92:	90 e0       	ldi	r25, 0x00	; 0
    af94:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:409
		LCDSerialPrint(F("LCD's LED will TURN OFF after booting"));
    af98:	67 ea       	ldi	r22, 0xA7	; 167
    af9a:	74 e0       	ldi	r23, 0x04	; 4
    af9c:	c8 01       	movw	r24, r16
    af9e:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    afa2:	c8 01       	movw	r24, r16
    afa4:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    afa8:	c8 01       	movw	r24, r16
    afaa:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:410
		delay(500);
    afae:	64 ef       	ldi	r22, 0xF4	; 244
    afb0:	71 e0       	ldi	r23, 0x01	; 1
    afb2:	80 e0       	ldi	r24, 0x00	; 0
    afb4:	90 e0       	ldi	r25, 0x00	; 0
    afb6:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:412
	}
	LCDSerialPrint(F("Watchdog activate"));
    afba:	65 e9       	ldi	r22, 0x95	; 149
    afbc:	74 e0       	ldi	r23, 0x04	; 4
    afbe:	c8 01       	movw	r24, r16
    afc0:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    afc4:	c8 01       	movw	r24, r16
    afc6:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    afca:	c8 01       	movw	r24, r16
    afcc:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:413
	Watchdog.enable(watchdogTimer);
    afd0:	80 e1       	ldi	r24, 0x10	; 16
    afd2:	97 e2       	ldi	r25, 0x27	; 39
    afd4:	0e 94 8b 05 	call	0xb16	; 0xb16 <WatchdogAVR::enable(int) [clone .constprop.48]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:414
	delay(50);
    afd8:	62 e3       	ldi	r22, 0x32	; 50
    afda:	70 e0       	ldi	r23, 0x00	; 0
    afdc:	80 e0       	ldi	r24, 0x00	; 0
    afde:	90 e0       	ldi	r25, 0x00	; 0
    afe0:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:417
///Initial Parameter==================================================
	//Serial.println("First time measurement");
	update_time_info();
    afe4:	0e 94 58 30 	call	0x60b0	; 0x60b0 <update_time_info()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:418
	getFilename(filename);
    afe8:	0e 94 6b 25 	call	0x4ad6	; 0x4ad6 <getFilename(char*) [clone .constprop.135]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:419
	File_check_exists();
    afec:	0e 94 1e 38 	call	0x703c	; 0x703c <File_check_exists()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:420
	last_day = day;
    aff0:	80 91 27 0c 	lds	r24, 0x0C27	; 0x800c27 <day>
    aff4:	90 91 28 0c 	lds	r25, 0x0C28	; 0x800c28 <day+0x1>
    aff8:	90 93 db 09 	sts	0x09DB, r25	; 0x8009db <last_day+0x1>
    affc:	80 93 da 09 	sts	0x09DA, r24	; 0x8009da <last_day>
flushAllSerial():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:2
void flushAllSerial() {
  flush_EC_serial();
    b000:	0e 94 2e 1e 	call	0x3c5c	; 0x3c5c <flush_EC_serial()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/String IO Format.ino:3
  flush_pH_serial();
    b004:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <flush_pH_serial()>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:422
	flushAllSerial();
	doMeasure();
    b008:	0e 94 c2 3a 	call	0x7584	; 0x7584 <doMeasure()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:423
	last_time = millis();
    b00c:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    b010:	60 93 f5 09 	sts	0x09F5, r22	; 0x8009f5 <last_time>
    b014:	70 93 f6 09 	sts	0x09F6, r23	; 0x8009f6 <last_time+0x1>
    b018:	80 93 f7 09 	sts	0x09F7, r24	; 0x8009f7 <last_time+0x2>
    b01c:	90 93 f8 09 	sts	0x09F8, r25	; 0x8009f8 <last_time+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:424
	last_time2 = millis();
    b020:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    b024:	60 93 f1 09 	sts	0x09F1, r22	; 0x8009f1 <last_time2>
    b028:	70 93 f2 09 	sts	0x09F2, r23	; 0x8009f2 <last_time2+0x1>
    b02c:	80 93 f3 09 	sts	0x09F3, r24	; 0x8009f3 <last_time2+0x2>
    b030:	90 93 f4 09 	sts	0x09F4, r25	; 0x8009f4 <last_time2+0x3>
reset():
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:30
  return actualMS;
}

void WatchdogAVR::reset() {
  // Reset the watchdog.
  wdt_reset();
    b034:	a8 95       	wdr
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:427
	Watchdog.reset();

	if (powerSaving) lcd.noBacklight();
    b036:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <powerSaving>
    b03a:	88 23       	and	r24, r24
    b03c:	39 f0       	breq	.+14     	; 0xb04c <main+0x964>
noBacklight():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:219
	}
}

// Turn the (optional) backlight off/on
void LiquidCrystal_I2C::noBacklight(void) {
	_backlightval=LCD_NOBACKLIGHT;
    b03e:	10 92 c6 10 	sts	0x10C6, r1	; 0x8010c6 <lcd+0xb>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:220
	expanderWrite(0);
    b042:	60 e0       	ldi	r22, 0x00	; 0
    b044:	8b eb       	ldi	r24, 0xBB	; 187
    b046:	90 e1       	ldi	r25, 0x10	; 16
    b048:	0e 94 46 1d 	call	0x3a8c	; 0x3a8c <LiquidCrystal_I2C::expanderWrite(unsigned char)>
encode():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:76
        term[curTermOffset] = 0;
        isValidSentence = endOfTermHandler();
      }
      ++curTermNumber;
      curTermOffset = 0;
      isChecksumTerm = c == '*';
    b04c:	33 24       	eor	r3, r3
    b04e:	33 94       	inc	r3
    b050:	dd 24       	eor	r13, r13
    b052:	d3 94       	inc	r13
reset():
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:30
    b054:	a8 95       	wdr
gps_new_get():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/GPS_DATA.ino:3
void gps_new_get() {
/// For one second we parse GPS data and report some key values
	for (unsigned long start = millis(); millis() - start < 100;)	if(ss.available() > 0)		gps.encode(ss.read());
    b056:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    b05a:	4b 01       	movw	r8, r22
    b05c:	5c 01       	movw	r10, r24
    b05e:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    b062:	68 19       	sub	r22, r8
    b064:	79 09       	sbc	r23, r9
    b066:	8a 09       	sbc	r24, r10
    b068:	9b 09       	sbc	r25, r11
    b06a:	64 36       	cpi	r22, 0x64	; 100
    b06c:	71 05       	cpc	r23, r1
    b06e:	81 05       	cpc	r24, r1
    b070:	91 05       	cpc	r25, r1
    b072:	08 f0       	brcs	.+2      	; 0xb076 <main+0x98e>
    b074:	df c2       	rjmp	.+1470   	; 0xb634 <main+0xf4c>
    b076:	85 eb       	ldi	r24, 0xB5	; 181
    b078:	9d e0       	ldi	r25, 0x0D	; 13
    b07a:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <HardwareSerial::available()>
    b07e:	18 16       	cp	r1, r24
    b080:	19 06       	cpc	r1, r25
    b082:	6c f7       	brge	.-38     	; 0xb05e <main+0x976>
    b084:	85 eb       	ldi	r24, 0xB5	; 181
    b086:	9d e0       	ldi	r25, 0x0D	; 13
    b088:	0e 94 ca 06 	call	0xd94	; 0xd94 <HardwareSerial::read()>
    b08c:	78 2e       	mov	r7, r24
encode():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:58
// public methods
//

bool TinyGPSPlus::encode(char c)
{
  ++encodedCharCount;
    b08e:	80 91 22 12 	lds	r24, 0x1222	; 0x801222 <gps+0x9d>
    b092:	90 91 23 12 	lds	r25, 0x1223	; 0x801223 <gps+0x9e>
    b096:	a0 91 24 12 	lds	r26, 0x1224	; 0x801224 <gps+0x9f>
    b09a:	b0 91 25 12 	lds	r27, 0x1225	; 0x801225 <gps+0xa0>
    b09e:	01 96       	adiw	r24, 0x01	; 1
    b0a0:	a1 1d       	adc	r26, r1
    b0a2:	b1 1d       	adc	r27, r1
    b0a4:	80 93 22 12 	sts	0x1222, r24	; 0x801222 <gps+0x9d>
    b0a8:	90 93 23 12 	sts	0x1223, r25	; 0x801223 <gps+0x9e>
    b0ac:	a0 93 24 12 	sts	0x1224, r26	; 0x801224 <gps+0x9f>
    b0b0:	b0 93 25 12 	sts	0x1225, r27	; 0x801225 <gps+0xa0>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:60

  switch(c)
    b0b4:	84 e2       	ldi	r24, 0x24	; 36
    b0b6:	78 16       	cp	r7, r24
    b0b8:	09 f4       	brne	.+2      	; 0xb0bc <main+0x9d4>
    b0ba:	9a c2       	rjmp	.+1332   	; 0xb5f0 <main+0xf08>
    b0bc:	e0 91 1c 12 	lds	r30, 0x121C	; 0x80121c <gps+0x97>
    b0c0:	87 15       	cp	r24, r7
    b0c2:	0c f4       	brge	.+2      	; 0xb0c6 <main+0x9de>
    b0c4:	cf c0       	rjmp	.+414    	; 0xb264 <main+0xb7c>
    b0c6:	9a e0       	ldi	r25, 0x0A	; 10
    b0c8:	79 16       	cp	r7, r25
    b0ca:	19 f0       	breq	.+6      	; 0xb0d2 <main+0x9ea>
    b0cc:	fd e0       	ldi	r31, 0x0D	; 13
    b0ce:	7f 12       	cpse	r7, r31
    b0d0:	9d c2       	rjmp	.+1338   	; 0xb60c <main+0xf24>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:69
  case '\r':
  case '\n':
  case '*':
    {
      bool isValidSentence = false;
      if (curTermOffset < sizeof(term))
    b0d2:	ef 30       	cpi	r30, 0x0F	; 15
    b0d4:	08 f0       	brcs	.+2      	; 0xb0d8 <main+0x9f0>
    b0d6:	44 c1       	rjmp	.+648    	; 0xb360 <main+0xc78>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:71
      {
        term[curTermOffset] = 0;
    b0d8:	f0 e0       	ldi	r31, 0x00	; 0
    b0da:	e5 5f       	subi	r30, 0xF5	; 245
    b0dc:	fd 4e       	sbci	r31, 0xED	; 237
    b0de:	10 82       	st	Z, r1
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:162
// Processes a just-completed term
// Returns true if new sentence has just passed checksum test and is validated
bool TinyGPSPlus::endOfTermHandler()
{
  // If it's the checksum term, and the checksum checks out, commit
  if (isChecksumTerm)
    b0e0:	80 91 0a 12 	lds	r24, 0x120A	; 0x80120a <gps+0x85>
    b0e4:	88 23       	and	r24, r24
    b0e6:	09 f4       	brne	.+2      	; 0xb0ea <main+0xa02>
    b0e8:	49 c1       	rjmp	.+658    	; 0xb37c <main+0xc94>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:164
  {
    byte checksum = 16 * fromHex(term[0]) + fromHex(term[1]);
    b0ea:	20 91 0b 12 	lds	r18, 0x120B	; 0x80120b <gps+0x86>
    b0ee:	82 2f       	mov	r24, r18
    b0f0:	02 2e       	mov	r0, r18
    b0f2:	00 0c       	add	r0, r0
    b0f4:	99 0b       	sbc	r25, r25
fromHex():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:105
//
// internal utilities
//
int TinyGPSPlus::fromHex(char a)
{
  if (a >= 'A' && a <= 'F')
    b0f6:	3f eb       	ldi	r19, 0xBF	; 191
    b0f8:	32 0f       	add	r19, r18
    b0fa:	36 30       	cpi	r19, 0x06	; 6
    b0fc:	08 f0       	brcs	.+2      	; 0xb100 <main+0xa18>
    b0fe:	bf c0       	rjmp	.+382    	; 0xb27e <main+0xb96>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:106
    return a - 'A' + 10;
    b100:	c7 97       	sbiw	r24, 0x37	; 55
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:164
bool TinyGPSPlus::endOfTermHandler()
{
  // If it's the checksum term, and the checksum checks out, commit
  if (isChecksumTerm)
  {
    byte checksum = 16 * fromHex(term[0]) + fromHex(term[1]);
    b102:	82 95       	swap	r24
    b104:	80 7f       	andi	r24, 0xF0	; 240
    b106:	90 91 0c 12 	lds	r25, 0x120C	; 0x80120c <gps+0x87>
    b10a:	29 2f       	mov	r18, r25
    b10c:	09 2e       	mov	r0, r25
    b10e:	00 0c       	add	r0, r0
    b110:	33 0b       	sbc	r19, r19
fromHex():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:105
//
// internal utilities
//
int TinyGPSPlus::fromHex(char a)
{
  if (a >= 'A' && a <= 'F')
    b112:	4f eb       	ldi	r20, 0xBF	; 191
    b114:	49 0f       	add	r20, r25
    b116:	46 30       	cpi	r20, 0x06	; 6
    b118:	08 f0       	brcs	.+2      	; 0xb11c <main+0xa34>
    b11a:	b9 c0       	rjmp	.+370    	; 0xb28e <main+0xba6>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:106
    return a - 'A' + 10;
    b11c:	27 53       	subi	r18, 0x37	; 55
    b11e:	31 09       	sbc	r19, r1
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:164
bool TinyGPSPlus::endOfTermHandler()
{
  // If it's the checksum term, and the checksum checks out, commit
  if (isChecksumTerm)
  {
    byte checksum = 16 * fromHex(term[0]) + fromHex(term[1]);
    b120:	82 0f       	add	r24, r18
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:165
    if (checksum == parity)
    b122:	90 91 09 12 	lds	r25, 0x1209	; 0x801209 <gps+0x84>
    b126:	89 13       	cpse	r24, r25
    b128:	08 c1       	rjmp	.+528    	; 0xb33a <main+0xc52>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:167
    {
      passedChecksumCount++;
    b12a:	80 91 2e 12 	lds	r24, 0x122E	; 0x80122e <gps+0xa9>
    b12e:	90 91 2f 12 	lds	r25, 0x122F	; 0x80122f <gps+0xaa>
    b132:	a0 91 30 12 	lds	r26, 0x1230	; 0x801230 <gps+0xab>
    b136:	b0 91 31 12 	lds	r27, 0x1231	; 0x801231 <gps+0xac>
    b13a:	01 96       	adiw	r24, 0x01	; 1
    b13c:	a1 1d       	adc	r26, r1
    b13e:	b1 1d       	adc	r27, r1
    b140:	80 93 2e 12 	sts	0x122E, r24	; 0x80122e <gps+0xa9>
    b144:	90 93 2f 12 	sts	0x122F, r25	; 0x80122f <gps+0xaa>
    b148:	a0 93 30 12 	sts	0x1230, r26	; 0x801230 <gps+0xab>
    b14c:	b0 93 31 12 	sts	0x1231, r27	; 0x801231 <gps+0xac>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:168
      if (sentenceHasFix)
    b150:	80 91 1d 12 	lds	r24, 0x121D	; 0x80121d <gps+0x98>
    b154:	88 23       	and	r24, r24
    b156:	99 f0       	breq	.+38     	; 0xb17e <main+0xa96>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:169
        ++sentencesWithFixCount;
    b158:	80 91 26 12 	lds	r24, 0x1226	; 0x801226 <gps+0xa1>
    b15c:	90 91 27 12 	lds	r25, 0x1227	; 0x801227 <gps+0xa2>
    b160:	a0 91 28 12 	lds	r26, 0x1228	; 0x801228 <gps+0xa3>
    b164:	b0 91 29 12 	lds	r27, 0x1229	; 0x801229 <gps+0xa4>
    b168:	01 96       	adiw	r24, 0x01	; 1
    b16a:	a1 1d       	adc	r26, r1
    b16c:	b1 1d       	adc	r27, r1
    b16e:	80 93 26 12 	sts	0x1226, r24	; 0x801226 <gps+0xa1>
    b172:	90 93 27 12 	sts	0x1227, r25	; 0x801227 <gps+0xa2>
    b176:	a0 93 28 12 	sts	0x1228, r26	; 0x801228 <gps+0xa3>
    b17a:	b0 93 29 12 	sts	0x1229, r27	; 0x801229 <gps+0xa4>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:171

      switch(curSentenceType)
    b17e:	f0 90 1a 12 	lds	r15, 0x121A	; 0x80121a <gps+0x95>
    b182:	ff 20       	and	r15, r15
    b184:	09 f4       	brne	.+2      	; 0xb188 <main+0xaa0>
    b186:	8c c0       	rjmp	.+280    	; 0xb2a0 <main+0xbb8>
    b188:	81 e0       	ldi	r24, 0x01	; 1
    b18a:	f8 12       	cpse	r15, r24
    b18c:	34 c0       	rjmp	.+104    	; 0xb1f6 <main+0xb0e>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:174
      {
      case GPS_SENTENCE_GPRMC:
        date.commit();
    b18e:	87 ea       	ldi	r24, 0xA7	; 167
    b190:	91 e1       	ldi	r25, 0x11	; 17
    b192:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <TinyGPSDate::commit()>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:175
        time.commit();
    b196:	85 eb       	ldi	r24, 0xB5	; 181
    b198:	91 e1       	ldi	r25, 0x11	; 17
    b19a:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <TinyGPSDate::commit()>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:176
        if (sentenceHasFix)
    b19e:	80 91 1d 12 	lds	r24, 0x121D	; 0x80121d <gps+0x98>
    b1a2:	88 23       	and	r24, r24
    b1a4:	41 f1       	breq	.+80     	; 0xb1f6 <main+0xb0e>
commit():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:339
  return directions[direction % 16];
}

void TinyGPSLocation::commit()
{
   rawLatData = rawNewLatData;
    b1a6:	87 e0       	ldi	r24, 0x07	; 7
    b1a8:	e5 e9       	ldi	r30, 0x95	; 149
    b1aa:	f1 e1       	ldi	r31, 0x11	; 17
    b1ac:	a7 e8       	ldi	r26, 0x87	; 135
    b1ae:	b1 e1       	ldi	r27, 0x11	; 17
    b1b0:	01 90       	ld	r0, Z+
    b1b2:	0d 92       	st	X+, r0
    b1b4:	8a 95       	dec	r24
    b1b6:	e1 f7       	brne	.-8      	; 0xb1b0 <main+0xac8>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:340
   rawLngData = rawNewLngData;
    b1b8:	87 e0       	ldi	r24, 0x07	; 7
    b1ba:	ec e9       	ldi	r30, 0x9C	; 156
    b1bc:	f1 e1       	ldi	r31, 0x11	; 17
    b1be:	ae e8       	ldi	r26, 0x8E	; 142
    b1c0:	b1 e1       	ldi	r27, 0x11	; 17
    b1c2:	01 90       	ld	r0, Z+
    b1c4:	0d 92       	st	X+, r0
    b1c6:	8a 95       	dec	r24
    b1c8:	e1 f7       	brne	.-8      	; 0xb1c2 <main+0xada>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:341
   lastCommitTime = millis();
    b1ca:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    b1ce:	60 93 a3 11 	sts	0x11A3, r22	; 0x8011a3 <gps+0x1e>
    b1d2:	70 93 a4 11 	sts	0x11A4, r23	; 0x8011a4 <gps+0x1f>
    b1d6:	80 93 a5 11 	sts	0x11A5, r24	; 0x8011a5 <gps+0x20>
    b1da:	90 93 a6 11 	sts	0x11A6, r25	; 0x8011a6 <gps+0x21>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:342
   valid = updated = true;
    b1de:	f0 92 86 11 	sts	0x1186, r15	; 0x801186 <gps+0x1>
    b1e2:	f0 92 85 11 	sts	0x1185, r15	; 0x801185 <gps>
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:179
        date.commit();
        time.commit();
        if (sentenceHasFix)
        {
           location.commit();
           speed.commit();
    b1e6:	83 ec       	ldi	r24, 0xC3	; 195
    b1e8:	91 e1       	ldi	r25, 0x11	; 17
    b1ea:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <TinyGPSDecimal::commit()>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:180
           course.commit();
    b1ee:	81 ed       	ldi	r24, 0xD1	; 209
    b1f0:	91 e1       	ldi	r25, 0x11	; 17
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:191
        {
          location.commit();
          altitude.commit();
        }
        satellites.commit();
        hdop.commit();
    b1f2:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <TinyGPSDecimal::commit()>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:196
        break;
      }

      // Commit all custom listeners of this sentence type
      for (TinyGPSCustom *p = customCandidates; p != NULL && strcmp(p->sentenceName, customCandidates->sentenceName) == 0; p = p->next)
    b1f6:	e0 90 20 12 	lds	r14, 0x1220	; 0x801220 <gps+0x9b>
    b1fa:	f0 90 21 12 	lds	r15, 0x1221	; 0x801221 <gps+0x9c>
    b1fe:	e1 14       	cp	r14, r1
    b200:	f1 04       	cpc	r15, r1
    b202:	09 f4       	brne	.+2      	; 0xb206 <main+0xb1e>
    b204:	ad c0       	rjmp	.+346    	; 0xb360 <main+0xc78>
    b206:	e0 91 20 12 	lds	r30, 0x1220	; 0x801220 <gps+0x9b>
    b20a:	f0 91 21 12 	lds	r31, 0x1221	; 0x801221 <gps+0x9c>
    b20e:	66 a1       	ldd	r22, Z+38	; 0x26
    b210:	77 a1       	ldd	r23, Z+39	; 0x27
    b212:	f7 01       	movw	r30, r14
    b214:	86 a1       	ldd	r24, Z+38	; 0x26
    b216:	97 a1       	ldd	r25, Z+39	; 0x27
    b218:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <strcmp>
    b21c:	89 2b       	or	r24, r25
    b21e:	09 f0       	breq	.+2      	; 0xb222 <main+0xb3a>
    b220:	9f c0       	rjmp	.+318    	; 0xb360 <main+0xc78>
commit():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:480
   gps.insertCustom(this, _sentenceName, _termNumber);
}

void TinyGPSCustom::commit()
{
   strcpy(this->buffer, this->stagingBuffer);
    b222:	b7 01       	movw	r22, r14
    b224:	c7 01       	movw	r24, r14
    b226:	40 96       	adiw	r24, 0x10	; 16
    b228:	0e 94 c8 6e 	call	0xdd90	; 0xdd90 <strcpy>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:481
   lastCommitTime = millis();
    b22c:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    b230:	f7 01       	movw	r30, r14
    b232:	60 a3       	std	Z+32, r22	; 0x20
    b234:	71 a3       	std	Z+33, r23	; 0x21
    b236:	82 a3       	std	Z+34, r24	; 0x22
    b238:	93 a3       	std	Z+35, r25	; 0x23
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:482
   valid = updated = true;
    b23a:	35 a2       	std	Z+37, r3	; 0x25
    b23c:	34 a2       	std	Z+36, r3	; 0x24
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:196
        hdop.commit();
        break;
      }

      // Commit all custom listeners of this sentence type
      for (TinyGPSCustom *p = customCandidates; p != NULL && strcmp(p->sentenceName, customCandidates->sentenceName) == 0; p = p->next)
    b23e:	e2 a4       	ldd	r14, Z+42	; 0x2a
    b240:	f3 a4       	ldd	r15, Z+43	; 0x2b
    b242:	dd cf       	rjmp	.-70     	; 0xb1fe <main+0xb16>
setup():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:389
	LCDSerialPrint(F("SD Checking"));
	SD_checking();
	delay(50);

	if (SD_alive && RTC_alive)  {		LCDSerialPrint(F("SD and RTC Pass"));		delay(50);	}
	else						{		LCDSerialPrint(F("SD or RTC error"));		delay(500);	}
    b244:	6e e5       	ldi	r22, 0x5E	; 94
    b246:	75 e0       	ldi	r23, 0x05	; 5
    b248:	c8 01       	movw	r24, r16
    b24a:	0e 94 18 35 	call	0x6a30	; 0x6a30 <String::String(__FlashStringHelper const*)>
    b24e:	c8 01       	movw	r24, r16
    b250:	0e 94 62 28 	call	0x50c4	; 0x50c4 <LCDSerialPrint(String)>
    b254:	c8 01       	movw	r24, r16
    b256:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    b25a:	64 ef       	ldi	r22, 0xF4	; 244
    b25c:	71 e0       	ldi	r23, 0x01	; 1
    b25e:	80 e0       	ldi	r24, 0x00	; 0
    b260:	90 e0       	ldi	r25, 0x00	; 0
    b262:	2a ce       	rjmp	.-940    	; 0xaeb8 <main+0x7d0>
encode():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:60

bool TinyGPSPlus::encode(char c)
{
  ++encodedCharCount;

  switch(c)
    b264:	2a e2       	ldi	r18, 0x2A	; 42
    b266:	72 16       	cp	r7, r18
    b268:	09 f4       	brne	.+2      	; 0xb26c <main+0xb84>
    b26a:	33 cf       	rjmp	.-410    	; 0xb0d2 <main+0x9ea>
    b26c:	3c e2       	ldi	r19, 0x2C	; 44
    b26e:	73 12       	cpse	r7, r19
    b270:	cd c1       	rjmp	.+922    	; 0xb60c <main+0xf24>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:63
  {
  case ',': // term terminators
    parity ^= (uint8_t)c;
    b272:	80 91 09 12 	lds	r24, 0x1209	; 0x801209 <gps+0x84>
    b276:	87 25       	eor	r24, r7
    b278:	80 93 09 12 	sts	0x1209, r24	; 0x801209 <gps+0x84>
    b27c:	2a cf       	rjmp	.-428    	; 0xb0d2 <main+0x9ea>
fromHex():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:107
//
int TinyGPSPlus::fromHex(char a)
{
  if (a >= 'A' && a <= 'F')
    return a - 'A' + 10;
  else if (a >= 'a' && a <= 'f')
    b27e:	21 56       	subi	r18, 0x61	; 97
    b280:	26 30       	cpi	r18, 0x06	; 6
    b282:	18 f4       	brcc	.+6      	; 0xb28a <main+0xba2>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:108
    return a - 'a' + 10;
    b284:	87 55       	subi	r24, 0x57	; 87
    b286:	91 09       	sbc	r25, r1
    b288:	3c cf       	rjmp	.-392    	; 0xb102 <main+0xa1a>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:110
  else
    return a - '0';
    b28a:	c0 97       	sbiw	r24, 0x30	; 48
    b28c:	3a cf       	rjmp	.-396    	; 0xb102 <main+0xa1a>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:107
//
int TinyGPSPlus::fromHex(char a)
{
  if (a >= 'A' && a <= 'F')
    return a - 'A' + 10;
  else if (a >= 'a' && a <= 'f')
    b28e:	91 56       	subi	r25, 0x61	; 97
    b290:	96 30       	cpi	r25, 0x06	; 6
    b292:	18 f4       	brcc	.+6      	; 0xb29a <main+0xbb2>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:108
    return a - 'a' + 10;
    b294:	27 55       	subi	r18, 0x57	; 87
    b296:	31 09       	sbc	r19, r1
    b298:	43 cf       	rjmp	.-378    	; 0xb120 <main+0xa38>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:110
  else
    return a - '0';
    b29a:	20 53       	subi	r18, 0x30	; 48
    b29c:	31 09       	sbc	r19, r1
    b29e:	40 cf       	rjmp	.-384    	; 0xb120 <main+0xa38>
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:184
           speed.commit();
           course.commit();
        }
        break;
      case GPS_SENTENCE_GPGGA:
        time.commit();
    b2a0:	85 eb       	ldi	r24, 0xB5	; 181
    b2a2:	91 e1       	ldi	r25, 0x11	; 17
    b2a4:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <TinyGPSDate::commit()>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:185
        if (sentenceHasFix)
    b2a8:	80 91 1d 12 	lds	r24, 0x121D	; 0x80121d <gps+0x98>
    b2ac:	88 23       	and	r24, r24
    b2ae:	21 f1       	breq	.+72     	; 0xb2f8 <main+0xc10>
commit():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:339
  return directions[direction % 16];
}

void TinyGPSLocation::commit()
{
   rawLatData = rawNewLatData;
    b2b0:	87 e0       	ldi	r24, 0x07	; 7
    b2b2:	e5 e9       	ldi	r30, 0x95	; 149
    b2b4:	f1 e1       	ldi	r31, 0x11	; 17
    b2b6:	a7 e8       	ldi	r26, 0x87	; 135
    b2b8:	b1 e1       	ldi	r27, 0x11	; 17
    b2ba:	01 90       	ld	r0, Z+
    b2bc:	0d 92       	st	X+, r0
    b2be:	8a 95       	dec	r24
    b2c0:	e1 f7       	brne	.-8      	; 0xb2ba <main+0xbd2>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:340
   rawLngData = rawNewLngData;
    b2c2:	87 e0       	ldi	r24, 0x07	; 7
    b2c4:	ec e9       	ldi	r30, 0x9C	; 156
    b2c6:	f1 e1       	ldi	r31, 0x11	; 17
    b2c8:	ae e8       	ldi	r26, 0x8E	; 142
    b2ca:	b1 e1       	ldi	r27, 0x11	; 17
    b2cc:	01 90       	ld	r0, Z+
    b2ce:	0d 92       	st	X+, r0
    b2d0:	8a 95       	dec	r24
    b2d2:	e1 f7       	brne	.-8      	; 0xb2cc <main+0xbe4>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:341
   lastCommitTime = millis();
    b2d4:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    b2d8:	60 93 a3 11 	sts	0x11A3, r22	; 0x8011a3 <gps+0x1e>
    b2dc:	70 93 a4 11 	sts	0x11A4, r23	; 0x8011a4 <gps+0x1f>
    b2e0:	80 93 a5 11 	sts	0x11A5, r24	; 0x8011a5 <gps+0x20>
    b2e4:	90 93 a6 11 	sts	0x11A6, r25	; 0x8011a6 <gps+0x21>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:342
   valid = updated = true;
    b2e8:	d0 92 86 11 	sts	0x1186, r13	; 0x801186 <gps+0x1>
    b2ec:	d0 92 85 11 	sts	0x1185, r13	; 0x801185 <gps>
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:188
      case GPS_SENTENCE_GPGGA:
        time.commit();
        if (sentenceHasFix)
        {
          location.commit();
          altitude.commit();
    b2f0:	8f ed       	ldi	r24, 0xDF	; 223
    b2f2:	91 e1       	ldi	r25, 0x11	; 17
    b2f4:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <TinyGPSDecimal::commit()>
commit():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:450
   newval = TinyGPSPlus::parseDecimal(term);
}

void TinyGPSInteger::commit()
{
   val = newval;
    b2f8:	80 91 f7 11 	lds	r24, 0x11F7	; 0x8011f7 <gps+0x72>
    b2fc:	90 91 f8 11 	lds	r25, 0x11F8	; 0x8011f8 <gps+0x73>
    b300:	a0 91 f9 11 	lds	r26, 0x11F9	; 0x8011f9 <gps+0x74>
    b304:	b0 91 fa 11 	lds	r27, 0x11FA	; 0x8011fa <gps+0x75>
    b308:	80 93 f3 11 	sts	0x11F3, r24	; 0x8011f3 <gps+0x6e>
    b30c:	90 93 f4 11 	sts	0x11F4, r25	; 0x8011f4 <gps+0x6f>
    b310:	a0 93 f5 11 	sts	0x11F5, r26	; 0x8011f5 <gps+0x70>
    b314:	b0 93 f6 11 	sts	0x11F6, r27	; 0x8011f6 <gps+0x71>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:451
   lastCommitTime = millis();
    b318:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    b31c:	60 93 ef 11 	sts	0x11EF, r22	; 0x8011ef <gps+0x6a>
    b320:	70 93 f0 11 	sts	0x11F0, r23	; 0x8011f0 <gps+0x6b>
    b324:	80 93 f1 11 	sts	0x11F1, r24	; 0x8011f1 <gps+0x6c>
    b328:	90 93 f2 11 	sts	0x11F2, r25	; 0x8011f2 <gps+0x6d>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:452
   valid = updated = true;
    b32c:	d0 92 ee 11 	sts	0x11EE, r13	; 0x8011ee <gps+0x69>
    b330:	d0 92 ed 11 	sts	0x11ED, r13	; 0x8011ed <gps+0x68>
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:191
        {
          location.commit();
          altitude.commit();
        }
        satellites.commit();
        hdop.commit();
    b334:	8b ef       	ldi	r24, 0xFB	; 251
    b336:	91 e1       	ldi	r25, 0x11	; 17
    b338:	5c cf       	rjmp	.-328    	; 0xb1f2 <main+0xb0a>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:203
      return true;
    }

    else
    {
      ++failedChecksumCount;
    b33a:	80 91 2a 12 	lds	r24, 0x122A	; 0x80122a <gps+0xa5>
    b33e:	90 91 2b 12 	lds	r25, 0x122B	; 0x80122b <gps+0xa6>
    b342:	a0 91 2c 12 	lds	r26, 0x122C	; 0x80122c <gps+0xa7>
    b346:	b0 91 2d 12 	lds	r27, 0x122D	; 0x80122d <gps+0xa8>
    b34a:	01 96       	adiw	r24, 0x01	; 1
    b34c:	a1 1d       	adc	r26, r1
    b34e:	b1 1d       	adc	r27, r1
    b350:	80 93 2a 12 	sts	0x122A, r24	; 0x80122a <gps+0xa5>
    b354:	90 93 2b 12 	sts	0x122B, r25	; 0x80122b <gps+0xa6>
    b358:	a0 93 2c 12 	sts	0x122C, r26	; 0x80122c <gps+0xa7>
    b35c:	b0 93 2d 12 	sts	0x122D, r27	; 0x80122d <gps+0xa8>
encode():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:74
      if (curTermOffset < sizeof(term))
      {
        term[curTermOffset] = 0;
        isValidSentence = endOfTermHandler();
      }
      ++curTermNumber;
    b360:	80 91 1b 12 	lds	r24, 0x121B	; 0x80121b <gps+0x96>
    b364:	8f 5f       	subi	r24, 0xFF	; 255
    b366:	80 93 1b 12 	sts	0x121B, r24	; 0x80121b <gps+0x96>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:75
      curTermOffset = 0;
    b36a:	10 92 1c 12 	sts	0x121C, r1	; 0x80121c <gps+0x97>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:76
      isChecksumTerm = c == '*';
    b36e:	81 e0       	ldi	r24, 0x01	; 1
    b370:	fa e2       	ldi	r31, 0x2A	; 42
    b372:	7f 12       	cpse	r7, r31
    b374:	80 e0       	ldi	r24, 0x00	; 0
    b376:	80 93 0a 12 	sts	0x120A, r24	; 0x80120a <gps+0x85>
    b37a:	71 ce       	rjmp	.-798    	; 0xb05e <main+0x976>
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:210

    return false;
  }

  // the first term determines the sentence type
  if (curTermNumber == 0)
    b37c:	80 91 1b 12 	lds	r24, 0x121B	; 0x80121b <gps+0x96>
    b380:	81 11       	cpse	r24, r1
    b382:	45 c0       	rjmp	.+138    	; 0xb40e <main+0xd26>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:212
  {
    if (!strcmp(term, _GPRMCterm) || !strcmp(term, _GNRMCterm))
    b384:	65 e6       	ldi	r22, 0x65	; 101
    b386:	77 e0       	ldi	r23, 0x07	; 7
    b388:	8b e0       	ldi	r24, 0x0B	; 11
    b38a:	92 e1       	ldi	r25, 0x12	; 18
    b38c:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <strcmp>
    b390:	89 2b       	or	r24, r25
    b392:	41 f0       	breq	.+16     	; 0xb3a4 <main+0xcbc>
    b394:	6b e6       	ldi	r22, 0x6B	; 107
    b396:	77 e0       	ldi	r23, 0x07	; 7
    b398:	8b e0       	ldi	r24, 0x0B	; 11
    b39a:	92 e1       	ldi	r25, 0x12	; 18
    b39c:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <strcmp>
    b3a0:	89 2b       	or	r24, r25
    b3a2:	f1 f4       	brne	.+60     	; 0xb3e0 <main+0xcf8>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:213
      curSentenceType = GPS_SENTENCE_GPRMC;
    b3a4:	d0 92 1a 12 	sts	0x121A, r13	; 0x80121a <gps+0x95>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:220
      curSentenceType = GPS_SENTENCE_GPGGA;
    else
      curSentenceType = GPS_SENTENCE_OTHER;

    // Any custom candidates of this sentence type?
    for (customCandidates = customElts; customCandidates != NULL && strcmp(customCandidates->sentenceName, term) < 0; customCandidates = customCandidates->next);
    b3a8:	80 91 1e 12 	lds	r24, 0x121E	; 0x80121e <gps+0x99>
    b3ac:	90 91 1f 12 	lds	r25, 0x121F	; 0x80121f <gps+0x9a>
    b3b0:	90 93 21 12 	sts	0x1221, r25	; 0x801221 <gps+0x9c>
    b3b4:	80 93 20 12 	sts	0x1220, r24	; 0x801220 <gps+0x9b>
    b3b8:	e0 90 20 12 	lds	r14, 0x1220	; 0x801220 <gps+0x9b>
    b3bc:	f0 90 21 12 	lds	r15, 0x1221	; 0x801221 <gps+0x9c>
    b3c0:	e1 14       	cp	r14, r1
    b3c2:	f1 04       	cpc	r15, r1
    b3c4:	69 f2       	breq	.-102    	; 0xb360 <main+0xc78>
    b3c6:	6b e0       	ldi	r22, 0x0B	; 11
    b3c8:	72 e1       	ldi	r23, 0x12	; 18
    b3ca:	f7 01       	movw	r30, r14
    b3cc:	86 a1       	ldd	r24, Z+38	; 0x26
    b3ce:	97 a1       	ldd	r25, Z+39	; 0x27
    b3d0:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <strcmp>
    b3d4:	97 ff       	sbrs	r25, 7
    b3d6:	39 c7       	rjmp	.+3698   	; 0xc24a <main+0x1b62>
    b3d8:	f7 01       	movw	r30, r14
    b3da:	82 a5       	ldd	r24, Z+42	; 0x2a
    b3dc:	93 a5       	ldd	r25, Z+43	; 0x2b
    b3de:	e8 cf       	rjmp	.-48     	; 0xb3b0 <main+0xcc8>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:214
  // the first term determines the sentence type
  if (curTermNumber == 0)
  {
    if (!strcmp(term, _GPRMCterm) || !strcmp(term, _GNRMCterm))
      curSentenceType = GPS_SENTENCE_GPRMC;
    else if (!strcmp(term, _GPGGAterm) || !strcmp(term, _GNGGAterm))
    b3e0:	61 e7       	ldi	r22, 0x71	; 113
    b3e2:	77 e0       	ldi	r23, 0x07	; 7
    b3e4:	8b e0       	ldi	r24, 0x0B	; 11
    b3e6:	92 e1       	ldi	r25, 0x12	; 18
    b3e8:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <strcmp>
    b3ec:	89 2b       	or	r24, r25
    b3ee:	41 f0       	breq	.+16     	; 0xb400 <main+0xd18>
    b3f0:	67 e7       	ldi	r22, 0x77	; 119
    b3f2:	77 e0       	ldi	r23, 0x07	; 7
    b3f4:	8b e0       	ldi	r24, 0x0B	; 11
    b3f6:	92 e1       	ldi	r25, 0x12	; 18
    b3f8:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <strcmp>
    b3fc:	89 2b       	or	r24, r25
    b3fe:	19 f4       	brne	.+6      	; 0xb406 <main+0xd1e>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:215
      curSentenceType = GPS_SENTENCE_GPGGA;
    b400:	10 92 1a 12 	sts	0x121A, r1	; 0x80121a <gps+0x95>
    b404:	d1 cf       	rjmp	.-94     	; 0xb3a8 <main+0xcc0>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:217
    else
      curSentenceType = GPS_SENTENCE_OTHER;
    b406:	f2 e0       	ldi	r31, 0x02	; 2
    b408:	f0 93 1a 12 	sts	0x121A, r31	; 0x80121a <gps+0x95>
    b40c:	cd cf       	rjmp	.-102    	; 0xb3a8 <main+0xcc0>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:227
       customCandidates = NULL;

    return false;
  }

  if (curSentenceType != GPS_SENTENCE_OTHER && term[0])
    b40e:	e0 91 1a 12 	lds	r30, 0x121A	; 0x80121a <gps+0x95>
    b412:	e2 30       	cpi	r30, 0x02	; 2
    b414:	09 f4       	brne	.+2      	; 0xb418 <main+0xd30>
    b416:	4a c0       	rjmp	.+148    	; 0xb4ac <main+0xdc4>
    b418:	90 91 0b 12 	lds	r25, 0x120B	; 0x80120b <gps+0x86>
    b41c:	99 23       	and	r25, r25
    b41e:	09 f4       	brne	.+2      	; 0xb422 <main+0xd3a>
    b420:	45 c0       	rjmp	.+138    	; 0xb4ac <main+0xdc4>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:228
    switch(COMBINE(curSentenceType, curTermNumber))
    b422:	20 e2       	ldi	r18, 0x20	; 32
    b424:	e2 9f       	mul	r30, r18
    b426:	f0 01       	movw	r30, r0
    b428:	11 24       	eor	r1, r1
    b42a:	e8 2b       	or	r30, r24
    b42c:	31 97       	sbiw	r30, 0x01	; 1
    b42e:	e9 32       	cpi	r30, 0x29	; 41
    b430:	f1 05       	cpc	r31, r1
    b432:	08 f0       	brcs	.+2      	; 0xb436 <main+0xd4e>
    b434:	3b c0       	rjmp	.+118    	; 0xb4ac <main+0xdc4>
    b436:	88 27       	eor	r24, r24
    b438:	ef 5d       	subi	r30, 0xDF	; 223
    b43a:	f5 4a       	sbci	r31, 0xA5	; 165
    b43c:	8f 4f       	sbci	r24, 0xFF	; 255
    b43e:	0c 94 2b 6c 	jmp	0xd856	; 0xd856 <__tablejump2__>
    b442:	4a 5a       	subi	r20, 0xAA	; 170
    b444:	8b 5a       	subi	r24, 0xAB	; 171
    b446:	92 5a       	subi	r25, 0xA2	; 162
    b448:	99 5a       	subi	r25, 0xA9	; 169
    b44a:	9c 5a       	subi	r25, 0xAC	; 172
    b44c:	ca 5a       	subi	r28, 0xAA	; 170
    b44e:	d1 5a       	subi	r29, 0xA1	; 161
    b450:	de 5a       	subi	r29, 0xAE	; 174
    b452:	eb 5a       	subi	r30, 0xAB	; 171
    b454:	56 5a       	subi	r21, 0xA6	; 166
    b456:	56 5a       	subi	r21, 0xA6	; 166
    b458:	56 5a       	subi	r21, 0xA6	; 166
    b45a:	56 5a       	subi	r21, 0xA6	; 166
    b45c:	56 5a       	subi	r21, 0xA6	; 166
    b45e:	56 5a       	subi	r21, 0xA6	; 166
    b460:	56 5a       	subi	r21, 0xA6	; 166
    b462:	56 5a       	subi	r21, 0xA6	; 166
    b464:	56 5a       	subi	r21, 0xA6	; 166
    b466:	56 5a       	subi	r21, 0xA6	; 166
    b468:	56 5a       	subi	r21, 0xA6	; 166
    b46a:	56 5a       	subi	r21, 0xA6	; 166
    b46c:	56 5a       	subi	r21, 0xA6	; 166
    b46e:	56 5a       	subi	r21, 0xA6	; 166
    b470:	56 5a       	subi	r21, 0xA6	; 166
    b472:	56 5a       	subi	r21, 0xA6	; 166
    b474:	56 5a       	subi	r21, 0xA6	; 166
    b476:	56 5a       	subi	r21, 0xA6	; 166
    b478:	56 5a       	subi	r21, 0xA6	; 166
    b47a:	56 5a       	subi	r21, 0xA6	; 166
    b47c:	56 5a       	subi	r21, 0xA6	; 166
    b47e:	56 5a       	subi	r21, 0xA6	; 166
    b480:	56 5a       	subi	r21, 0xA6	; 166
    b482:	4a 5a       	subi	r20, 0xAA	; 170
    b484:	85 5a       	subi	r24, 0xA5	; 165
    b486:	8b 5a       	subi	r24, 0xAB	; 171
    b488:	92 5a       	subi	r25, 0xA2	; 162
    b48a:	99 5a       	subi	r25, 0xA9	; 169
    b48c:	9c 5a       	subi	r25, 0xAC	; 172
    b48e:	a3 5a       	subi	r26, 0xA3	; 163
    b490:	b0 5a       	subi	r27, 0xA0	; 160
    b492:	bd 5a       	subi	r27, 0xAD	; 173
setTime():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:385
   valid = updated = true;
}

void TinyGPSTime::setTime(const char *term)
{
   newTime = (uint32_t)TinyGPSPlus::parseDecimal(term);
    b494:	8b e0       	ldi	r24, 0x0B	; 11
    b496:	92 e1       	ldi	r25, 0x12	; 18
    b498:	0e 94 52 29 	call	0x52a4	; 0x52a4 <TinyGPSPlus::parseDecimal(char const*)>
    b49c:	60 93 bb 11 	sts	0x11BB, r22	; 0x8011bb <gps+0x36>
    b4a0:	70 93 bc 11 	sts	0x11BC, r23	; 0x8011bc <gps+0x37>
    b4a4:	80 93 bd 11 	sts	0x11BD, r24	; 0x8011bd <gps+0x38>
    b4a8:	90 93 be 11 	sts	0x11BE, r25	; 0x8011be <gps+0x39>
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:277
      altitude.set(term);
      break;
  }

  // Set custom values as needed
  for (TinyGPSCustom *p = customCandidates; p != NULL && strcmp(p->sentenceName, customCandidates->sentenceName) == 0 && p->termNumber <= curTermNumber; p = p->next)
    b4ac:	e0 90 20 12 	lds	r14, 0x1220	; 0x801220 <gps+0x9b>
    b4b0:	f0 90 21 12 	lds	r15, 0x1221	; 0x801221 <gps+0x9c>
    b4b4:	c0 90 1b 12 	lds	r12, 0x121B	; 0x80121b <gps+0x96>
    b4b8:	e1 14       	cp	r14, r1
    b4ba:	f1 04       	cpc	r15, r1
    b4bc:	09 f4       	brne	.+2      	; 0xb4c0 <main+0xdd8>
    b4be:	50 cf       	rjmp	.-352    	; 0xb360 <main+0xc78>
    b4c0:	e0 91 20 12 	lds	r30, 0x1220	; 0x801220 <gps+0x9b>
    b4c4:	f0 91 21 12 	lds	r31, 0x1221	; 0x801221 <gps+0x9c>
    b4c8:	66 a1       	ldd	r22, Z+38	; 0x26
    b4ca:	77 a1       	ldd	r23, Z+39	; 0x27
    b4cc:	f7 01       	movw	r30, r14
    b4ce:	86 a1       	ldd	r24, Z+38	; 0x26
    b4d0:	97 a1       	ldd	r25, Z+39	; 0x27
    b4d2:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <strcmp>
    b4d6:	89 2b       	or	r24, r25
    b4d8:	09 f0       	breq	.+2      	; 0xb4dc <main+0xdf4>
    b4da:	42 cf       	rjmp	.-380    	; 0xb360 <main+0xc78>
    b4dc:	f7 01       	movw	r30, r14
    b4de:	20 a5       	ldd	r18, Z+40	; 0x28
    b4e0:	31 a5       	ldd	r19, Z+41	; 0x29
    b4e2:	8c 2d       	mov	r24, r12
    b4e4:	90 e0       	ldi	r25, 0x00	; 0
    b4e6:	82 17       	cp	r24, r18
    b4e8:	93 07       	cpc	r25, r19
    b4ea:	0c f4       	brge	.+2      	; 0xb4ee <main+0xe06>
    b4ec:	39 cf       	rjmp	.-398    	; 0xb360 <main+0xc78>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:278
    if (p->termNumber == curTermNumber)
    b4ee:	28 17       	cp	r18, r24
    b4f0:	39 07       	cpc	r19, r25
    b4f2:	39 f4       	brne	.+14     	; 0xb502 <main+0xe1a>
set():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:487
   valid = updated = true;
}

void TinyGPSCustom::set(const char *term)
{
   strncpy(this->stagingBuffer, term, sizeof(this->stagingBuffer));
    b4f4:	40 e1       	ldi	r20, 0x10	; 16
    b4f6:	50 e0       	ldi	r21, 0x00	; 0
    b4f8:	6b e0       	ldi	r22, 0x0B	; 11
    b4fa:	72 e1       	ldi	r23, 0x12	; 18
    b4fc:	c7 01       	movw	r24, r14
    b4fe:	0e 94 cf 6e 	call	0xdd9e	; 0xdd9e <strncpy>
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:277
      altitude.set(term);
      break;
  }

  // Set custom values as needed
  for (TinyGPSCustom *p = customCandidates; p != NULL && strcmp(p->sentenceName, customCandidates->sentenceName) == 0 && p->termNumber <= curTermNumber; p = p->next)
    b502:	f7 01       	movw	r30, r14
    b504:	e2 a4       	ldd	r14, Z+42	; 0x2a
    b506:	f3 a4       	ldd	r15, Z+43	; 0x2b
    b508:	d5 cf       	rjmp	.-86     	; 0xb4b4 <main+0xdcc>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:235
    case COMBINE(GPS_SENTENCE_GPRMC, 1): // Time in both sentences
    case COMBINE(GPS_SENTENCE_GPGGA, 1):
      time.setTime(term);
      break;
    case COMBINE(GPS_SENTENCE_GPRMC, 2): // GPRMC validity
      sentenceHasFix = term[0] == 'A';
    b50a:	81 e0       	ldi	r24, 0x01	; 1
    b50c:	91 34       	cpi	r25, 0x41	; 65
    b50e:	09 f4       	brne	.+2      	; 0xb512 <main+0xe2a>
    b510:	45 c0       	rjmp	.+138    	; 0xb59c <main+0xeb4>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:263
      break;
    case COMBINE(GPS_SENTENCE_GPRMC, 9): // Date (GPRMC)
      date.setDate(term);
      break;
    case COMBINE(GPS_SENTENCE_GPGGA, 6): // Fix data (GPGGA)
      sentenceHasFix = term[0] > '0';
    b512:	80 e0       	ldi	r24, 0x00	; 0
    b514:	43 c0       	rjmp	.+134    	; 0xb59c <main+0xeb4>
setLatitude():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:347
   valid = updated = true;
}

void TinyGPSLocation::setLatitude(const char *term)
{
   TinyGPSPlus::parseDegrees(term, rawNewLatData);
    b516:	65 e9       	ldi	r22, 0x95	; 149
    b518:	71 e1       	ldi	r23, 0x11	; 17
setLongitude():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:352
}

void TinyGPSLocation::setLongitude(const char *term)
{
   TinyGPSPlus::parseDegrees(term, rawNewLngData);
    b51a:	8b e0       	ldi	r24, 0x0B	; 11
    b51c:	92 e1       	ldi	r25, 0x12	; 18
    b51e:	0e 94 cb 28 	call	0x5196	; 0x5196 <TinyGPSPlus::parseDegrees(char const*, RawDegrees&)>
    b522:	c4 cf       	rjmp	.-120    	; 0xb4ac <main+0xdc4>
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:243
    case COMBINE(GPS_SENTENCE_GPGGA, 2):
      location.setLatitude(term);
      break;
    case COMBINE(GPS_SENTENCE_GPRMC, 4): // N/S
    case COMBINE(GPS_SENTENCE_GPGGA, 3):
      location.rawNewLatData.negative = term[0] == 'S';
    b524:	81 e0       	ldi	r24, 0x01	; 1
    b526:	93 35       	cpi	r25, 0x53	; 83
    b528:	09 f0       	breq	.+2      	; 0xb52c <main+0xe44>
    b52a:	80 e0       	ldi	r24, 0x00	; 0
    b52c:	80 93 9b 11 	sts	0x119B, r24	; 0x80119b <gps+0x16>
    b530:	bd cf       	rjmp	.-134    	; 0xb4ac <main+0xdc4>
setLongitude():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:352
   TinyGPSPlus::parseDegrees(term, rawNewLatData);
}

void TinyGPSLocation::setLongitude(const char *term)
{
   TinyGPSPlus::parseDegrees(term, rawNewLngData);
    b532:	6c e9       	ldi	r22, 0x9C	; 156
    b534:	71 e1       	ldi	r23, 0x11	; 17
    b536:	f1 cf       	rjmp	.-30     	; 0xb51a <main+0xe32>
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:251
    case COMBINE(GPS_SENTENCE_GPGGA, 4):
      location.setLongitude(term);
      break;
    case COMBINE(GPS_SENTENCE_GPRMC, 6): // E/W
    case COMBINE(GPS_SENTENCE_GPGGA, 5):
      location.rawNewLngData.negative = term[0] == 'W';
    b538:	81 e0       	ldi	r24, 0x01	; 1
    b53a:	97 35       	cpi	r25, 0x57	; 87
    b53c:	09 f0       	breq	.+2      	; 0xb540 <main+0xe58>
    b53e:	80 e0       	ldi	r24, 0x00	; 0
    b540:	80 93 a2 11 	sts	0x11A2, r24	; 0x8011a2 <gps+0x1d>
    b544:	b3 cf       	rjmp	.-154    	; 0xb4ac <main+0xdc4>
set():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:445
   valid = updated = true;
}

void TinyGPSDecimal::set(const char *term)
{
   newval = TinyGPSPlus::parseDecimal(term);
    b546:	8b e0       	ldi	r24, 0x0B	; 11
    b548:	92 e1       	ldi	r25, 0x12	; 18
    b54a:	0e 94 52 29 	call	0x52a4	; 0x52a4 <TinyGPSPlus::parseDecimal(char const*)>
    b54e:	60 93 cd 11 	sts	0x11CD, r22	; 0x8011cd <gps+0x48>
    b552:	70 93 ce 11 	sts	0x11CE, r23	; 0x8011ce <gps+0x49>
    b556:	80 93 cf 11 	sts	0x11CF, r24	; 0x8011cf <gps+0x4a>
    b55a:	90 93 d0 11 	sts	0x11D0, r25	; 0x8011d0 <gps+0x4b>
    b55e:	a6 cf       	rjmp	.-180    	; 0xb4ac <main+0xdc4>
    b560:	8b e0       	ldi	r24, 0x0B	; 11
    b562:	92 e1       	ldi	r25, 0x12	; 18
    b564:	0e 94 52 29 	call	0x52a4	; 0x52a4 <TinyGPSPlus::parseDecimal(char const*)>
    b568:	60 93 db 11 	sts	0x11DB, r22	; 0x8011db <gps+0x56>
    b56c:	70 93 dc 11 	sts	0x11DC, r23	; 0x8011dc <gps+0x57>
    b570:	80 93 dd 11 	sts	0x11DD, r24	; 0x8011dd <gps+0x58>
    b574:	90 93 de 11 	sts	0x11DE, r25	; 0x8011de <gps+0x59>
    b578:	99 cf       	rjmp	.-206    	; 0xb4ac <main+0xdc4>
setDate():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:390
   newTime = (uint32_t)TinyGPSPlus::parseDecimal(term);
}

void TinyGPSDate::setDate(const char *term)
{
   newDate = atol(term);
    b57a:	8b e0       	ldi	r24, 0x0B	; 11
    b57c:	92 e1       	ldi	r25, 0x12	; 18
    b57e:	0e 94 1f 64 	call	0xc83e	; 0xc83e <atol>
    b582:	60 93 ad 11 	sts	0x11AD, r22	; 0x8011ad <gps+0x28>
    b586:	70 93 ae 11 	sts	0x11AE, r23	; 0x8011ae <gps+0x29>
    b58a:	80 93 af 11 	sts	0x11AF, r24	; 0x8011af <gps+0x2a>
    b58e:	90 93 b0 11 	sts	0x11B0, r25	; 0x8011b0 <gps+0x2b>
    b592:	8c cf       	rjmp	.-232    	; 0xb4ac <main+0xdc4>
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:263
      break;
    case COMBINE(GPS_SENTENCE_GPRMC, 9): // Date (GPRMC)
      date.setDate(term);
      break;
    case COMBINE(GPS_SENTENCE_GPGGA, 6): // Fix data (GPGGA)
      sentenceHasFix = term[0] > '0';
    b594:	81 e0       	ldi	r24, 0x01	; 1
    b596:	91 33       	cpi	r25, 0x31	; 49
    b598:	0c f4       	brge	.+2      	; 0xb59c <main+0xeb4>
    b59a:	bb cf       	rjmp	.-138    	; 0xb512 <main+0xe2a>
    b59c:	80 93 1d 12 	sts	0x121D, r24	; 0x80121d <gps+0x98>
    b5a0:	85 cf       	rjmp	.-246    	; 0xb4ac <main+0xdc4>
set():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:457
   valid = updated = true;
}

void TinyGPSInteger::set(const char *term)
{
   newval = atol(term);
    b5a2:	8b e0       	ldi	r24, 0x0B	; 11
    b5a4:	92 e1       	ldi	r25, 0x12	; 18
    b5a6:	0e 94 1f 64 	call	0xc83e	; 0xc83e <atol>
    b5aa:	60 93 f7 11 	sts	0x11F7, r22	; 0x8011f7 <gps+0x72>
    b5ae:	70 93 f8 11 	sts	0x11F8, r23	; 0x8011f8 <gps+0x73>
    b5b2:	80 93 f9 11 	sts	0x11F9, r24	; 0x8011f9 <gps+0x74>
    b5b6:	90 93 fa 11 	sts	0x11FA, r25	; 0x8011fa <gps+0x75>
    b5ba:	78 cf       	rjmp	.-272    	; 0xb4ac <main+0xdc4>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:445
   valid = updated = true;
}

void TinyGPSDecimal::set(const char *term)
{
   newval = TinyGPSPlus::parseDecimal(term);
    b5bc:	8b e0       	ldi	r24, 0x0B	; 11
    b5be:	92 e1       	ldi	r25, 0x12	; 18
    b5c0:	0e 94 52 29 	call	0x52a4	; 0x52a4 <TinyGPSPlus::parseDecimal(char const*)>
    b5c4:	60 93 05 12 	sts	0x1205, r22	; 0x801205 <gps+0x80>
    b5c8:	70 93 06 12 	sts	0x1206, r23	; 0x801206 <gps+0x81>
    b5cc:	80 93 07 12 	sts	0x1207, r24	; 0x801207 <gps+0x82>
    b5d0:	90 93 08 12 	sts	0x1208, r25	; 0x801208 <gps+0x83>
    b5d4:	6b cf       	rjmp	.-298    	; 0xb4ac <main+0xdc4>
    b5d6:	8b e0       	ldi	r24, 0x0B	; 11
    b5d8:	92 e1       	ldi	r25, 0x12	; 18
    b5da:	0e 94 52 29 	call	0x52a4	; 0x52a4 <TinyGPSPlus::parseDecimal(char const*)>
    b5de:	60 93 e9 11 	sts	0x11E9, r22	; 0x8011e9 <gps+0x64>
    b5e2:	70 93 ea 11 	sts	0x11EA, r23	; 0x8011ea <gps+0x65>
    b5e6:	80 93 eb 11 	sts	0x11EB, r24	; 0x8011eb <gps+0x66>
    b5ea:	90 93 ec 11 	sts	0x11EC, r25	; 0x8011ec <gps+0x67>
    b5ee:	5e cf       	rjmp	.-324    	; 0xb4ac <main+0xdc4>
encode():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:82
      return isValidSentence;
    }
    break;

  case '$': // sentence begin
    curTermNumber = curTermOffset = 0;
    b5f0:	10 92 1c 12 	sts	0x121C, r1	; 0x80121c <gps+0x97>
    b5f4:	10 92 1b 12 	sts	0x121B, r1	; 0x80121b <gps+0x96>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:83
    parity = 0;
    b5f8:	10 92 09 12 	sts	0x1209, r1	; 0x801209 <gps+0x84>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:84
    curSentenceType = GPS_SENTENCE_OTHER;
    b5fc:	22 e0       	ldi	r18, 0x02	; 2
    b5fe:	20 93 1a 12 	sts	0x121A, r18	; 0x80121a <gps+0x95>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:85
    isChecksumTerm = false;
    b602:	10 92 0a 12 	sts	0x120A, r1	; 0x80120a <gps+0x85>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:86
    sentenceHasFix = false;
    b606:	10 92 1d 12 	sts	0x121D, r1	; 0x80121d <gps+0x98>
    b60a:	29 cd       	rjmp	.-1454   	; 0xb05e <main+0x976>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:90
    return false;

  default: // ordinary characters
    if (curTermOffset < sizeof(term) - 1)
    b60c:	ee 30       	cpi	r30, 0x0E	; 14
    b60e:	40 f4       	brcc	.+16     	; 0xb620 <main+0xf38>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:91
      term[curTermOffset++] = c;
    b610:	81 e0       	ldi	r24, 0x01	; 1
    b612:	8e 0f       	add	r24, r30
    b614:	80 93 1c 12 	sts	0x121C, r24	; 0x80121c <gps+0x97>
    b618:	f0 e0       	ldi	r31, 0x00	; 0
    b61a:	e5 5f       	subi	r30, 0xF5	; 245
    b61c:	fd 4e       	sbci	r31, 0xED	; 237
    b61e:	70 82       	st	Z, r7
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:92
    if (!isChecksumTerm)
    b620:	80 91 0a 12 	lds	r24, 0x120A	; 0x80120a <gps+0x85>
    b624:	81 11       	cpse	r24, r1
    b626:	1b cd       	rjmp	.-1482   	; 0xb05e <main+0x976>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:93
      parity ^= c;
    b628:	80 91 09 12 	lds	r24, 0x1209	; 0x801209 <gps+0x84>
    b62c:	78 26       	eor	r7, r24
    b62e:	70 92 09 12 	sts	0x1209, r7	; 0x801209 <gps+0x84>
    b632:	15 cd       	rjmp	.-1494   	; 0xb05e <main+0x976>
run():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:126
}

void Countimer::run()
{
	// timer is running only if is not completed or not stopped.
	if (_isCounterCompleted || _isStopped)
    b634:	80 91 4a 12 	lds	r24, 0x124A	; 0x80124a <resetRow1+0x18>
    b638:	81 11       	cpse	r24, r1
    b63a:	5c c0       	rjmp	.+184    	; 0xb6f4 <main+0x100c>
    b63c:	80 91 4b 12 	lds	r24, 0x124B	; 0x80124b <resetRow1+0x19>
    b640:	81 11       	cpse	r24, r1
    b642:	58 c0       	rjmp	.+176    	; 0xb6f4 <main+0x100c>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:129
		return;

	if (millis() - _previousMillis >= _interval) {
    b644:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    b648:	80 90 36 12 	lds	r8, 0x1236	; 0x801236 <resetRow1+0x4>
    b64c:	90 90 37 12 	lds	r9, 0x1237	; 0x801237 <resetRow1+0x5>
    b650:	a0 90 38 12 	lds	r10, 0x1238	; 0x801238 <resetRow1+0x6>
    b654:	b0 90 39 12 	lds	r11, 0x1239	; 0x801239 <resetRow1+0x7>
    b658:	68 19       	sub	r22, r8
    b65a:	79 09       	sbc	r23, r9
    b65c:	8a 09       	sbc	r24, r10
    b65e:	9b 09       	sbc	r25, r11
    b660:	80 90 32 12 	lds	r8, 0x1232	; 0x801232 <resetRow1>
    b664:	90 90 33 12 	lds	r9, 0x1233	; 0x801233 <resetRow1+0x1>
    b668:	a0 90 34 12 	lds	r10, 0x1234	; 0x801234 <resetRow1+0x2>
    b66c:	b0 90 35 12 	lds	r11, 0x1235	; 0x801235 <resetRow1+0x3>
    b670:	68 15       	cp	r22, r8
    b672:	79 05       	cpc	r23, r9
    b674:	8a 05       	cpc	r24, r10
    b676:	9b 05       	cpc	r25, r11
    b678:	e8 f1       	brcs	.+122    	; 0xb6f4 <main+0x100c>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:131

		if (_countType == COUNT_DOWN)
    b67a:	80 91 56 12 	lds	r24, 0x1256	; 0x801256 <resetRow1+0x24>
    b67e:	90 91 57 12 	lds	r25, 0x1257	; 0x801257 <resetRow1+0x25>
    b682:	82 30       	cpi	r24, 0x02	; 2
    b684:	91 05       	cpc	r25, r1
    b686:	09 f0       	breq	.+2      	; 0xb68a <main+0xfa2>
    b688:	89 c0       	rjmp	.+274    	; 0xb79c <main+0x10b4>
countDown():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:149
	}
}

void Countimer::countDown()
{
	if (_currentCountTime > 0)
    b68a:	80 91 3a 12 	lds	r24, 0x123A	; 0x80123a <resetRow1+0x8>
    b68e:	90 91 3b 12 	lds	r25, 0x123B	; 0x80123b <resetRow1+0x9>
    b692:	a0 91 3c 12 	lds	r26, 0x123C	; 0x80123c <resetRow1+0xa>
    b696:	b0 91 3d 12 	lds	r27, 0x123D	; 0x80123d <resetRow1+0xb>
    b69a:	89 2b       	or	r24, r25
    b69c:	8a 2b       	or	r24, r26
    b69e:	8b 2b       	or	r24, r27
    b6a0:	09 f4       	brne	.+2      	; 0xb6a4 <main+0xfbc>
    b6a2:	aa c0       	rjmp	.+340    	; 0xb7f8 <main+0x1110>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:151
	{
		callback();
    b6a4:	0e 94 21 06 	call	0xc42	; 0xc42 <Countimer::callback() [clone .constprop.13]>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:152
		_currentCountTime -= _interval;
    b6a8:	80 91 3a 12 	lds	r24, 0x123A	; 0x80123a <resetRow1+0x8>
    b6ac:	90 91 3b 12 	lds	r25, 0x123B	; 0x80123b <resetRow1+0x9>
    b6b0:	a0 91 3c 12 	lds	r26, 0x123C	; 0x80123c <resetRow1+0xa>
    b6b4:	b0 91 3d 12 	lds	r27, 0x123D	; 0x80123d <resetRow1+0xb>
    b6b8:	40 91 32 12 	lds	r20, 0x1232	; 0x801232 <resetRow1>
    b6bc:	50 91 33 12 	lds	r21, 0x1233	; 0x801233 <resetRow1+0x1>
    b6c0:	60 91 34 12 	lds	r22, 0x1234	; 0x801234 <resetRow1+0x2>
    b6c4:	70 91 35 12 	lds	r23, 0x1235	; 0x801235 <resetRow1+0x3>
    b6c8:	84 1b       	sub	r24, r20
    b6ca:	95 0b       	sbc	r25, r21
    b6cc:	a6 0b       	sbc	r26, r22
    b6ce:	b7 0b       	sbc	r27, r23
countUp():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:166
void Countimer::countUp()
{
	if (_currentCountTime < _countTime)
	{
		callback();
		_currentCountTime += _interval;
    b6d0:	80 93 3a 12 	sts	0x123A, r24	; 0x80123a <resetRow1+0x8>
    b6d4:	90 93 3b 12 	sts	0x123B, r25	; 0x80123b <resetRow1+0x9>
    b6d8:	a0 93 3c 12 	sts	0x123C, r26	; 0x80123c <resetRow1+0xa>
    b6dc:	b0 93 3d 12 	sts	0x123D, r27	; 0x80123d <resetRow1+0xb>
run():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:143
		}
		else
		{
			callback();
		}
		_previousMillis = millis();
    b6e0:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    b6e4:	60 93 36 12 	sts	0x1236, r22	; 0x801236 <resetRow1+0x4>
    b6e8:	70 93 37 12 	sts	0x1237, r23	; 0x801237 <resetRow1+0x5>
    b6ec:	80 93 38 12 	sts	0x1238, r24	; 0x801238 <resetRow1+0x6>
    b6f0:	90 93 39 12 	sts	0x1239, r25	; 0x801239 <resetRow1+0x7>
IOloop():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:490
		serialComplete = false;
	}
}

void IOloop() {
	battery.loop();
    b6f4:	82 e7       	ldi	r24, 0x72	; 114
    b6f6:	90 e1       	ldi	r25, 0x10	; 16
    b6f8:	0e 94 06 24 	call	0x480c	; 0x480c <BlinkControl::loop()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:491
	SDIO.loop();
    b6fc:	89 e2       	ldi	r24, 0x29	; 41
    b6fe:	90 e1       	ldi	r25, 0x10	; 16
    b700:	0e 94 06 24 	call	0x480c	; 0x480c <BlinkControl::loop()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:492
	ThermoER.loop();
    b704:	80 ee       	ldi	r24, 0xE0	; 224
    b706:	9f e0       	ldi	r25, 0x0F	; 15
    b708:	0e 94 06 24 	call	0x480c	; 0x480c <BlinkControl::loop()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:495
	//RTCER.loop();
	//GPSLED.loop();
	PGER.loop();
    b70c:	87 e9       	ldi	r24, 0x97	; 151
    b70e:	9f e0       	ldi	r25, 0x0F	; 15
    b710:	0e 94 06 24 	call	0x480c	; 0x480c <BlinkControl::loop()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:496
	RamER.loop();
    b714:	8e e4       	ldi	r24, 0x4E	; 78
    b716:	9f e0       	ldi	r25, 0x0F	; 15
    b718:	0e 94 06 24 	call	0x480c	; 0x480c <BlinkControl::loop()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:497
	customKeypad.tick();
    b71c:	0e 94 6d 08 	call	0x10da	; 0x10da <Adafruit_Keypad::tick() [clone .constprop.54]>
available():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:94

  return value;
}

template <int N> int Adafruit_Keypad_RingbufferN<N>::available() {
  int delta = _iHead - _iTail;
    b720:	80 91 60 13 	lds	r24, 0x1360	; 0x801360 <customKeypad+0x108>
    b724:	90 91 61 13 	lds	r25, 0x1361	; 0x801361 <customKeypad+0x109>
    b728:	20 91 62 13 	lds	r18, 0x1362	; 0x801362 <customKeypad+0x10a>
    b72c:	30 91 63 13 	lds	r19, 0x1363	; 0x801363 <customKeypad+0x10b>
    b730:	82 1b       	sub	r24, r18
    b732:	93 0b       	sbc	r25, r19
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:96

  if (delta < 0)
    b734:	97 fd       	sbrc	r25, 7
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:97
    return N + delta;
    b736:	93 95       	inc	r25
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:184
/*!
    @brief  check how many events are in the keypads buffer
    @returns    the number of events currently in the buffer
*/
/**************************************************************************/
int Adafruit_Keypad::available() { return (_eventbuf.available() >> 1); }
    b738:	95 95       	asr	r25
    b73a:	87 95       	ror	r24
CheckKeypadInput():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:2
void CheckKeypadInput() {
	while (customKeypad.available())
    b73c:	89 2b       	or	r24, r25
    b73e:	09 f4       	brne	.+2      	; 0xb742 <main+0x105a>
    b740:	87 c0       	rjmp	.+270    	; 0xb850 <main+0x1168>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:4
	{
		keypadEvent e = customKeypad.read();
    b742:	0e 94 2d 05 	call	0xa5a	; 0xa5a <Adafruit_Keypad::read() [clone .constprop.58]>
    b746:	f8 2e       	mov	r15, r24
    b748:	e9 2e       	mov	r14, r25
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:6
		char inputdata = (char)e.bit.KEY;
		if (e.bit.EVENT == KEY_JUST_PRESSED)
    b74a:	31 e0       	ldi	r19, 0x01	; 1
    b74c:	93 13       	cpse	r25, r19
    b74e:	e8 cf       	rjmp	.-48     	; 0xb720 <main+0x1038>
pad():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/tone_function.ino:10
void waring() {
	tone(buzzerpin, 50, 1000);
}

void pad() {
	tone(buzzerpin, 5000, 50);
    b750:	42 e3       	ldi	r20, 0x32	; 50
    b752:	50 e0       	ldi	r21, 0x00	; 0
    b754:	60 e0       	ldi	r22, 0x00	; 0
    b756:	70 e0       	ldi	r23, 0x00	; 0
    b758:	88 e8       	ldi	r24, 0x88	; 136
    b75a:	93 e1       	ldi	r25, 0x13	; 19
    b75c:	0e 94 44 09 	call	0x1288	; 0x1288 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]>
    b760:	20 91 e8 09 	lds	r18, 0x09E8	; 0x8009e8 <data_index>
    b764:	30 91 e9 09 	lds	r19, 0x09E9	; 0x8009e9 <data_index+0x1>
CheckKeypadInput():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:9
		{
			pad();
			switch (inputdata)
    b768:	83 e2       	ldi	r24, 0x23	; 35
    b76a:	f8 16       	cp	r15, r24
    b76c:	09 f4       	brne	.+2      	; 0xb770 <main+0x1088>
    b76e:	52 c0       	rjmp	.+164    	; 0xb814 <main+0x112c>
    b770:	9c e3       	ldi	r25, 0x3C	; 60
    b772:	f9 16       	cp	r15, r25
    b774:	09 f4       	brne	.+2      	; 0xb778 <main+0x1090>
    b776:	5b c0       	rjmp	.+182    	; 0xb82e <main+0x1146>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:5
void CheckKeypadInput() {
	while (customKeypad.available())
	{
		keypadEvent e = customKeypad.read();
		char inputdata = (char)e.bit.KEY;
    b778:	8f 2d       	mov	r24, r15
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:22
					if (data_index > 0)		data_index--;
					keypaddata[data_index] = '\0';
				}break;
				default:
				{
					if (inputdata == '.' && data_index == 2)	inputdata = '*';
    b77a:	8e 32       	cpi	r24, 0x2E	; 46
    b77c:	21 f4       	brne	.+8      	; 0xb786 <main+0x109e>
    b77e:	22 30       	cpi	r18, 0x02	; 2
    b780:	31 05       	cpc	r19, r1
    b782:	09 f4       	brne	.+2      	; 0xb786 <main+0x109e>
main():
    b784:	8a e2       	ldi	r24, 0x2A	; 42
CheckKeypadInput():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:23
					keypaddata[data_index] = inputdata;
    b786:	f9 01       	movw	r30, r18
    b788:	e2 52       	subi	r30, 0x22	; 34
    b78a:	f6 4f       	sbci	r31, 0xF6	; 246
    b78c:	80 83       	st	Z, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:24
					data_index++;
    b78e:	2f 5f       	subi	r18, 0xFF	; 255
    b790:	3f 4f       	sbci	r19, 0xFF	; 255
    b792:	30 93 e9 09 	sts	0x09E9, r19	; 0x8009e9 <data_index+0x1>
    b796:	20 93 e8 09 	sts	0x09E8, r18	; 0x8009e8 <data_index>
    b79a:	3e c0       	rjmp	.+124    	; 0xb818 <main+0x1130>
run():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:135

		if (_countType == COUNT_DOWN)
		{
			countDown();
		}
		else if (_countType == COUNT_UP)
    b79c:	01 97       	sbiw	r24, 0x01	; 1
    b79e:	b9 f5       	brne	.+110    	; 0xb80e <main+0x1126>
countUp():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:163
	}
}

void Countimer::countUp()
{
	if (_currentCountTime < _countTime)
    b7a0:	40 91 3a 12 	lds	r20, 0x123A	; 0x80123a <resetRow1+0x8>
    b7a4:	50 91 3b 12 	lds	r21, 0x123B	; 0x80123b <resetRow1+0x9>
    b7a8:	60 91 3c 12 	lds	r22, 0x123C	; 0x80123c <resetRow1+0xa>
    b7ac:	70 91 3d 12 	lds	r23, 0x123D	; 0x80123d <resetRow1+0xb>
    b7b0:	80 91 42 12 	lds	r24, 0x1242	; 0x801242 <resetRow1+0x10>
    b7b4:	90 91 43 12 	lds	r25, 0x1243	; 0x801243 <resetRow1+0x11>
    b7b8:	a0 91 44 12 	lds	r26, 0x1244	; 0x801244 <resetRow1+0x12>
    b7bc:	b0 91 45 12 	lds	r27, 0x1245	; 0x801245 <resetRow1+0x13>
    b7c0:	48 17       	cp	r20, r24
    b7c2:	59 07       	cpc	r21, r25
    b7c4:	6a 07       	cpc	r22, r26
    b7c6:	7b 07       	cpc	r23, r27
    b7c8:	b8 f4       	brcc	.+46     	; 0xb7f8 <main+0x1110>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:165
	{
		callback();
    b7ca:	0e 94 21 06 	call	0xc42	; 0xc42 <Countimer::callback() [clone .constprop.13]>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:166
		_currentCountTime += _interval;
    b7ce:	80 91 3a 12 	lds	r24, 0x123A	; 0x80123a <resetRow1+0x8>
    b7d2:	90 91 3b 12 	lds	r25, 0x123B	; 0x80123b <resetRow1+0x9>
    b7d6:	a0 91 3c 12 	lds	r26, 0x123C	; 0x80123c <resetRow1+0xa>
    b7da:	b0 91 3d 12 	lds	r27, 0x123D	; 0x80123d <resetRow1+0xb>
    b7de:	40 91 32 12 	lds	r20, 0x1232	; 0x801232 <resetRow1>
    b7e2:	50 91 33 12 	lds	r21, 0x1233	; 0x801233 <resetRow1+0x1>
    b7e6:	60 91 34 12 	lds	r22, 0x1234	; 0x801234 <resetRow1+0x2>
    b7ea:	70 91 35 12 	lds	r23, 0x1235	; 0x801235 <resetRow1+0x3>
    b7ee:	84 0f       	add	r24, r20
    b7f0:	95 1f       	adc	r25, r21
    b7f2:	a6 1f       	adc	r26, r22
    b7f4:	b7 1f       	adc	r27, r23
    b7f6:	6c cf       	rjmp	.-296    	; 0xb6d0 <main+0xfe8>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:170
	}
	else
	{
		stop();
    b7f8:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <Countimer::stop() [clone .constprop.145]>
complete():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:183
		_callback();
}

void Countimer::complete()
{
	if(_onComplete != NULL)
    b7fc:	e0 91 48 12 	lds	r30, 0x1248	; 0x801248 <resetRow1+0x16>
    b800:	f0 91 49 12 	lds	r31, 0x1249	; 0x801249 <resetRow1+0x17>
    b804:	30 97       	sbiw	r30, 0x00	; 0
    b806:	09 f4       	brne	.+2      	; 0xb80a <main+0x1122>
    b808:	6b cf       	rjmp	.-298    	; 0xb6e0 <main+0xff8>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:184
		_onComplete();
    b80a:	19 95       	eicall
    b80c:	69 cf       	rjmp	.-302    	; 0xb6e0 <main+0xff8>
run():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:141
		{
			countUp();
		}
		else
		{
			callback();
    b80e:	0e 94 21 06 	call	0xc42	; 0xc42 <Countimer::callback() [clone .constprop.13]>
    b812:	66 cf       	rjmp	.-308    	; 0xb6e0 <main+0xff8>
CheckKeypadInput():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:13
			pad();
			switch (inputdata)
			{
				case '#':
				{
					data_available = true;
    b814:	e0 92 ea 09 	sts	0x09EA, r14	; 0x8009ea <data_available>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:28
					keypaddata[data_index] = inputdata;
					data_index++;
				}
				break;
			}
			if (data_index >= 10)	data_available = true;
    b818:	80 91 e8 09 	lds	r24, 0x09E8	; 0x8009e8 <data_index>
    b81c:	90 91 e9 09 	lds	r25, 0x09E9	; 0x8009e9 <data_index+0x1>
    b820:	0a 97       	sbiw	r24, 0x0a	; 10
    b822:	14 f0       	brlt	.+4      	; 0xb828 <main+0x1140>
    b824:	d0 92 ea 09 	sts	0x09EA, r13	; 0x8009ea <data_available>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:30

			LCDUpdateRow1();
    b828:	0e 94 4a 31 	call	0x6294	; 0x6294 <LCDUpdateRow1()>
    b82c:	79 cf       	rjmp	.-270    	; 0xb720 <main+0x1038>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:17
				{
					data_available = true;
				}break;
				case '<':
				{
					if (data_index > 0)		data_index--;
    b82e:	12 16       	cp	r1, r18
    b830:	13 06       	cpc	r1, r19
    b832:	34 f4       	brge	.+12     	; 0xb840 <main+0x1158>
    b834:	21 50       	subi	r18, 0x01	; 1
    b836:	31 09       	sbc	r19, r1
    b838:	30 93 e9 09 	sts	0x09E9, r19	; 0x8009e9 <data_index+0x1>
    b83c:	20 93 e8 09 	sts	0x09E8, r18	; 0x8009e8 <data_index>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:18
					keypaddata[data_index] = '\0';
    b840:	e0 91 e8 09 	lds	r30, 0x09E8	; 0x8009e8 <data_index>
    b844:	f0 91 e9 09 	lds	r31, 0x09E9	; 0x8009e9 <data_index+0x1>
    b848:	e2 52       	subi	r30, 0x22	; 34
    b84a:	f6 4f       	sbci	r31, 0xF6	; 246
    b84c:	10 82       	st	Z, r1
    b84e:	e4 cf       	rjmp	.-56     	; 0xb818 <main+0x1130>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:33
			if (data_index >= 10)	data_available = true;

			LCDUpdateRow1();
		}
	}
	if (data_available)
    b850:	20 90 ea 09 	lds	r2, 0x09EA	; 0x8009ea <data_available>
    b854:	22 20       	and	r2, r2
    b856:	09 f4       	brne	.+2      	; 0xb85a <main+0x1172>
    b858:	f3 c1       	rjmp	.+998    	; 0xbc40 <main+0x1558>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:35
	{
		String resault;
    b85a:	63 ea       	ldi	r22, 0xA3	; 163
    b85c:	73 e0       	ldi	r23, 0x03	; 3
    b85e:	ce 01       	movw	r24, r28
    b860:	85 96       	adiw	r24, 0x25	; 37
    b862:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:37
		//JudgeKeypadEvent();
		lcd.setCursor(0, 1);
    b866:	61 e0       	ldi	r22, 0x01	; 1
    b868:	80 e0       	ldi	r24, 0x00	; 0
    b86a:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:38
		lcd.print("                ");
    b86e:	6d e7       	ldi	r22, 0x7D	; 125
    b870:	77 e0       	ldi	r23, 0x07	; 7
    b872:	8b eb       	ldi	r24, 0xBB	; 187
    b874:	90 e1       	ldi	r25, 0x10	; 16
    b876:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:62
}

String KeypadStringDecode() {
	//Take first letter as type
	//First, we convert data form char array to string and remove '\0'
	String str = String(keypaddata);
    b87a:	6e ed       	ldi	r22, 0xDE	; 222
    b87c:	79 e0       	ldi	r23, 0x09	; 9
    b87e:	ce 01       	movw	r24, r28
    b880:	4f 96       	adiw	r24, 0x1f	; 31
    b882:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:63
	char latter = keypaddata[0];
    b886:	50 90 de 09 	lds	r5, 0x09DE	; 0x8009de <keypaddata>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:64
	int number = keypaddata[1] - '0';
    b88a:	e0 90 df 09 	lds	r14, 0x09DF	; 0x8009df <keypaddata+0x1>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:65
	char star = keypaddata[2];
    b88e:	c0 90 e0 09 	lds	r12, 0x09E0	; 0x8009e0 <keypaddata+0x2>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:66
	String data;
    b892:	63 ea       	ldi	r22, 0xA3	; 163
    b894:	73 e0       	ldi	r23, 0x03	; 3
    b896:	ce 01       	movw	r24, r28
    b898:	49 96       	adiw	r24, 0x19	; 25
    b89a:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:69

	//First, we check the first data is latter A to C
	if (latter < 65 || latter > 67)	return "*fail [?__]";
    b89e:	8f eb       	ldi	r24, 0xBF	; 191
    b8a0:	85 0d       	add	r24, r5
    b8a2:	6e e8       	ldi	r22, 0x8E	; 142
    b8a4:	77 e0       	ldi	r23, 0x07	; 7
    b8a6:	83 30       	cpi	r24, 0x03	; 3
    b8a8:	08 f0       	brcs	.+2      	; 0xb8ac <main+0x11c4>
    b8aa:	73 c0       	rjmp	.+230    	; 0xb992 <main+0x12aa>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:64
String KeypadStringDecode() {
	//Take first letter as type
	//First, we convert data form char array to string and remove '\0'
	String str = String(keypaddata);
	char latter = keypaddata[0];
	int number = keypaddata[1] - '0';
    b8ac:	0e 2c       	mov	r0, r14
    b8ae:	00 0c       	add	r0, r0
    b8b0:	ff 08       	sbc	r15, r15
    b8b2:	e0 e3       	ldi	r30, 0x30	; 48
    b8b4:	ee 1a       	sub	r14, r30
    b8b6:	f1 08       	sbc	r15, r1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:71
	String data;

	//First, we check the first data is latter A to C
	if (latter < 65 || latter > 67)	return "*fail [?__]";
	//Second, we check the second data is number
	if (number < 0 || number > 9)	return "*fail [_?_]";
    b8b8:	6a e9       	ldi	r22, 0x9A	; 154
    b8ba:	77 e0       	ldi	r23, 0x07	; 7
    b8bc:	fa e0       	ldi	r31, 0x0A	; 10
    b8be:	ef 16       	cp	r14, r31
    b8c0:	f1 04       	cpc	r15, r1
    b8c2:	08 f0       	brcs	.+2      	; 0xb8c6 <main+0x11de>
    b8c4:	66 c0       	rjmp	.+204    	; 0xb992 <main+0x12aa>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:73
	//Third, we check the third data is * or \0
	if (star == '*')	data = str.substring(3);
    b8c6:	2a e2       	ldi	r18, 0x2A	; 42
    b8c8:	c2 12       	cpse	r12, r18
    b8ca:	58 c0       	rjmp	.+176    	; 0xb97c <main+0x1294>
substring():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:178
	int indexOf( const String &str, unsigned int fromIndex ) const;
	int lastIndexOf( char ch ) const;
	int lastIndexOf( char ch, unsigned int fromIndex ) const;
	int lastIndexOf( const String &str ) const;
	int lastIndexOf( const String &str, unsigned int fromIndex ) const;
	String substring( unsigned int beginIndex ) const { return substring(beginIndex, len); };
    b8cc:	8b a0       	ldd	r8, Y+35	; 0x23
    b8ce:	9c a0       	ldd	r9, Y+36	; 0x24
main():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:618

String String::substring(unsigned int left, unsigned int right) const
{
	if (left > right) {
		unsigned int temp = right;
		right = left;
    b8d0:	33 e0       	ldi	r19, 0x03	; 3
    b8d2:	63 2e       	mov	r6, r19
    b8d4:	71 2c       	mov	r7, r1
substring():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:616
	return found;
}

String String::substring(unsigned int left, unsigned int right) const
{
	if (left > right) {
    b8d6:	33 e0       	ldi	r19, 0x03	; 3
    b8d8:	83 16       	cp	r8, r19
    b8da:	91 04       	cpc	r9, r1
    b8dc:	20 f0       	brcs	.+8      	; 0xb8e6 <main+0x11fe>
    b8de:	34 01       	movw	r6, r8
    b8e0:	43 e0       	ldi	r20, 0x03	; 3
    b8e2:	84 2e       	mov	r8, r20
    b8e4:	91 2c       	mov	r9, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:621
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
    b8e6:	63 ea       	ldi	r22, 0xA3	; 163
    b8e8:	73 e0       	ldi	r23, 0x03	; 3
    b8ea:	c8 01       	movw	r24, r16
    b8ec:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:622
	if (left >= len) return out;
    b8f0:	ab a0       	ldd	r10, Y+35	; 0x23
    b8f2:	bc a0       	ldd	r11, Y+36	; 0x24
    b8f4:	8a 14       	cp	r8, r10
    b8f6:	9b 04       	cpc	r9, r11
    b8f8:	d0 f4       	brcc	.+52     	; 0xb92e <main+0x1246>
    b8fa:	6a 14       	cp	r6, r10
    b8fc:	7b 04       	cpc	r7, r11
    b8fe:	08 f4       	brcc	.+2      	; 0xb902 <main+0x121a>
    b900:	53 01       	movw	r10, r6
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:624
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
    b902:	ef 8d       	ldd	r30, Y+31	; 0x1f
    b904:	f8 a1       	ldd	r31, Y+32	; 0x20
    b906:	ea 0d       	add	r30, r10
    b908:	fb 1d       	adc	r31, r11
    b90a:	70 80       	ld	r7, Z
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:625
	buffer[right] = '\0';	
    b90c:	10 82       	st	Z, r1
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:626
	out = buffer + left;  // pointer arithmetic
    b90e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    b910:	78 a1       	ldd	r23, Y+32	; 0x20
    b912:	68 0d       	add	r22, r8
    b914:	79 1d       	adc	r23, r9
operator=():
    b916:	c8 01       	movw	r24, r16
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:240
}
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) copy(cstr, strlen(cstr));
    b918:	61 15       	cp	r22, r1
    b91a:	71 05       	cpc	r23, r1
    b91c:	61 f1       	breq	.+88     	; 0xb976 <main+0x128e>
    b91e:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
substring():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:627
	if (left >= len) return out;
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
	buffer[right] = '\0';	
	out = buffer + left;  // pointer arithmetic
	buffer[right] = temp;  //restore character
    b922:	8f 8d       	ldd	r24, Y+31	; 0x1f
    b924:	98 a1       	ldd	r25, Y+32	; 0x20
    b926:	a8 0e       	add	r10, r24
    b928:	b9 1e       	adc	r11, r25
    b92a:	f5 01       	movw	r30, r10
    b92c:	70 82       	st	Z, r7
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String & String::operator = (String &&rval)
{
	if (this != &rval) move(rval);
    b92e:	b8 01       	movw	r22, r16
    b930:	ce 01       	movw	r24, r28
    b932:	49 96       	adiw	r24, 0x19	; 25
    b934:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:73
    b938:	c8 01       	movw	r24, r16
    b93a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:78
	else if (star == '\0') data = "nan";
	else return "*fail [__?]";

	//Switch the program to excute by latter
	switch (latter)
    b93e:	f2 e4       	ldi	r31, 0x42	; 66
    b940:	5f 16       	cp	r5, r31
    b942:	09 f4       	brne	.+2      	; 0xb946 <main+0x125e>
    b944:	be c0       	rjmp	.+380    	; 0xbac2 <main+0x13da>
    b946:	23 e4       	ldi	r18, 0x43	; 67
    b948:	52 16       	cp	r5, r18
    b94a:	09 f4       	brne	.+2      	; 0xb94e <main+0x1266>
    b94c:	89 c2       	rjmp	.+1298   	; 0xbe60 <main+0x1778>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:82
	{
		case 'A': //Calibration parameter
		{
			switch (number)
    b94e:	f7 01       	movw	r30, r14
    b950:	31 97       	sbiw	r30, 0x01	; 1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:109
		///thermocouple calibration action---
			case 7:
				star == '\0' ? calibrateThermo(25.0f) : calibrateThermo(data.toFloat());
				break;
			default:
				return "*fail [Acmd]";
    b952:	63 ec       	ldi	r22, 0xC3	; 195
    b954:	77 e0       	ldi	r23, 0x07	; 7
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:82
	//Switch the program to excute by latter
	switch (latter)
	{
		case 'A': //Calibration parameter
		{
			switch (number)
    b956:	e7 30       	cpi	r30, 0x07	; 7
    b958:	f1 05       	cpc	r31, r1
    b95a:	d8 f4       	brcc	.+54     	; 0xb992 <main+0x12aa>
    b95c:	88 27       	eor	r24, r24
    b95e:	ec 54       	subi	r30, 0x4C	; 76
    b960:	f3 4a       	sbci	r31, 0xA3	; 163
    b962:	8f 4f       	sbci	r24, 0xFF	; 255
    b964:	0c 94 2b 6c 	jmp	0xd856	; 0xd856 <__tablejump2__>
    b968:	cd 5c       	subi	r28, 0xCD	; 205
    b96a:	de 5c       	subi	r29, 0xCE	; 206
    b96c:	f8 5c       	subi	r31, 0xC8	; 200
    b96e:	0d 5d       	subi	r16, 0xDD	; 221
    b970:	2a 5d       	subi	r18, 0xDA	; 218
    b972:	3f 5d       	subi	r19, 0xDF	; 223
    b974:	54 5d       	subi	r21, 0xD4	; 212
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:241
#endif

String & String::operator = (const char *cstr)
{
	if (cstr) copy(cstr, strlen(cstr));
	else invalidate();
    b976:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <String::invalidate()>
    b97a:	d3 cf       	rjmp	.-90     	; 0xb922 <main+0x123a>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:74
	if (latter < 65 || latter > 67)	return "*fail [?__]";
	//Second, we check the second data is number
	if (number < 0 || number > 9)	return "*fail [_?_]";
	//Third, we check the third data is * or \0
	if (star == '*')	data = str.substring(3);
	else if (star == '\0') data = "nan";
    b97c:	c1 10       	cpse	r12, r1
    b97e:	07 c0       	rjmp	.+14     	; 0xb98e <main+0x12a6>
operator=():
    b980:	6d e6       	ldi	r22, 0x6D	; 109
    b982:	73 e0       	ldi	r23, 0x03	; 3
    b984:	ce 01       	movw	r24, r28
    b986:	49 96       	adiw	r24, 0x19	; 25
    b988:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
    b98c:	d8 cf       	rjmp	.-80     	; 0xb93e <main+0x1256>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:75
	else return "*fail [__?]";
    b98e:	66 ea       	ldi	r22, 0xA6	; 166
    b990:	77 e0       	ldi	r23, 0x07	; 7
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:200
		break;
		default:
			return "*fail";
		break;
	}
	return "*OK";
    b992:	c8 01       	movw	r24, r16
    b994:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    b998:	18 c1       	rjmp	.+560    	; 0xbbca <main+0x14e2>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:86
		{
			switch (number)
			{
		///Conductivity calibration action---
			case 1:
				ECCalibration("dry", NULL);
    b99a:	62 eb       	ldi	r22, 0xB2	; 178
    b99c:	77 e0       	ldi	r23, 0x07	; 7
    b99e:	c8 01       	movw	r24, r16
    b9a0:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    b9a4:	40 e0       	ldi	r20, 0x00	; 0
    b9a6:	50 e0       	ldi	r21, 0x00	; 0
    b9a8:	ba 01       	movw	r22, r20
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:92
				break;
			case 2:
				star == '\0' ? ECCalibration( "low", 12880) : ECCalibration( "low", data.toInt());
				break;
			case 3:
				star == '\0' ? ECCalibration("high", 80000) : ECCalibration("high", data.toInt());
    b9aa:	c8 01       	movw	r24, r16
    b9ac:	0e 94 a8 33 	call	0x6750	; 0x6750 <ECCalibration(String, long)>
    b9b0:	c8 01       	movw	r24, r16
    b9b2:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:200
		break;
		default:
			return "*fail";
		break;
	}
	return "*OK";
    b9b6:	6a e3       	ldi	r22, 0x3A	; 58
    b9b8:	74 e0       	ldi	r23, 0x04	; 4
    b9ba:	eb cf       	rjmp	.-42     	; 0xb992 <main+0x12aa>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:89
		///Conductivity calibration action---
			case 1:
				ECCalibration("dry", NULL);
				break;
			case 2:
				star == '\0' ? ECCalibration( "low", 12880) : ECCalibration( "low", data.toInt());
    b9bc:	c1 10       	cpse	r12, r1
    b9be:	0a c0       	rjmp	.+20     	; 0xb9d4 <main+0x12ec>
    b9c0:	66 eb       	ldi	r22, 0xB6	; 182
    b9c2:	77 e0       	ldi	r23, 0x07	; 7
    b9c4:	c8 01       	movw	r24, r16
    b9c6:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    b9ca:	40 e5       	ldi	r20, 0x50	; 80
    b9cc:	52 e3       	ldi	r21, 0x32	; 50
    b9ce:	60 e0       	ldi	r22, 0x00	; 0
    b9d0:	70 e0       	ldi	r23, 0x00	; 0
    b9d2:	eb cf       	rjmp	.-42     	; 0xb9aa <main+0x12c2>
    b9d4:	ce 01       	movw	r24, r28
    b9d6:	49 96       	adiw	r24, 0x19	; 25
    b9d8:	0e 94 c0 28 	call	0x5180	; 0x5180 <String::toInt() const>
    b9dc:	4b 01       	movw	r8, r22
    b9de:	5c 01       	movw	r10, r24
    b9e0:	66 eb       	ldi	r22, 0xB6	; 182
    b9e2:	77 e0       	ldi	r23, 0x07	; 7
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:92
				break;
			case 3:
				star == '\0' ? ECCalibration("high", 80000) : ECCalibration("high", data.toInt());
    b9e4:	c8 01       	movw	r24, r16
    b9e6:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    b9ea:	b5 01       	movw	r22, r10
    b9ec:	a4 01       	movw	r20, r8
    b9ee:	dd cf       	rjmp	.-70     	; 0xb9aa <main+0x12c2>
    b9f0:	c1 10       	cpse	r12, r1
    b9f2:	0a c0       	rjmp	.+20     	; 0xba08 <main+0x1320>
    b9f4:	6a eb       	ldi	r22, 0xBA	; 186
    b9f6:	77 e0       	ldi	r23, 0x07	; 7
    b9f8:	c8 01       	movw	r24, r16
    b9fa:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    b9fe:	40 e8       	ldi	r20, 0x80	; 128
    ba00:	58 e3       	ldi	r21, 0x38	; 56
    ba02:	61 e0       	ldi	r22, 0x01	; 1
    ba04:	70 e0       	ldi	r23, 0x00	; 0
    ba06:	d1 cf       	rjmp	.-94     	; 0xb9aa <main+0x12c2>
    ba08:	ce 01       	movw	r24, r28
    ba0a:	49 96       	adiw	r24, 0x19	; 25
    ba0c:	0e 94 c0 28 	call	0x5180	; 0x5180 <String::toInt() const>
    ba10:	4b 01       	movw	r8, r22
    ba12:	5c 01       	movw	r10, r24
    ba14:	6a eb       	ldi	r22, 0xBA	; 186
    ba16:	77 e0       	ldi	r23, 0x07	; 7
    ba18:	e5 cf       	rjmp	.-54     	; 0xb9e4 <main+0x12fc>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:96
				break;
		///pH calibration action---
			case 4:
				star == '\0' ? pHCalibration( "mid",  7.0f) : pHCalibration( "mid", data.toFloat());
    ba1a:	c1 10       	cpse	r12, r1
    ba1c:	0d c0       	rjmp	.+26     	; 0xba38 <main+0x1350>
    ba1e:	6f eb       	ldi	r22, 0xBF	; 191
    ba20:	77 e0       	ldi	r23, 0x07	; 7
    ba22:	c8 01       	movw	r24, r16
    ba24:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    ba28:	40 e0       	ldi	r20, 0x00	; 0
    ba2a:	50 e0       	ldi	r21, 0x00	; 0
    ba2c:	60 ee       	ldi	r22, 0xE0	; 224
    ba2e:	70 e4       	ldi	r23, 0x40	; 64
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:99
				break;
			case 5:
				star == '\0' ? pHCalibration( "low",  4.0f) : pHCalibration( "low", data.toFloat());
    ba30:	c8 01       	movw	r24, r16
    ba32:	0e 94 02 32 	call	0x6404	; 0x6404 <pHCalibration(String, float)>
    ba36:	bc cf       	rjmp	.-136    	; 0xb9b0 <main+0x12c8>
toFloat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:743
	return 0;
}

float String::toFloat(void) const
{
	return float(toDouble());
    ba38:	ce 01       	movw	r24, r28
    ba3a:	49 96       	adiw	r24, 0x19	; 25
    ba3c:	0e 94 b5 28 	call	0x516a	; 0x516a <String::toDouble() const>
    ba40:	4b 01       	movw	r8, r22
    ba42:	5c 01       	movw	r10, r24
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:96
			case 3:
				star == '\0' ? ECCalibration("high", 80000) : ECCalibration("high", data.toInt());
				break;
		///pH calibration action---
			case 4:
				star == '\0' ? pHCalibration( "mid",  7.0f) : pHCalibration( "mid", data.toFloat());
    ba44:	6f eb       	ldi	r22, 0xBF	; 191
    ba46:	77 e0       	ldi	r23, 0x07	; 7
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:102
				break;
			case 5:
				star == '\0' ? pHCalibration( "low",  4.0f) : pHCalibration( "low", data.toFloat());
				break;
			case 6:
				star == '\0' ? pHCalibration("high", 10.0f) : pHCalibration("high", data.toFloat());
    ba48:	c8 01       	movw	r24, r16
    ba4a:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    ba4e:	b5 01       	movw	r22, r10
    ba50:	a4 01       	movw	r20, r8
    ba52:	ee cf       	rjmp	.-36     	; 0xba30 <main+0x1348>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:99
		///pH calibration action---
			case 4:
				star == '\0' ? pHCalibration( "mid",  7.0f) : pHCalibration( "mid", data.toFloat());
				break;
			case 5:
				star == '\0' ? pHCalibration( "low",  4.0f) : pHCalibration( "low", data.toFloat());
    ba54:	c1 10       	cpse	r12, r1
    ba56:	0a c0       	rjmp	.+20     	; 0xba6c <main+0x1384>
    ba58:	66 eb       	ldi	r22, 0xB6	; 182
    ba5a:	77 e0       	ldi	r23, 0x07	; 7
    ba5c:	c8 01       	movw	r24, r16
    ba5e:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    ba62:	40 e0       	ldi	r20, 0x00	; 0
    ba64:	50 e0       	ldi	r21, 0x00	; 0
    ba66:	60 e8       	ldi	r22, 0x80	; 128
    ba68:	70 e4       	ldi	r23, 0x40	; 64
    ba6a:	e2 cf       	rjmp	.-60     	; 0xba30 <main+0x1348>
toFloat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:743
    ba6c:	ce 01       	movw	r24, r28
    ba6e:	49 96       	adiw	r24, 0x19	; 25
    ba70:	0e 94 b5 28 	call	0x516a	; 0x516a <String::toDouble() const>
    ba74:	4b 01       	movw	r8, r22
    ba76:	5c 01       	movw	r10, r24
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:99
    ba78:	66 eb       	ldi	r22, 0xB6	; 182
    ba7a:	77 e0       	ldi	r23, 0x07	; 7
    ba7c:	e5 cf       	rjmp	.-54     	; 0xba48 <main+0x1360>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:102
				break;
			case 6:
				star == '\0' ? pHCalibration("high", 10.0f) : pHCalibration("high", data.toFloat());
    ba7e:	c1 10       	cpse	r12, r1
    ba80:	0a c0       	rjmp	.+20     	; 0xba96 <main+0x13ae>
    ba82:	6a eb       	ldi	r22, 0xBA	; 186
    ba84:	77 e0       	ldi	r23, 0x07	; 7
    ba86:	c8 01       	movw	r24, r16
    ba88:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    ba8c:	40 e0       	ldi	r20, 0x00	; 0
    ba8e:	50 e0       	ldi	r21, 0x00	; 0
    ba90:	60 e2       	ldi	r22, 0x20	; 32
    ba92:	71 e4       	ldi	r23, 0x41	; 65
    ba94:	cd cf       	rjmp	.-102    	; 0xba30 <main+0x1348>
toFloat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:743
    ba96:	ce 01       	movw	r24, r28
    ba98:	49 96       	adiw	r24, 0x19	; 25
    ba9a:	0e 94 b5 28 	call	0x516a	; 0x516a <String::toDouble() const>
    ba9e:	4b 01       	movw	r8, r22
    baa0:	5c 01       	movw	r10, r24
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:102
    baa2:	6a eb       	ldi	r22, 0xBA	; 186
    baa4:	77 e0       	ldi	r23, 0x07	; 7
    baa6:	d0 cf       	rjmp	.-96     	; 0xba48 <main+0x1360>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:106
				break;
		///thermocouple calibration action---
			case 7:
				star == '\0' ? calibrateThermo(25.0f) : calibrateThermo(data.toFloat());
    baa8:	60 e0       	ldi	r22, 0x00	; 0
    baaa:	70 e0       	ldi	r23, 0x00	; 0
    baac:	88 ec       	ldi	r24, 0xC8	; 200
    baae:	91 e4       	ldi	r25, 0x41	; 65
    bab0:	cc 20       	and	r12, r12
    bab2:	21 f0       	breq	.+8      	; 0xbabc <main+0x13d4>
toFloat():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:743
    bab4:	ce 01       	movw	r24, r28
    bab6:	49 96       	adiw	r24, 0x19	; 25
    bab8:	0e 94 b5 28 	call	0x516a	; 0x516a <String::toDouble() const>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:106
    babc:	0e 94 87 4a 	call	0x950e	; 0x950e <calibrateThermo(float)>
    bac0:	7a cf       	rjmp	.-268    	; 0xb9b6 <main+0x12ce>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:116
			}
		}
		break;
		case 'B':
		{
			switch (number)
    bac2:	32 e0       	ldi	r19, 0x02	; 2
    bac4:	e3 16       	cp	r14, r19
    bac6:	f1 04       	cpc	r15, r1
    bac8:	09 f4       	brne	.+2      	; 0xbacc <main+0x13e4>
    baca:	43 c0       	rjmp	.+134    	; 0xbb52 <main+0x146a>
    bacc:	83 e0       	ldi	r24, 0x03	; 3
    bace:	e8 16       	cp	r14, r24
    bad0:	f1 04       	cpc	r15, r1
    bad2:	09 f4       	brne	.+2      	; 0xbad6 <main+0x13ee>
    bad4:	b2 c1       	rjmp	.+868    	; 0xbe3a <main+0x1752>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:139
				{
					updatePumpValue(data.toInt());
				}
					break;
				default:
					return "*fail [Bcmd]";
    bad6:	6c ee       	ldi	r22, 0xEC	; 236
    bad8:	77 e0       	ldi	r23, 0x07	; 7
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:116
			}
		}
		break;
		case 'B':
		{
			switch (number)
    bada:	ea 94       	dec	r14
    badc:	ef 28       	or	r14, r15
    bade:	09 f0       	breq	.+2      	; 0xbae2 <main+0x13fa>
    bae0:	58 cf       	rjmp	.-336    	; 0xb992 <main+0x12aa>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:121
			{
		///powersaving mode action---
				case 1:
				{
					String cmd = "P," + String(data.toInt()) + "\r";
    bae2:	ce 01       	movw	r24, r28
    bae4:	49 96       	adiw	r24, 0x19	; 25
    bae6:	0e 94 c0 28 	call	0x5180	; 0x5180 <String::toInt() const>
    baea:	ab 01       	movw	r20, r22
    baec:	bc 01       	movw	r22, r24
    baee:	c8 01       	movw	r24, r16
    baf0:	0e 94 9c 2b 	call	0x5738	; 0x5738 <String::String(long, unsigned char) [clone .constprop.40]>
_ZN15StringSumHelperC2EPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:217

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    baf4:	60 ed       	ldi	r22, 0xD0	; 208
    baf6:	77 e0       	ldi	r23, 0x07	; 7
    baf8:	ce 01       	movw	r24, r28
    bafa:	07 96       	adiw	r24, 0x07	; 7
    bafc:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:121
    bb00:	b8 01       	movw	r22, r16
    bb02:	ce 01       	movw	r24, r28
    bb04:	07 96       	adiw	r24, 0x07	; 7
    bb06:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    bb0a:	66 e9       	ldi	r22, 0x96	; 150
    bb0c:	78 e0       	ldi	r23, 0x08	; 8
    bb0e:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    bb12:	bc 01       	movw	r22, r24
    bb14:	ce 01       	movw	r24, r28
    bb16:	0d 96       	adiw	r24, 0x0d	; 13
    bb18:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    bb1c:	ce 01       	movw	r24, r28
    bb1e:	07 96       	adiw	r24, 0x07	; 7
    bb20:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    bb24:	c8 01       	movw	r24, r16
    bb26:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:122
					if(!SerialDecode(cmd)) return "*fail [B1]";
    bb2a:	be 01       	movw	r22, r28
    bb2c:	63 5f       	subi	r22, 0xF3	; 243
    bb2e:	7f 4f       	sbci	r23, 0xFF	; 255
    bb30:	c8 01       	movw	r24, r16
    bb32:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    bb36:	c8 01       	movw	r24, r16
    bb38:	0e 94 f4 4a 	call	0x95e8	; 0x95e8 <SerialDecode(String)>
    bb3c:	f8 2e       	mov	r15, r24
    bb3e:	c8 01       	movw	r24, r16
    bb40:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    bb44:	63 ed       	ldi	r22, 0xD3	; 211
    bb46:	77 e0       	ldi	r23, 0x07	; 7
    bb48:	ff 20       	and	r15, r15
    bb4a:	c1 f1       	breq	.+112    	; 0xbbbc <main+0x14d4>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:158
			}
			break;
		///EC print way 0:uS 1:salinity
			case 2:
			{
				String cmd = "S," + String(data.toInt()) + "\r";
    bb4c:	ce 01       	movw	r24, r28
    bb4e:	0d 96       	adiw	r24, 0x0d	; 13
    bb50:	30 cf       	rjmp	.-416    	; 0xb9b2 <main+0x12ca>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:128
				}
					break;
		///Interval setting action---
				case 2:
				{
					String cmd = "I," + String(data.toInt()) + "\r";
    bb52:	ce 01       	movw	r24, r28
    bb54:	49 96       	adiw	r24, 0x19	; 25
    bb56:	0e 94 c0 28 	call	0x5180	; 0x5180 <String::toInt() const>
    bb5a:	ab 01       	movw	r20, r22
    bb5c:	bc 01       	movw	r22, r24
    bb5e:	c8 01       	movw	r24, r16
    bb60:	0e 94 9c 2b 	call	0x5738	; 0x5738 <String::String(long, unsigned char) [clone .constprop.40]>
_ZN15StringSumHelperC2EPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:217
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    bb64:	6e ed       	ldi	r22, 0xDE	; 222
    bb66:	77 e0       	ldi	r23, 0x07	; 7
    bb68:	ce 01       	movw	r24, r28
    bb6a:	07 96       	adiw	r24, 0x07	; 7
    bb6c:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:128
    bb70:	b8 01       	movw	r22, r16
    bb72:	ce 01       	movw	r24, r28
    bb74:	07 96       	adiw	r24, 0x07	; 7
    bb76:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    bb7a:	66 e9       	ldi	r22, 0x96	; 150
    bb7c:	78 e0       	ldi	r23, 0x08	; 8
    bb7e:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    bb82:	bc 01       	movw	r22, r24
    bb84:	ce 01       	movw	r24, r28
    bb86:	0d 96       	adiw	r24, 0x0d	; 13
    bb88:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    bb8c:	ce 01       	movw	r24, r28
    bb8e:	07 96       	adiw	r24, 0x07	; 7
    bb90:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    bb94:	c8 01       	movw	r24, r16
    bb96:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:129
					if (!SerialDecode(cmd)) return "*fail [B2]";
    bb9a:	be 01       	movw	r22, r28
    bb9c:	63 5f       	subi	r22, 0xF3	; 243
    bb9e:	7f 4f       	sbci	r23, 0xFF	; 255
    bba0:	c8 01       	movw	r24, r16
    bba2:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    bba6:	c8 01       	movw	r24, r16
    bba8:	0e 94 f4 4a 	call	0x95e8	; 0x95e8 <SerialDecode(String)>
    bbac:	f8 2e       	mov	r15, r24
    bbae:	c8 01       	movw	r24, r16
    bbb0:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    bbb4:	61 ee       	ldi	r22, 0xE1	; 225
    bbb6:	77 e0       	ldi	r23, 0x07	; 7
    bbb8:	f1 10       	cpse	r15, r1
    bbba:	c8 cf       	rjmp	.-112    	; 0xbb4c <main+0x1464>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:159
			break;
		///EC print way 0:uS 1:salinity
			case 2:
			{
				String cmd = "S," + String(data.toInt()) + "\r";
				if (!SerialDecode(cmd)) return "*fail [C2]";
    bbbc:	c8 01       	movw	r24, r16
    bbbe:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    bbc2:	ce 01       	movw	r24, r28
    bbc4:	0d 96       	adiw	r24, 0x0d	; 13
    bbc6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:66
	//First, we convert data form char array to string and remove '\0'
	String str = String(keypaddata);
	char latter = keypaddata[0];
	int number = keypaddata[1] - '0';
	char star = keypaddata[2];
	String data;
    bbca:	ce 01       	movw	r24, r28
    bbcc:	49 96       	adiw	r24, 0x19	; 25
    bbce:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:62
}

String KeypadStringDecode() {
	//Take first letter as type
	//First, we convert data form char array to string and remove '\0'
	String str = String(keypaddata);
    bbd2:	ce 01       	movw	r24, r28
    bbd4:	4f 96       	adiw	r24, 0x1f	; 31
    bbd6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
operator=():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:227
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
String & String::operator = (String &&rval)
{
	if (this != &rval) move(rval);
    bbda:	b8 01       	movw	r22, r16
    bbdc:	ce 01       	movw	r24, r28
    bbde:	85 96       	adiw	r24, 0x25	; 37
    bbe0:	0e 94 a5 29 	call	0x534a	; 0x534a <String::move(String&)>
CheckKeypadInput():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:39
	{
		String resault;
		//JudgeKeypadEvent();
		lcd.setCursor(0, 1);
		lcd.print("                ");
		resault = KeypadStringDecode();
    bbe4:	c8 01       	movw	r24, r16
    bbe6:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:40
		Serial.println(resault);
    bbea:	be 01       	movw	r22, r28
    bbec:	6b 5d       	subi	r22, 0xDB	; 219
    bbee:	7f 4f       	sbci	r23, 0xFF	; 255
    bbf0:	82 e5       	ldi	r24, 0x52	; 82
    bbf2:	9e e0       	ldi	r25, 0x0E	; 14
    bbf4:	0e 94 4e 28 	call	0x509c	; 0x509c <Print::println(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:41
		lcd.setCursor(0, 1);
    bbf8:	61 e0       	ldi	r22, 0x01	; 1
    bbfa:	80 e0       	ldi	r24, 0x00	; 0
    bbfc:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:42
		lcd.print(resault);
    bc00:	be 01       	movw	r22, r28
    bc02:	6b 5d       	subi	r22, 0xDB	; 219
    bc04:	7f 4f       	sbci	r23, 0xFF	; 255
    bc06:	8b eb       	ldi	r24, 0xBB	; 187
    bc08:	90 e1       	ldi	r25, 0x10	; 16
    bc0a:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
start():
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:92
	return _isStopped;
}

void Countimer::start()
{
	_isStopped = false;
    bc0e:	10 92 4b 12 	sts	0x124B, r1	; 0x80124b <resetRow1+0x19>
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:93
	if(_isCounterCompleted)
    bc12:	80 91 4a 12 	lds	r24, 0x124A	; 0x80124a <resetRow1+0x18>
    bc16:	81 11       	cpse	r24, r1
D:\USER\Documents\Arduino\libraries\Countimer-master/Countimer.cpp:94
		_isCounterCompleted = false;
    bc18:	10 92 4a 12 	sts	0x124A, r1	; 0x80124a <resetRow1+0x18>
ResetKeypadData():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:51
	}
	delay(10);
}

void ResetKeypadData() {
	data_available = false;
    bc1c:	10 92 ea 09 	sts	0x09EA, r1	; 0x8009ea <data_available>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:52
	data_index = 0;
    bc20:	10 92 e9 09 	sts	0x09E9, r1	; 0x8009e9 <data_index+0x1>
    bc24:	10 92 e8 09 	sts	0x09E8, r1	; 0x8009e8 <data_index>
    bc28:	ee ed       	ldi	r30, 0xDE	; 222
    bc2a:	f9 e0       	ldi	r31, 0x09	; 9
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:55
	//Serial.println(String(keypaddata));
	for (int i = 0; i < 10; i++) {
		keypaddata[i] = '\0';
    bc2c:	11 92       	st	Z+, r1
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:54

void ResetKeypadData() {
	data_available = false;
	data_index = 0;
	//Serial.println(String(keypaddata));
	for (int i = 0; i < 10; i++) {
    bc2e:	28 ee       	ldi	r18, 0xE8	; 232
    bc30:	39 e0       	ldi	r19, 0x09	; 9
    bc32:	2e 17       	cp	r18, r30
    bc34:	3f 07       	cpc	r19, r31
    bc36:	d1 f7       	brne	.-12     	; 0xbc2c <main+0x1544>
CheckKeypadInput():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:35
			LCDUpdateRow1();
		}
	}
	if (data_available)
	{
		String resault;
    bc38:	ce 01       	movw	r24, r28
    bc3a:	85 96       	adiw	r24, 0x25	; 37
    bc3c:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:47
		lcd.print(resault);
		//row1cleared = false;
		resetRow1.start();
		ResetKeypadData();
	}
	delay(10);
    bc40:	6a e0       	ldi	r22, 0x0A	; 10
    bc42:	70 e0       	ldi	r23, 0x00	; 0
    bc44:	80 e0       	ldi	r24, 0x00	; 0
    bc46:	90 e0       	ldi	r25, 0x00	; 0
    bc48:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
SerialDecodeLoop():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:482
		}
	}
}

void SerialDecodeLoop() {
	if (serialComplete) {
    bc4c:	80 91 eb 09 	lds	r24, 0x09EB	; 0x8009eb <serialComplete>
    bc50:	88 23       	and	r24, r24
    bc52:	99 f0       	breq	.+38     	; 0xbc7a <main+0x1592>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:483
		SerialDecode(strSerial);
    bc54:	68 e4       	ldi	r22, 0x48	; 72
    bc56:	7f e0       	ldi	r23, 0x0F	; 15
    bc58:	c8 01       	movw	r24, r16
    bc5a:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    bc5e:	c8 01       	movw	r24, r16
    bc60:	0e 94 f4 4a 	call	0x95e8	; 0x95e8 <SerialDecode(String)>
    bc64:	c8 01       	movw	r24, r16
    bc66:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
operator=():
    bc6a:	63 ea       	ldi	r22, 0xA3	; 163
    bc6c:	73 e0       	ldi	r23, 0x03	; 3
    bc6e:	88 e4       	ldi	r24, 0x48	; 72
    bc70:	9f e0       	ldi	r25, 0x0F	; 15
    bc72:	0e 94 3c 2b 	call	0x5678	; 0x5678 <String::operator=(char const*) [clone .part.3]>
SerialDecodeLoop():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:485
		strSerial = "";
		serialComplete = false;
    bc76:	10 92 eb 09 	sts	0x09EB, r1	; 0x8009eb <serialComplete>
loop():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:438
	gps_new_get();					//GPS Function									 [GPS_DATA]
	resetRow1.run();
	IOloop();
	SerialDecodeLoop();
///Update By Interval Set in "interval" ==================================================
	if (abs(millis() - last_time) >= interval)
    bc7a:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    bc7e:	4b 01       	movw	r8, r22
    bc80:	5c 01       	movw	r10, r24
    bc82:	40 90 f5 09 	lds	r4, 0x09F5	; 0x8009f5 <last_time>
    bc86:	50 90 f6 09 	lds	r5, 0x09F6	; 0x8009f6 <last_time+0x1>
    bc8a:	60 90 f7 09 	lds	r6, 0x09F7	; 0x8009f7 <last_time+0x2>
    bc8e:	70 90 f8 09 	lds	r7, 0x09F8	; 0x8009f8 <last_time+0x3>
    bc92:	84 14       	cp	r8, r4
    bc94:	95 04       	cpc	r9, r5
    bc96:	a6 04       	cpc	r10, r6
    bc98:	b7 04       	cpc	r11, r7
    bc9a:	09 f4       	brne	.+2      	; 0xbc9e <main+0x15b6>
    bc9c:	9b c2       	rjmp	.+1334   	; 0xc1d4 <main+0x1aec>
    bc9e:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    bca2:	4b 01       	movw	r8, r22
    bca4:	5c 01       	movw	r10, r24
    bca6:	84 18       	sub	r8, r4
    bca8:	95 08       	sbc	r9, r5
    bcaa:	a6 08       	sbc	r10, r6
    bcac:	b7 08       	sbc	r11, r7
    bcae:	80 91 89 02 	lds	r24, 0x0289	; 0x800289 <interval>
    bcb2:	90 91 8a 02 	lds	r25, 0x028A	; 0x80028a <interval+0x1>
    bcb6:	a0 91 8b 02 	lds	r26, 0x028B	; 0x80028b <interval+0x2>
    bcba:	b0 91 8c 02 	lds	r27, 0x028C	; 0x80028c <interval+0x3>
    bcbe:	88 16       	cp	r8, r24
    bcc0:	99 06       	cpc	r9, r25
    bcc2:	aa 06       	cpc	r10, r26
    bcc4:	bb 06       	cpc	r11, r27
    bcc6:	08 f4       	brcc	.+2      	; 0xbcca <main+0x15e2>
    bcc8:	52 c0       	rjmp	.+164    	; 0xbd6e <main+0x1686>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:440
	{
		last_time = millis();		//Set Time for Time Action
    bcca:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    bcce:	60 93 f5 09 	sts	0x09F5, r22	; 0x8009f5 <last_time>
    bcd2:	70 93 f6 09 	sts	0x09F6, r23	; 0x8009f6 <last_time+0x1>
    bcd6:	80 93 f7 09 	sts	0x09F7, r24	; 0x8009f7 <last_time+0x2>
    bcda:	90 93 f8 09 	sts	0x09F8, r25	; 0x8009f8 <last_time+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:441
		last_time2 = millis();		//Set Time for Time Action
    bcde:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    bce2:	60 93 f1 09 	sts	0x09F1, r22	; 0x8009f1 <last_time2>
    bce6:	70 93 f2 09 	sts	0x09F2, r23	; 0x8009f2 <last_time2+0x1>
    bcea:	80 93 f3 09 	sts	0x09F3, r24	; 0x8009f3 <last_time2+0x2>
    bcee:	90 93 f4 09 	sts	0x09F4, r25	; 0x8009f4 <last_time2+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:442
		doMeasure();
    bcf2:	0e 94 c2 3a 	call	0x7584	; 0x7584 <doMeasure()>
freeMemory():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SRam_Check.ino:13
    bcf6:	80 91 6a 13 	lds	r24, 0x136A	; 0x80136a <__brkval>
    bcfa:	90 91 6b 13 	lds	r25, 0x136B	; 0x80136b <__brkval+0x1>
    bcfe:	78 01       	movw	r14, r16
    bd00:	e8 1a       	sub	r14, r24
    bd02:	f9 0a       	sbc	r15, r25
checkSRam():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SRam_Check.ino:21
#endif  // __arm__
}

void checkSRam() {
	int sRam = freeMemory();
	if (sRam < 3000) {
    bd04:	38 eb       	ldi	r19, 0xB8	; 184
    bd06:	e3 16       	cp	r14, r19
    bd08:	3b e0       	ldi	r19, 0x0B	; 11
    bd0a:	f3 06       	cpc	r15, r19
    bd0c:	d4 f4       	brge	.+52     	; 0xbd42 <main+0x165a>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SRam_Check.ino:22
		lcd.setCursor(0, 1);
    bd0e:	61 e0       	ldi	r22, 0x01	; 1
    bd10:	80 e0       	ldi	r24, 0x00	; 0
    bd12:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SRam_Check.ino:23
		lcd.print("SRam-> ");
    bd16:	65 ef       	ldi	r22, 0xF5	; 245
    bd18:	78 e0       	ldi	r23, 0x08	; 8
    bd1a:	8b eb       	ldi	r24, 0xBB	; 187
    bd1c:	90 e1       	ldi	r25, 0x10	; 16
    bd1e:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SRam_Check.ino:24
		lcd.print(String(sRam));
    bd22:	b7 01       	movw	r22, r14
    bd24:	c8 01       	movw	r24, r16
    bd26:	0e 94 46 2b 	call	0x568c	; 0x568c <String::String(int, unsigned char) [clone .constprop.124]>
    bd2a:	b8 01       	movw	r22, r16
    bd2c:	8b eb       	ldi	r24, 0xBB	; 187
    bd2e:	90 e1       	ldi	r25, 0x10	; 16
    bd30:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
    bd34:	c8 01       	movw	r24, r16
    bd36:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SRam_Check.ino:25
		RamER.resume();
    bd3a:	8e e4       	ldi	r24, 0x4E	; 78
    bd3c:	9f e0       	ldi	r25, 0x0F	; 15
    bd3e:	0e 94 60 1d 	call	0x3ac0	; 0x3ac0 <BlinkControl::resume()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SRam_Check.ino:27
	}
	SerialDebug("SRam=", String(sRam));
    bd42:	b7 01       	movw	r22, r14
    bd44:	c8 01       	movw	r24, r16
    bd46:	0e 94 46 2b 	call	0x568c	; 0x568c <String::String(int, unsigned char) [clone .constprop.124]>
    bd4a:	6d ef       	ldi	r22, 0xFD	; 253
    bd4c:	78 e0       	ldi	r23, 0x08	; 8
    bd4e:	ce 01       	movw	r24, r28
    bd50:	07 96       	adiw	r24, 0x07	; 7
    bd52:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    bd56:	b8 01       	movw	r22, r16
    bd58:	ce 01       	movw	r24, r28
    bd5a:	07 96       	adiw	r24, 0x07	; 7
    bd5c:	0e 94 92 28 	call	0x5124	; 0x5124 <SerialDebug(String, String)>
    bd60:	ce 01       	movw	r24, r28
    bd62:	07 96       	adiw	r24, 0x07	; 7
    bd64:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    bd68:	c8 01       	movw	r24, r16
    bd6a:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
loop():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:446
		checkSRam();
	}
///Update By Interval of 1s ==============================================================
	if (abs(millis() - last_time2) >= 1000)
    bd6e:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    bd72:	4b 01       	movw	r8, r22
    bd74:	5c 01       	movw	r10, r24
    bd76:	40 90 f1 09 	lds	r4, 0x09F1	; 0x8009f1 <last_time2>
    bd7a:	50 90 f2 09 	lds	r5, 0x09F2	; 0x8009f2 <last_time2+0x1>
    bd7e:	60 90 f3 09 	lds	r6, 0x09F3	; 0x8009f3 <last_time2+0x2>
    bd82:	70 90 f4 09 	lds	r7, 0x09F4	; 0x8009f4 <last_time2+0x3>
    bd86:	84 14       	cp	r8, r4
    bd88:	95 04       	cpc	r9, r5
    bd8a:	a6 04       	cpc	r10, r6
    bd8c:	b7 04       	cpc	r11, r7
    bd8e:	09 f4       	brne	.+2      	; 0xbd92 <main+0x16aa>
    bd90:	28 c2       	rjmp	.+1104   	; 0xc1e2 <main+0x1afa>
    bd92:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    bd96:	64 19       	sub	r22, r4
    bd98:	75 09       	sbc	r23, r5
    bd9a:	86 09       	sbc	r24, r6
    bd9c:	97 09       	sbc	r25, r7
    bd9e:	68 3e       	cpi	r22, 0xE8	; 232
    bda0:	73 40       	sbci	r23, 0x03	; 3
    bda2:	81 05       	cpc	r24, r1
    bda4:	91 05       	cpc	r25, r1
    bda6:	08 f0       	brcs	.+2      	; 0xbdaa <main+0x16c2>
    bda8:	2a c2       	rjmp	.+1108   	; 0xc1fe <main+0x1b16>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:452
	{
		last_time2 = millis();		//Set Time for Time Action
		update_time_info();			//Get New Time  								 [RTC]
	}
///LED backlight control in powersaving mode================================================
	if (powerSaving) 
    bdaa:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <powerSaving>
    bdae:	88 23       	and	r24, r24
    bdb0:	99 f1       	breq	.+102    	; 0xbe18 <main+0x1730>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:454
	{
		unsigned long temp = abs(millis() - lasttime_powersaving);
    bdb2:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    bdb6:	4b 01       	movw	r8, r22
    bdb8:	5c 01       	movw	r10, r24
    bdba:	40 90 ec 09 	lds	r4, 0x09EC	; 0x8009ec <lasttime_powersaving>
    bdbe:	50 90 ed 09 	lds	r5, 0x09ED	; 0x8009ed <lasttime_powersaving+0x1>
    bdc2:	60 90 ee 09 	lds	r6, 0x09EE	; 0x8009ee <lasttime_powersaving+0x2>
    bdc6:	70 90 ef 09 	lds	r7, 0x09EF	; 0x8009ef <lasttime_powersaving+0x3>
    bdca:	84 14       	cp	r8, r4
    bdcc:	95 04       	cpc	r9, r5
    bdce:	a6 04       	cpc	r10, r6
    bdd0:	b7 04       	cpc	r11, r7
    bdd2:	09 f4       	brne	.+2      	; 0xbdd6 <main+0x16ee>
    bdd4:	21 c2       	rjmp	.+1090   	; 0xc218 <main+0x1b30>
    bdd6:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    bdda:	4b 01       	movw	r8, r22
    bddc:	5c 01       	movw	r10, r24
    bdde:	84 18       	sub	r8, r4
    bde0:	95 08       	sbc	r9, r5
    bde2:	a6 08       	sbc	r10, r6
    bde4:	b7 08       	sbc	r11, r7
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:455
		if (temp >= 600000)
    bde6:	20 ec       	ldi	r18, 0xC0	; 192
    bde8:	82 16       	cp	r8, r18
    bdea:	27 e2       	ldi	r18, 0x27	; 39
    bdec:	92 06       	cpc	r9, r18
    bdee:	29 e0       	ldi	r18, 0x09	; 9
    bdf0:	a2 06       	cpc	r10, r18
    bdf2:	b1 04       	cpc	r11, r1
    bdf4:	88 f0       	brcs	.+34     	; 0xbe18 <main+0x1730>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:457
		{
			if (temp <= 610000) {
    bdf6:	31 ed       	ldi	r19, 0xD1	; 209
    bdf8:	83 16       	cp	r8, r19
    bdfa:	3e e4       	ldi	r19, 0x4E	; 78
    bdfc:	93 06       	cpc	r9, r19
    bdfe:	39 e0       	ldi	r19, 0x09	; 9
    be00:	a3 06       	cpc	r10, r19
    be02:	b1 04       	cpc	r11, r1
    be04:	08 f0       	brcs	.+2      	; 0xbe08 <main+0x1720>
    be06:	0f c2       	rjmp	.+1054   	; 0xc226 <main+0x1b3e>
backlight():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:224
}

void LiquidCrystal_I2C::backlight(void) {
	_backlightval=LCD_BACKLIGHT;
    be08:	88 e0       	ldi	r24, 0x08	; 8
    be0a:	80 93 c6 10 	sts	0x10C6, r24	; 0x8010c6 <lcd+0xb>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:225
	expanderWrite(0);
    be0e:	60 e0       	ldi	r22, 0x00	; 0
    be10:	8b eb       	ldi	r24, 0xBB	; 187
    be12:	90 e1       	ldi	r25, 0x10	; 16
    be14:	0e 94 46 1d 	call	0x3a8c	; 0x3a8c <LiquidCrystal_I2C::expanderWrite(unsigned char)>
freeMemory():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SRam_Check.ino:13
int freeMemory() {
	char top;
#ifdef __arm__
	return &top - reinterpret_cast<char*>(sbrk(0));
#elif defined(CORE_TEENSY) || (ARDUINO > 103 && ARDUINO != 151)
	return &top - __brkval;
    be18:	80 91 6a 13 	lds	r24, 0x136A	; 0x80136a <__brkval>
    be1c:	90 91 6b 13 	lds	r25, 0x136B	; 0x80136b <__brkval+0x1>
    be20:	f8 01       	movw	r30, r16
    be22:	e8 1b       	sub	r30, r24
    be24:	f9 0b       	sbc	r31, r25
    be26:	cf 01       	movw	r24, r30
SRamRestart():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/SRam_Check.ino:32
	SerialDebug("SRam=", String(sRam));
}

void SRamRestart() {
	int sRam = freeMemory();
	if(sRam < 2500)	resetFunc();
    be28:	84 3c       	cpi	r24, 0xC4	; 196
    be2a:	99 40       	sbci	r25, 0x09	; 9
    be2c:	1c f4       	brge	.+6      	; 0xbe34 <main+0x174c>
    be2e:	f0 e0       	ldi	r31, 0x00	; 0
    be30:	e0 e0       	ldi	r30, 0x00	; 0
    be32:	19 95       	eicall
main():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/main.cpp:47
	
	setup();
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    be34:	0e 94 e9 2a 	call	0x55d2	; 0x55d2 <serialEventRun()>
    be38:	0d c9       	rjmp	.-3558   	; 0xb054 <main+0x96c>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:135
				}
					break;
		///Pump speed setting action---
				case 3:
				{
					updatePumpValue(data.toInt());
    be3a:	ce 01       	movw	r24, r28
    be3c:	49 96       	adiw	r24, 0x19	; 25
    be3e:	0e 94 c0 28 	call	0x5180	; 0x5180 <String::toInt() const>
    be42:	4b 01       	movw	r8, r22
updatePumpValue():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:11
	if (freq == 0) pwm = 0;
	analogWrite(pump_pin, pwm);
}

void updatePumpValue(int value) {
	UpdateEEP(pumpPower_addr, value);
    be44:	82 e1       	ldi	r24, 0x12	; 18
    be46:	90 e0       	ldi	r25, 0x00	; 0
    be48:	0e 94 f9 49 	call	0x93f2	; 0x93f2 <bool UpdateEEP<int>(int, int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:12
	pumpPower = value;
    be4c:	90 92 dd 09 	sts	0x09DD, r9	; 0x8009dd <pumpPower+0x1>
    be50:	80 92 dc 09 	sts	0x09DC, r8	; 0x8009dc <pumpPower>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:13
	PrintEEPParameter();
    be54:	0e 94 7e 39 	call	0x72fc	; 0x72fc <PrintEEPParameter()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/pump.ino:14
	pumpControl(value);
    be58:	c4 01       	movw	r24, r8
    be5a:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <pumpControl(int)>
    be5e:	ab cd       	rjmp	.-1194   	; 0xb9b6 <main+0x12ce>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:146
			}
		}
		break;
		case 'C':
		{
			switch (number)
    be60:	e3 e0       	ldi	r30, 0x03	; 3
    be62:	ee 16       	cp	r14, r30
    be64:	f1 04       	cpc	r15, r1
    be66:	09 f4       	brne	.+2      	; 0xbe6a <main+0x1782>
    be68:	91 c0       	rjmp	.+290    	; 0xbf8c <main+0x18a4>
    be6a:	64 f4       	brge	.+24     	; 0xbe84 <main+0x179c>
    be6c:	21 e0       	ldi	r18, 0x01	; 1
    be6e:	e2 16       	cp	r14, r18
    be70:	f1 04       	cpc	r15, r1
    be72:	01 f1       	breq	.+64     	; 0xbeb4 <main+0x17cc>
    be74:	32 e0       	ldi	r19, 0x02	; 2
    be76:	e3 16       	cp	r14, r19
    be78:	f1 04       	cpc	r15, r1
    be7a:	09 f4       	brne	.+2      	; 0xbe7e <main+0x1796>
    be7c:	51 c0       	rjmp	.+162    	; 0xbf20 <main+0x1838>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:191
			case 9:
			{
				if (data.equals("ABC123")) init_System();
			}break;
			default:
				return "*fail [Ccmd]";
    be7e:	68 ee       	ldi	r22, 0xE8	; 232
    be80:	78 e0       	ldi	r23, 0x08	; 8
    be82:	87 cd       	rjmp	.-1266   	; 0xb992 <main+0x12aa>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:146
			}
		}
		break;
		case 'C':
		{
			switch (number)
    be84:	88 e0       	ldi	r24, 0x08	; 8
    be86:	e8 16       	cp	r14, r24
    be88:	f1 04       	cpc	r15, r1
    be8a:	09 f4       	brne	.+2      	; 0xbe8e <main+0x17a6>
    be8c:	96 c0       	rjmp	.+300    	; 0xbfba <main+0x18d2>
    be8e:	99 e0       	ldi	r25, 0x09	; 9
    be90:	e9 16       	cp	r14, r25
    be92:	f1 04       	cpc	r15, r1
    be94:	09 f4       	brne	.+2      	; 0xbe98 <main+0x17b0>
    be96:	95 c0       	rjmp	.+298    	; 0xbfc2 <main+0x18da>
    be98:	e7 e0       	ldi	r30, 0x07	; 7
    be9a:	ee 16       	cp	r14, r30
    be9c:	f1 04       	cpc	r15, r1
    be9e:	79 f7       	brne	.-34     	; 0xbe7e <main+0x1796>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:176
				
			}
			break;
		///Restart
			case 7:
				delay(100);
    bea0:	64 e6       	ldi	r22, 0x64	; 100
    bea2:	70 e0       	ldi	r23, 0x00	; 0
    bea4:	80 e0       	ldi	r24, 0x00	; 0
    bea6:	90 e0       	ldi	r25, 0x00	; 0
init_System():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:15
		SensorFactoryReset();
		tone(buzzerpin, 20, 50);
		lcd.setCursor(0, 3);
		lcd.print("Finish...Reboot");
		Serial.println("Initialize Complete!");
		delay(3000);
    bea8:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:16
		resetFunc();
    beac:	f0 e0       	ldi	r31, 0x00	; 0
    beae:	e0 e0       	ldi	r30, 0x00	; 0
    beb0:	19 95       	eicall
    beb2:	81 cd       	rjmp	.-1278   	; 0xb9b6 <main+0x12ce>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:151
			switch (number)
			{
		///ID setting action---
			case 1:
			{
				String cmd = "D," + String(data.toInt()) + "\r";
    beb4:	ce 01       	movw	r24, r28
    beb6:	49 96       	adiw	r24, 0x19	; 25
    beb8:	0e 94 c0 28 	call	0x5180	; 0x5180 <String::toInt() const>
    bebc:	ab 01       	movw	r20, r22
    bebe:	bc 01       	movw	r22, r24
    bec0:	c8 01       	movw	r24, r16
    bec2:	0e 94 9c 2b 	call	0x5738	; 0x5738 <String::String(long, unsigned char) [clone .constprop.40]>
_ZN15StringSumHelperC2EPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:217
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    bec6:	69 ef       	ldi	r22, 0xF9	; 249
    bec8:	77 e0       	ldi	r23, 0x07	; 7
    beca:	ce 01       	movw	r24, r28
    becc:	07 96       	adiw	r24, 0x07	; 7
    bece:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:151
    bed2:	b8 01       	movw	r22, r16
    bed4:	ce 01       	movw	r24, r28
    bed6:	07 96       	adiw	r24, 0x07	; 7
    bed8:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    bedc:	66 e9       	ldi	r22, 0x96	; 150
    bede:	78 e0       	ldi	r23, 0x08	; 8
    bee0:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    bee4:	bc 01       	movw	r22, r24
    bee6:	ce 01       	movw	r24, r28
    bee8:	0d 96       	adiw	r24, 0x0d	; 13
    beea:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    beee:	ce 01       	movw	r24, r28
    bef0:	07 96       	adiw	r24, 0x07	; 7
    bef2:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    bef6:	c8 01       	movw	r24, r16
    bef8:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:152
				if (!SerialDecode(cmd)) return "*fail [C1]";
    befc:	be 01       	movw	r22, r28
    befe:	63 5f       	subi	r22, 0xF3	; 243
    bf00:	7f 4f       	sbci	r23, 0xFF	; 255
    bf02:	c8 01       	movw	r24, r16
    bf04:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    bf08:	c8 01       	movw	r24, r16
    bf0a:	0e 94 f4 4a 	call	0x95e8	; 0x95e8 <SerialDecode(String)>
    bf0e:	f8 2e       	mov	r15, r24
    bf10:	c8 01       	movw	r24, r16
    bf12:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    bf16:	6c ef       	ldi	r22, 0xFC	; 252
    bf18:	77 e0       	ldi	r23, 0x07	; 7
    bf1a:	f1 10       	cpse	r15, r1
    bf1c:	17 ce       	rjmp	.-978    	; 0xbb4c <main+0x1464>
    bf1e:	4e ce       	rjmp	.-868    	; 0xbbbc <main+0x14d4>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:158
			}
			break;
		///EC print way 0:uS 1:salinity
			case 2:
			{
				String cmd = "S," + String(data.toInt()) + "\r";
    bf20:	ce 01       	movw	r24, r28
    bf22:	49 96       	adiw	r24, 0x19	; 25
    bf24:	0e 94 c0 28 	call	0x5180	; 0x5180 <String::toInt() const>
    bf28:	ab 01       	movw	r20, r22
    bf2a:	bc 01       	movw	r22, r24
    bf2c:	c8 01       	movw	r24, r16
    bf2e:	0e 94 9c 2b 	call	0x5738	; 0x5738 <String::String(long, unsigned char) [clone .constprop.40]>
_ZN15StringSumHelperC2EPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:217
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    bf32:	67 e0       	ldi	r22, 0x07	; 7
    bf34:	78 e0       	ldi	r23, 0x08	; 8
    bf36:	ce 01       	movw	r24, r28
    bf38:	07 96       	adiw	r24, 0x07	; 7
    bf3a:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:158
    bf3e:	b8 01       	movw	r22, r16
    bf40:	ce 01       	movw	r24, r28
    bf42:	07 96       	adiw	r24, 0x07	; 7
    bf44:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    bf48:	66 e9       	ldi	r22, 0x96	; 150
    bf4a:	78 e0       	ldi	r23, 0x08	; 8
    bf4c:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    bf50:	bc 01       	movw	r22, r24
    bf52:	ce 01       	movw	r24, r28
    bf54:	0d 96       	adiw	r24, 0x0d	; 13
    bf56:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    bf5a:	ce 01       	movw	r24, r28
    bf5c:	07 96       	adiw	r24, 0x07	; 7
    bf5e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    bf62:	c8 01       	movw	r24, r16
    bf64:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:159
				if (!SerialDecode(cmd)) return "*fail [C2]";
    bf68:	be 01       	movw	r22, r28
    bf6a:	63 5f       	subi	r22, 0xF3	; 243
    bf6c:	7f 4f       	sbci	r23, 0xFF	; 255
    bf6e:	c8 01       	movw	r24, r16
    bf70:	0e 94 16 2c 	call	0x582c	; 0x582c <String::String(String const&)>
    bf74:	c8 01       	movw	r24, r16
    bf76:	0e 94 f4 4a 	call	0x95e8	; 0x95e8 <SerialDecode(String)>
    bf7a:	f8 2e       	mov	r15, r24
    bf7c:	c8 01       	movw	r24, r16
    bf7e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    bf82:	f1 10       	cpse	r15, r1
    bf84:	e3 cd       	rjmp	.-1082   	; 0xbb4c <main+0x1464>
    bf86:	6a e0       	ldi	r22, 0x0A	; 10
    bf88:	78 e0       	ldi	r23, 0x08	; 8
    bf8a:	18 ce       	rjmp	.-976    	; 0xbbbc <main+0x14d4>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:165
			}
			break;
			case 3: 
			{
				if (star == '\0') {
					return SyncRTCbyGPS(false);
    bf8c:	60 e0       	ldi	r22, 0x00	; 0
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:164
				if (!SerialDecode(cmd)) return "*fail [C2]";
			}
			break;
			case 3: 
			{
				if (star == '\0') {
    bf8e:	cc 20       	and	r12, r12
    bf90:	69 f0       	breq	.+26     	; 0xbfac <main+0x18c4>
equals():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:451
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    bf92:	8d 8d       	ldd	r24, Y+29	; 0x1d
    bf94:	9e 8d       	ldd	r25, Y+30	; 0x1e
    bf96:	89 2b       	or	r24, r25
    bf98:	69 f0       	breq	.+26     	; 0xbfb4 <main+0x18cc>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:453
	if (cstr == NULL) return buffer[0] == 0;
	return strcmp(buffer, cstr) == 0;
    bf9a:	65 e1       	ldi	r22, 0x15	; 21
    bf9c:	78 e0       	ldi	r23, 0x08	; 8
    bf9e:	89 8d       	ldd	r24, Y+25	; 0x19
    bfa0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    bfa2:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <strcmp>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:168
					return SyncRTCbyGPS(false);
				}
				else {
					if(data.equals("1234"))		return SyncRTCbyGPS(true);
    bfa6:	89 2b       	or	r24, r25
    bfa8:	29 f4       	brne	.+10     	; 0xbfb4 <main+0x18cc>
    bfaa:	61 e0       	ldi	r22, 0x01	; 1
    bfac:	c8 01       	movw	r24, r16
    bfae:	0e 94 88 2e 	call	0x5d10	; 0x5d10 <SyncRTCbyGPS(bool)>
    bfb2:	0b ce       	rjmp	.-1002   	; 0xbbca <main+0x14e2>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:169
					else return "*fail [C3]";
    bfb4:	6a e1       	ldi	r22, 0x1A	; 26
    bfb6:	78 e0       	ldi	r23, 0x08	; 8
    bfb8:	ec cc       	rjmp	.-1576   	; 0xb992 <main+0x12aa>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:182
				resetFunc();
				break;
		///Enable debug output---
			case 8:
			{
				debugMode = true;
    bfba:	d0 92 fa 09 	sts	0x09FA, r13	; 0x8009fa <debugMode>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:183
				PrintEEPParameter();
    bfbe:	0e 94 7e 39 	call	0x72fc	; 0x72fc <PrintEEPParameter()>
equals():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:451
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
	if (len == 0) return (cstr == NULL || *cstr == 0);
    bfc2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    bfc4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    bfc6:	89 2b       	or	r24, r25
    bfc8:	09 f4       	brne	.+2      	; 0xbfcc <main+0x18e4>
    bfca:	f5 cc       	rjmp	.-1558   	; 0xb9b6 <main+0x12ce>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:453
	if (cstr == NULL) return buffer[0] == 0;
	return strcmp(buffer, cstr) == 0;
    bfcc:	65 e2       	ldi	r22, 0x25	; 37
    bfce:	78 e0       	ldi	r23, 0x08	; 8
    bfd0:	89 8d       	ldd	r24, Y+25	; 0x19
    bfd2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    bfd4:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <strcmp>
KeypadStringDecode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/keypad.ino:188
			}
		///Reset all system action---
			case 9:
			{
				if (data.equals("ABC123")) init_System();
    bfd8:	89 2b       	or	r24, r25
    bfda:	09 f0       	breq	.+2      	; 0xbfde <main+0x18f6>
    bfdc:	ec cc       	rjmp	.-1576   	; 0xb9b6 <main+0x12ce>
wdt_disable():
c:\users\tensh\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\avr/wdt.h:528
				"out __SREG__,__tmp_reg__"   "\n\t"
				: [TEMPREG] "=d" (temp_reg)
				: [WDTREG]  "n"  (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
				: "r0"
		);
    bfde:	0f b6       	in	r0, 0x3f	; 63
    bfe0:	f8 94       	cli
    bfe2:	a8 95       	wdr
    bfe4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    bfe8:	88 61       	ori	r24, 0x18	; 24
    bfea:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    bfee:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x700060>
    bff2:	0f be       	out	0x3f, r0	; 63
disable():
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:36
}

void WatchdogAVR::disable() {
  // Disable the watchdog and clear any saved watchdog timer value.
  wdt_disable();
  _wdto = -1;
    bff4:	8f ef       	ldi	r24, 0xFF	; 255
    bff6:	9f ef       	ldi	r25, 0xFF	; 255
    bff8:	90 93 f0 0e 	sts	0x0EF0, r25	; 0x800ef0 <Watchdog+0x1>
    bffc:	80 93 ef 0e 	sts	0x0EEF, r24	; 0x800eef <Watchdog>
init_System():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:3
void init_System() {
	Watchdog.disable();
	RamER.on();
    c000:	8e e4       	ldi	r24, 0x4E	; 78
    c002:	9f e0       	ldi	r25, 0x0F	; 15
    c004:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <BlinkControl::on(bool) [clone .constprop.44]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:4
	battery.on();
    c008:	82 e7       	ldi	r24, 0x72	; 114
    c00a:	90 e1       	ldi	r25, 0x10	; 16
    c00c:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <BlinkControl::on(bool) [clone .constprop.44]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:5
	SDIO.on();
    c010:	89 e2       	ldi	r24, 0x29	; 41
    c012:	90 e1       	ldi	r25, 0x10	; 16
    c014:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <BlinkControl::on(bool) [clone .constprop.44]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:6
	ThermoER.on();
    c018:	80 ee       	ldi	r24, 0xE0	; 224
    c01a:	9f e0       	ldi	r25, 0x0F	; 15
    c01c:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <BlinkControl::on(bool) [clone .constprop.44]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:7
	PGER.on();
    c020:	87 e9       	ldi	r24, 0x97	; 151
    c022:	9f e0       	ldi	r25, 0x0F	; 15
    c024:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <BlinkControl::on(bool) [clone .constprop.44]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:9
	//RTCER.on();
	if (LogIn("2567", "---System   Reset---")) {
    c028:	6c e2       	ldi	r22, 0x2C	; 44
    c02a:	78 e0       	ldi	r23, 0x08	; 8
    c02c:	ce 01       	movw	r24, r28
    c02e:	0d 96       	adiw	r24, 0x0d	; 13
    c030:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
    c034:	61 e4       	ldi	r22, 0x41	; 65
    c036:	78 e0       	ldi	r23, 0x08	; 8
    c038:	ce 01       	movw	r24, r28
    c03a:	43 96       	adiw	r24, 0x13	; 19
    c03c:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
LogIn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:62
	delay(5000);
	resetFunc();
}

bool LogIn(String pinCode, String title) {
	lcd.clear();
    c040:	0e 94 e5 22 	call	0x45ca	; 0x45ca <LiquidCrystal_I2C::clear() [clone .constprop.143]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:63
	String cmd = "";
    c044:	63 ea       	ldi	r22, 0xA3	; 163
    c046:	73 e0       	ldi	r23, 0x03	; 3
    c048:	ce 01       	movw	r24, r28
    c04a:	07 96       	adiw	r24, 0x07	; 7
    c04c:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:64
	lcd.setCursor(0, 0);
    c050:	60 e0       	ldi	r22, 0x00	; 0
    c052:	80 e0       	ldi	r24, 0x00	; 0
    c054:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:65
	lcd.print(title);
    c058:	be 01       	movw	r22, r28
    c05a:	63 5f       	subi	r22, 0xF3	; 243
    c05c:	7f 4f       	sbci	r23, 0xFF	; 255
    c05e:	8b eb       	ldi	r24, 0xBB	; 187
    c060:	90 e1       	ldi	r25, 0x10	; 16
    c062:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:66
	lcd.setCursor(0, 1);
    c066:	61 e0       	ldi	r22, 0x01	; 1
    c068:	80 e0       	ldi	r24, 0x00	; 0
    c06a:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
_ZN15StringSumHelperC2EPKc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:217
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
    c06e:	66 e4       	ldi	r22, 0x46	; 70
    c070:	78 e0       	ldi	r23, 0x08	; 8
    c072:	c8 01       	movw	r24, r16
    c074:	0e 94 1f 2c 	call	0x583e	; 0x583e <String::String(char const*)>
LogIn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:67
	lcd.print("Enter:[" + pinCode + "]-> apply");
    c078:	be 01       	movw	r22, r28
    c07a:	6d 5e       	subi	r22, 0xED	; 237
    c07c:	7f 4f       	sbci	r23, 0xFF	; 255
    c07e:	c8 01       	movw	r24, r16
    c080:	0e 94 48 2a 	call	0x5490	; 0x5490 <operator+(StringSumHelper const&, String const&)>
    c084:	6e e4       	ldi	r22, 0x4E	; 78
    c086:	78 e0       	ldi	r23, 0x08	; 8
    c088:	0e 94 32 2a 	call	0x5464	; 0x5464 <operator+(StringSumHelper const&, char const*)>
    c08c:	bc 01       	movw	r22, r24
    c08e:	8b eb       	ldi	r24, 0xBB	; 187
    c090:	90 e1       	ldi	r25, 0x10	; 16
    c092:	0e 94 43 06 	call	0xc86	; 0xc86 <Print::print(String const&)>
_ZN15StringSumHelperD2Ev():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:213
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
    c096:	c8 01       	movw	r24, r16
    c098:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
LogIn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:68
	lcd.setCursor(0, 2);
    c09c:	62 e0       	ldi	r22, 0x02	; 2
    c09e:	80 e0       	ldi	r24, 0x00	; 0
    c0a0:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:69
	lcd.print("PIN:");
    c0a4:	68 e5       	ldi	r22, 0x58	; 88
    c0a6:	78 e0       	ldi	r23, 0x08	; 8
    c0a8:	8b eb       	ldi	r24, 0xBB	; 187
    c0aa:	90 e1       	ldi	r25, 0x10	; 16
    c0ac:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
GetInputData():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:93
		return false;
	}
}

bool GetInputData(String* cmd, long expair, bool print) {
	long entertime = millis();
    c0b0:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    c0b4:	4b 01       	movw	r8, r22
    c0b6:	5c 01       	movw	r10, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:95
	while (true) {
		if (millis() - entertime <= expair)
    c0b8:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    c0bc:	68 19       	sub	r22, r8
    c0be:	79 09       	sbc	r23, r9
    c0c0:	8a 09       	sbc	r24, r10
    c0c2:	9b 09       	sbc	r25, r11
    c0c4:	61 33       	cpi	r22, 0x31	; 49
    c0c6:	75 47       	sbci	r23, 0x75	; 117
    c0c8:	81 05       	cpc	r24, r1
    c0ca:	91 05       	cpc	r25, r1
    c0cc:	08 f0       	brcs	.+2      	; 0xc0d0 <main+0x19e8>
    c0ce:	c5 c0       	rjmp	.+394    	; 0xc25a <main+0x1b72>
GetPadData():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:105
	}
}

bool GetPadData(String* s, bool beep)
{
	customKeypad.tick();
    c0d0:	0e 94 6d 08 	call	0x10da	; 0x10da <Adafruit_Keypad::tick() [clone .constprop.54]>
main():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:106
	bool finish = false;
    c0d4:	f1 2c       	mov	r15, r1
available():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:94

  return value;
}

template <int N> int Adafruit_Keypad_RingbufferN<N>::available() {
  int delta = _iHead - _iTail;
    c0d6:	80 91 60 13 	lds	r24, 0x1360	; 0x801360 <customKeypad+0x108>
    c0da:	90 91 61 13 	lds	r25, 0x1361	; 0x801361 <customKeypad+0x109>
    c0de:	20 91 62 13 	lds	r18, 0x1362	; 0x801362 <customKeypad+0x10a>
    c0e2:	30 91 63 13 	lds	r19, 0x1363	; 0x801363 <customKeypad+0x10b>
    c0e6:	82 1b       	sub	r24, r18
    c0e8:	93 0b       	sbc	r25, r19
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:96

  if (delta < 0)
    c0ea:	97 fd       	sbrc	r25, 7
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad_Ringbuffer.h:97
    return N + delta;
    c0ec:	93 95       	inc	r25
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:184
    c0ee:	95 95       	asr	r25
    c0f0:	87 95       	ror	r24
GetPadData():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:107
	while (customKeypad.available())
    c0f2:	89 2b       	or	r24, r25
    c0f4:	e9 f0       	breq	.+58     	; 0xc130 <main+0x1a48>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:110
	{
		
		keypadEvent e = customKeypad.read();
    c0f6:	0e 94 2d 05 	call	0xa5a	; 0xa5a <Adafruit_Keypad::read() [clone .constprop.58]>
    c0fa:	e8 2e       	mov	r14, r24
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:112
		char inputdata = (char)e.bit.KEY;
		if (e.bit.EVENT == KEY_JUST_PRESSED)
    c0fc:	91 30       	cpi	r25, 0x01	; 1
    c0fe:	59 f7       	brne	.-42     	; 0xc0d6 <main+0x19ee>
pad():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/tone_function.ino:10
    c100:	42 e3       	ldi	r20, 0x32	; 50
    c102:	50 e0       	ldi	r21, 0x00	; 0
    c104:	60 e0       	ldi	r22, 0x00	; 0
    c106:	70 e0       	ldi	r23, 0x00	; 0
    c108:	88 e8       	ldi	r24, 0x88	; 136
    c10a:	93 e1       	ldi	r25, 0x13	; 19
    c10c:	0e 94 44 09 	call	0x1288	; 0x1288 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]>
GetPadData():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:115
		{
			pad();
			if (inputdata == '#')
    c110:	23 e2       	ldi	r18, 0x23	; 35
    c112:	e2 16       	cp	r14, r18
    c114:	59 f0       	breq	.+22     	; 0xc12c <main+0x1a44>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:120
			{
				finish = true;
			}
			else {
				lcd.print(beep ? inputdata : '*');
    c116:	6e 2d       	mov	r22, r14
    c118:	8b eb       	ldi	r24, 0xBB	; 187
    c11a:	90 e1       	ldi	r25, 0x10	; 16
    c11c:	0e 94 3c 06 	call	0xc78	; 0xc78 <Print::print(char)>
_ZN6StringpLEc():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.h:115

	// if there's not enough memory for the concatenated value, the string
	// will be left unchanged (but this isn't signalled in any way)
	String & operator += (const String &rhs)	{concat(rhs); return (*this);}
	String & operator += (const char *cstr)		{concat(cstr); return (*this);}
	String & operator += (char c)			{concat(c); return (*this);}
    c120:	6e 2d       	mov	r22, r14
    c122:	ce 01       	movw	r24, r28
    c124:	07 96       	adiw	r24, 0x07	; 7
    c126:	0e 94 ba 2a 	call	0x5574	; 0x5574 <String::concat(char)>
    c12a:	d5 cf       	rjmp	.-86     	; 0xc0d6 <main+0x19ee>
main():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:117
		if (e.bit.EVENT == KEY_JUST_PRESSED)
		{
			pad();
			if (inputdata == '#')
			{
				finish = true;
    c12c:	f2 2c       	mov	r15, r2
    c12e:	d3 cf       	rjmp	.-90     	; 0xc0d6 <main+0x19ee>
GetPadData():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:125
				lcd.print(beep ? inputdata : '*');
				*s += inputdata;
			}
		}
	}
	delay(50);
    c130:	62 e3       	ldi	r22, 0x32	; 50
    c132:	70 e0       	ldi	r23, 0x00	; 0
    c134:	80 e0       	ldi	r24, 0x00	; 0
    c136:	90 e0       	ldi	r25, 0x00	; 0
    c138:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
GetInputData():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:97
bool GetInputData(String* cmd, long expair, bool print) {
	long entertime = millis();
	while (true) {
		if (millis() - entertime <= expair)
		{
			if (GetPadData(cmd, print))	return true;
    c13c:	ff 20       	and	r15, r15
    c13e:	09 f4       	brne	.+2      	; 0xc142 <main+0x1a5a>
    c140:	bb cf       	rjmp	.-138    	; 0xc0b8 <main+0x19d0>
LogIn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:79
		delay(1000);
		lcd.clear();
		return false;
	}

	lcd.setCursor(0, 2);
    c142:	62 e0       	ldi	r22, 0x02	; 2
    c144:	80 e0       	ldi	r24, 0x00	; 0
    c146:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
equals():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:446
	return strcmp(buffer, s.buffer);
}

unsigned char String::equals(const String &s2) const
{
	return (len == s2.len && compareTo(s2) == 0);
    c14a:	2f 89       	ldd	r18, Y+23	; 0x17
    c14c:	38 8d       	ldd	r19, Y+24	; 0x18
    c14e:	8b 85       	ldd	r24, Y+11	; 0x0b
    c150:	9c 85       	ldd	r25, Y+12	; 0x0c
    c152:	28 17       	cp	r18, r24
    c154:	39 07       	cpc	r19, r25
    c156:	a1 f4       	brne	.+40     	; 0xc180 <main+0x1a98>
compareTo():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:436
/*  Comparison                               */
/*********************************************/

int String::compareTo(const String &s) const
{
	if (!buffer || !s.buffer) {
    c158:	8b 89       	ldd	r24, Y+19	; 0x13
    c15a:	9c 89       	ldd	r25, Y+20	; 0x14
    c15c:	6f 81       	ldd	r22, Y+7	; 0x07
    c15e:	78 85       	ldd	r23, Y+8	; 0x08
    c160:	00 97       	sbiw	r24, 0x00	; 0
    c162:	09 f4       	brne	.+2      	; 0xc166 <main+0x1a7e>
    c164:	81 c0       	rjmp	.+258    	; 0xc268 <main+0x1b80>
    c166:	61 15       	cp	r22, r1
    c168:	71 05       	cpc	r23, r1
    c16a:	39 f4       	brne	.+14     	; 0xc17a <main+0x1a92>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:438
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
		if (buffer && len > 0) return *(unsigned char *)buffer;
    c16c:	23 2b       	or	r18, r19
    c16e:	09 f4       	brne	.+2      	; 0xc172 <main+0x1a8a>
    c170:	89 c0       	rjmp	.+274    	; 0xc284 <main+0x1b9c>
    c172:	fc 01       	movw	r30, r24
    c174:	80 81       	ld	r24, Z
    c176:	90 e0       	ldi	r25, 0x00	; 0
    c178:	82 c0       	rjmp	.+260    	; 0xc27e <main+0x1b96>
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:441
		return 0;
	}
	return strcmp(buffer, s.buffer);
    c17a:	0e 94 bf 6e 	call	0xdd7e	; 0xdd7e <strcmp>
    c17e:	7f c0       	rjmp	.+254    	; 0xc27e <main+0x1b96>
LogIn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:85
	if (pinCode.equals(cmd)) {
		lcd.print("  PinCode Accepted  ");
		return true;
	}
	else {
		lcd.print("PIN Reject .....Exit");
    c180:	62 e7       	ldi	r22, 0x72	; 114
    c182:	78 e0       	ldi	r23, 0x08	; 8
    c184:	8b eb       	ldi	r24, 0xBB	; 187
    c186:	90 e1       	ldi	r25, 0x10	; 16
    c188:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:86
		delay(1000);
    c18c:	68 ee       	ldi	r22, 0xE8	; 232
    c18e:	73 e0       	ldi	r23, 0x03	; 3
    c190:	80 e0       	ldi	r24, 0x00	; 0
    c192:	90 e0       	ldi	r25, 0x00	; 0
    c194:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:87
		lcd.clear();
    c198:	0e 94 e5 22 	call	0x45ca	; 0x45ca <LiquidCrystal_I2C::clear() [clone .constprop.143]>
main():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:88
		return false;
    c19c:	f1 2c       	mov	r15, r1
    c19e:	78 c0       	rjmp	.+240    	; 0xc290 <main+0x1ba8>
reset():
D:\USER\Documents\Arduino\libraries\Adafruit_SleepyDog_Library\utility/WatchdogAVR.cpp:30
  return actualMS;
}

void WatchdogAVR::reset() {
  // Reset the watchdog.
  wdt_reset();
    c1a0:	a8 95       	wdr
init_System():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:20
		delay(3000);
		resetFunc();
	}
	else {
		Watchdog.reset();
		Watchdog.enable();
    c1a2:	90 e0       	ldi	r25, 0x00	; 0
    c1a4:	80 e0       	ldi	r24, 0x00	; 0
    c1a6:	0e 94 8b 05 	call	0xb16	; 0xb16 <WatchdogAVR::enable(int) [clone .constprop.48]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:21
		RamER.off();
    c1aa:	8e e4       	ldi	r24, 0x4E	; 78
    c1ac:	9f e0       	ldi	r25, 0x0F	; 15
    c1ae:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:22
		battery.off();
    c1b2:	82 e7       	ldi	r24, 0x72	; 114
    c1b4:	90 e1       	ldi	r25, 0x10	; 16
    c1b6:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:23
		SDIO.off();
    c1ba:	89 e2       	ldi	r24, 0x29	; 41
    c1bc:	90 e1       	ldi	r25, 0x10	; 16
    c1be:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:24
		ThermoER.off();
    c1c2:	80 ee       	ldi	r24, 0xE0	; 224
    c1c4:	9f e0       	ldi	r25, 0x0F	; 15
    c1c6:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:25
		PGER.off();
    c1ca:	87 e9       	ldi	r24, 0x97	; 151
    c1cc:	9f e0       	ldi	r25, 0x0F	; 15
    c1ce:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <BlinkControl::off()>
    c1d2:	f1 cb       	rjmp	.-2078   	; 0xb9b6 <main+0x12ce>
loop():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:438
	gps_new_get();					//GPS Function									 [GPS_DATA]
	resetRow1.run();
	IOloop();
	SerialDecodeLoop();
///Update By Interval Set in "interval" ==================================================
	if (abs(millis() - last_time) >= interval)
    c1d4:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    c1d8:	86 1a       	sub	r8, r22
    c1da:	97 0a       	sbc	r9, r23
    c1dc:	a8 0a       	sbc	r10, r24
    c1de:	b9 0a       	sbc	r11, r25
    c1e0:	66 cd       	rjmp	.-1332   	; 0xbcae <main+0x15c6>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:446
		last_time2 = millis();		//Set Time for Time Action
		doMeasure();
		checkSRam();
	}
///Update By Interval of 1s ==============================================================
	if (abs(millis() - last_time2) >= 1000)
    c1e2:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    c1e6:	86 1a       	sub	r8, r22
    c1e8:	97 0a       	sbc	r9, r23
    c1ea:	a8 0a       	sbc	r10, r24
    c1ec:	b9 0a       	sbc	r11, r25
    c1ee:	f8 ee       	ldi	r31, 0xE8	; 232
    c1f0:	8f 16       	cp	r8, r31
    c1f2:	f3 e0       	ldi	r31, 0x03	; 3
    c1f4:	9f 06       	cpc	r9, r31
    c1f6:	a1 04       	cpc	r10, r1
    c1f8:	b1 04       	cpc	r11, r1
    c1fa:	08 f4       	brcc	.+2      	; 0xc1fe <main+0x1b16>
    c1fc:	d6 cd       	rjmp	.-1108   	; 0xbdaa <main+0x16c2>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:448
	{
		last_time2 = millis();		//Set Time for Time Action
    c1fe:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    c202:	60 93 f1 09 	sts	0x09F1, r22	; 0x8009f1 <last_time2>
    c206:	70 93 f2 09 	sts	0x09F2, r23	; 0x8009f2 <last_time2+0x1>
    c20a:	80 93 f3 09 	sts	0x09F3, r24	; 0x8009f3 <last_time2+0x2>
    c20e:	90 93 f4 09 	sts	0x09F4, r25	; 0x8009f4 <last_time2+0x3>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:449
		update_time_info();			//Get New Time  								 [RTC]
    c212:	0e 94 58 30 	call	0x60b0	; 0x60b0 <update_time_info()>
    c216:	c9 cd       	rjmp	.-1134   	; 0xbdaa <main+0x16c2>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:454
	}
///LED backlight control in powersaving mode================================================
	if (powerSaving) 
	{
		unsigned long temp = abs(millis() - lasttime_powersaving);
    c218:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    c21c:	86 1a       	sub	r8, r22
    c21e:	97 0a       	sbc	r9, r23
    c220:	a8 0a       	sbc	r10, r24
    c222:	b9 0a       	sbc	r11, r25
    c224:	e0 cd       	rjmp	.-1088   	; 0xbde6 <main+0x16fe>
noBacklight():
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:219
	}
}

// Turn the (optional) backlight off/on
void LiquidCrystal_I2C::noBacklight(void) {
	_backlightval=LCD_NOBACKLIGHT;
    c226:	10 92 c6 10 	sts	0x10C6, r1	; 0x8010c6 <lcd+0xb>
D:\USER\Documents\Arduino\libraries\LiquidCrystal_I2C/LiquidCrystal_I2C.cpp:220
	expanderWrite(0);
    c22a:	60 e0       	ldi	r22, 0x00	; 0
    c22c:	8b eb       	ldi	r24, 0xBB	; 187
    c22e:	90 e1       	ldi	r25, 0x10	; 16
    c230:	0e 94 46 1d 	call	0x3a8c	; 0x3a8c <LiquidCrystal_I2C::expanderWrite(unsigned char)>
loop():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:462
			if (temp <= 610000) {
				lcd.backlight();
			}
			else {
				lcd.noBacklight();
				lasttime_powersaving = millis();
    c234:	0e 94 66 0d 	call	0x1acc	; 0x1acc <millis>
    c238:	60 93 ec 09 	sts	0x09EC, r22	; 0x8009ec <lasttime_powersaving>
    c23c:	70 93 ed 09 	sts	0x09ED, r23	; 0x8009ed <lasttime_powersaving+0x1>
    c240:	80 93 ee 09 	sts	0x09EE, r24	; 0x8009ee <lasttime_powersaving+0x2>
    c244:	90 93 ef 09 	sts	0x09EF, r25	; 0x8009ef <lasttime_powersaving+0x3>
    c248:	e7 cd       	rjmp	.-1074   	; 0xbe18 <main+0x1730>
endOfTermHandler():
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:221
    else
      curSentenceType = GPS_SENTENCE_OTHER;

    // Any custom candidates of this sentence type?
    for (customCandidates = customElts; customCandidates != NULL && strcmp(customCandidates->sentenceName, term) < 0; customCandidates = customCandidates->next);
    if (customCandidates != NULL && strcmp(customCandidates->sentenceName, term) > 0)
    c24a:	89 2b       	or	r24, r25
    c24c:	09 f4       	brne	.+2      	; 0xc250 <main+0x1b68>
    c24e:	88 c8       	rjmp	.-3824   	; 0xb360 <main+0xc78>
D:\USER\Documents\Arduino\libraries\TinyGPSPlus-1.0.2b\src/TinyGPS++.cpp:222
       customCandidates = NULL;
    c250:	10 92 21 12 	sts	0x1221, r1	; 0x801221 <gps+0x9c>
    c254:	10 92 20 12 	sts	0x1220, r1	; 0x801220 <gps+0x9b>
    c258:	83 c8       	rjmp	.-3834   	; 0xb360 <main+0xc78>
LogIn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:72
	lcd.print("Enter:[" + pinCode + "]-> apply");
	lcd.setCursor(0, 2);
	lcd.print("PIN:");
	
	if (!GetInputData(&cmd, 30000, true)) {
		lcd.setCursor(0, 2);
    c25a:	62 e0       	ldi	r22, 0x02	; 2
    c25c:	80 e0       	ldi	r24, 0x00	; 0
    c25e:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:73
		lcd.print("Time Out .......Exit");
    c262:	63 e0       	ldi	r22, 0x03	; 3
    c264:	79 e0       	ldi	r23, 0x09	; 9
    c266:	8e cf       	rjmp	.-228    	; 0xc184 <main+0x1a9c>
compareTo():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:437
/*********************************************/

int String::compareTo(const String &s) const
{
	if (!buffer || !s.buffer) {
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
    c268:	61 15       	cp	r22, r1
    c26a:	71 05       	cpc	r23, r1
    c26c:	59 f0       	breq	.+22     	; 0xc284 <main+0x1b9c>
    c26e:	23 2b       	or	r18, r19
    c270:	49 f0       	breq	.+18     	; 0xc284 <main+0x1b9c>
    c272:	fb 01       	movw	r30, r22
    c274:	80 81       	ld	r24, Z
    c276:	90 e0       	ldi	r25, 0x00	; 0
    c278:	91 95       	neg	r25
    c27a:	81 95       	neg	r24
    c27c:	91 09       	sbc	r25, r1
equals():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/WString.cpp:446
	return strcmp(buffer, s.buffer);
}

unsigned char String::equals(const String &s2) const
{
	return (len == s2.len && compareTo(s2) == 0);
    c27e:	89 2b       	or	r24, r25
    c280:	09 f0       	breq	.+2      	; 0xc284 <main+0x1b9c>
    c282:	7e cf       	rjmp	.-260    	; 0xc180 <main+0x1a98>
LogIn():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:81
		return false;
	}

	lcd.setCursor(0, 2);
	if (pinCode.equals(cmd)) {
		lcd.print("  PinCode Accepted  ");
    c284:	6d e5       	ldi	r22, 0x5D	; 93
    c286:	78 e0       	ldi	r23, 0x08	; 8
    c288:	8b eb       	ldi	r24, 0xBB	; 187
    c28a:	90 e1       	ldi	r25, 0x10	; 16
    c28c:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:63
	resetFunc();
}

bool LogIn(String pinCode, String title) {
	lcd.clear();
	String cmd = "";
    c290:	ce 01       	movw	r24, r28
    c292:	07 96       	adiw	r24, 0x07	; 7
    c294:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
init_System():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:9
	battery.on();
	SDIO.on();
	ThermoER.on();
	PGER.on();
	//RTCER.on();
	if (LogIn("2567", "---System   Reset---")) {
    c298:	ce 01       	movw	r24, r28
    c29a:	43 96       	adiw	r24, 0x13	; 19
    c29c:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    c2a0:	ce 01       	movw	r24, r28
    c2a2:	0d 96       	adiw	r24, 0x0d	; 13
    c2a4:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    c2a8:	ff 20       	and	r15, r15
    c2aa:	09 f4       	brne	.+2      	; 0xc2ae <main+0x1bc6>
    c2ac:	79 cf       	rjmp	.-270    	; 0xc1a0 <main+0x1ab8>
SensorFactoryReset():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:130
	delay(50);
	return finish;
}

void SensorFactoryReset() {
	UpdateEEP(IDAddress, 99);
    c2ae:	63 e6       	ldi	r22, 0x63	; 99
    c2b0:	70 e0       	ldi	r23, 0x00	; 0
    c2b2:	90 e0       	ldi	r25, 0x00	; 0
    c2b4:	80 e0       	ldi	r24, 0x00	; 0
    c2b6:	0e 94 f9 49 	call	0x93f2	; 0x93f2 <bool UpdateEEP<int>(int, int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:131
	UpdateEEP(k_cal_addr, 0.0f);
    c2ba:	40 e0       	ldi	r20, 0x00	; 0
    c2bc:	50 e0       	ldi	r21, 0x00	; 0
    c2be:	ba 01       	movw	r22, r20
    c2c0:	82 e0       	ldi	r24, 0x02	; 2
    c2c2:	90 e0       	ldi	r25, 0x00	; 0
    c2c4:	0e 94 2e 4a 	call	0x945c	; 0x945c <bool UpdateEEP<float>(int, float)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:132
	UpdateEEP(interval_addr, 10000l);
    c2c8:	60 e1       	ldi	r22, 0x10	; 16
    c2ca:	77 e2       	ldi	r23, 0x27	; 39
    c2cc:	80 e0       	ldi	r24, 0x00	; 0
    c2ce:	90 e0       	ldi	r25, 0x00	; 0
    c2d0:	0e 94 ae 49 	call	0x935c	; 0x935c <bool UpdateEEP<long>(int, long) [clone .constprop.50]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:133
	UpdateEEP(power_addr, 0);
    c2d4:	70 e0       	ldi	r23, 0x00	; 0
    c2d6:	60 e0       	ldi	r22, 0x00	; 0
    c2d8:	8a e0       	ldi	r24, 0x0A	; 10
    c2da:	90 e0       	ldi	r25, 0x00	; 0
    c2dc:	0e 94 f9 49 	call	0x93f2	; 0x93f2 <bool UpdateEEP<int>(int, int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:134
	UpdateEEP(pumpPower_addr, 0);
    c2e0:	70 e0       	ldi	r23, 0x00	; 0
    c2e2:	60 e0       	ldi	r22, 0x00	; 0
    c2e4:	82 e1       	ldi	r24, 0x12	; 18
    c2e6:	90 e0       	ldi	r25, 0x00	; 0
    c2e8:	0e 94 f9 49 	call	0x93f2	; 0x93f2 <bool UpdateEEP<int>(int, int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:135
	UpdateEEP(voltage_min_addr, 6.2f);
    c2ec:	46 e6       	ldi	r20, 0x66	; 102
    c2ee:	56 e6       	ldi	r21, 0x66	; 102
    c2f0:	66 ec       	ldi	r22, 0xC6	; 198
    c2f2:	70 e4       	ldi	r23, 0x40	; 64
    c2f4:	88 e1       	ldi	r24, 0x18	; 24
    c2f6:	90 e0       	ldi	r25, 0x00	; 0
    c2f8:	0e 94 2e 4a 	call	0x945c	; 0x945c <bool UpdateEEP<float>(int, float)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:136
	UpdateEEP(voltage_max_addr, 8.4f);
    c2fc:	46 e6       	ldi	r20, 0x66	; 102
    c2fe:	56 e6       	ldi	r21, 0x66	; 102
    c300:	66 e0       	ldi	r22, 0x06	; 6
    c302:	71 e4       	ldi	r23, 0x41	; 65
    c304:	8e e1       	ldi	r24, 0x1E	; 30
    c306:	90 e0       	ldi	r25, 0x00	; 0
    c308:	0e 94 2e 4a 	call	0x945c	; 0x945c <bool UpdateEEP<float>(int, float)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:137
	UpdateEEP(voltage_slope_addr, 1.0f);
    c30c:	40 e0       	ldi	r20, 0x00	; 0
    c30e:	50 e0       	ldi	r21, 0x00	; 0
    c310:	60 e8       	ldi	r22, 0x80	; 128
    c312:	7f e3       	ldi	r23, 0x3F	; 63
    c314:	84 e2       	ldi	r24, 0x24	; 36
    c316:	90 e0       	ldi	r25, 0x00	; 0
    c318:	0e 94 2e 4a 	call	0x945c	; 0x945c <bool UpdateEEP<float>(int, float)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:138
	UpdateEEP(pCO2_lowP_addr, 0.8f);
    c31c:	4d ec       	ldi	r20, 0xCD	; 205
    c31e:	5c ec       	ldi	r21, 0xCC	; 204
    c320:	6c e4       	ldi	r22, 0x4C	; 76
    c322:	7f e3       	ldi	r23, 0x3F	; 63
    c324:	80 e5       	ldi	r24, 0x50	; 80
    c326:	90 e0       	ldi	r25, 0x00	; 0
    c328:	0e 94 2e 4a 	call	0x945c	; 0x945c <bool UpdateEEP<float>(int, float)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:139
	UpdateEEP(pCO2_highP_addr, 1.2f);
    c32c:	4a e9       	ldi	r20, 0x9A	; 154
    c32e:	59 e9       	ldi	r21, 0x99	; 153
    c330:	69 e9       	ldi	r22, 0x99	; 153
    c332:	7f e3       	ldi	r23, 0x3F	; 63
    c334:	86 e5       	ldi	r24, 0x56	; 86
    c336:	90 e0       	ldi	r25, 0x00	; 0
    c338:	0e 94 2e 4a 	call	0x945c	; 0x945c <bool UpdateEEP<float>(int, float)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:140
	UpdateEEP(pCO2_PSampleT_addr, 3);
    c33c:	63 e0       	ldi	r22, 0x03	; 3
    c33e:	70 e0       	ldi	r23, 0x00	; 0
    c340:	8c e5       	ldi	r24, 0x5C	; 92
    c342:	90 e0       	ldi	r25, 0x00	; 0
    c344:	0e 94 f9 49 	call	0x93f2	; 0x93f2 <bool UpdateEEP<int>(int, int)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:141
	UpdateEEP(pCO2_PRecoverMode_addr, false);
    c348:	80 e0       	ldi	r24, 0x00	; 0
    c34a:	0e 94 85 49 	call	0x930a	; 0x930a <bool UpdateEEP<bool>(int, bool) [clone .constprop.51]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:143
	//RTC.adjust(DateTime(F(__DATE__), F(__TIME__)));
	Atlas_EC.print("\r");
    c34e:	66 e9       	ldi	r22, 0x96	; 150
    c350:	78 e0       	ldi	r23, 0x08	; 8
    c352:	88 e1       	ldi	r24, 0x18	; 24
    c354:	9d e0       	ldi	r25, 0x0D	; 13
    c356:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:144
	Atlas_pH.print("\r");
    c35a:	66 e9       	ldi	r22, 0x96	; 150
    c35c:	78 e0       	ldi	r23, 0x08	; 8
    c35e:	8b e7       	ldi	r24, 0x7B	; 123
    c360:	9c e0       	ldi	r25, 0x0C	; 12
    c362:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:145
	delay(100);
    c366:	64 e6       	ldi	r22, 0x64	; 100
    c368:	70 e0       	ldi	r23, 0x00	; 0
    c36a:	80 e0       	ldi	r24, 0x00	; 0
    c36c:	90 e0       	ldi	r25, 0x00	; 0
    c36e:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:146
	Atlas_EC.print("*OK,1\r");
    c372:	67 e8       	ldi	r22, 0x87	; 135
    c374:	78 e0       	ldi	r23, 0x08	; 8
    c376:	88 e1       	ldi	r24, 0x18	; 24
    c378:	9d e0       	ldi	r25, 0x0D	; 13
    c37a:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:147
	Atlas_pH.print("*OK,1\r");
    c37e:	67 e8       	ldi	r22, 0x87	; 135
    c380:	78 e0       	ldi	r23, 0x08	; 8
    c382:	8b e7       	ldi	r24, 0x7B	; 123
    c384:	9c e0       	ldi	r25, 0x0C	; 12
    c386:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:148
	delay(50);
    c38a:	62 e3       	ldi	r22, 0x32	; 50
    c38c:	70 e0       	ldi	r23, 0x00	; 0
    c38e:	80 e0       	ldi	r24, 0x00	; 0
    c390:	90 e0       	ldi	r25, 0x00	; 0
    c392:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:149
	Atlas_EC.print("L,0\r");
    c396:	6e e8       	ldi	r22, 0x8E	; 142
    c398:	78 e0       	ldi	r23, 0x08	; 8
    c39a:	88 e1       	ldi	r24, 0x18	; 24
    c39c:	9d e0       	ldi	r25, 0x0D	; 13
    c39e:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:150
	Atlas_pH.print("L,0\r");
    c3a2:	6e e8       	ldi	r22, 0x8E	; 142
    c3a4:	78 e0       	ldi	r23, 0x08	; 8
    c3a6:	8b e7       	ldi	r24, 0x7B	; 123
    c3a8:	9c e0       	ldi	r25, 0x0C	; 12
    c3aa:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:151
	delay(50);
    c3ae:	62 e3       	ldi	r22, 0x32	; 50
    c3b0:	70 e0       	ldi	r23, 0x00	; 0
    c3b2:	80 e0       	ldi	r24, 0x00	; 0
    c3b4:	90 e0       	ldi	r25, 0x00	; 0
    c3b6:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:152
	Atlas_EC.print("C,0\r");
    c3ba:	63 e9       	ldi	r22, 0x93	; 147
    c3bc:	78 e0       	ldi	r23, 0x08	; 8
    c3be:	88 e1       	ldi	r24, 0x18	; 24
    c3c0:	9d e0       	ldi	r25, 0x0D	; 13
    c3c2:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:153
	Atlas_pH.print("C,0\r");
    c3c6:	63 e9       	ldi	r22, 0x93	; 147
    c3c8:	78 e0       	ldi	r23, 0x08	; 8
    c3ca:	8b e7       	ldi	r24, 0x7B	; 123
    c3cc:	9c e0       	ldi	r25, 0x0C	; 12
    c3ce:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:154
	delay(50);
    c3d2:	62 e3       	ldi	r22, 0x32	; 50
    c3d4:	70 e0       	ldi	r23, 0x00	; 0
    c3d6:	80 e0       	ldi	r24, 0x00	; 0
    c3d8:	90 e0       	ldi	r25, 0x00	; 0
    c3da:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:155
	Atlas_EC.print("Cal,clear\r");
    c3de:	68 e9       	ldi	r22, 0x98	; 152
    c3e0:	78 e0       	ldi	r23, 0x08	; 8
    c3e2:	88 e1       	ldi	r24, 0x18	; 24
    c3e4:	9d e0       	ldi	r25, 0x0D	; 13
    c3e6:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:156
	Atlas_pH.print("Cal,clear\r");
    c3ea:	68 e9       	ldi	r22, 0x98	; 152
    c3ec:	78 e0       	ldi	r23, 0x08	; 8
    c3ee:	8b e7       	ldi	r24, 0x7B	; 123
    c3f0:	9c e0       	ldi	r25, 0x0C	; 12
    c3f2:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:157
	delay(50);
    c3f6:	62 e3       	ldi	r22, 0x32	; 50
    c3f8:	70 e0       	ldi	r23, 0x00	; 0
    c3fa:	80 e0       	ldi	r24, 0x00	; 0
    c3fc:	90 e0       	ldi	r25, 0x00	; 0
    c3fe:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:158
	Atlas_EC.print("O,EC,1\r");
    c402:	63 ea       	ldi	r22, 0xA3	; 163
    c404:	78 e0       	ldi	r23, 0x08	; 8
    c406:	88 e1       	ldi	r24, 0x18	; 24
    c408:	9d e0       	ldi	r25, 0x0D	; 13
    c40a:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:159
	delay(50);
    c40e:	62 e3       	ldi	r22, 0x32	; 50
    c410:	70 e0       	ldi	r23, 0x00	; 0
    c412:	80 e0       	ldi	r24, 0x00	; 0
    c414:	90 e0       	ldi	r25, 0x00	; 0
    c416:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:160
	Atlas_EC.print("O,TDS,1\r");
    c41a:	6b ea       	ldi	r22, 0xAB	; 171
    c41c:	78 e0       	ldi	r23, 0x08	; 8
    c41e:	88 e1       	ldi	r24, 0x18	; 24
    c420:	9d e0       	ldi	r25, 0x0D	; 13
    c422:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:161
	delay(50);
    c426:	62 e3       	ldi	r22, 0x32	; 50
    c428:	70 e0       	ldi	r23, 0x00	; 0
    c42a:	80 e0       	ldi	r24, 0x00	; 0
    c42c:	90 e0       	ldi	r25, 0x00	; 0
    c42e:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:162
	Atlas_EC.print("O,S,1\r");
    c432:	64 eb       	ldi	r22, 0xB4	; 180
    c434:	78 e0       	ldi	r23, 0x08	; 8
    c436:	88 e1       	ldi	r24, 0x18	; 24
    c438:	9d e0       	ldi	r25, 0x0D	; 13
    c43a:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:163
	delay(50);
    c43e:	62 e3       	ldi	r22, 0x32	; 50
    c440:	70 e0       	ldi	r23, 0x00	; 0
    c442:	80 e0       	ldi	r24, 0x00	; 0
    c444:	90 e0       	ldi	r25, 0x00	; 0
    c446:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:164
	Atlas_EC.print("O,SG,1\r");
    c44a:	6b eb       	ldi	r22, 0xBB	; 187
    c44c:	78 e0       	ldi	r23, 0x08	; 8
    c44e:	88 e1       	ldi	r24, 0x18	; 24
    c450:	9d e0       	ldi	r25, 0x0D	; 13
    c452:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:165
	delay(50);
    c456:	62 e3       	ldi	r22, 0x32	; 50
    c458:	70 e0       	ldi	r23, 0x00	; 0
    c45a:	80 e0       	ldi	r24, 0x00	; 0
    c45c:	90 e0       	ldi	r25, 0x00	; 0
    c45e:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <delay>
init_System():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:11
	ThermoER.on();
	PGER.on();
	//RTCER.on();
	if (LogIn("2567", "---System   Reset---")) {
		SensorFactoryReset();
		tone(buzzerpin, 20, 50);
    c462:	42 e3       	ldi	r20, 0x32	; 50
    c464:	50 e0       	ldi	r21, 0x00	; 0
    c466:	60 e0       	ldi	r22, 0x00	; 0
    c468:	70 e0       	ldi	r23, 0x00	; 0
    c46a:	84 e1       	ldi	r24, 0x14	; 20
    c46c:	90 e0       	ldi	r25, 0x00	; 0
    c46e:	0e 94 44 09 	call	0x1288	; 0x1288 <tone(unsigned char, unsigned int, unsigned long) [clone .constprop.91]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:12
		lcd.setCursor(0, 3);
    c472:	63 e0       	ldi	r22, 0x03	; 3
    c474:	80 e0       	ldi	r24, 0x00	; 0
    c476:	0e 94 b3 22 	call	0x4566	; 0x4566 <LiquidCrystal_I2C::setCursor(unsigned char, unsigned char) [clone .constprop.196]>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:13
		lcd.print("Finish...Reboot");
    c47a:	63 ec       	ldi	r22, 0xC3	; 195
    c47c:	78 e0       	ldi	r23, 0x08	; 8
    c47e:	8b eb       	ldi	r24, 0xBB	; 187
    c480:	90 e1       	ldi	r25, 0x10	; 16
    c482:	0e 94 7d 28 	call	0x50fa	; 0x50fa <Print::print(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:14
		Serial.println("Initialize Complete!");
    c486:	63 ed       	ldi	r22, 0xD3	; 211
    c488:	78 e0       	ldi	r23, 0x08	; 8
    c48a:	82 e5       	ldi	r24, 0x52	; 82
    c48c:	9e e0       	ldi	r25, 0x0E	; 14
    c48e:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <Print::println(char const*)>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Development_Mode.ino:15
		delay(3000);
    c492:	68 eb       	ldi	r22, 0xB8	; 184
    c494:	7b e0       	ldi	r23, 0x0B	; 11
    c496:	80 e0       	ldi	r24, 0x00	; 0
    c498:	90 e0       	ldi	r25, 0x00	; 0
    c49a:	06 cd       	rjmp	.-1524   	; 0xbea8 <main+0x17c0>

0000c49c <BlinkControl::~BlinkControl()>:
__base_dtor ():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:54
  ledcSetup(this->_pwmChannel, this->_pwmFreq, this->_pwmResolutionBits);
}
#endif

BlinkControl::~BlinkControl() {
  delete[] this->_blinkTiming;
    c49c:	fc 01       	movw	r30, r24
    c49e:	86 a9       	ldd	r24, Z+54	; 0x36
    c4a0:	97 a9       	ldd	r25, Z+55	; 0x37
    c4a2:	00 97       	sbiw	r24, 0x00	; 0
    c4a4:	11 f0       	breq	.+4      	; 0xc4aa <BlinkControl::~BlinkControl()+0xe>
operator delete():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/new.cpp:35
    c4a6:	0c 94 74 63 	jmp	0xc6e8	; 0xc6e8 <free>
__base_dtor ():
D:\USER\Documents\Arduino\libraries\BlinkControl\src/BlinkControl.cpp:55
}
    c4aa:	08 95       	ret

0000c4ac <_GLOBAL__sub_D_debugMode>:
__static_initialization_and_destruction_0():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:290
//SoftwareSerial ESP8266(12, 13);
// ESP_times = 0;
//=====================================

//SerialEvent==========================
String strSerial = "";
    c4ac:	88 e4       	ldi	r24, 0x48	; 72
    c4ae:	9f e0       	ldi	r25, 0x0F	; 15
    c4b0:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:277
BlinkControl battery(27);
BlinkControl SDIO(29);
BlinkControl ThermoER(31);
//BlinkControl RTCER(33);
BlinkControl PGER(33);
BlinkControl RamER(35);
    c4b4:	8e e4       	ldi	r24, 0x4E	; 78
    c4b6:	9f e0       	ldi	r25, 0x0F	; 15
    c4b8:	0e 94 4e 62 	call	0xc49c	; 0xc49c <BlinkControl::~BlinkControl()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:276
//status led pin
BlinkControl battery(27);
BlinkControl SDIO(29);
BlinkControl ThermoER(31);
//BlinkControl RTCER(33);
BlinkControl PGER(33);
    c4bc:	87 e9       	ldi	r24, 0x97	; 151
    c4be:	9f e0       	ldi	r25, 0x0F	; 15
    c4c0:	0e 94 4e 62 	call	0xc49c	; 0xc49c <BlinkControl::~BlinkControl()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:274
int pumpPower = 0;

//status led pin
BlinkControl battery(27);
BlinkControl SDIO(29);
BlinkControl ThermoER(31);
    c4c4:	80 ee       	ldi	r24, 0xE0	; 224
    c4c6:	9f e0       	ldi	r25, 0x0F	; 15
    c4c8:	0e 94 4e 62 	call	0xc49c	; 0xc49c <BlinkControl::~BlinkControl()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:273
#define pump_pin 6
int pumpPower = 0;

//status led pin
BlinkControl battery(27);
BlinkControl SDIO(29);
    c4cc:	89 e2       	ldi	r24, 0x29	; 41
    c4ce:	90 e1       	ldi	r25, 0x10	; 16
    c4d0:	0e 94 4e 62 	call	0xc49c	; 0xc49c <BlinkControl::~BlinkControl()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:272

#define pump_pin 6
int pumpPower = 0;

//status led pin
BlinkControl battery(27);
    c4d4:	82 e7       	ldi	r24, 0x72	; 114
    c4d6:	90 e1       	ldi	r25, 0x10	; 16
    c4d8:	0e 94 4e 62 	call	0xc49c	; 0xc49c <BlinkControl::~BlinkControl()>
__base_dtor ():
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:65
Adafruit_BME280::Adafruit_BME280(int8_t cspin, int8_t mosipin, int8_t misopin,
                                 int8_t sckpin)
    : _cs(cspin), _mosi(mosipin), _miso(misopin), _sck(sckpin) {}

Adafruit_BME280::~Adafruit_BME280(void) {
  if (temp_sensor) {
    c4dc:	80 91 cb 10 	lds	r24, 0x10CB	; 0x8010cb <bme280+0x4>
    c4e0:	90 91 cc 10 	lds	r25, 0x10CC	; 0x8010cc <bme280+0x5>
    c4e4:	00 97       	sbiw	r24, 0x00	; 0
    c4e6:	39 f0       	breq	.+14     	; 0xc4f6 <_GLOBAL__sub_D_debugMode+0x4a>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:66
    delete temp_sensor;
    c4e8:	dc 01       	movw	r26, r24
    c4ea:	ed 91       	ld	r30, X+
    c4ec:	fc 91       	ld	r31, X
    c4ee:	02 80       	ldd	r0, Z+2	; 0x02
    c4f0:	f3 81       	ldd	r31, Z+3	; 0x03
    c4f2:	e0 2d       	mov	r30, r0
    c4f4:	19 95       	eicall
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:68
  }
  if (pressure_sensor) {
    c4f6:	80 91 cd 10 	lds	r24, 0x10CD	; 0x8010cd <bme280+0x6>
    c4fa:	90 91 ce 10 	lds	r25, 0x10CE	; 0x8010ce <bme280+0x7>
    c4fe:	00 97       	sbiw	r24, 0x00	; 0
    c500:	39 f0       	breq	.+14     	; 0xc510 <_GLOBAL__sub_D_debugMode+0x64>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:69
    delete pressure_sensor;
    c502:	dc 01       	movw	r26, r24
    c504:	ed 91       	ld	r30, X+
    c506:	fc 91       	ld	r31, X
    c508:	02 80       	ldd	r0, Z+2	; 0x02
    c50a:	f3 81       	ldd	r31, Z+3	; 0x03
    c50c:	e0 2d       	mov	r30, r0
    c50e:	19 95       	eicall
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:71
  }
  if (humidity_sensor) {
    c510:	80 91 cf 10 	lds	r24, 0x10CF	; 0x8010cf <bme280+0x8>
    c514:	90 91 d0 10 	lds	r25, 0x10D0	; 0x8010d0 <bme280+0x9>
    c518:	00 97       	sbiw	r24, 0x00	; 0
    c51a:	39 f0       	breq	.+14     	; 0xc52a <_GLOBAL__sub_D_debugMode+0x7e>
D:\USER\Documents\Arduino\libraries\Adafruit_BME280_Library/Adafruit_BME280.cpp:72
    delete humidity_sensor;
    c51c:	dc 01       	movw	r26, r24
    c51e:	ed 91       	ld	r30, X+
    c520:	fc 91       	ld	r31, X
    c522:	02 80       	ldd	r0, Z+2	; 0x02
    c524:	f3 81       	ldd	r31, Z+3	; 0x03
    c526:	e0 2d       	mov	r30, r0
    c528:	19 95       	eicall
__static_initialization_and_destruction_0():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:168
//const byte co2Addr = 0x7F;
#define co2Addr 0x7F
//byte  readCO2[] = { 0xFE, 0X44, 0X00, 0X08, 0X02, 0X9F, 0X25 };
//byte response[] = { 0, 0, 0, 0, 0, 0, 0 };
bool readCO2Success = true;
String K30Serial = "";
    c52a:	86 e0       	ldi	r24, 0x06	; 6
    c52c:	91 e1       	ldi	r25, 0x11	; 17
    c52e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:135
boolean connected;
//Tsys01 Data Parameter END==========================================================================

//Atlas Conductivity Data Parameter==================================================================
HardwareSerial &Atlas_EC = Serial2;						//Atlas EC Using UART Port2
String  strEC = ""; 								//a string to hold the data from the Atlas Scientific product
    c532:	87 e2       	ldi	r24, 0x27	; 39
    c534:	91 e1       	ldi	r25, 0x11	; 17
    c536:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
__base_dtor ():
D:\USER\Documents\Arduino\libraries\arduino_90191/Adafruit_SPIDevice.cpp:77

/*!
 *    @brief  Release memory allocated in constructors
 */
Adafruit_SPIDevice::~Adafruit_SPIDevice() {
  if (_spiSetting) {
    c53a:	80 91 56 11 	lds	r24, 0x1156	; 0x801156 <max+0x2>
    c53e:	90 91 57 11 	lds	r25, 0x1157	; 0x801157 <max+0x3>
    c542:	00 97       	sbiw	r24, 0x00	; 0
    c544:	11 f0       	breq	.+4      	; 0xc54a <_GLOBAL__sub_D_debugMode+0x9e>
operator delete():
C:\Users\tensh\AppData\Local\arduino15\packages\arduino\hardware\avr\1.8.3\cores\arduino/new.cpp:35
    c546:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
__static_initialization_and_destruction_0():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:108
//GPS DATA Parameter=================================================================================
//TinyGPSPlus gps;
TinyGPSPlus gps;
HardwareSerial &ss = Serial1;							//GPS Using UART Port1
String flat = "", flon = "";
String GPS_datetime = "";
    c54a:	83 e7       	ldi	r24, 0x73	; 115
    c54c:	91 e1       	ldi	r25, 0x11	; 17
    c54e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/Drifter_Mega_V3.0.ino:107

//GPS DATA Parameter=================================================================================
//TinyGPSPlus gps;
TinyGPSPlus gps;
HardwareSerial &ss = Serial1;							//GPS Using UART Port1
String flat = "", flon = "";
    c552:	89 e7       	ldi	r24, 0x79	; 121
    c554:	91 e1       	ldi	r25, 0x11	; 17
    c556:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
    c55a:	8f e7       	ldi	r24, 0x7F	; 127
    c55c:	91 e1       	ldi	r25, 0x11	; 17
    c55e:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <String::~String()>
__base_dtor ():
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:43
/*!
    @brief  default destructor
*/
/**************************************************************************/
Adafruit_Keypad::~Adafruit_Keypad() {
  if (_keystates != NULL) {
    c562:	80 91 5e 12 	lds	r24, 0x125E	; 0x80125e <customKeypad+0x6>
    c566:	90 91 5f 12 	lds	r25, 0x125F	; 0x80125f <customKeypad+0x7>
    c56a:	00 97       	sbiw	r24, 0x00	; 0
    c56c:	11 f0       	breq	.+4      	; 0xc572 <_GLOBAL__sub_D_debugMode+0xc6>
D:\USER\Documents\Arduino\libraries\Adafruit_Keypad/Adafruit_Keypad.cpp:44
    free((void *)_keystates);
    c56e:	0c 94 74 63 	jmp	0xc6e8	; 0xc6e8 <free>
_GLOBAL__sub_D_debugMode():
D:\USER\Documents\Arduino\Drifter_Mega_V3.0/tone_function.ino:11
}
    c572:	08 95       	ret

0000c574 <dtostrf>:
dtostrf():
    c574:	ef 92       	push	r14
    c576:	0f 93       	push	r16
    c578:	1f 93       	push	r17
    c57a:	cf 93       	push	r28
    c57c:	df 93       	push	r29
    c57e:	e8 01       	movw	r28, r16
    c580:	34 e0       	ldi	r19, 0x04	; 4
    c582:	47 fd       	sbrc	r20, 7
    c584:	34 e1       	ldi	r19, 0x14	; 20
    c586:	04 2e       	mov	r0, r20
    c588:	00 0c       	add	r0, r0
    c58a:	55 0b       	sbc	r21, r21
    c58c:	57 ff       	sbrs	r21, 7
    c58e:	03 c0       	rjmp	.+6      	; 0xc596 <dtostrf+0x22>
    c590:	51 95       	neg	r21
    c592:	41 95       	neg	r20
    c594:	51 09       	sbc	r21, r1
    c596:	e3 2e       	mov	r14, r19
    c598:	02 2f       	mov	r16, r18
    c59a:	24 2f       	mov	r18, r20
    c59c:	ae 01       	movw	r20, r28
    c59e:	0e 94 f4 64 	call	0xc9e8	; 0xc9e8 <dtoa_prf>
    c5a2:	ce 01       	movw	r24, r28
    c5a4:	df 91       	pop	r29
    c5a6:	cf 91       	pop	r28
    c5a8:	1f 91       	pop	r17
    c5aa:	0f 91       	pop	r16
    c5ac:	ef 90       	pop	r14
    c5ae:	08 95       	ret

0000c5b0 <malloc>:
malloc():
    c5b0:	0f 93       	push	r16
    c5b2:	1f 93       	push	r17
    c5b4:	cf 93       	push	r28
    c5b6:	df 93       	push	r29
    c5b8:	82 30       	cpi	r24, 0x02	; 2
    c5ba:	91 05       	cpc	r25, r1
    c5bc:	10 f4       	brcc	.+4      	; 0xc5c2 <malloc+0x12>
    c5be:	82 e0       	ldi	r24, 0x02	; 2
    c5c0:	90 e0       	ldi	r25, 0x00	; 0
    c5c2:	e0 91 6c 13 	lds	r30, 0x136C	; 0x80136c <__flp>
    c5c6:	f0 91 6d 13 	lds	r31, 0x136D	; 0x80136d <__flp+0x1>
    c5ca:	30 e0       	ldi	r19, 0x00	; 0
    c5cc:	20 e0       	ldi	r18, 0x00	; 0
    c5ce:	b0 e0       	ldi	r27, 0x00	; 0
    c5d0:	a0 e0       	ldi	r26, 0x00	; 0
    c5d2:	30 97       	sbiw	r30, 0x00	; 0
    c5d4:	99 f4       	brne	.+38     	; 0xc5fc <malloc+0x4c>
    c5d6:	21 15       	cp	r18, r1
    c5d8:	31 05       	cpc	r19, r1
    c5da:	09 f4       	brne	.+2      	; 0xc5de <malloc+0x2e>
    c5dc:	4a c0       	rjmp	.+148    	; 0xc672 <malloc+0xc2>
    c5de:	28 1b       	sub	r18, r24
    c5e0:	39 0b       	sbc	r19, r25
    c5e2:	24 30       	cpi	r18, 0x04	; 4
    c5e4:	31 05       	cpc	r19, r1
    c5e6:	d8 f5       	brcc	.+118    	; 0xc65e <malloc+0xae>
    c5e8:	8a 81       	ldd	r24, Y+2	; 0x02
    c5ea:	9b 81       	ldd	r25, Y+3	; 0x03
    c5ec:	61 15       	cp	r22, r1
    c5ee:	71 05       	cpc	r23, r1
    c5f0:	89 f1       	breq	.+98     	; 0xc654 <malloc+0xa4>
    c5f2:	fb 01       	movw	r30, r22
    c5f4:	93 83       	std	Z+3, r25	; 0x03
    c5f6:	82 83       	std	Z+2, r24	; 0x02
    c5f8:	fe 01       	movw	r30, r28
    c5fa:	11 c0       	rjmp	.+34     	; 0xc61e <malloc+0x6e>
    c5fc:	40 81       	ld	r20, Z
    c5fe:	51 81       	ldd	r21, Z+1	; 0x01
    c600:	02 81       	ldd	r16, Z+2	; 0x02
    c602:	13 81       	ldd	r17, Z+3	; 0x03
    c604:	48 17       	cp	r20, r24
    c606:	59 07       	cpc	r21, r25
    c608:	e0 f0       	brcs	.+56     	; 0xc642 <malloc+0x92>
    c60a:	48 17       	cp	r20, r24
    c60c:	59 07       	cpc	r21, r25
    c60e:	99 f4       	brne	.+38     	; 0xc636 <malloc+0x86>
    c610:	10 97       	sbiw	r26, 0x00	; 0
    c612:	61 f0       	breq	.+24     	; 0xc62c <malloc+0x7c>
    c614:	12 96       	adiw	r26, 0x02	; 2
    c616:	0c 93       	st	X, r16
    c618:	12 97       	sbiw	r26, 0x02	; 2
    c61a:	13 96       	adiw	r26, 0x03	; 3
    c61c:	1c 93       	st	X, r17
    c61e:	32 96       	adiw	r30, 0x02	; 2
    c620:	cf 01       	movw	r24, r30
    c622:	df 91       	pop	r29
    c624:	cf 91       	pop	r28
    c626:	1f 91       	pop	r17
    c628:	0f 91       	pop	r16
    c62a:	08 95       	ret
    c62c:	00 93 6c 13 	sts	0x136C, r16	; 0x80136c <__flp>
    c630:	10 93 6d 13 	sts	0x136D, r17	; 0x80136d <__flp+0x1>
    c634:	f4 cf       	rjmp	.-24     	; 0xc61e <malloc+0x6e>
    c636:	21 15       	cp	r18, r1
    c638:	31 05       	cpc	r19, r1
    c63a:	51 f0       	breq	.+20     	; 0xc650 <malloc+0xa0>
    c63c:	42 17       	cp	r20, r18
    c63e:	53 07       	cpc	r21, r19
    c640:	38 f0       	brcs	.+14     	; 0xc650 <malloc+0xa0>
    c642:	a9 01       	movw	r20, r18
    c644:	db 01       	movw	r26, r22
    c646:	9a 01       	movw	r18, r20
    c648:	bd 01       	movw	r22, r26
    c64a:	df 01       	movw	r26, r30
    c64c:	f8 01       	movw	r30, r16
    c64e:	c1 cf       	rjmp	.-126    	; 0xc5d2 <malloc+0x22>
    c650:	ef 01       	movw	r28, r30
    c652:	f9 cf       	rjmp	.-14     	; 0xc646 <malloc+0x96>
    c654:	90 93 6d 13 	sts	0x136D, r25	; 0x80136d <__flp+0x1>
    c658:	80 93 6c 13 	sts	0x136C, r24	; 0x80136c <__flp>
    c65c:	cd cf       	rjmp	.-102    	; 0xc5f8 <malloc+0x48>
    c65e:	fe 01       	movw	r30, r28
    c660:	e2 0f       	add	r30, r18
    c662:	f3 1f       	adc	r31, r19
    c664:	81 93       	st	Z+, r24
    c666:	91 93       	st	Z+, r25
    c668:	22 50       	subi	r18, 0x02	; 2
    c66a:	31 09       	sbc	r19, r1
    c66c:	39 83       	std	Y+1, r19	; 0x01
    c66e:	28 83       	st	Y, r18
    c670:	d7 cf       	rjmp	.-82     	; 0xc620 <malloc+0x70>
    c672:	20 91 6a 13 	lds	r18, 0x136A	; 0x80136a <__brkval>
    c676:	30 91 6b 13 	lds	r19, 0x136B	; 0x80136b <__brkval+0x1>
    c67a:	23 2b       	or	r18, r19
    c67c:	41 f4       	brne	.+16     	; 0xc68e <malloc+0xde>
    c67e:	20 91 a5 02 	lds	r18, 0x02A5	; 0x8002a5 <__malloc_heap_start>
    c682:	30 91 a6 02 	lds	r19, 0x02A6	; 0x8002a6 <__malloc_heap_start+0x1>
    c686:	30 93 6b 13 	sts	0x136B, r19	; 0x80136b <__brkval+0x1>
    c68a:	20 93 6a 13 	sts	0x136A, r18	; 0x80136a <__brkval>
    c68e:	20 91 a3 02 	lds	r18, 0x02A3	; 0x8002a3 <__malloc_heap_end>
    c692:	30 91 a4 02 	lds	r19, 0x02A4	; 0x8002a4 <__malloc_heap_end+0x1>
    c696:	21 15       	cp	r18, r1
    c698:	31 05       	cpc	r19, r1
    c69a:	41 f4       	brne	.+16     	; 0xc6ac <malloc+0xfc>
    c69c:	2d b7       	in	r18, 0x3d	; 61
    c69e:	3e b7       	in	r19, 0x3e	; 62
    c6a0:	40 91 a7 02 	lds	r20, 0x02A7	; 0x8002a7 <__malloc_margin>
    c6a4:	50 91 a8 02 	lds	r21, 0x02A8	; 0x8002a8 <__malloc_margin+0x1>
    c6a8:	24 1b       	sub	r18, r20
    c6aa:	35 0b       	sbc	r19, r21
    c6ac:	e0 91 6a 13 	lds	r30, 0x136A	; 0x80136a <__brkval>
    c6b0:	f0 91 6b 13 	lds	r31, 0x136B	; 0x80136b <__brkval+0x1>
    c6b4:	e2 17       	cp	r30, r18
    c6b6:	f3 07       	cpc	r31, r19
    c6b8:	a0 f4       	brcc	.+40     	; 0xc6e2 <malloc+0x132>
    c6ba:	2e 1b       	sub	r18, r30
    c6bc:	3f 0b       	sbc	r19, r31
    c6be:	28 17       	cp	r18, r24
    c6c0:	39 07       	cpc	r19, r25
    c6c2:	78 f0       	brcs	.+30     	; 0xc6e2 <malloc+0x132>
    c6c4:	ac 01       	movw	r20, r24
    c6c6:	4e 5f       	subi	r20, 0xFE	; 254
    c6c8:	5f 4f       	sbci	r21, 0xFF	; 255
    c6ca:	24 17       	cp	r18, r20
    c6cc:	35 07       	cpc	r19, r21
    c6ce:	48 f0       	brcs	.+18     	; 0xc6e2 <malloc+0x132>
    c6d0:	4e 0f       	add	r20, r30
    c6d2:	5f 1f       	adc	r21, r31
    c6d4:	50 93 6b 13 	sts	0x136B, r21	; 0x80136b <__brkval+0x1>
    c6d8:	40 93 6a 13 	sts	0x136A, r20	; 0x80136a <__brkval>
    c6dc:	81 93       	st	Z+, r24
    c6de:	91 93       	st	Z+, r25
    c6e0:	9f cf       	rjmp	.-194    	; 0xc620 <malloc+0x70>
    c6e2:	f0 e0       	ldi	r31, 0x00	; 0
    c6e4:	e0 e0       	ldi	r30, 0x00	; 0
    c6e6:	9c cf       	rjmp	.-200    	; 0xc620 <malloc+0x70>

0000c6e8 <free>:
free():
    c6e8:	cf 93       	push	r28
    c6ea:	df 93       	push	r29
    c6ec:	00 97       	sbiw	r24, 0x00	; 0
    c6ee:	e9 f0       	breq	.+58     	; 0xc72a <free+0x42>
    c6f0:	fc 01       	movw	r30, r24
    c6f2:	32 97       	sbiw	r30, 0x02	; 2
    c6f4:	13 82       	std	Z+3, r1	; 0x03
    c6f6:	12 82       	std	Z+2, r1	; 0x02
    c6f8:	a0 91 6c 13 	lds	r26, 0x136C	; 0x80136c <__flp>
    c6fc:	b0 91 6d 13 	lds	r27, 0x136D	; 0x80136d <__flp+0x1>
    c700:	ed 01       	movw	r28, r26
    c702:	30 e0       	ldi	r19, 0x00	; 0
    c704:	20 e0       	ldi	r18, 0x00	; 0
    c706:	10 97       	sbiw	r26, 0x00	; 0
    c708:	a1 f4       	brne	.+40     	; 0xc732 <free+0x4a>
    c70a:	20 81       	ld	r18, Z
    c70c:	31 81       	ldd	r19, Z+1	; 0x01
    c70e:	82 0f       	add	r24, r18
    c710:	93 1f       	adc	r25, r19
    c712:	20 91 6a 13 	lds	r18, 0x136A	; 0x80136a <__brkval>
    c716:	30 91 6b 13 	lds	r19, 0x136B	; 0x80136b <__brkval+0x1>
    c71a:	28 17       	cp	r18, r24
    c71c:	39 07       	cpc	r19, r25
    c71e:	09 f0       	breq	.+2      	; 0xc722 <free+0x3a>
    c720:	61 c0       	rjmp	.+194    	; 0xc7e4 <free+0xfc>
    c722:	f0 93 6b 13 	sts	0x136B, r31	; 0x80136b <__brkval+0x1>
    c726:	e0 93 6a 13 	sts	0x136A, r30	; 0x80136a <__brkval>
    c72a:	df 91       	pop	r29
    c72c:	cf 91       	pop	r28
    c72e:	08 95       	ret
    c730:	ea 01       	movw	r28, r20
    c732:	ce 17       	cp	r28, r30
    c734:	df 07       	cpc	r29, r31
    c736:	e8 f5       	brcc	.+122    	; 0xc7b2 <free+0xca>
    c738:	4a 81       	ldd	r20, Y+2	; 0x02
    c73a:	5b 81       	ldd	r21, Y+3	; 0x03
    c73c:	9e 01       	movw	r18, r28
    c73e:	41 15       	cp	r20, r1
    c740:	51 05       	cpc	r21, r1
    c742:	b1 f7       	brne	.-20     	; 0xc730 <free+0x48>
    c744:	e9 01       	movw	r28, r18
    c746:	fb 83       	std	Y+3, r31	; 0x03
    c748:	ea 83       	std	Y+2, r30	; 0x02
    c74a:	49 91       	ld	r20, Y+
    c74c:	59 91       	ld	r21, Y+
    c74e:	c4 0f       	add	r28, r20
    c750:	d5 1f       	adc	r29, r21
    c752:	ec 17       	cp	r30, r28
    c754:	fd 07       	cpc	r31, r29
    c756:	61 f4       	brne	.+24     	; 0xc770 <free+0x88>
    c758:	80 81       	ld	r24, Z
    c75a:	91 81       	ldd	r25, Z+1	; 0x01
    c75c:	02 96       	adiw	r24, 0x02	; 2
    c75e:	84 0f       	add	r24, r20
    c760:	95 1f       	adc	r25, r21
    c762:	e9 01       	movw	r28, r18
    c764:	99 83       	std	Y+1, r25	; 0x01
    c766:	88 83       	st	Y, r24
    c768:	82 81       	ldd	r24, Z+2	; 0x02
    c76a:	93 81       	ldd	r25, Z+3	; 0x03
    c76c:	9b 83       	std	Y+3, r25	; 0x03
    c76e:	8a 83       	std	Y+2, r24	; 0x02
    c770:	f0 e0       	ldi	r31, 0x00	; 0
    c772:	e0 e0       	ldi	r30, 0x00	; 0
    c774:	12 96       	adiw	r26, 0x02	; 2
    c776:	8d 91       	ld	r24, X+
    c778:	9c 91       	ld	r25, X
    c77a:	13 97       	sbiw	r26, 0x03	; 3
    c77c:	00 97       	sbiw	r24, 0x00	; 0
    c77e:	b9 f5       	brne	.+110    	; 0xc7ee <free+0x106>
    c780:	2d 91       	ld	r18, X+
    c782:	3c 91       	ld	r19, X
    c784:	11 97       	sbiw	r26, 0x01	; 1
    c786:	cd 01       	movw	r24, r26
    c788:	02 96       	adiw	r24, 0x02	; 2
    c78a:	82 0f       	add	r24, r18
    c78c:	93 1f       	adc	r25, r19
    c78e:	20 91 6a 13 	lds	r18, 0x136A	; 0x80136a <__brkval>
    c792:	30 91 6b 13 	lds	r19, 0x136B	; 0x80136b <__brkval+0x1>
    c796:	28 17       	cp	r18, r24
    c798:	39 07       	cpc	r19, r25
    c79a:	39 f6       	brne	.-114    	; 0xc72a <free+0x42>
    c79c:	30 97       	sbiw	r30, 0x00	; 0
    c79e:	51 f5       	brne	.+84     	; 0xc7f4 <free+0x10c>
    c7a0:	10 92 6d 13 	sts	0x136D, r1	; 0x80136d <__flp+0x1>
    c7a4:	10 92 6c 13 	sts	0x136C, r1	; 0x80136c <__flp>
    c7a8:	b0 93 6b 13 	sts	0x136B, r27	; 0x80136b <__brkval+0x1>
    c7ac:	a0 93 6a 13 	sts	0x136A, r26	; 0x80136a <__brkval>
    c7b0:	bc cf       	rjmp	.-136    	; 0xc72a <free+0x42>
    c7b2:	d3 83       	std	Z+3, r29	; 0x03
    c7b4:	c2 83       	std	Z+2, r28	; 0x02
    c7b6:	40 81       	ld	r20, Z
    c7b8:	51 81       	ldd	r21, Z+1	; 0x01
    c7ba:	84 0f       	add	r24, r20
    c7bc:	95 1f       	adc	r25, r21
    c7be:	c8 17       	cp	r28, r24
    c7c0:	d9 07       	cpc	r29, r25
    c7c2:	61 f4       	brne	.+24     	; 0xc7dc <free+0xf4>
    c7c4:	4e 5f       	subi	r20, 0xFE	; 254
    c7c6:	5f 4f       	sbci	r21, 0xFF	; 255
    c7c8:	88 81       	ld	r24, Y
    c7ca:	99 81       	ldd	r25, Y+1	; 0x01
    c7cc:	48 0f       	add	r20, r24
    c7ce:	59 1f       	adc	r21, r25
    c7d0:	51 83       	std	Z+1, r21	; 0x01
    c7d2:	40 83       	st	Z, r20
    c7d4:	8a 81       	ldd	r24, Y+2	; 0x02
    c7d6:	9b 81       	ldd	r25, Y+3	; 0x03
    c7d8:	93 83       	std	Z+3, r25	; 0x03
    c7da:	82 83       	std	Z+2, r24	; 0x02
    c7dc:	21 15       	cp	r18, r1
    c7de:	31 05       	cpc	r19, r1
    c7e0:	09 f0       	breq	.+2      	; 0xc7e4 <free+0xfc>
    c7e2:	b0 cf       	rjmp	.-160    	; 0xc744 <free+0x5c>
    c7e4:	f0 93 6d 13 	sts	0x136D, r31	; 0x80136d <__flp+0x1>
    c7e8:	e0 93 6c 13 	sts	0x136C, r30	; 0x80136c <__flp>
    c7ec:	9e cf       	rjmp	.-196    	; 0xc72a <free+0x42>
    c7ee:	fd 01       	movw	r30, r26
    c7f0:	dc 01       	movw	r26, r24
    c7f2:	c0 cf       	rjmp	.-128    	; 0xc774 <free+0x8c>
    c7f4:	13 82       	std	Z+3, r1	; 0x03
    c7f6:	12 82       	std	Z+2, r1	; 0x02
    c7f8:	d7 cf       	rjmp	.-82     	; 0xc7a8 <free+0xc0>

0000c7fa <atof>:
atof():
    c7fa:	66 27       	eor	r22, r22
    c7fc:	77 27       	eor	r23, r23
    c7fe:	0c 94 6d 66 	jmp	0xccda	; 0xccda <strtod>

0000c802 <atoi>:
atoi():
    c802:	fc 01       	movw	r30, r24
    c804:	88 27       	eor	r24, r24
    c806:	99 27       	eor	r25, r25
    c808:	e8 94       	clt
    c80a:	21 91       	ld	r18, Z+
    c80c:	20 32       	cpi	r18, 0x20	; 32
    c80e:	e9 f3       	breq	.-6      	; 0xc80a <atoi+0x8>
    c810:	29 30       	cpi	r18, 0x09	; 9
    c812:	10 f0       	brcs	.+4      	; 0xc818 <atoi+0x16>
    c814:	2e 30       	cpi	r18, 0x0E	; 14
    c816:	c8 f3       	brcs	.-14     	; 0xc80a <atoi+0x8>
    c818:	2b 32       	cpi	r18, 0x2B	; 43
    c81a:	41 f0       	breq	.+16     	; 0xc82c <atoi+0x2a>
    c81c:	2d 32       	cpi	r18, 0x2D	; 45
    c81e:	39 f4       	brne	.+14     	; 0xc82e <atoi+0x2c>
    c820:	68 94       	set
    c822:	04 c0       	rjmp	.+8      	; 0xc82c <atoi+0x2a>
    c824:	0e 94 b0 64 	call	0xc960	; 0xc960 <__mulhi_const_10>
    c828:	82 0f       	add	r24, r18
    c82a:	91 1d       	adc	r25, r1
    c82c:	21 91       	ld	r18, Z+
    c82e:	20 53       	subi	r18, 0x30	; 48
    c830:	2a 30       	cpi	r18, 0x0A	; 10
    c832:	c0 f3       	brcs	.-16     	; 0xc824 <atoi+0x22>
    c834:	1e f4       	brtc	.+6      	; 0xc83c <atoi+0x3a>
    c836:	90 95       	com	r25
    c838:	81 95       	neg	r24
    c83a:	9f 4f       	sbci	r25, 0xFF	; 255
    c83c:	08 95       	ret

0000c83e <atol>:
atol():
    c83e:	1f 93       	push	r17
    c840:	fc 01       	movw	r30, r24
    c842:	99 27       	eor	r25, r25
    c844:	88 27       	eor	r24, r24
    c846:	bc 01       	movw	r22, r24
    c848:	e8 94       	clt
    c84a:	11 91       	ld	r17, Z+
    c84c:	10 32       	cpi	r17, 0x20	; 32
    c84e:	e9 f3       	breq	.-6      	; 0xc84a <atol+0xc>
    c850:	19 30       	cpi	r17, 0x09	; 9
    c852:	10 f0       	brcs	.+4      	; 0xc858 <atol+0x1a>
    c854:	1e 30       	cpi	r17, 0x0E	; 14
    c856:	c8 f3       	brcs	.-14     	; 0xc84a <atol+0xc>
    c858:	1b 32       	cpi	r17, 0x2B	; 43
    c85a:	51 f0       	breq	.+20     	; 0xc870 <atol+0x32>
    c85c:	1d 32       	cpi	r17, 0x2D	; 45
    c85e:	49 f4       	brne	.+18     	; 0xc872 <atol+0x34>
    c860:	68 94       	set
    c862:	06 c0       	rjmp	.+12     	; 0xc870 <atol+0x32>
    c864:	0e 94 9b 64 	call	0xc936	; 0xc936 <__mulsi_const_10>
    c868:	61 0f       	add	r22, r17
    c86a:	71 1d       	adc	r23, r1
    c86c:	81 1d       	adc	r24, r1
    c86e:	91 1d       	adc	r25, r1
    c870:	11 91       	ld	r17, Z+
    c872:	10 53       	subi	r17, 0x30	; 48
    c874:	1a 30       	cpi	r17, 0x0A	; 10
    c876:	b0 f3       	brcs	.-20     	; 0xc864 <atol+0x26>
    c878:	3e f4       	brtc	.+14     	; 0xc888 <atol+0x4a>
    c87a:	90 95       	com	r25
    c87c:	80 95       	com	r24
    c87e:	70 95       	com	r23
    c880:	61 95       	neg	r22
    c882:	7f 4f       	sbci	r23, 0xFF	; 255
    c884:	8f 4f       	sbci	r24, 0xFF	; 255
    c886:	9f 4f       	sbci	r25, 0xFF	; 255
    c888:	1f 91       	pop	r17
    c88a:	08 95       	ret

0000c88c <strcpy_P>:
strcpy_P():
    c88c:	fb 01       	movw	r30, r22
    c88e:	dc 01       	movw	r26, r24
    c890:	05 90       	lpm	r0, Z+
    c892:	0d 92       	st	X+, r0
    c894:	00 20       	and	r0, r0
    c896:	e1 f7       	brne	.-8      	; 0xc890 <strcpy_P+0x4>
    c898:	08 95       	ret

0000c89a <__strlen_P>:
__strlen_P():
    c89a:	fc 01       	movw	r30, r24
    c89c:	05 90       	lpm	r0, Z+
    c89e:	00 20       	and	r0, r0
    c8a0:	e9 f7       	brne	.-6      	; 0xc89c <__strlen_P+0x2>
    c8a2:	80 95       	com	r24
    c8a4:	90 95       	com	r25
    c8a6:	8e 0f       	add	r24, r30
    c8a8:	9f 1f       	adc	r25, r31
    c8aa:	08 95       	ret

0000c8ac <strtok>:
strtok():
    c8ac:	48 e6       	ldi	r20, 0x68	; 104
    c8ae:	53 e1       	ldi	r21, 0x13	; 19
    c8b0:	0c 94 5a 64 	jmp	0xc8b4	; 0xc8b4 <strtok_r>

0000c8b4 <strtok_r>:
strtok_r():
    c8b4:	fa 01       	movw	r30, r20
    c8b6:	a1 91       	ld	r26, Z+
    c8b8:	b0 81       	ld	r27, Z
    c8ba:	00 97       	sbiw	r24, 0x00	; 0
    c8bc:	19 f4       	brne	.+6      	; 0xc8c4 <strtok_r+0x10>
    c8be:	10 97       	sbiw	r26, 0x00	; 0
    c8c0:	e1 f0       	breq	.+56     	; 0xc8fa <strtok_r+0x46>
    c8c2:	cd 01       	movw	r24, r26
    c8c4:	dc 01       	movw	r26, r24
    c8c6:	cd 01       	movw	r24, r26
    c8c8:	0d 90       	ld	r0, X+
    c8ca:	00 20       	and	r0, r0
    c8cc:	11 f4       	brne	.+4      	; 0xc8d2 <strtok_r+0x1e>
    c8ce:	c0 01       	movw	r24, r0
    c8d0:	13 c0       	rjmp	.+38     	; 0xc8f8 <strtok_r+0x44>
    c8d2:	fb 01       	movw	r30, r22
    c8d4:	21 91       	ld	r18, Z+
    c8d6:	22 23       	and	r18, r18
    c8d8:	19 f0       	breq	.+6      	; 0xc8e0 <strtok_r+0x2c>
    c8da:	20 15       	cp	r18, r0
    c8dc:	d9 f7       	brne	.-10     	; 0xc8d4 <strtok_r+0x20>
    c8de:	f3 cf       	rjmp	.-26     	; 0xc8c6 <strtok_r+0x12>
    c8e0:	fb 01       	movw	r30, r22
    c8e2:	21 91       	ld	r18, Z+
    c8e4:	20 15       	cp	r18, r0
    c8e6:	19 f4       	brne	.+6      	; 0xc8ee <strtok_r+0x3a>
    c8e8:	1e 92       	st	-X, r1
    c8ea:	11 96       	adiw	r26, 0x01	; 1
    c8ec:	06 c0       	rjmp	.+12     	; 0xc8fa <strtok_r+0x46>
    c8ee:	22 23       	and	r18, r18
    c8f0:	c1 f7       	brne	.-16     	; 0xc8e2 <strtok_r+0x2e>
    c8f2:	0d 90       	ld	r0, X+
    c8f4:	00 20       	and	r0, r0
    c8f6:	a1 f7       	brne	.-24     	; 0xc8e0 <strtok_r+0x2c>
    c8f8:	d0 01       	movw	r26, r0
    c8fa:	fa 01       	movw	r30, r20
    c8fc:	a1 93       	st	Z+, r26
    c8fe:	b0 83       	st	Z, r27
    c900:	08 95       	ret

0000c902 <__itoa_ncheck>:
__itoa_ncheck():
    c902:	bb 27       	eor	r27, r27
    c904:	4a 30       	cpi	r20, 0x0A	; 10
    c906:	31 f4       	brne	.+12     	; 0xc914 <__itoa_ncheck+0x12>
    c908:	99 23       	and	r25, r25
    c90a:	22 f4       	brpl	.+8      	; 0xc914 <__itoa_ncheck+0x12>
    c90c:	bd e2       	ldi	r27, 0x2D	; 45
    c90e:	90 95       	com	r25
    c910:	81 95       	neg	r24
    c912:	9f 4f       	sbci	r25, 0xFF	; 255
    c914:	0c 94 db 64 	jmp	0xc9b6	; 0xc9b6 <__utoa_common>

0000c918 <__ltoa_ncheck>:
__ltoa_ncheck():
    c918:	bb 27       	eor	r27, r27
    c91a:	2a 30       	cpi	r18, 0x0A	; 10
    c91c:	51 f4       	brne	.+20     	; 0xc932 <__ltoa_ncheck+0x1a>
    c91e:	99 23       	and	r25, r25
    c920:	42 f4       	brpl	.+16     	; 0xc932 <__ltoa_ncheck+0x1a>
    c922:	bd e2       	ldi	r27, 0x2D	; 45
    c924:	90 95       	com	r25
    c926:	80 95       	com	r24
    c928:	70 95       	com	r23
    c92a:	61 95       	neg	r22
    c92c:	7f 4f       	sbci	r23, 0xFF	; 255
    c92e:	8f 4f       	sbci	r24, 0xFF	; 255
    c930:	9f 4f       	sbci	r25, 0xFF	; 255
    c932:	0c 94 b9 64 	jmp	0xc972	; 0xc972 <__ultoa_common>

0000c936 <__mulsi_const_10>:
__mulsi_const_10():
    c936:	59 2f       	mov	r21, r25
    c938:	48 2f       	mov	r20, r24
    c93a:	37 2f       	mov	r19, r23
    c93c:	26 2f       	mov	r18, r22
    c93e:	66 0f       	add	r22, r22
    c940:	77 1f       	adc	r23, r23
    c942:	88 1f       	adc	r24, r24
    c944:	99 1f       	adc	r25, r25
    c946:	66 0f       	add	r22, r22
    c948:	77 1f       	adc	r23, r23
    c94a:	88 1f       	adc	r24, r24
    c94c:	99 1f       	adc	r25, r25
    c94e:	62 0f       	add	r22, r18
    c950:	73 1f       	adc	r23, r19
    c952:	84 1f       	adc	r24, r20
    c954:	95 1f       	adc	r25, r21
    c956:	66 0f       	add	r22, r22
    c958:	77 1f       	adc	r23, r23
    c95a:	88 1f       	adc	r24, r24
    c95c:	99 1f       	adc	r25, r25
    c95e:	08 95       	ret

0000c960 <__mulhi_const_10>:
__mulhi_const_10():
    c960:	7a e0       	ldi	r23, 0x0A	; 10
    c962:	97 9f       	mul	r25, r23
    c964:	90 2d       	mov	r25, r0
    c966:	87 9f       	mul	r24, r23
    c968:	80 2d       	mov	r24, r0
    c96a:	91 0d       	add	r25, r1
    c96c:	11 24       	eor	r1, r1
    c96e:	08 95       	ret

0000c970 <__ultoa_ncheck>:
__ultoa_ncheck():
    c970:	bb 27       	eor	r27, r27

0000c972 <__ultoa_common>:
    c972:	fa 01       	movw	r30, r20
    c974:	a6 2f       	mov	r26, r22
    c976:	62 17       	cp	r22, r18
    c978:	71 05       	cpc	r23, r1
    c97a:	81 05       	cpc	r24, r1
    c97c:	91 05       	cpc	r25, r1
    c97e:	33 0b       	sbc	r19, r19
    c980:	30 fb       	bst	r19, 0
    c982:	66 f0       	brts	.+24     	; 0xc99c <__ultoa_common+0x2a>
    c984:	aa 27       	eor	r26, r26
    c986:	66 0f       	add	r22, r22
    c988:	77 1f       	adc	r23, r23
    c98a:	88 1f       	adc	r24, r24
    c98c:	99 1f       	adc	r25, r25
    c98e:	aa 1f       	adc	r26, r26
    c990:	a2 17       	cp	r26, r18
    c992:	10 f0       	brcs	.+4      	; 0xc998 <__ultoa_common+0x26>
    c994:	a2 1b       	sub	r26, r18
    c996:	63 95       	inc	r22
    c998:	38 50       	subi	r19, 0x08	; 8
    c99a:	a9 f7       	brne	.-22     	; 0xc986 <__ultoa_common+0x14>
    c99c:	a0 5d       	subi	r26, 0xD0	; 208
    c99e:	aa 33       	cpi	r26, 0x3A	; 58
    c9a0:	08 f0       	brcs	.+2      	; 0xc9a4 <__ultoa_common+0x32>
    c9a2:	a9 5d       	subi	r26, 0xD9	; 217
    c9a4:	a1 93       	st	Z+, r26
    c9a6:	36 f7       	brtc	.-52     	; 0xc974 <__ultoa_common+0x2>
    c9a8:	b1 11       	cpse	r27, r1
    c9aa:	b1 93       	st	Z+, r27
    c9ac:	10 82       	st	Z, r1
    c9ae:	ca 01       	movw	r24, r20
    c9b0:	0c 94 c4 68 	jmp	0xd188	; 0xd188 <strrev>

0000c9b4 <__utoa_ncheck>:
__utoa_ncheck():
    c9b4:	bb 27       	eor	r27, r27

0000c9b6 <__utoa_common>:
    c9b6:	fb 01       	movw	r30, r22
    c9b8:	55 27       	eor	r21, r21
    c9ba:	aa 27       	eor	r26, r26
    c9bc:	88 0f       	add	r24, r24
    c9be:	99 1f       	adc	r25, r25
    c9c0:	aa 1f       	adc	r26, r26
    c9c2:	a4 17       	cp	r26, r20
    c9c4:	10 f0       	brcs	.+4      	; 0xc9ca <__utoa_common+0x14>
    c9c6:	a4 1b       	sub	r26, r20
    c9c8:	83 95       	inc	r24
    c9ca:	50 51       	subi	r21, 0x10	; 16
    c9cc:	b9 f7       	brne	.-18     	; 0xc9bc <__utoa_common+0x6>
    c9ce:	a0 5d       	subi	r26, 0xD0	; 208
    c9d0:	aa 33       	cpi	r26, 0x3A	; 58
    c9d2:	08 f0       	brcs	.+2      	; 0xc9d6 <__utoa_common+0x20>
    c9d4:	a9 5d       	subi	r26, 0xD9	; 217
    c9d6:	a1 93       	st	Z+, r26
    c9d8:	00 97       	sbiw	r24, 0x00	; 0
    c9da:	79 f7       	brne	.-34     	; 0xc9ba <__utoa_common+0x4>
    c9dc:	b1 11       	cpse	r27, r1
    c9de:	b1 93       	st	Z+, r27
    c9e0:	11 92       	st	Z+, r1
    c9e2:	cb 01       	movw	r24, r22
    c9e4:	0c 94 c4 68 	jmp	0xd188	; 0xd188 <strrev>

0000c9e8 <dtoa_prf>:
dtoa_prf():
    c9e8:	8f 92       	push	r8
    c9ea:	9f 92       	push	r9
    c9ec:	af 92       	push	r10
    c9ee:	bf 92       	push	r11
    c9f0:	cf 92       	push	r12
    c9f2:	df 92       	push	r13
    c9f4:	ef 92       	push	r14
    c9f6:	ff 92       	push	r15
    c9f8:	0f 93       	push	r16
    c9fa:	1f 93       	push	r17
    c9fc:	cf 93       	push	r28
    c9fe:	df 93       	push	r29
    ca00:	00 d0       	rcall	.+0      	; 0xca02 <dtoa_prf+0x1a>
    ca02:	00 d0       	rcall	.+0      	; 0xca04 <dtoa_prf+0x1c>
    ca04:	00 d0       	rcall	.+0      	; 0xca06 <dtoa_prf+0x1e>
    ca06:	cd b7       	in	r28, 0x3d	; 61
    ca08:	de b7       	in	r29, 0x3e	; 62
    ca0a:	6a 01       	movw	r12, r20
    ca0c:	f2 2e       	mov	r15, r18
    ca0e:	b0 2e       	mov	r11, r16
    ca10:	10 2f       	mov	r17, r16
    ca12:	fb e3       	ldi	r31, 0x3B	; 59
    ca14:	af 2e       	mov	r10, r31
    ca16:	a0 16       	cp	r10, r16
    ca18:	08 f4       	brcc	.+2      	; 0xca1c <dtoa_prf+0x34>
    ca1a:	1b e3       	ldi	r17, 0x3B	; 59
    ca1c:	1f 5f       	subi	r17, 0xFF	; 255
    ca1e:	01 2f       	mov	r16, r17
    ca20:	27 e0       	ldi	r18, 0x07	; 7
    ca22:	ae 01       	movw	r20, r28
    ca24:	4f 5f       	subi	r20, 0xFF	; 255
    ca26:	5f 4f       	sbci	r21, 0xFF	; 255
    ca28:	0e 94 cb 67 	call	0xcf96	; 0xcf96 <__ftoa_engine>
    ca2c:	bc 01       	movw	r22, r24
    ca2e:	89 81       	ldd	r24, Y+1	; 0x01
    ca30:	98 2f       	mov	r25, r24
    ca32:	99 70       	andi	r25, 0x09	; 9
    ca34:	91 30       	cpi	r25, 0x01	; 1
    ca36:	09 f4       	brne	.+2      	; 0xca3a <dtoa_prf+0x52>
    ca38:	4e c0       	rjmp	.+156    	; 0xcad6 <dtoa_prf+0xee>
    ca3a:	9b e2       	ldi	r25, 0x2B	; 43
    ca3c:	e1 fc       	sbrc	r14, 1
    ca3e:	04 c0       	rjmp	.+8      	; 0xca48 <dtoa_prf+0x60>
    ca40:	9e 2d       	mov	r25, r14
    ca42:	91 70       	andi	r25, 0x01	; 1
    ca44:	e0 fc       	sbrc	r14, 0
    ca46:	49 c0       	rjmp	.+146    	; 0xcada <dtoa_prf+0xf2>
    ca48:	5e 2d       	mov	r21, r14
    ca4a:	50 71       	andi	r21, 0x10	; 16
    ca4c:	e8 2f       	mov	r30, r24
    ca4e:	e8 70       	andi	r30, 0x08	; 8
    ca50:	83 ff       	sbrs	r24, 3
    ca52:	55 c0       	rjmp	.+170    	; 0xcafe <dtoa_prf+0x116>
    ca54:	84 e0       	ldi	r24, 0x04	; 4
    ca56:	91 11       	cpse	r25, r1
    ca58:	01 c0       	rjmp	.+2      	; 0xca5c <dtoa_prf+0x74>
    ca5a:	83 e0       	ldi	r24, 0x03	; 3
    ca5c:	ef 2d       	mov	r30, r15
    ca5e:	e8 1b       	sub	r30, r24
    ca60:	8f 15       	cp	r24, r15
    ca62:	08 f0       	brcs	.+2      	; 0xca66 <dtoa_prf+0x7e>
    ca64:	e0 e0       	ldi	r30, 0x00	; 0
    ca66:	d6 01       	movw	r26, r12
    ca68:	8e 2f       	mov	r24, r30
    ca6a:	20 e2       	ldi	r18, 0x20	; 32
    ca6c:	55 23       	and	r21, r21
    ca6e:	c9 f1       	breq	.+114    	; 0xcae2 <dtoa_prf+0xfa>
    ca70:	99 23       	and	r25, r25
    ca72:	29 f0       	breq	.+10     	; 0xca7e <dtoa_prf+0x96>
    ca74:	d6 01       	movw	r26, r12
    ca76:	9c 93       	st	X, r25
    ca78:	c6 01       	movw	r24, r12
    ca7a:	01 96       	adiw	r24, 0x01	; 1
    ca7c:	6c 01       	movw	r12, r24
    ca7e:	96 01       	movw	r18, r12
    ca80:	2d 5f       	subi	r18, 0xFD	; 253
    ca82:	3f 4f       	sbci	r19, 0xFF	; 255
    ca84:	e2 fe       	sbrs	r14, 2
    ca86:	33 c0       	rjmp	.+102    	; 0xcaee <dtoa_prf+0x106>
    ca88:	8e e4       	ldi	r24, 0x4E	; 78
    ca8a:	d6 01       	movw	r26, r12
    ca8c:	8c 93       	st	X, r24
    ca8e:	91 e4       	ldi	r25, 0x41	; 65
    ca90:	11 96       	adiw	r26, 0x01	; 1
    ca92:	9c 93       	st	X, r25
    ca94:	11 97       	sbiw	r26, 0x01	; 1
    ca96:	12 96       	adiw	r26, 0x02	; 2
    ca98:	8c 93       	st	X, r24
    ca9a:	d9 01       	movw	r26, r18
    ca9c:	8e 2f       	mov	r24, r30
    ca9e:	90 e2       	ldi	r25, 0x20	; 32
    caa0:	81 11       	cpse	r24, r1
    caa2:	2a c0       	rjmp	.+84     	; 0xcaf8 <dtoa_prf+0x110>
    caa4:	e2 0f       	add	r30, r18
    caa6:	f3 2f       	mov	r31, r19
    caa8:	f1 1d       	adc	r31, r1
    caaa:	10 82       	st	Z, r1
    caac:	8e ef       	ldi	r24, 0xFE	; 254
    caae:	9f ef       	ldi	r25, 0xFF	; 255
    cab0:	29 96       	adiw	r28, 0x09	; 9
    cab2:	0f b6       	in	r0, 0x3f	; 63
    cab4:	f8 94       	cli
    cab6:	de bf       	out	0x3e, r29	; 62
    cab8:	0f be       	out	0x3f, r0	; 63
    caba:	cd bf       	out	0x3d, r28	; 61
    cabc:	df 91       	pop	r29
    cabe:	cf 91       	pop	r28
    cac0:	1f 91       	pop	r17
    cac2:	0f 91       	pop	r16
    cac4:	ff 90       	pop	r15
    cac6:	ef 90       	pop	r14
    cac8:	df 90       	pop	r13
    caca:	cf 90       	pop	r12
    cacc:	bf 90       	pop	r11
    cace:	af 90       	pop	r10
    cad0:	9f 90       	pop	r9
    cad2:	8f 90       	pop	r8
    cad4:	08 95       	ret
    cad6:	9d e2       	ldi	r25, 0x2D	; 45
    cad8:	b7 cf       	rjmp	.-146    	; 0xca48 <dtoa_prf+0x60>
    cada:	90 e2       	ldi	r25, 0x20	; 32
    cadc:	b5 cf       	rjmp	.-150    	; 0xca48 <dtoa_prf+0x60>
    cade:	2d 93       	st	X+, r18
    cae0:	81 50       	subi	r24, 0x01	; 1
    cae2:	81 11       	cpse	r24, r1
    cae4:	fc cf       	rjmp	.-8      	; 0xcade <dtoa_prf+0xf6>
    cae6:	ce 0e       	add	r12, r30
    cae8:	d1 1c       	adc	r13, r1
    caea:	e0 e0       	ldi	r30, 0x00	; 0
    caec:	c1 cf       	rjmp	.-126    	; 0xca70 <dtoa_prf+0x88>
    caee:	8e e6       	ldi	r24, 0x6E	; 110
    caf0:	d6 01       	movw	r26, r12
    caf2:	8c 93       	st	X, r24
    caf4:	91 e6       	ldi	r25, 0x61	; 97
    caf6:	cc cf       	rjmp	.-104    	; 0xca90 <dtoa_prf+0xa8>
    caf8:	9d 93       	st	X+, r25
    cafa:	81 50       	subi	r24, 0x01	; 1
    cafc:	d1 cf       	rjmp	.-94     	; 0xcaa0 <dtoa_prf+0xb8>
    cafe:	48 2f       	mov	r20, r24
    cb00:	44 70       	andi	r20, 0x04	; 4
    cb02:	82 ff       	sbrs	r24, 2
    cb04:	3d c0       	rjmp	.+122    	; 0xcb80 <dtoa_prf+0x198>
    cb06:	84 e0       	ldi	r24, 0x04	; 4
    cb08:	91 11       	cpse	r25, r1
    cb0a:	01 c0       	rjmp	.+2      	; 0xcb0e <dtoa_prf+0x126>
    cb0c:	83 e0       	ldi	r24, 0x03	; 3
    cb0e:	8f 15       	cp	r24, r15
    cb10:	10 f4       	brcc	.+4      	; 0xcb16 <dtoa_prf+0x12e>
    cb12:	ef 2d       	mov	r30, r15
    cb14:	e8 1b       	sub	r30, r24
    cb16:	d6 01       	movw	r26, r12
    cb18:	8e 2f       	mov	r24, r30
    cb1a:	20 e2       	ldi	r18, 0x20	; 32
    cb1c:	55 23       	and	r21, r21
    cb1e:	09 f1       	breq	.+66     	; 0xcb62 <dtoa_prf+0x17a>
    cb20:	99 23       	and	r25, r25
    cb22:	29 f0       	breq	.+10     	; 0xcb2e <dtoa_prf+0x146>
    cb24:	d6 01       	movw	r26, r12
    cb26:	9c 93       	st	X, r25
    cb28:	c6 01       	movw	r24, r12
    cb2a:	01 96       	adiw	r24, 0x01	; 1
    cb2c:	6c 01       	movw	r12, r24
    cb2e:	96 01       	movw	r18, r12
    cb30:	2d 5f       	subi	r18, 0xFD	; 253
    cb32:	3f 4f       	sbci	r19, 0xFF	; 255
    cb34:	e2 fe       	sbrs	r14, 2
    cb36:	1b c0       	rjmp	.+54     	; 0xcb6e <dtoa_prf+0x186>
    cb38:	89 e4       	ldi	r24, 0x49	; 73
    cb3a:	d6 01       	movw	r26, r12
    cb3c:	8c 93       	st	X, r24
    cb3e:	8e e4       	ldi	r24, 0x4E	; 78
    cb40:	11 96       	adiw	r26, 0x01	; 1
    cb42:	8c 93       	st	X, r24
    cb44:	11 97       	sbiw	r26, 0x01	; 1
    cb46:	86 e4       	ldi	r24, 0x46	; 70
    cb48:	12 96       	adiw	r26, 0x02	; 2
    cb4a:	8c 93       	st	X, r24
    cb4c:	d9 01       	movw	r26, r18
    cb4e:	8e 2f       	mov	r24, r30
    cb50:	90 e2       	ldi	r25, 0x20	; 32
    cb52:	88 23       	and	r24, r24
    cb54:	09 f4       	brne	.+2      	; 0xcb58 <dtoa_prf+0x170>
    cb56:	a6 cf       	rjmp	.-180    	; 0xcaa4 <dtoa_prf+0xbc>
    cb58:	9d 93       	st	X+, r25
    cb5a:	81 50       	subi	r24, 0x01	; 1
    cb5c:	fa cf       	rjmp	.-12     	; 0xcb52 <dtoa_prf+0x16a>
    cb5e:	2d 93       	st	X+, r18
    cb60:	81 50       	subi	r24, 0x01	; 1
    cb62:	81 11       	cpse	r24, r1
    cb64:	fc cf       	rjmp	.-8      	; 0xcb5e <dtoa_prf+0x176>
    cb66:	ce 0e       	add	r12, r30
    cb68:	d1 1c       	adc	r13, r1
    cb6a:	e0 e0       	ldi	r30, 0x00	; 0
    cb6c:	d9 cf       	rjmp	.-78     	; 0xcb20 <dtoa_prf+0x138>
    cb6e:	89 e6       	ldi	r24, 0x69	; 105
    cb70:	d6 01       	movw	r26, r12
    cb72:	8c 93       	st	X, r24
    cb74:	8e e6       	ldi	r24, 0x6E	; 110
    cb76:	11 96       	adiw	r26, 0x01	; 1
    cb78:	8c 93       	st	X, r24
    cb7a:	11 97       	sbiw	r26, 0x01	; 1
    cb7c:	86 e6       	ldi	r24, 0x66	; 102
    cb7e:	e4 cf       	rjmp	.-56     	; 0xcb48 <dtoa_prf+0x160>
    cb80:	9b 01       	movw	r18, r22
    cb82:	77 ff       	sbrs	r23, 7
    cb84:	02 c0       	rjmp	.+4      	; 0xcb8a <dtoa_prf+0x1a2>
    cb86:	30 e0       	ldi	r19, 0x00	; 0
    cb88:	20 e0       	ldi	r18, 0x00	; 0
    cb8a:	a1 e0       	ldi	r26, 0x01	; 1
    cb8c:	b0 e0       	ldi	r27, 0x00	; 0
    cb8e:	91 11       	cpse	r25, r1
    cb90:	02 c0       	rjmp	.+4      	; 0xcb96 <dtoa_prf+0x1ae>
    cb92:	b0 e0       	ldi	r27, 0x00	; 0
    cb94:	a0 e0       	ldi	r26, 0x00	; 0
    cb96:	f9 01       	movw	r30, r18
    cb98:	31 96       	adiw	r30, 0x01	; 1
    cb9a:	ae 0f       	add	r26, r30
    cb9c:	bf 1f       	adc	r27, r31
    cb9e:	8b 2c       	mov	r8, r11
    cba0:	91 2c       	mov	r9, r1
    cba2:	bb 20       	and	r11, r11
    cba4:	09 f4       	brne	.+2      	; 0xcba8 <dtoa_prf+0x1c0>
    cba6:	61 c0       	rjmp	.+194    	; 0xcc6a <dtoa_prf+0x282>
    cba8:	54 01       	movw	r10, r8
    cbaa:	ef ef       	ldi	r30, 0xFF	; 255
    cbac:	ae 1a       	sub	r10, r30
    cbae:	be 0a       	sbc	r11, r30
    cbb0:	aa 0d       	add	r26, r10
    cbb2:	bb 1d       	adc	r27, r11
    cbb4:	fa 16       	cp	r15, r26
    cbb6:	1b 06       	cpc	r1, r27
    cbb8:	19 f0       	breq	.+6      	; 0xcbc0 <dtoa_prf+0x1d8>
    cbba:	14 f0       	brlt	.+4      	; 0xcbc0 <dtoa_prf+0x1d8>
    cbbc:	4f 2d       	mov	r20, r15
    cbbe:	4a 1b       	sub	r20, r26
    cbc0:	51 11       	cpse	r21, r1
    cbc2:	88 c0       	rjmp	.+272    	; 0xccd4 <dtoa_prf+0x2ec>
    cbc4:	e3 fc       	sbrc	r14, 3
    cbc6:	59 c0       	rjmp	.+178    	; 0xcc7a <dtoa_prf+0x292>
    cbc8:	76 01       	movw	r14, r12
    cbca:	a4 2f       	mov	r26, r20
    cbcc:	b0 e2       	ldi	r27, 0x20	; 32
    cbce:	a1 11       	cpse	r26, r1
    cbd0:	4f c0       	rjmp	.+158    	; 0xcc70 <dtoa_prf+0x288>
    cbd2:	c4 0e       	add	r12, r20
    cbd4:	d1 1c       	adc	r13, r1
    cbd6:	99 23       	and	r25, r25
    cbd8:	09 f4       	brne	.+2      	; 0xcbdc <dtoa_prf+0x1f4>
    cbda:	5b c0       	rjmp	.+182    	; 0xcc92 <dtoa_prf+0x2aa>
    cbdc:	40 e0       	ldi	r20, 0x00	; 0
    cbde:	d6 01       	movw	r26, r12
    cbe0:	11 96       	adiw	r26, 0x01	; 1
    cbe2:	f6 01       	movw	r30, r12
    cbe4:	90 83       	st	Z, r25
    cbe6:	6d 01       	movw	r12, r26
    cbe8:	55 23       	and	r21, r21
    cbea:	09 f4       	brne	.+2      	; 0xcbee <dtoa_prf+0x206>
    cbec:	48 c0       	rjmp	.+144    	; 0xcc7e <dtoa_prf+0x296>
    cbee:	01 2f       	mov	r16, r17
    cbf0:	06 0f       	add	r16, r22
    cbf2:	9a 81       	ldd	r25, Y+2	; 0x02
    cbf4:	58 2f       	mov	r21, r24
    cbf6:	50 71       	andi	r21, 0x10	; 16
    cbf8:	84 ff       	sbrs	r24, 4
    cbfa:	03 c0       	rjmp	.+6      	; 0xcc02 <dtoa_prf+0x21a>
    cbfc:	91 33       	cpi	r25, 0x31	; 49
    cbfe:	09 f4       	brne	.+2      	; 0xcc02 <dtoa_prf+0x21a>
    cc00:	01 50       	subi	r16, 0x01	; 1
    cc02:	10 16       	cp	r1, r16
    cc04:	0c f0       	brlt	.+2      	; 0xcc08 <dtoa_prf+0x220>
    cc06:	47 c0       	rjmp	.+142    	; 0xcc96 <dtoa_prf+0x2ae>
    cc08:	09 30       	cpi	r16, 0x09	; 9
    cc0a:	08 f0       	brcs	.+2      	; 0xcc0e <dtoa_prf+0x226>
    cc0c:	08 e0       	ldi	r16, 0x08	; 8
    cc0e:	ee e2       	ldi	r30, 0x2E	; 46
    cc10:	fe 2e       	mov	r15, r30
    cc12:	5b 01       	movw	r10, r22
    cc14:	a0 1a       	sub	r10, r16
    cc16:	b1 08       	sbc	r11, r1
    cc18:	85 01       	movw	r16, r10
    cc1a:	91 94       	neg	r9
    cc1c:	81 94       	neg	r8
    cc1e:	91 08       	sbc	r9, r1
    cc20:	2f 3f       	cpi	r18, 0xFF	; 255
    cc22:	32 07       	cpc	r19, r18
    cc24:	29 f4       	brne	.+10     	; 0xcc30 <dtoa_prf+0x248>
    cc26:	d6 01       	movw	r26, r12
    cc28:	fc 92       	st	X, r15
    cc2a:	f6 01       	movw	r30, r12
    cc2c:	31 96       	adiw	r30, 0x01	; 1
    cc2e:	6f 01       	movw	r12, r30
    cc30:	62 17       	cp	r22, r18
    cc32:	73 07       	cpc	r23, r19
    cc34:	94 f1       	brlt	.+100    	; 0xcc9a <dtoa_prf+0x2b2>
    cc36:	02 17       	cp	r16, r18
    cc38:	13 07       	cpc	r17, r19
    cc3a:	7c f5       	brge	.+94     	; 0xcc9a <dtoa_prf+0x2b2>
    cc3c:	db 01       	movw	r26, r22
    cc3e:	a2 1b       	sub	r26, r18
    cc40:	b3 0b       	sbc	r27, r19
    cc42:	aa 24       	eor	r10, r10
    cc44:	a3 94       	inc	r10
    cc46:	b1 2c       	mov	r11, r1
    cc48:	ac 0e       	add	r10, r28
    cc4a:	bd 1e       	adc	r11, r29
    cc4c:	aa 0d       	add	r26, r10
    cc4e:	bb 1d       	adc	r27, r11
    cc50:	11 96       	adiw	r26, 0x01	; 1
    cc52:	8c 91       	ld	r24, X
    cc54:	21 50       	subi	r18, 0x01	; 1
    cc56:	31 09       	sbc	r19, r1
    cc58:	d6 01       	movw	r26, r12
    cc5a:	11 96       	adiw	r26, 0x01	; 1
    cc5c:	28 15       	cp	r18, r8
    cc5e:	39 05       	cpc	r19, r9
    cc60:	f4 f0       	brlt	.+60     	; 0xcc9e <dtoa_prf+0x2b6>
    cc62:	f6 01       	movw	r30, r12
    cc64:	80 83       	st	Z, r24
    cc66:	6d 01       	movw	r12, r26
    cc68:	db cf       	rjmp	.-74     	; 0xcc20 <dtoa_prf+0x238>
    cc6a:	b1 2c       	mov	r11, r1
    cc6c:	a1 2c       	mov	r10, r1
    cc6e:	a0 cf       	rjmp	.-192    	; 0xcbb0 <dtoa_prf+0x1c8>
    cc70:	f7 01       	movw	r30, r14
    cc72:	b1 93       	st	Z+, r27
    cc74:	7f 01       	movw	r14, r30
    cc76:	a1 50       	subi	r26, 0x01	; 1
    cc78:	aa cf       	rjmp	.-172    	; 0xcbce <dtoa_prf+0x1e6>
    cc7a:	91 11       	cpse	r25, r1
    cc7c:	b0 cf       	rjmp	.-160    	; 0xcbde <dtoa_prf+0x1f6>
    cc7e:	d6 01       	movw	r26, r12
    cc80:	94 2f       	mov	r25, r20
    cc82:	50 e3       	ldi	r21, 0x30	; 48
    cc84:	02 c0       	rjmp	.+4      	; 0xcc8a <dtoa_prf+0x2a2>
    cc86:	5d 93       	st	X+, r21
    cc88:	91 50       	subi	r25, 0x01	; 1
    cc8a:	91 11       	cpse	r25, r1
    cc8c:	fc cf       	rjmp	.-8      	; 0xcc86 <dtoa_prf+0x29e>
    cc8e:	c4 0e       	add	r12, r20
    cc90:	d1 1c       	adc	r13, r1
    cc92:	40 e0       	ldi	r20, 0x00	; 0
    cc94:	ac cf       	rjmp	.-168    	; 0xcbee <dtoa_prf+0x206>
    cc96:	01 e0       	ldi	r16, 0x01	; 1
    cc98:	ba cf       	rjmp	.-140    	; 0xcc0e <dtoa_prf+0x226>
    cc9a:	80 e3       	ldi	r24, 0x30	; 48
    cc9c:	db cf       	rjmp	.-74     	; 0xcc54 <dtoa_prf+0x26c>
    cc9e:	62 17       	cp	r22, r18
    cca0:	73 07       	cpc	r23, r19
    cca2:	31 f4       	brne	.+12     	; 0xccb0 <dtoa_prf+0x2c8>
    cca4:	96 33       	cpi	r25, 0x36	; 54
    cca6:	88 f4       	brcc	.+34     	; 0xccca <dtoa_prf+0x2e2>
    cca8:	95 33       	cpi	r25, 0x35	; 53
    ccaa:	11 f4       	brne	.+4      	; 0xccb0 <dtoa_prf+0x2c8>
    ccac:	55 23       	and	r21, r21
    ccae:	69 f0       	breq	.+26     	; 0xccca <dtoa_prf+0x2e2>
    ccb0:	f6 01       	movw	r30, r12
    ccb2:	80 83       	st	Z, r24
    ccb4:	fd 01       	movw	r30, r26
    ccb6:	84 2f       	mov	r24, r20
    ccb8:	90 e2       	ldi	r25, 0x20	; 32
    ccba:	81 11       	cpse	r24, r1
    ccbc:	08 c0       	rjmp	.+16     	; 0xccce <dtoa_prf+0x2e6>
    ccbe:	a4 0f       	add	r26, r20
    ccc0:	b1 1d       	adc	r27, r1
    ccc2:	1c 92       	st	X, r1
    ccc4:	90 e0       	ldi	r25, 0x00	; 0
    ccc6:	80 e0       	ldi	r24, 0x00	; 0
    ccc8:	f3 ce       	rjmp	.-538    	; 0xcab0 <dtoa_prf+0xc8>
    ccca:	81 e3       	ldi	r24, 0x31	; 49
    cccc:	f1 cf       	rjmp	.-30     	; 0xccb0 <dtoa_prf+0x2c8>
    ccce:	91 93       	st	Z+, r25
    ccd0:	81 50       	subi	r24, 0x01	; 1
    ccd2:	f3 cf       	rjmp	.-26     	; 0xccba <dtoa_prf+0x2d2>
    ccd4:	91 11       	cpse	r25, r1
    ccd6:	83 cf       	rjmp	.-250    	; 0xcbde <dtoa_prf+0x1f6>
    ccd8:	8a cf       	rjmp	.-236    	; 0xcbee <dtoa_prf+0x206>

0000ccda <strtod>:
strtod():
    ccda:	8f 92       	push	r8
    ccdc:	9f 92       	push	r9
    ccde:	af 92       	push	r10
    cce0:	bf 92       	push	r11
    cce2:	cf 92       	push	r12
    cce4:	df 92       	push	r13
    cce6:	ef 92       	push	r14
    cce8:	ff 92       	push	r15
    ccea:	0f 93       	push	r16
    ccec:	1f 93       	push	r17
    ccee:	cf 93       	push	r28
    ccf0:	df 93       	push	r29
    ccf2:	5c 01       	movw	r10, r24
    ccf4:	7b 01       	movw	r14, r22
    ccf6:	61 15       	cp	r22, r1
    ccf8:	71 05       	cpc	r23, r1
    ccfa:	19 f0       	breq	.+6      	; 0xcd02 <strtod+0x28>
    ccfc:	db 01       	movw	r26, r22
    ccfe:	8d 93       	st	X+, r24
    cd00:	9c 93       	st	X, r25
    cd02:	85 01       	movw	r16, r10
    cd04:	0f 5f       	subi	r16, 0xFF	; 255
    cd06:	1f 4f       	sbci	r17, 0xFF	; 255
    cd08:	f5 01       	movw	r30, r10
    cd0a:	d0 81       	ld	r29, Z
    cd0c:	8d 2f       	mov	r24, r29
    cd0e:	90 e0       	ldi	r25, 0x00	; 0
    cd10:	0e 94 a3 68 	call	0xd146	; 0xd146 <isspace>
    cd14:	6c 01       	movw	r12, r24
    cd16:	89 2b       	or	r24, r25
    cd18:	b9 f5       	brne	.+110    	; 0xcd88 <strtod+0xae>
    cd1a:	dd 32       	cpi	r29, 0x2D	; 45
    cd1c:	b9 f5       	brne	.+110    	; 0xcd8c <strtod+0xb2>
    cd1e:	0f 5f       	subi	r16, 0xFF	; 255
    cd20:	1f 4f       	sbci	r17, 0xFF	; 255
    cd22:	d5 01       	movw	r26, r10
    cd24:	11 96       	adiw	r26, 0x01	; 1
    cd26:	dc 91       	ld	r29, X
    cd28:	c1 e0       	ldi	r28, 0x01	; 1
    cd2a:	58 01       	movw	r10, r16
    cd2c:	f1 e0       	ldi	r31, 0x01	; 1
    cd2e:	af 1a       	sub	r10, r31
    cd30:	b1 08       	sbc	r11, r1
    cd32:	43 e0       	ldi	r20, 0x03	; 3
    cd34:	50 e0       	ldi	r21, 0x00	; 0
    cd36:	60 e7       	ldi	r22, 0x70	; 112
    cd38:	72 e0       	ldi	r23, 0x02	; 2
    cd3a:	c5 01       	movw	r24, r10
    cd3c:	0e 94 ac 68 	call	0xd158	; 0xd158 <strncasecmp_P>
    cd40:	89 2b       	or	r24, r25
    cd42:	69 f5       	brne	.+90     	; 0xcd9e <strtod+0xc4>
    cd44:	68 01       	movw	r12, r16
    cd46:	82 e0       	ldi	r24, 0x02	; 2
    cd48:	c8 0e       	add	r12, r24
    cd4a:	d1 1c       	adc	r13, r1
    cd4c:	45 e0       	ldi	r20, 0x05	; 5
    cd4e:	50 e0       	ldi	r21, 0x00	; 0
    cd50:	6b e6       	ldi	r22, 0x6B	; 107
    cd52:	72 e0       	ldi	r23, 0x02	; 2
    cd54:	c6 01       	movw	r24, r12
    cd56:	0e 94 ac 68 	call	0xd158	; 0xd158 <strncasecmp_P>
    cd5a:	89 2b       	or	r24, r25
    cd5c:	21 f4       	brne	.+8      	; 0xcd66 <strtod+0x8c>
    cd5e:	68 01       	movw	r12, r16
    cd60:	97 e0       	ldi	r25, 0x07	; 7
    cd62:	c9 0e       	add	r12, r25
    cd64:	d1 1c       	adc	r13, r1
    cd66:	e1 14       	cp	r14, r1
    cd68:	f1 04       	cpc	r15, r1
    cd6a:	19 f0       	breq	.+6      	; 0xcd72 <strtod+0x98>
    cd6c:	d7 01       	movw	r26, r14
    cd6e:	cd 92       	st	X+, r12
    cd70:	dc 92       	st	X, r13
    cd72:	60 e0       	ldi	r22, 0x00	; 0
    cd74:	70 e0       	ldi	r23, 0x00	; 0
    cd76:	80 e8       	ldi	r24, 0x80	; 128
    cd78:	9f ef       	ldi	r25, 0xFF	; 255
    cd7a:	c1 11       	cpse	r28, r1
    cd7c:	ff c0       	rjmp	.+510    	; 0xcf7c <strtod+0x2a2>
    cd7e:	60 e0       	ldi	r22, 0x00	; 0
    cd80:	70 e0       	ldi	r23, 0x00	; 0
    cd82:	80 e8       	ldi	r24, 0x80	; 128
    cd84:	9f e7       	ldi	r25, 0x7F	; 127
    cd86:	fa c0       	rjmp	.+500    	; 0xcf7c <strtod+0x2a2>
    cd88:	58 01       	movw	r10, r16
    cd8a:	bb cf       	rjmp	.-138    	; 0xcd02 <strtod+0x28>
    cd8c:	db 32       	cpi	r29, 0x2B	; 43
    cd8e:	29 f4       	brne	.+10     	; 0xcd9a <strtod+0xc0>
    cd90:	85 01       	movw	r16, r10
    cd92:	0e 5f       	subi	r16, 0xFE	; 254
    cd94:	1f 4f       	sbci	r17, 0xFF	; 255
    cd96:	f5 01       	movw	r30, r10
    cd98:	d1 81       	ldd	r29, Z+1	; 0x01
    cd9a:	c0 e0       	ldi	r28, 0x00	; 0
    cd9c:	c6 cf       	rjmp	.-116    	; 0xcd2a <strtod+0x50>
    cd9e:	43 e0       	ldi	r20, 0x03	; 3
    cda0:	50 e0       	ldi	r21, 0x00	; 0
    cda2:	68 e6       	ldi	r22, 0x68	; 104
    cda4:	72 e0       	ldi	r23, 0x02	; 2
    cda6:	c5 01       	movw	r24, r10
    cda8:	0e 94 ac 68 	call	0xd158	; 0xd158 <strncasecmp_P>
    cdac:	89 2b       	or	r24, r25
    cdae:	e9 f0       	breq	.+58     	; 0xcdea <strtod+0x110>
    cdb0:	f8 01       	movw	r30, r16
    cdb2:	10 e0       	ldi	r17, 0x00	; 0
    cdb4:	00 e0       	ldi	r16, 0x00	; 0
    cdb6:	20 e0       	ldi	r18, 0x00	; 0
    cdb8:	30 e0       	ldi	r19, 0x00	; 0
    cdba:	a9 01       	movw	r20, r18
    cdbc:	5f 01       	movw	r10, r30
    cdbe:	b0 ed       	ldi	r27, 0xD0	; 208
    cdc0:	8b 2e       	mov	r8, r27
    cdc2:	8d 0e       	add	r8, r29
    cdc4:	89 e0       	ldi	r24, 0x09	; 9
    cdc6:	88 15       	cp	r24, r8
    cdc8:	c8 f1       	brcs	.+114    	; 0xce3c <strtod+0x162>
    cdca:	9c 2e       	mov	r9, r28
    cdcc:	68 94       	set
    cdce:	91 f8       	bld	r9, 1
    cdd0:	8c 2f       	mov	r24, r28
    cdd2:	88 70       	andi	r24, 0x08	; 8
    cdd4:	c2 ff       	sbrs	r28, 2
    cdd6:	16 c0       	rjmp	.+44     	; 0xce04 <strtod+0x12a>
    cdd8:	81 11       	cpse	r24, r1
    cdda:	02 c0       	rjmp	.+4      	; 0xcde0 <strtod+0x106>
    cddc:	0f 5f       	subi	r16, 0xFF	; 255
    cdde:	1f 4f       	sbci	r17, 0xFF	; 255
    cde0:	31 96       	adiw	r30, 0x01	; 1
    cde2:	d5 01       	movw	r26, r10
    cde4:	dc 91       	ld	r29, X
    cde6:	c9 2d       	mov	r28, r9
    cde8:	e9 cf       	rjmp	.-46     	; 0xcdbc <strtod+0xe2>
    cdea:	e1 14       	cp	r14, r1
    cdec:	f1 04       	cpc	r15, r1
    cdee:	29 f0       	breq	.+10     	; 0xcdfa <strtod+0x120>
    cdf0:	0e 5f       	subi	r16, 0xFE	; 254
    cdf2:	1f 4f       	sbci	r17, 0xFF	; 255
    cdf4:	f7 01       	movw	r30, r14
    cdf6:	11 83       	std	Z+1, r17	; 0x01
    cdf8:	00 83       	st	Z, r16
    cdfa:	60 e0       	ldi	r22, 0x00	; 0
    cdfc:	70 e0       	ldi	r23, 0x00	; 0
    cdfe:	80 ec       	ldi	r24, 0xC0	; 192
    ce00:	9f e7       	ldi	r25, 0x7F	; 127
    ce02:	bc c0       	rjmp	.+376    	; 0xcf7c <strtod+0x2a2>
    ce04:	88 23       	and	r24, r24
    ce06:	11 f0       	breq	.+4      	; 0xce0c <strtod+0x132>
    ce08:	01 50       	subi	r16, 0x01	; 1
    ce0a:	11 09       	sbc	r17, r1
    ce0c:	a5 e0       	ldi	r26, 0x05	; 5
    ce0e:	b0 e0       	ldi	r27, 0x00	; 0
    ce10:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
    ce14:	9b 01       	movw	r18, r22
    ce16:	ac 01       	movw	r20, r24
    ce18:	22 0f       	add	r18, r18
    ce1a:	33 1f       	adc	r19, r19
    ce1c:	44 1f       	adc	r20, r20
    ce1e:	55 1f       	adc	r21, r21
    ce20:	28 0d       	add	r18, r8
    ce22:	31 1d       	adc	r19, r1
    ce24:	41 1d       	adc	r20, r1
    ce26:	51 1d       	adc	r21, r1
    ce28:	28 39       	cpi	r18, 0x98	; 152
    ce2a:	99 e9       	ldi	r25, 0x99	; 153
    ce2c:	39 07       	cpc	r19, r25
    ce2e:	49 07       	cpc	r20, r25
    ce30:	99 e1       	ldi	r25, 0x19	; 25
    ce32:	59 07       	cpc	r21, r25
    ce34:	a8 f2       	brcs	.-86     	; 0xcde0 <strtod+0x106>
    ce36:	c6 60       	ori	r28, 0x06	; 6
    ce38:	9c 2e       	mov	r9, r28
    ce3a:	d2 cf       	rjmp	.-92     	; 0xcde0 <strtod+0x106>
    ce3c:	ae ef       	ldi	r26, 0xFE	; 254
    ce3e:	8a 12       	cpse	r8, r26
    ce40:	06 c0       	rjmp	.+12     	; 0xce4e <strtod+0x174>
    ce42:	c3 fd       	sbrc	r28, 3
    ce44:	3c c0       	rjmp	.+120    	; 0xcebe <strtod+0x1e4>
    ce46:	9c 2e       	mov	r9, r28
    ce48:	68 94       	set
    ce4a:	93 f8       	bld	r9, 3
    ce4c:	c9 cf       	rjmp	.-110    	; 0xcde0 <strtod+0x106>
    ce4e:	df 7d       	andi	r29, 0xDF	; 223
    ce50:	d5 34       	cpi	r29, 0x45	; 69
    ce52:	a9 f5       	brne	.+106    	; 0xcebe <strtod+0x1e4>
    ce54:	80 81       	ld	r24, Z
    ce56:	8d 32       	cpi	r24, 0x2D	; 45
    ce58:	39 f4       	brne	.+14     	; 0xce68 <strtod+0x18e>
    ce5a:	c0 61       	ori	r28, 0x10	; 16
    ce5c:	df 01       	movw	r26, r30
    ce5e:	12 96       	adiw	r26, 0x02	; 2
    ce60:	81 81       	ldd	r24, Z+1	; 0x01
    ce62:	62 e0       	ldi	r22, 0x02	; 2
    ce64:	70 e0       	ldi	r23, 0x00	; 0
    ce66:	06 c0       	rjmp	.+12     	; 0xce74 <strtod+0x19a>
    ce68:	df 01       	movw	r26, r30
    ce6a:	8b 32       	cpi	r24, 0x2B	; 43
    ce6c:	c1 f3       	breq	.-16     	; 0xce5e <strtod+0x184>
    ce6e:	11 96       	adiw	r26, 0x01	; 1
    ce70:	61 e0       	ldi	r22, 0x01	; 1
    ce72:	70 e0       	ldi	r23, 0x00	; 0
    ce74:	80 53       	subi	r24, 0x30	; 48
    ce76:	5d 01       	movw	r10, r26
    ce78:	a6 1a       	sub	r10, r22
    ce7a:	b7 0a       	sbc	r11, r23
    ce7c:	8a 30       	cpi	r24, 0x0A	; 10
    ce7e:	f8 f4       	brcc	.+62     	; 0xcebe <strtod+0x1e4>
    ce80:	e0 e8       	ldi	r30, 0x80	; 128
    ce82:	ce 16       	cp	r12, r30
    ce84:	ec e0       	ldi	r30, 0x0C	; 12
    ce86:	de 06       	cpc	r13, r30
    ce88:	5c f4       	brge	.+22     	; 0xcea0 <strtod+0x1c6>
    ce8a:	b6 01       	movw	r22, r12
    ce8c:	66 0f       	add	r22, r22
    ce8e:	77 1f       	adc	r23, r23
    ce90:	66 0f       	add	r22, r22
    ce92:	77 1f       	adc	r23, r23
    ce94:	c6 0e       	add	r12, r22
    ce96:	d7 1e       	adc	r13, r23
    ce98:	cc 0c       	add	r12, r12
    ce9a:	dd 1c       	adc	r13, r13
    ce9c:	c8 0e       	add	r12, r24
    ce9e:	d1 1c       	adc	r13, r1
    cea0:	5d 01       	movw	r10, r26
    cea2:	ff ef       	ldi	r31, 0xFF	; 255
    cea4:	af 1a       	sub	r10, r31
    cea6:	bf 0a       	sbc	r11, r31
    cea8:	8c 91       	ld	r24, X
    ceaa:	80 53       	subi	r24, 0x30	; 48
    ceac:	8a 30       	cpi	r24, 0x0A	; 10
    ceae:	a8 f1       	brcs	.+106    	; 0xcf1a <strtod+0x240>
    ceb0:	c4 ff       	sbrs	r28, 4
    ceb2:	03 c0       	rjmp	.+6      	; 0xceba <strtod+0x1e0>
    ceb4:	d1 94       	neg	r13
    ceb6:	c1 94       	neg	r12
    ceb8:	d1 08       	sbc	r13, r1
    ceba:	0c 0d       	add	r16, r12
    cebc:	1d 1d       	adc	r17, r13
    cebe:	c1 ff       	sbrs	r28, 1
    cec0:	09 c0       	rjmp	.+18     	; 0xced4 <strtod+0x1fa>
    cec2:	e1 14       	cp	r14, r1
    cec4:	f1 04       	cpc	r15, r1
    cec6:	31 f0       	breq	.+12     	; 0xced4 <strtod+0x1fa>
    cec8:	81 e0       	ldi	r24, 0x01	; 1
    ceca:	a8 1a       	sub	r10, r24
    cecc:	b1 08       	sbc	r11, r1
    cece:	d7 01       	movw	r26, r14
    ced0:	ad 92       	st	X+, r10
    ced2:	bc 92       	st	X, r11
    ced4:	ca 01       	movw	r24, r20
    ced6:	b9 01       	movw	r22, r18
    ced8:	0e 94 d9 68 	call	0xd1b2	; 0xd1b2 <__floatunsisf>
    cedc:	c3 70       	andi	r28, 0x03	; 3
    cede:	c3 30       	cpi	r28, 0x03	; 3
    cee0:	09 f4       	brne	.+2      	; 0xcee4 <strtod+0x20a>
    cee2:	90 58       	subi	r25, 0x80	; 128
    cee4:	4b 01       	movw	r8, r22
    cee6:	5c 01       	movw	r10, r24
    cee8:	20 e0       	ldi	r18, 0x00	; 0
    ceea:	30 e0       	ldi	r19, 0x00	; 0
    ceec:	a9 01       	movw	r20, r18
    ceee:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
    cef2:	88 23       	and	r24, r24
    cef4:	09 f4       	brne	.+2      	; 0xcef8 <strtod+0x21e>
    cef6:	40 c0       	rjmp	.+128    	; 0xcf78 <strtod+0x29e>
    cef8:	cf e9       	ldi	r28, 0x9F	; 159
    cefa:	d2 e0       	ldi	r29, 0x02	; 2
    cefc:	17 ff       	sbrs	r17, 7
    cefe:	05 c0       	rjmp	.+10     	; 0xcf0a <strtod+0x230>
    cf00:	11 95       	neg	r17
    cf02:	01 95       	neg	r16
    cf04:	11 09       	sbc	r17, r1
    cf06:	c7 e8       	ldi	r28, 0x87	; 135
    cf08:	d2 e0       	ldi	r29, 0x02	; 2
    cf0a:	6e 01       	movw	r12, r28
    cf0c:	b8 e1       	ldi	r27, 0x18	; 24
    cf0e:	cb 1a       	sub	r12, r27
    cf10:	d1 08       	sbc	r13, r1
    cf12:	80 e2       	ldi	r24, 0x20	; 32
    cf14:	e8 2e       	mov	r14, r24
    cf16:	f1 2c       	mov	r15, r1
    cf18:	0f c0       	rjmp	.+30     	; 0xcf38 <strtod+0x25e>
    cf1a:	d5 01       	movw	r26, r10
    cf1c:	b1 cf       	rjmp	.-158    	; 0xce80 <strtod+0x1a6>
    cf1e:	fe 01       	movw	r30, r28
    cf20:	25 91       	lpm	r18, Z+
    cf22:	35 91       	lpm	r19, Z+
    cf24:	45 91       	lpm	r20, Z+
    cf26:	54 91       	lpm	r21, Z
    cf28:	0e 19       	sub	r16, r14
    cf2a:	1f 09       	sbc	r17, r15
    cf2c:	c5 01       	movw	r24, r10
    cf2e:	b4 01       	movw	r22, r8
    cf30:	0e 94 3a 69 	call	0xd274	; 0xd274 <__mulsf3>
    cf34:	4b 01       	movw	r8, r22
    cf36:	5c 01       	movw	r10, r24
    cf38:	d5 01       	movw	r26, r10
    cf3a:	c4 01       	movw	r24, r8
    cf3c:	0e 15       	cp	r16, r14
    cf3e:	1f 05       	cpc	r17, r15
    cf40:	74 f7       	brge	.-36     	; 0xcf1e <strtod+0x244>
    cf42:	24 97       	sbiw	r28, 0x04	; 4
    cf44:	f5 94       	asr	r15
    cf46:	e7 94       	ror	r14
    cf48:	cc 16       	cp	r12, r28
    cf4a:	dd 06       	cpc	r13, r29
    cf4c:	a9 f7       	brne	.-22     	; 0xcf38 <strtod+0x25e>
    cf4e:	8a 2f       	mov	r24, r26
    cf50:	88 0f       	add	r24, r24
    cf52:	8b 2f       	mov	r24, r27
    cf54:	88 1f       	adc	r24, r24
    cf56:	8f 3f       	cpi	r24, 0xFF	; 255
    cf58:	49 f0       	breq	.+18     	; 0xcf6c <strtod+0x292>
    cf5a:	20 e0       	ldi	r18, 0x00	; 0
    cf5c:	30 e0       	ldi	r19, 0x00	; 0
    cf5e:	a9 01       	movw	r20, r18
    cf60:	c5 01       	movw	r24, r10
    cf62:	b4 01       	movw	r22, r8
    cf64:	0e 94 d4 68 	call	0xd1a8	; 0xd1a8 <__cmpsf2>
    cf68:	81 11       	cpse	r24, r1
    cf6a:	06 c0       	rjmp	.+12     	; 0xcf78 <strtod+0x29e>
    cf6c:	82 e2       	ldi	r24, 0x22	; 34
    cf6e:	90 e0       	ldi	r25, 0x00	; 0
    cf70:	90 93 6f 13 	sts	0x136F, r25	; 0x80136f <errno+0x1>
    cf74:	80 93 6e 13 	sts	0x136E, r24	; 0x80136e <errno>
    cf78:	c5 01       	movw	r24, r10
    cf7a:	b4 01       	movw	r22, r8
    cf7c:	df 91       	pop	r29
    cf7e:	cf 91       	pop	r28
    cf80:	1f 91       	pop	r17
    cf82:	0f 91       	pop	r16
    cf84:	ff 90       	pop	r15
    cf86:	ef 90       	pop	r14
    cf88:	df 90       	pop	r13
    cf8a:	cf 90       	pop	r12
    cf8c:	bf 90       	pop	r11
    cf8e:	af 90       	pop	r10
    cf90:	9f 90       	pop	r9
    cf92:	8f 90       	pop	r8
    cf94:	08 95       	ret

0000cf96 <__ftoa_engine>:
__ftoa_engine():
    cf96:	28 30       	cpi	r18, 0x08	; 8
    cf98:	08 f0       	brcs	.+2      	; 0xcf9c <__ftoa_engine+0x6>
    cf9a:	27 e0       	ldi	r18, 0x07	; 7
    cf9c:	33 27       	eor	r19, r19
    cf9e:	da 01       	movw	r26, r20
    cfa0:	99 0f       	add	r25, r25
    cfa2:	31 1d       	adc	r19, r1
    cfa4:	87 fd       	sbrc	r24, 7
    cfa6:	91 60       	ori	r25, 0x01	; 1
    cfa8:	00 96       	adiw	r24, 0x00	; 0
    cfaa:	61 05       	cpc	r22, r1
    cfac:	71 05       	cpc	r23, r1
    cfae:	39 f4       	brne	.+14     	; 0xcfbe <__ftoa_engine+0x28>
    cfb0:	32 60       	ori	r19, 0x02	; 2
    cfb2:	2e 5f       	subi	r18, 0xFE	; 254
    cfb4:	3d 93       	st	X+, r19
    cfb6:	30 e3       	ldi	r19, 0x30	; 48
    cfb8:	2a 95       	dec	r18
    cfba:	e1 f7       	brne	.-8      	; 0xcfb4 <__ftoa_engine+0x1e>
    cfbc:	08 95       	ret
    cfbe:	9f 3f       	cpi	r25, 0xFF	; 255
    cfc0:	30 f0       	brcs	.+12     	; 0xcfce <__ftoa_engine+0x38>
    cfc2:	80 38       	cpi	r24, 0x80	; 128
    cfc4:	71 05       	cpc	r23, r1
    cfc6:	61 05       	cpc	r22, r1
    cfc8:	09 f0       	breq	.+2      	; 0xcfcc <__ftoa_engine+0x36>
    cfca:	3c 5f       	subi	r19, 0xFC	; 252
    cfcc:	3c 5f       	subi	r19, 0xFC	; 252
    cfce:	3d 93       	st	X+, r19
    cfd0:	91 30       	cpi	r25, 0x01	; 1
    cfd2:	08 f0       	brcs	.+2      	; 0xcfd6 <__ftoa_engine+0x40>
    cfd4:	80 68       	ori	r24, 0x80	; 128
    cfd6:	91 1d       	adc	r25, r1
    cfd8:	df 93       	push	r29
    cfda:	cf 93       	push	r28
    cfdc:	1f 93       	push	r17
    cfde:	0f 93       	push	r16
    cfe0:	ff 92       	push	r15
    cfe2:	ef 92       	push	r14
    cfe4:	19 2f       	mov	r17, r25
    cfe6:	98 7f       	andi	r25, 0xF8	; 248
    cfe8:	96 95       	lsr	r25
    cfea:	e9 2f       	mov	r30, r25
    cfec:	96 95       	lsr	r25
    cfee:	96 95       	lsr	r25
    cff0:	e9 0f       	add	r30, r25
    cff2:	ff 27       	eor	r31, r31
    cff4:	e3 50       	subi	r30, 0x03	; 3
    cff6:	fd 4f       	sbci	r31, 0xFD	; 253
    cff8:	99 27       	eor	r25, r25
    cffa:	33 27       	eor	r19, r19
    cffc:	ee 24       	eor	r14, r14
    cffe:	ff 24       	eor	r15, r15
    d000:	a7 01       	movw	r20, r14
    d002:	e7 01       	movw	r28, r14
    d004:	05 90       	lpm	r0, Z+
    d006:	08 94       	sec
    d008:	07 94       	ror	r0
    d00a:	28 f4       	brcc	.+10     	; 0xd016 <__ftoa_engine+0x80>
    d00c:	36 0f       	add	r19, r22
    d00e:	e7 1e       	adc	r14, r23
    d010:	f8 1e       	adc	r15, r24
    d012:	49 1f       	adc	r20, r25
    d014:	51 1d       	adc	r21, r1
    d016:	66 0f       	add	r22, r22
    d018:	77 1f       	adc	r23, r23
    d01a:	88 1f       	adc	r24, r24
    d01c:	99 1f       	adc	r25, r25
    d01e:	06 94       	lsr	r0
    d020:	a1 f7       	brne	.-24     	; 0xd00a <__ftoa_engine+0x74>
    d022:	05 90       	lpm	r0, Z+
    d024:	07 94       	ror	r0
    d026:	28 f4       	brcc	.+10     	; 0xd032 <__ftoa_engine+0x9c>
    d028:	e7 0e       	add	r14, r23
    d02a:	f8 1e       	adc	r15, r24
    d02c:	49 1f       	adc	r20, r25
    d02e:	56 1f       	adc	r21, r22
    d030:	c1 1d       	adc	r28, r1
    d032:	77 0f       	add	r23, r23
    d034:	88 1f       	adc	r24, r24
    d036:	99 1f       	adc	r25, r25
    d038:	66 1f       	adc	r22, r22
    d03a:	06 94       	lsr	r0
    d03c:	a1 f7       	brne	.-24     	; 0xd026 <__ftoa_engine+0x90>
    d03e:	05 90       	lpm	r0, Z+
    d040:	07 94       	ror	r0
    d042:	28 f4       	brcc	.+10     	; 0xd04e <__ftoa_engine+0xb8>
    d044:	f8 0e       	add	r15, r24
    d046:	49 1f       	adc	r20, r25
    d048:	56 1f       	adc	r21, r22
    d04a:	c7 1f       	adc	r28, r23
    d04c:	d1 1d       	adc	r29, r1
    d04e:	88 0f       	add	r24, r24
    d050:	99 1f       	adc	r25, r25
    d052:	66 1f       	adc	r22, r22
    d054:	77 1f       	adc	r23, r23
    d056:	06 94       	lsr	r0
    d058:	a1 f7       	brne	.-24     	; 0xd042 <__ftoa_engine+0xac>
    d05a:	05 90       	lpm	r0, Z+
    d05c:	07 94       	ror	r0
    d05e:	20 f4       	brcc	.+8      	; 0xd068 <__ftoa_engine+0xd2>
    d060:	49 0f       	add	r20, r25
    d062:	56 1f       	adc	r21, r22
    d064:	c7 1f       	adc	r28, r23
    d066:	d8 1f       	adc	r29, r24
    d068:	99 0f       	add	r25, r25
    d06a:	66 1f       	adc	r22, r22
    d06c:	77 1f       	adc	r23, r23
    d06e:	88 1f       	adc	r24, r24
    d070:	06 94       	lsr	r0
    d072:	a9 f7       	brne	.-22     	; 0xd05e <__ftoa_engine+0xc8>
    d074:	84 91       	lpm	r24, Z
    d076:	10 95       	com	r17
    d078:	17 70       	andi	r17, 0x07	; 7
    d07a:	41 f0       	breq	.+16     	; 0xd08c <__ftoa_engine+0xf6>
    d07c:	d6 95       	lsr	r29
    d07e:	c7 95       	ror	r28
    d080:	57 95       	ror	r21
    d082:	47 95       	ror	r20
    d084:	f7 94       	ror	r15
    d086:	e7 94       	ror	r14
    d088:	1a 95       	dec	r17
    d08a:	c1 f7       	brne	.-16     	; 0xd07c <__ftoa_engine+0xe6>
    d08c:	e3 ea       	ldi	r30, 0xA3	; 163
    d08e:	f2 e0       	ldi	r31, 0x02	; 2
    d090:	68 94       	set
    d092:	15 90       	lpm	r1, Z+
    d094:	15 91       	lpm	r17, Z+
    d096:	35 91       	lpm	r19, Z+
    d098:	65 91       	lpm	r22, Z+
    d09a:	95 91       	lpm	r25, Z+
    d09c:	05 90       	lpm	r0, Z+
    d09e:	7f e2       	ldi	r23, 0x2F	; 47
    d0a0:	73 95       	inc	r23
    d0a2:	e1 18       	sub	r14, r1
    d0a4:	f1 0a       	sbc	r15, r17
    d0a6:	43 0b       	sbc	r20, r19
    d0a8:	56 0b       	sbc	r21, r22
    d0aa:	c9 0b       	sbc	r28, r25
    d0ac:	d0 09       	sbc	r29, r0
    d0ae:	c0 f7       	brcc	.-16     	; 0xd0a0 <__ftoa_engine+0x10a>
    d0b0:	e1 0c       	add	r14, r1
    d0b2:	f1 1e       	adc	r15, r17
    d0b4:	43 1f       	adc	r20, r19
    d0b6:	56 1f       	adc	r21, r22
    d0b8:	c9 1f       	adc	r28, r25
    d0ba:	d0 1d       	adc	r29, r0
    d0bc:	7e f4       	brtc	.+30     	; 0xd0dc <__ftoa_engine+0x146>
    d0be:	70 33       	cpi	r23, 0x30	; 48
    d0c0:	11 f4       	brne	.+4      	; 0xd0c6 <__ftoa_engine+0x130>
    d0c2:	8a 95       	dec	r24
    d0c4:	e6 cf       	rjmp	.-52     	; 0xd092 <__ftoa_engine+0xfc>
    d0c6:	e8 94       	clt
    d0c8:	01 50       	subi	r16, 0x01	; 1
    d0ca:	30 f0       	brcs	.+12     	; 0xd0d8 <__ftoa_engine+0x142>
    d0cc:	08 0f       	add	r16, r24
    d0ce:	0a f4       	brpl	.+2      	; 0xd0d2 <__ftoa_engine+0x13c>
    d0d0:	00 27       	eor	r16, r16
    d0d2:	02 17       	cp	r16, r18
    d0d4:	08 f4       	brcc	.+2      	; 0xd0d8 <__ftoa_engine+0x142>
    d0d6:	20 2f       	mov	r18, r16
    d0d8:	23 95       	inc	r18
    d0da:	02 2f       	mov	r16, r18
    d0dc:	7a 33       	cpi	r23, 0x3A	; 58
    d0de:	28 f0       	brcs	.+10     	; 0xd0ea <__ftoa_engine+0x154>
    d0e0:	79 e3       	ldi	r23, 0x39	; 57
    d0e2:	7d 93       	st	X+, r23
    d0e4:	2a 95       	dec	r18
    d0e6:	e9 f7       	brne	.-6      	; 0xd0e2 <__ftoa_engine+0x14c>
    d0e8:	10 c0       	rjmp	.+32     	; 0xd10a <__ftoa_engine+0x174>
    d0ea:	7d 93       	st	X+, r23
    d0ec:	2a 95       	dec	r18
    d0ee:	89 f6       	brne	.-94     	; 0xd092 <__ftoa_engine+0xfc>
    d0f0:	06 94       	lsr	r0
    d0f2:	97 95       	ror	r25
    d0f4:	67 95       	ror	r22
    d0f6:	37 95       	ror	r19
    d0f8:	17 95       	ror	r17
    d0fa:	17 94       	ror	r1
    d0fc:	e1 18       	sub	r14, r1
    d0fe:	f1 0a       	sbc	r15, r17
    d100:	43 0b       	sbc	r20, r19
    d102:	56 0b       	sbc	r21, r22
    d104:	c9 0b       	sbc	r28, r25
    d106:	d0 09       	sbc	r29, r0
    d108:	98 f0       	brcs	.+38     	; 0xd130 <__ftoa_engine+0x19a>
    d10a:	23 95       	inc	r18
    d10c:	7e 91       	ld	r23, -X
    d10e:	73 95       	inc	r23
    d110:	7a 33       	cpi	r23, 0x3A	; 58
    d112:	08 f0       	brcs	.+2      	; 0xd116 <__ftoa_engine+0x180>
    d114:	70 e3       	ldi	r23, 0x30	; 48
    d116:	7c 93       	st	X, r23
    d118:	20 13       	cpse	r18, r16
    d11a:	b8 f7       	brcc	.-18     	; 0xd10a <__ftoa_engine+0x174>
    d11c:	7e 91       	ld	r23, -X
    d11e:	70 61       	ori	r23, 0x10	; 16
    d120:	7d 93       	st	X+, r23
    d122:	30 f0       	brcs	.+12     	; 0xd130 <__ftoa_engine+0x19a>
    d124:	83 95       	inc	r24
    d126:	71 e3       	ldi	r23, 0x31	; 49
    d128:	7d 93       	st	X+, r23
    d12a:	70 e3       	ldi	r23, 0x30	; 48
    d12c:	2a 95       	dec	r18
    d12e:	e1 f7       	brne	.-8      	; 0xd128 <__ftoa_engine+0x192>
    d130:	11 24       	eor	r1, r1
    d132:	ef 90       	pop	r14
    d134:	ff 90       	pop	r15
    d136:	0f 91       	pop	r16
    d138:	1f 91       	pop	r17
    d13a:	cf 91       	pop	r28
    d13c:	df 91       	pop	r29
    d13e:	99 27       	eor	r25, r25
    d140:	87 fd       	sbrc	r24, 7
    d142:	90 95       	com	r25
    d144:	08 95       	ret

0000d146 <isspace>:
isspace():
    d146:	91 11       	cpse	r25, r1
    d148:	0c 94 a7 69 	jmp	0xd34e	; 0xd34e <__ctype_isfalse>
    d14c:	80 32       	cpi	r24, 0x20	; 32
    d14e:	19 f0       	breq	.+6      	; 0xd156 <isspace+0x10>
    d150:	89 50       	subi	r24, 0x09	; 9
    d152:	85 50       	subi	r24, 0x05	; 5
    d154:	c8 f7       	brcc	.-14     	; 0xd148 <isspace+0x2>
    d156:	08 95       	ret

0000d158 <strncasecmp_P>:
strncasecmp_P():
    d158:	fb 01       	movw	r30, r22
    d15a:	dc 01       	movw	r26, r24
    d15c:	41 50       	subi	r20, 0x01	; 1
    d15e:	50 40       	sbci	r21, 0x00	; 0
    d160:	88 f0       	brcs	.+34     	; 0xd184 <strncasecmp_P+0x2c>
    d162:	8d 91       	ld	r24, X+
    d164:	81 34       	cpi	r24, 0x41	; 65
    d166:	1c f0       	brlt	.+6      	; 0xd16e <strncasecmp_P+0x16>
    d168:	8b 35       	cpi	r24, 0x5B	; 91
    d16a:	0c f4       	brge	.+2      	; 0xd16e <strncasecmp_P+0x16>
    d16c:	80 5e       	subi	r24, 0xE0	; 224
    d16e:	65 91       	lpm	r22, Z+
    d170:	61 34       	cpi	r22, 0x41	; 65
    d172:	1c f0       	brlt	.+6      	; 0xd17a <strncasecmp_P+0x22>
    d174:	6b 35       	cpi	r22, 0x5B	; 91
    d176:	0c f4       	brge	.+2      	; 0xd17a <strncasecmp_P+0x22>
    d178:	60 5e       	subi	r22, 0xE0	; 224
    d17a:	86 1b       	sub	r24, r22
    d17c:	61 11       	cpse	r22, r1
    d17e:	71 f3       	breq	.-36     	; 0xd15c <strncasecmp_P+0x4>
    d180:	99 0b       	sbc	r25, r25
    d182:	08 95       	ret
    d184:	88 1b       	sub	r24, r24
    d186:	fc cf       	rjmp	.-8      	; 0xd180 <strncasecmp_P+0x28>

0000d188 <strrev>:
strrev():
    d188:	dc 01       	movw	r26, r24
    d18a:	fc 01       	movw	r30, r24
    d18c:	67 2f       	mov	r22, r23
    d18e:	71 91       	ld	r23, Z+
    d190:	77 23       	and	r23, r23
    d192:	e1 f7       	brne	.-8      	; 0xd18c <strrev+0x4>
    d194:	32 97       	sbiw	r30, 0x02	; 2
    d196:	04 c0       	rjmp	.+8      	; 0xd1a0 <strrev+0x18>
    d198:	7c 91       	ld	r23, X
    d19a:	6d 93       	st	X+, r22
    d19c:	70 83       	st	Z, r23
    d19e:	62 91       	ld	r22, -Z
    d1a0:	ae 17       	cp	r26, r30
    d1a2:	bf 07       	cpc	r27, r31
    d1a4:	c8 f3       	brcs	.-14     	; 0xd198 <strrev+0x10>
    d1a6:	08 95       	ret

0000d1a8 <__cmpsf2>:
__cmpsf2():
    d1a8:	0e 94 16 69 	call	0xd22c	; 0xd22c <__fp_cmp>
    d1ac:	08 f4       	brcc	.+2      	; 0xd1b0 <__cmpsf2+0x8>
    d1ae:	81 e0       	ldi	r24, 0x01	; 1
    d1b0:	08 95       	ret

0000d1b2 <__floatunsisf>:
__floatunsisf():
    d1b2:	e8 94       	clt
    d1b4:	09 c0       	rjmp	.+18     	; 0xd1c8 <__floatsisf+0x12>

0000d1b6 <__floatsisf>:
    d1b6:	97 fb       	bst	r25, 7
    d1b8:	3e f4       	brtc	.+14     	; 0xd1c8 <__floatsisf+0x12>
    d1ba:	90 95       	com	r25
    d1bc:	80 95       	com	r24
    d1be:	70 95       	com	r23
    d1c0:	61 95       	neg	r22
    d1c2:	7f 4f       	sbci	r23, 0xFF	; 255
    d1c4:	8f 4f       	sbci	r24, 0xFF	; 255
    d1c6:	9f 4f       	sbci	r25, 0xFF	; 255
    d1c8:	99 23       	and	r25, r25
    d1ca:	a9 f0       	breq	.+42     	; 0xd1f6 <__floatsisf+0x40>
    d1cc:	f9 2f       	mov	r31, r25
    d1ce:	96 e9       	ldi	r25, 0x96	; 150
    d1d0:	bb 27       	eor	r27, r27
    d1d2:	93 95       	inc	r25
    d1d4:	f6 95       	lsr	r31
    d1d6:	87 95       	ror	r24
    d1d8:	77 95       	ror	r23
    d1da:	67 95       	ror	r22
    d1dc:	b7 95       	ror	r27
    d1de:	f1 11       	cpse	r31, r1
    d1e0:	f8 cf       	rjmp	.-16     	; 0xd1d2 <__floatsisf+0x1c>
    d1e2:	fa f4       	brpl	.+62     	; 0xd222 <__floatsisf+0x6c>
    d1e4:	bb 0f       	add	r27, r27
    d1e6:	11 f4       	brne	.+4      	; 0xd1ec <__floatsisf+0x36>
    d1e8:	60 ff       	sbrs	r22, 0
    d1ea:	1b c0       	rjmp	.+54     	; 0xd222 <__floatsisf+0x6c>
    d1ec:	6f 5f       	subi	r22, 0xFF	; 255
    d1ee:	7f 4f       	sbci	r23, 0xFF	; 255
    d1f0:	8f 4f       	sbci	r24, 0xFF	; 255
    d1f2:	9f 4f       	sbci	r25, 0xFF	; 255
    d1f4:	16 c0       	rjmp	.+44     	; 0xd222 <__floatsisf+0x6c>
    d1f6:	88 23       	and	r24, r24
    d1f8:	11 f0       	breq	.+4      	; 0xd1fe <__floatsisf+0x48>
    d1fa:	96 e9       	ldi	r25, 0x96	; 150
    d1fc:	11 c0       	rjmp	.+34     	; 0xd220 <__floatsisf+0x6a>
    d1fe:	77 23       	and	r23, r23
    d200:	21 f0       	breq	.+8      	; 0xd20a <__floatsisf+0x54>
    d202:	9e e8       	ldi	r25, 0x8E	; 142
    d204:	87 2f       	mov	r24, r23
    d206:	76 2f       	mov	r23, r22
    d208:	05 c0       	rjmp	.+10     	; 0xd214 <__floatsisf+0x5e>
    d20a:	66 23       	and	r22, r22
    d20c:	71 f0       	breq	.+28     	; 0xd22a <__floatsisf+0x74>
    d20e:	96 e8       	ldi	r25, 0x86	; 134
    d210:	86 2f       	mov	r24, r22
    d212:	70 e0       	ldi	r23, 0x00	; 0
    d214:	60 e0       	ldi	r22, 0x00	; 0
    d216:	2a f0       	brmi	.+10     	; 0xd222 <__floatsisf+0x6c>
    d218:	9a 95       	dec	r25
    d21a:	66 0f       	add	r22, r22
    d21c:	77 1f       	adc	r23, r23
    d21e:	88 1f       	adc	r24, r24
    d220:	da f7       	brpl	.-10     	; 0xd218 <__floatsisf+0x62>
    d222:	88 0f       	add	r24, r24
    d224:	96 95       	lsr	r25
    d226:	87 95       	ror	r24
    d228:	97 f9       	bld	r25, 7
    d22a:	08 95       	ret

0000d22c <__fp_cmp>:
__fp_cmp():
    d22c:	99 0f       	add	r25, r25
    d22e:	00 08       	sbc	r0, r0
    d230:	55 0f       	add	r21, r21
    d232:	aa 0b       	sbc	r26, r26
    d234:	e0 e8       	ldi	r30, 0x80	; 128
    d236:	fe ef       	ldi	r31, 0xFE	; 254
    d238:	16 16       	cp	r1, r22
    d23a:	17 06       	cpc	r1, r23
    d23c:	e8 07       	cpc	r30, r24
    d23e:	f9 07       	cpc	r31, r25
    d240:	c0 f0       	brcs	.+48     	; 0xd272 <__fp_cmp+0x46>
    d242:	12 16       	cp	r1, r18
    d244:	13 06       	cpc	r1, r19
    d246:	e4 07       	cpc	r30, r20
    d248:	f5 07       	cpc	r31, r21
    d24a:	98 f0       	brcs	.+38     	; 0xd272 <__fp_cmp+0x46>
    d24c:	62 1b       	sub	r22, r18
    d24e:	73 0b       	sbc	r23, r19
    d250:	84 0b       	sbc	r24, r20
    d252:	95 0b       	sbc	r25, r21
    d254:	39 f4       	brne	.+14     	; 0xd264 <__fp_cmp+0x38>
    d256:	0a 26       	eor	r0, r26
    d258:	61 f0       	breq	.+24     	; 0xd272 <__fp_cmp+0x46>
    d25a:	23 2b       	or	r18, r19
    d25c:	24 2b       	or	r18, r20
    d25e:	25 2b       	or	r18, r21
    d260:	21 f4       	brne	.+8      	; 0xd26a <__fp_cmp+0x3e>
    d262:	08 95       	ret
    d264:	0a 26       	eor	r0, r26
    d266:	09 f4       	brne	.+2      	; 0xd26a <__fp_cmp+0x3e>
    d268:	a1 40       	sbci	r26, 0x01	; 1
    d26a:	a6 95       	lsr	r26
    d26c:	8f ef       	ldi	r24, 0xFF	; 255
    d26e:	81 1d       	adc	r24, r1
    d270:	81 1d       	adc	r24, r1
    d272:	08 95       	ret

0000d274 <__mulsf3>:
__mulsf3():
    d274:	0e 94 4d 69 	call	0xd29a	; 0xd29a <__mulsf3x>
    d278:	0c 94 c1 69 	jmp	0xd382	; 0xd382 <__fp_round>
    d27c:	0e 94 b3 69 	call	0xd366	; 0xd366 <__fp_pscA>
    d280:	38 f0       	brcs	.+14     	; 0xd290 <__mulsf3+0x1c>
    d282:	0e 94 ba 69 	call	0xd374	; 0xd374 <__fp_pscB>
    d286:	20 f0       	brcs	.+8      	; 0xd290 <__mulsf3+0x1c>
    d288:	95 23       	and	r25, r21
    d28a:	11 f0       	breq	.+4      	; 0xd290 <__mulsf3+0x1c>
    d28c:	0c 94 aa 69 	jmp	0xd354	; 0xd354 <__fp_inf>
    d290:	0c 94 b0 69 	jmp	0xd360	; 0xd360 <__fp_nan>
    d294:	11 24       	eor	r1, r1
    d296:	0c 94 f5 69 	jmp	0xd3ea	; 0xd3ea <__fp_szero>

0000d29a <__mulsf3x>:
__mulsf3x():
    d29a:	0e 94 d2 69 	call	0xd3a4	; 0xd3a4 <__fp_split3>
    d29e:	70 f3       	brcs	.-36     	; 0xd27c <__mulsf3+0x8>

0000d2a0 <__mulsf3_pse>:
    d2a0:	95 9f       	mul	r25, r21
    d2a2:	c1 f3       	breq	.-16     	; 0xd294 <__mulsf3+0x20>
    d2a4:	95 0f       	add	r25, r21
    d2a6:	50 e0       	ldi	r21, 0x00	; 0
    d2a8:	55 1f       	adc	r21, r21
    d2aa:	62 9f       	mul	r22, r18
    d2ac:	f0 01       	movw	r30, r0
    d2ae:	72 9f       	mul	r23, r18
    d2b0:	bb 27       	eor	r27, r27
    d2b2:	f0 0d       	add	r31, r0
    d2b4:	b1 1d       	adc	r27, r1
    d2b6:	63 9f       	mul	r22, r19
    d2b8:	aa 27       	eor	r26, r26
    d2ba:	f0 0d       	add	r31, r0
    d2bc:	b1 1d       	adc	r27, r1
    d2be:	aa 1f       	adc	r26, r26
    d2c0:	64 9f       	mul	r22, r20
    d2c2:	66 27       	eor	r22, r22
    d2c4:	b0 0d       	add	r27, r0
    d2c6:	a1 1d       	adc	r26, r1
    d2c8:	66 1f       	adc	r22, r22
    d2ca:	82 9f       	mul	r24, r18
    d2cc:	22 27       	eor	r18, r18
    d2ce:	b0 0d       	add	r27, r0
    d2d0:	a1 1d       	adc	r26, r1
    d2d2:	62 1f       	adc	r22, r18
    d2d4:	73 9f       	mul	r23, r19
    d2d6:	b0 0d       	add	r27, r0
    d2d8:	a1 1d       	adc	r26, r1
    d2da:	62 1f       	adc	r22, r18
    d2dc:	83 9f       	mul	r24, r19
    d2de:	a0 0d       	add	r26, r0
    d2e0:	61 1d       	adc	r22, r1
    d2e2:	22 1f       	adc	r18, r18
    d2e4:	74 9f       	mul	r23, r20
    d2e6:	33 27       	eor	r19, r19
    d2e8:	a0 0d       	add	r26, r0
    d2ea:	61 1d       	adc	r22, r1
    d2ec:	23 1f       	adc	r18, r19
    d2ee:	84 9f       	mul	r24, r20
    d2f0:	60 0d       	add	r22, r0
    d2f2:	21 1d       	adc	r18, r1
    d2f4:	82 2f       	mov	r24, r18
    d2f6:	76 2f       	mov	r23, r22
    d2f8:	6a 2f       	mov	r22, r26
    d2fa:	11 24       	eor	r1, r1
    d2fc:	9f 57       	subi	r25, 0x7F	; 127
    d2fe:	50 40       	sbci	r21, 0x00	; 0
    d300:	9a f0       	brmi	.+38     	; 0xd328 <__mulsf3_pse+0x88>
    d302:	f1 f0       	breq	.+60     	; 0xd340 <__mulsf3_pse+0xa0>
    d304:	88 23       	and	r24, r24
    d306:	4a f0       	brmi	.+18     	; 0xd31a <__mulsf3_pse+0x7a>
    d308:	ee 0f       	add	r30, r30
    d30a:	ff 1f       	adc	r31, r31
    d30c:	bb 1f       	adc	r27, r27
    d30e:	66 1f       	adc	r22, r22
    d310:	77 1f       	adc	r23, r23
    d312:	88 1f       	adc	r24, r24
    d314:	91 50       	subi	r25, 0x01	; 1
    d316:	50 40       	sbci	r21, 0x00	; 0
    d318:	a9 f7       	brne	.-22     	; 0xd304 <__mulsf3_pse+0x64>
    d31a:	9e 3f       	cpi	r25, 0xFE	; 254
    d31c:	51 05       	cpc	r21, r1
    d31e:	80 f0       	brcs	.+32     	; 0xd340 <__mulsf3_pse+0xa0>
    d320:	0c 94 aa 69 	jmp	0xd354	; 0xd354 <__fp_inf>
    d324:	0c 94 f5 69 	jmp	0xd3ea	; 0xd3ea <__fp_szero>
    d328:	5f 3f       	cpi	r21, 0xFF	; 255
    d32a:	e4 f3       	brlt	.-8      	; 0xd324 <__mulsf3_pse+0x84>
    d32c:	98 3e       	cpi	r25, 0xE8	; 232
    d32e:	d4 f3       	brlt	.-12     	; 0xd324 <__mulsf3_pse+0x84>
    d330:	86 95       	lsr	r24
    d332:	77 95       	ror	r23
    d334:	67 95       	ror	r22
    d336:	b7 95       	ror	r27
    d338:	f7 95       	ror	r31
    d33a:	e7 95       	ror	r30
    d33c:	9f 5f       	subi	r25, 0xFF	; 255
    d33e:	c1 f7       	brne	.-16     	; 0xd330 <__mulsf3_pse+0x90>
    d340:	fe 2b       	or	r31, r30
    d342:	88 0f       	add	r24, r24
    d344:	91 1d       	adc	r25, r1
    d346:	96 95       	lsr	r25
    d348:	87 95       	ror	r24
    d34a:	97 f9       	bld	r25, 7
    d34c:	08 95       	ret

0000d34e <__ctype_isfalse>:
    d34e:	99 27       	eor	r25, r25
    d350:	88 27       	eor	r24, r24

0000d352 <__ctype_istrue>:
    d352:	08 95       	ret

0000d354 <__fp_inf>:
    d354:	97 f9       	bld	r25, 7
    d356:	9f 67       	ori	r25, 0x7F	; 127
    d358:	80 e8       	ldi	r24, 0x80	; 128
    d35a:	70 e0       	ldi	r23, 0x00	; 0
    d35c:	60 e0       	ldi	r22, 0x00	; 0
    d35e:	08 95       	ret

0000d360 <__fp_nan>:
    d360:	9f ef       	ldi	r25, 0xFF	; 255
    d362:	80 ec       	ldi	r24, 0xC0	; 192
    d364:	08 95       	ret

0000d366 <__fp_pscA>:
    d366:	00 24       	eor	r0, r0
    d368:	0a 94       	dec	r0
    d36a:	16 16       	cp	r1, r22
__fp_pscA():
    d36c:	17 06       	cpc	r1, r23
    d36e:	18 06       	cpc	r1, r24
    d370:	09 06       	cpc	r0, r25
    d372:	08 95       	ret

0000d374 <__fp_pscB>:
__fp_pscB():
    d374:	00 24       	eor	r0, r0
    d376:	0a 94       	dec	r0
    d378:	12 16       	cp	r1, r18
    d37a:	13 06       	cpc	r1, r19
    d37c:	14 06       	cpc	r1, r20
    d37e:	05 06       	cpc	r0, r21
    d380:	08 95       	ret

0000d382 <__fp_round>:
__fp_round():
    d382:	09 2e       	mov	r0, r25
    d384:	03 94       	inc	r0
    d386:	00 0c       	add	r0, r0
    d388:	11 f4       	brne	.+4      	; 0xd38e <__fp_round+0xc>
    d38a:	88 23       	and	r24, r24
    d38c:	52 f0       	brmi	.+20     	; 0xd3a2 <__fp_round+0x20>
    d38e:	bb 0f       	add	r27, r27
    d390:	40 f4       	brcc	.+16     	; 0xd3a2 <__fp_round+0x20>
    d392:	bf 2b       	or	r27, r31
    d394:	11 f4       	brne	.+4      	; 0xd39a <__fp_round+0x18>
    d396:	60 ff       	sbrs	r22, 0
    d398:	04 c0       	rjmp	.+8      	; 0xd3a2 <__fp_round+0x20>
    d39a:	6f 5f       	subi	r22, 0xFF	; 255
    d39c:	7f 4f       	sbci	r23, 0xFF	; 255
    d39e:	8f 4f       	sbci	r24, 0xFF	; 255
    d3a0:	9f 4f       	sbci	r25, 0xFF	; 255
    d3a2:	08 95       	ret

0000d3a4 <__fp_split3>:
__fp_split3():
    d3a4:	57 fd       	sbrc	r21, 7
    d3a6:	90 58       	subi	r25, 0x80	; 128
    d3a8:	44 0f       	add	r20, r20
    d3aa:	55 1f       	adc	r21, r21
    d3ac:	59 f0       	breq	.+22     	; 0xd3c4 <__fp_splitA+0x10>
    d3ae:	5f 3f       	cpi	r21, 0xFF	; 255
    d3b0:	71 f0       	breq	.+28     	; 0xd3ce <__fp_splitA+0x1a>
    d3b2:	47 95       	ror	r20

0000d3b4 <__fp_splitA>:
    d3b4:	88 0f       	add	r24, r24
    d3b6:	97 fb       	bst	r25, 7
    d3b8:	99 1f       	adc	r25, r25
    d3ba:	61 f0       	breq	.+24     	; 0xd3d4 <__fp_splitA+0x20>
    d3bc:	9f 3f       	cpi	r25, 0xFF	; 255
    d3be:	79 f0       	breq	.+30     	; 0xd3de <__fp_splitA+0x2a>
    d3c0:	87 95       	ror	r24
    d3c2:	08 95       	ret
    d3c4:	12 16       	cp	r1, r18
    d3c6:	13 06       	cpc	r1, r19
    d3c8:	14 06       	cpc	r1, r20
    d3ca:	55 1f       	adc	r21, r21
    d3cc:	f2 cf       	rjmp	.-28     	; 0xd3b2 <__fp_split3+0xe>
    d3ce:	46 95       	lsr	r20
    d3d0:	f1 df       	rcall	.-30     	; 0xd3b4 <__fp_splitA>
    d3d2:	08 c0       	rjmp	.+16     	; 0xd3e4 <__fp_splitA+0x30>
    d3d4:	16 16       	cp	r1, r22
    d3d6:	17 06       	cpc	r1, r23
    d3d8:	18 06       	cpc	r1, r24
    d3da:	99 1f       	adc	r25, r25
    d3dc:	f1 cf       	rjmp	.-30     	; 0xd3c0 <__fp_splitA+0xc>
    d3de:	86 95       	lsr	r24
    d3e0:	71 05       	cpc	r23, r1
    d3e2:	61 05       	cpc	r22, r1
    d3e4:	08 94       	sec
    d3e6:	08 95       	ret

0000d3e8 <__fp_zero>:
__fp_zero():
    d3e8:	e8 94       	clt

0000d3ea <__fp_szero>:
    d3ea:	bb 27       	eor	r27, r27
    d3ec:	66 27       	eor	r22, r22
    d3ee:	77 27       	eor	r23, r23
    d3f0:	cb 01       	movw	r24, r22
    d3f2:	97 f9       	bld	r25, 7
    d3f4:	08 95       	ret

0000d3f6 <eeprom_read_byte>:
eeprom_read_byte():
    d3f6:	f9 99       	sbic	0x1f, 1	; 31
    d3f8:	fe cf       	rjmp	.-4      	; 0xd3f6 <eeprom_read_byte>
    d3fa:	92 bd       	out	0x22, r25	; 34
    d3fc:	81 bd       	out	0x21, r24	; 33
    d3fe:	f8 9a       	sbi	0x1f, 0	; 31
    d400:	99 27       	eor	r25, r25
    d402:	80 b5       	in	r24, 0x20	; 32
    d404:	08 95       	ret

0000d406 <eeprom_write_byte>:
eeprom_write_byte():
    d406:	26 2f       	mov	r18, r22

0000d408 <eeprom_write_r18>:
    d408:	f9 99       	sbic	0x1f, 1	; 31
    d40a:	fe cf       	rjmp	.-4      	; 0xd408 <eeprom_write_r18>
    d40c:	1f ba       	out	0x1f, r1	; 31
    d40e:	92 bd       	out	0x22, r25	; 34
    d410:	81 bd       	out	0x21, r24	; 33
    d412:	20 bd       	out	0x20, r18	; 32
    d414:	0f b6       	in	r0, 0x3f	; 63
    d416:	f8 94       	cli
    d418:	fa 9a       	sbi	0x1f, 2	; 31
    d41a:	f9 9a       	sbi	0x1f, 1	; 31
    d41c:	0f be       	out	0x3f, r0	; 63
    d41e:	01 96       	adiw	r24, 0x01	; 1
    d420:	08 95       	ret

0000d422 <__divmodsi4>:
__divmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
    d422:	05 2e       	mov	r0, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
    d424:	97 fb       	bst	r25, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
    d426:	1e f4       	brtc	.+6      	; 0xd42e <__divmodsi4+0xc>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
    d428:	00 94       	com	r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
    d42a:	0e 94 28 6a 	call	0xd450	; 0xd450 <__negsi2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
    d42e:	57 fd       	sbrc	r21, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1693
    d430:	07 d0       	rcall	.+14     	; 0xd440 <__divmodsi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
    d432:	0e 94 43 6a 	call	0xd486	; 0xd486 <__udivmodsi4>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
    d436:	07 fc       	sbrc	r0, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1696
    d438:	03 d0       	rcall	.+6      	; 0xd440 <__divmodsi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
    d43a:	4e f4       	brtc	.+18     	; 0xd44e <__divmodsi4_exit>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
    d43c:	0c 94 28 6a 	jmp	0xd450	; 0xd450 <__negsi2>

0000d440 <__divmodsi4_neg2>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
    d440:	50 95       	com	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
    d442:	40 95       	com	r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
    d444:	30 95       	com	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
    d446:	21 95       	neg	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
    d448:	3f 4f       	sbci	r19, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
    d44a:	4f 4f       	sbci	r20, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
    d44c:	5f 4f       	sbci	r21, 0xFF	; 255

0000d44e <__divmodsi4_exit>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
    d44e:	08 95       	ret

0000d450 <__negsi2>:
__negsi2():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
    d450:	90 95       	com	r25
    d452:	80 95       	com	r24
    d454:	70 95       	com	r23
    d456:	61 95       	neg	r22
    d458:	7f 4f       	sbci	r23, 0xFF	; 255
    d45a:	8f 4f       	sbci	r24, 0xFF	; 255
    d45c:	9f 4f       	sbci	r25, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
    d45e:	08 95       	ret

0000d460 <__muluhisi3>:
__muluhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    d460:	0e 94 65 6a 	call	0xd4ca	; 0xd4ca <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    d464:	a5 9f       	mul	r26, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    d466:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    d468:	b4 9f       	mul	r27, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    d46a:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    d46c:	a4 9f       	mul	r26, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    d46e:	80 0d       	add	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    d470:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    d472:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    d474:	08 95       	ret

0000d476 <__mulshisi3>:
__mulshisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    d476:	b7 ff       	sbrs	r27, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    d478:	0c 94 30 6a 	jmp	0xd460	; 0xd460 <__muluhisi3>

0000d47c <__mulohisi3>:
__mulohisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    d47c:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    d480:	82 1b       	sub	r24, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    d482:	93 0b       	sbc	r25, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    d484:	08 95       	ret

0000d486 <__udivmodsi4>:
__udivmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    d486:	a1 e2       	ldi	r26, 0x21	; 33
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    d488:	1a 2e       	mov	r1, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    d48a:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    d48c:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    d48e:	fd 01       	movw	r30, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    d490:	0d c0       	rjmp	.+26     	; 0xd4ac <__udivmodsi4_ep>

0000d492 <__udivmodsi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    d492:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    d494:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    d496:	ee 1f       	adc	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    d498:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    d49a:	a2 17       	cp	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    d49c:	b3 07       	cpc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    d49e:	e4 07       	cpc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    d4a0:	f5 07       	cpc	r31, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    d4a2:	20 f0       	brcs	.+8      	; 0xd4ac <__udivmodsi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    d4a4:	a2 1b       	sub	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    d4a6:	b3 0b       	sbc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    d4a8:	e4 0b       	sbc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    d4aa:	f5 0b       	sbc	r31, r21

0000d4ac <__udivmodsi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    d4ac:	66 1f       	adc	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    d4ae:	77 1f       	adc	r23, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    d4b0:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    d4b2:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    d4b4:	1a 94       	dec	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    d4b6:	69 f7       	brne	.-38     	; 0xd492 <__udivmodsi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    d4b8:	60 95       	com	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    d4ba:	70 95       	com	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    d4bc:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    d4be:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    d4c0:	9b 01       	movw	r18, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    d4c2:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    d4c4:	bd 01       	movw	r22, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    d4c6:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    d4c8:	08 95       	ret

0000d4ca <__umulhisi3>:
__umulhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    d4ca:	a2 9f       	mul	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    d4cc:	b0 01       	movw	r22, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    d4ce:	b3 9f       	mul	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    d4d0:	c0 01       	movw	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    d4d2:	a3 9f       	mul	r26, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    d4d4:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    d4d6:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    d4d8:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    d4da:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    d4dc:	b2 9f       	mul	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    d4de:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    d4e0:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    d4e2:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    d4e4:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    d4e6:	08 95       	ret

0000d4e8 <__subsf3>:
__subsf3():
    d4e8:	50 58       	subi	r21, 0x80	; 128

0000d4ea <__addsf3>:
    d4ea:	bb 27       	eor	r27, r27
    d4ec:	aa 27       	eor	r26, r26
    d4ee:	0e 94 8c 6a 	call	0xd518	; 0xd518 <__addsf3x>
    d4f2:	0c 94 c1 69 	jmp	0xd382	; 0xd382 <__fp_round>
__addsf3():
    d4f6:	0e 94 b3 69 	call	0xd366	; 0xd366 <__fp_pscA>
    d4fa:	38 f0       	brcs	.+14     	; 0xd50a <__addsf3+0x20>
    d4fc:	0e 94 ba 69 	call	0xd374	; 0xd374 <__fp_pscB>
    d500:	20 f0       	brcs	.+8      	; 0xd50a <__addsf3+0x20>
    d502:	39 f4       	brne	.+14     	; 0xd512 <__addsf3+0x28>
    d504:	9f 3f       	cpi	r25, 0xFF	; 255
    d506:	19 f4       	brne	.+6      	; 0xd50e <__addsf3+0x24>
    d508:	26 f4       	brtc	.+8      	; 0xd512 <__addsf3+0x28>
    d50a:	0c 94 b0 69 	jmp	0xd360	; 0xd360 <__fp_nan>
    d50e:	0e f4       	brtc	.+2      	; 0xd512 <__addsf3+0x28>
    d510:	e0 95       	com	r30
    d512:	e7 fb       	bst	r30, 7
    d514:	0c 94 aa 69 	jmp	0xd354	; 0xd354 <__fp_inf>

0000d518 <__addsf3x>:
__addsf3x():
    d518:	e9 2f       	mov	r30, r25
    d51a:	0e 94 d2 69 	call	0xd3a4	; 0xd3a4 <__fp_split3>
    d51e:	58 f3       	brcs	.-42     	; 0xd4f6 <__addsf3+0xc>
    d520:	ba 17       	cp	r27, r26
    d522:	62 07       	cpc	r22, r18
    d524:	73 07       	cpc	r23, r19
    d526:	84 07       	cpc	r24, r20
    d528:	95 07       	cpc	r25, r21
    d52a:	20 f0       	brcs	.+8      	; 0xd534 <__addsf3x+0x1c>
    d52c:	79 f4       	brne	.+30     	; 0xd54c <__addsf3x+0x34>
    d52e:	a6 f5       	brtc	.+104    	; 0xd598 <__addsf3x+0x80>
    d530:	0c 94 f4 69 	jmp	0xd3e8	; 0xd3e8 <__fp_zero>
    d534:	0e f4       	brtc	.+2      	; 0xd538 <__addsf3x+0x20>
    d536:	e0 95       	com	r30
    d538:	0b 2e       	mov	r0, r27
    d53a:	ba 2f       	mov	r27, r26
    d53c:	a0 2d       	mov	r26, r0
    d53e:	0b 01       	movw	r0, r22
    d540:	b9 01       	movw	r22, r18
    d542:	90 01       	movw	r18, r0
    d544:	0c 01       	movw	r0, r24
    d546:	ca 01       	movw	r24, r20
    d548:	a0 01       	movw	r20, r0
    d54a:	11 24       	eor	r1, r1
    d54c:	ff 27       	eor	r31, r31
    d54e:	59 1b       	sub	r21, r25
    d550:	99 f0       	breq	.+38     	; 0xd578 <__addsf3x+0x60>
    d552:	59 3f       	cpi	r21, 0xF9	; 249
    d554:	50 f4       	brcc	.+20     	; 0xd56a <__addsf3x+0x52>
    d556:	50 3e       	cpi	r21, 0xE0	; 224
    d558:	68 f1       	brcs	.+90     	; 0xd5b4 <__addsf3x+0x9c>
    d55a:	1a 16       	cp	r1, r26
    d55c:	f0 40       	sbci	r31, 0x00	; 0
    d55e:	a2 2f       	mov	r26, r18
    d560:	23 2f       	mov	r18, r19
    d562:	34 2f       	mov	r19, r20
    d564:	44 27       	eor	r20, r20
    d566:	58 5f       	subi	r21, 0xF8	; 248
    d568:	f3 cf       	rjmp	.-26     	; 0xd550 <__addsf3x+0x38>
    d56a:	46 95       	lsr	r20
    d56c:	37 95       	ror	r19
    d56e:	27 95       	ror	r18
    d570:	a7 95       	ror	r26
    d572:	f0 40       	sbci	r31, 0x00	; 0
    d574:	53 95       	inc	r21
    d576:	c9 f7       	brne	.-14     	; 0xd56a <__addsf3x+0x52>
    d578:	7e f4       	brtc	.+30     	; 0xd598 <__addsf3x+0x80>
    d57a:	1f 16       	cp	r1, r31
    d57c:	ba 0b       	sbc	r27, r26
    d57e:	62 0b       	sbc	r22, r18
    d580:	73 0b       	sbc	r23, r19
    d582:	84 0b       	sbc	r24, r20
    d584:	ba f0       	brmi	.+46     	; 0xd5b4 <__addsf3x+0x9c>
    d586:	91 50       	subi	r25, 0x01	; 1
    d588:	a1 f0       	breq	.+40     	; 0xd5b2 <__addsf3x+0x9a>
    d58a:	ff 0f       	add	r31, r31
    d58c:	bb 1f       	adc	r27, r27
    d58e:	66 1f       	adc	r22, r22
    d590:	77 1f       	adc	r23, r23
    d592:	88 1f       	adc	r24, r24
    d594:	c2 f7       	brpl	.-16     	; 0xd586 <__addsf3x+0x6e>
    d596:	0e c0       	rjmp	.+28     	; 0xd5b4 <__addsf3x+0x9c>
    d598:	ba 0f       	add	r27, r26
    d59a:	62 1f       	adc	r22, r18
    d59c:	73 1f       	adc	r23, r19
    d59e:	84 1f       	adc	r24, r20
    d5a0:	48 f4       	brcc	.+18     	; 0xd5b4 <__addsf3x+0x9c>
    d5a2:	87 95       	ror	r24
    d5a4:	77 95       	ror	r23
    d5a6:	67 95       	ror	r22
    d5a8:	b7 95       	ror	r27
    d5aa:	f7 95       	ror	r31
    d5ac:	9e 3f       	cpi	r25, 0xFE	; 254
    d5ae:	08 f0       	brcs	.+2      	; 0xd5b2 <__addsf3x+0x9a>
    d5b0:	b0 cf       	rjmp	.-160    	; 0xd512 <__addsf3+0x28>
    d5b2:	93 95       	inc	r25
    d5b4:	88 0f       	add	r24, r24
    d5b6:	08 f0       	brcs	.+2      	; 0xd5ba <__addsf3x+0xa2>
    d5b8:	99 27       	eor	r25, r25
    d5ba:	ee 0f       	add	r30, r30
    d5bc:	97 95       	ror	r25
    d5be:	87 95       	ror	r24
    d5c0:	08 95       	ret

0000d5c2 <__divsf3>:
    d5c2:	0e 94 f5 6a 	call	0xd5ea	; 0xd5ea <__divsf3x>
    d5c6:	0c 94 c1 69 	jmp	0xd382	; 0xd382 <__fp_round>
    d5ca:	0e 94 ba 69 	call	0xd374	; 0xd374 <__fp_pscB>
    d5ce:	58 f0       	brcs	.+22     	; 0xd5e6 <__divsf3+0x24>
    d5d0:	0e 94 b3 69 	call	0xd366	; 0xd366 <__fp_pscA>
    d5d4:	40 f0       	brcs	.+16     	; 0xd5e6 <__divsf3+0x24>
    d5d6:	29 f4       	brne	.+10     	; 0xd5e2 <__divsf3+0x20>
    d5d8:	5f 3f       	cpi	r21, 0xFF	; 255
    d5da:	29 f0       	breq	.+10     	; 0xd5e6 <__divsf3+0x24>
    d5dc:	0c 94 aa 69 	jmp	0xd354	; 0xd354 <__fp_inf>
    d5e0:	51 11       	cpse	r21, r1
    d5e2:	0c 94 f5 69 	jmp	0xd3ea	; 0xd3ea <__fp_szero>
__divsf3():
    d5e6:	0c 94 b0 69 	jmp	0xd360	; 0xd360 <__fp_nan>

0000d5ea <__divsf3x>:
__divsf3x():
    d5ea:	0e 94 d2 69 	call	0xd3a4	; 0xd3a4 <__fp_split3>
    d5ee:	68 f3       	brcs	.-38     	; 0xd5ca <__divsf3+0x8>

0000d5f0 <__divsf3_pse>:
    d5f0:	99 23       	and	r25, r25
    d5f2:	b1 f3       	breq	.-20     	; 0xd5e0 <__divsf3+0x1e>
    d5f4:	55 23       	and	r21, r21
    d5f6:	91 f3       	breq	.-28     	; 0xd5dc <__divsf3+0x1a>
    d5f8:	95 1b       	sub	r25, r21
    d5fa:	55 0b       	sbc	r21, r21
    d5fc:	bb 27       	eor	r27, r27
    d5fe:	aa 27       	eor	r26, r26
    d600:	62 17       	cp	r22, r18
    d602:	73 07       	cpc	r23, r19
    d604:	84 07       	cpc	r24, r20
    d606:	38 f0       	brcs	.+14     	; 0xd616 <__divsf3_pse+0x26>
    d608:	9f 5f       	subi	r25, 0xFF	; 255
    d60a:	5f 4f       	sbci	r21, 0xFF	; 255
    d60c:	22 0f       	add	r18, r18
    d60e:	33 1f       	adc	r19, r19
    d610:	44 1f       	adc	r20, r20
    d612:	aa 1f       	adc	r26, r26
    d614:	a9 f3       	breq	.-22     	; 0xd600 <__divsf3_pse+0x10>
    d616:	35 d0       	rcall	.+106    	; 0xd682 <__divsf3_pse+0x92>
    d618:	0e 2e       	mov	r0, r30
    d61a:	3a f0       	brmi	.+14     	; 0xd62a <__divsf3_pse+0x3a>
    d61c:	e0 e8       	ldi	r30, 0x80	; 128
    d61e:	32 d0       	rcall	.+100    	; 0xd684 <__divsf3_pse+0x94>
    d620:	91 50       	subi	r25, 0x01	; 1
    d622:	50 40       	sbci	r21, 0x00	; 0
    d624:	e6 95       	lsr	r30
    d626:	00 1c       	adc	r0, r0
    d628:	ca f7       	brpl	.-14     	; 0xd61c <__divsf3_pse+0x2c>
    d62a:	2b d0       	rcall	.+86     	; 0xd682 <__divsf3_pse+0x92>
    d62c:	fe 2f       	mov	r31, r30
    d62e:	29 d0       	rcall	.+82     	; 0xd682 <__divsf3_pse+0x92>
    d630:	66 0f       	add	r22, r22
    d632:	77 1f       	adc	r23, r23
    d634:	88 1f       	adc	r24, r24
    d636:	bb 1f       	adc	r27, r27
    d638:	26 17       	cp	r18, r22
    d63a:	37 07       	cpc	r19, r23
    d63c:	48 07       	cpc	r20, r24
    d63e:	ab 07       	cpc	r26, r27
    d640:	b0 e8       	ldi	r27, 0x80	; 128
    d642:	09 f0       	breq	.+2      	; 0xd646 <__divsf3_pse+0x56>
    d644:	bb 0b       	sbc	r27, r27
    d646:	80 2d       	mov	r24, r0
    d648:	bf 01       	movw	r22, r30
    d64a:	ff 27       	eor	r31, r31
    d64c:	93 58       	subi	r25, 0x83	; 131
    d64e:	5f 4f       	sbci	r21, 0xFF	; 255
    d650:	3a f0       	brmi	.+14     	; 0xd660 <__divsf3_pse+0x70>
    d652:	9e 3f       	cpi	r25, 0xFE	; 254
    d654:	51 05       	cpc	r21, r1
    d656:	78 f0       	brcs	.+30     	; 0xd676 <__divsf3_pse+0x86>
    d658:	0c 94 aa 69 	jmp	0xd354	; 0xd354 <__fp_inf>
    d65c:	0c 94 f5 69 	jmp	0xd3ea	; 0xd3ea <__fp_szero>
    d660:	5f 3f       	cpi	r21, 0xFF	; 255
    d662:	e4 f3       	brlt	.-8      	; 0xd65c <__divsf3_pse+0x6c>
    d664:	98 3e       	cpi	r25, 0xE8	; 232
    d666:	d4 f3       	brlt	.-12     	; 0xd65c <__divsf3_pse+0x6c>
    d668:	86 95       	lsr	r24
    d66a:	77 95       	ror	r23
    d66c:	67 95       	ror	r22
    d66e:	b7 95       	ror	r27
    d670:	f7 95       	ror	r31
    d672:	9f 5f       	subi	r25, 0xFF	; 255
    d674:	c9 f7       	brne	.-14     	; 0xd668 <__divsf3_pse+0x78>
    d676:	88 0f       	add	r24, r24
    d678:	91 1d       	adc	r25, r1
    d67a:	96 95       	lsr	r25
    d67c:	87 95       	ror	r24
    d67e:	97 f9       	bld	r25, 7
    d680:	08 95       	ret
    d682:	e1 e0       	ldi	r30, 0x01	; 1
    d684:	66 0f       	add	r22, r22
    d686:	77 1f       	adc	r23, r23
    d688:	88 1f       	adc	r24, r24
    d68a:	bb 1f       	adc	r27, r27
    d68c:	62 17       	cp	r22, r18
    d68e:	73 07       	cpc	r23, r19
    d690:	84 07       	cpc	r24, r20
    d692:	ba 07       	cpc	r27, r26
    d694:	20 f0       	brcs	.+8      	; 0xd69e <__divsf3_pse+0xae>
    d696:	62 1b       	sub	r22, r18
    d698:	73 0b       	sbc	r23, r19
    d69a:	84 0b       	sbc	r24, r20
    d69c:	ba 0b       	sbc	r27, r26
    d69e:	ee 1f       	adc	r30, r30
    d6a0:	88 f7       	brcc	.-30     	; 0xd684 <__divsf3_pse+0x94>
    d6a2:	e0 95       	com	r30
    d6a4:	08 95       	ret

0000d6a6 <__fixsfsi>:
    d6a6:	0e 94 5a 6b 	call	0xd6b4	; 0xd6b4 <__fixunssfsi>
    d6aa:	68 94       	set
    d6ac:	b1 11       	cpse	r27, r1
    d6ae:	0c 94 f5 69 	jmp	0xd3ea	; 0xd3ea <__fp_szero>
    d6b2:	08 95       	ret

0000d6b4 <__fixunssfsi>:
    d6b4:	0e 94 da 69 	call	0xd3b4	; 0xd3b4 <__fp_splitA>
    d6b8:	88 f0       	brcs	.+34     	; 0xd6dc <__fixunssfsi+0x28>
    d6ba:	9f 57       	subi	r25, 0x7F	; 127
    d6bc:	98 f0       	brcs	.+38     	; 0xd6e4 <__fixunssfsi+0x30>
    d6be:	b9 2f       	mov	r27, r25
    d6c0:	99 27       	eor	r25, r25
    d6c2:	b7 51       	subi	r27, 0x17	; 23
    d6c4:	b0 f0       	brcs	.+44     	; 0xd6f2 <__fixunssfsi+0x3e>
__fixunssfsi():
    d6c6:	e1 f0       	breq	.+56     	; 0xd700 <__fixunssfsi+0x4c>
    d6c8:	66 0f       	add	r22, r22
    d6ca:	77 1f       	adc	r23, r23
    d6cc:	88 1f       	adc	r24, r24
    d6ce:	99 1f       	adc	r25, r25
    d6d0:	1a f0       	brmi	.+6      	; 0xd6d8 <__fixunssfsi+0x24>
    d6d2:	ba 95       	dec	r27
    d6d4:	c9 f7       	brne	.-14     	; 0xd6c8 <__fixunssfsi+0x14>
    d6d6:	14 c0       	rjmp	.+40     	; 0xd700 <__fixunssfsi+0x4c>
    d6d8:	b1 30       	cpi	r27, 0x01	; 1
    d6da:	91 f0       	breq	.+36     	; 0xd700 <__fixunssfsi+0x4c>
    d6dc:	0e 94 f4 69 	call	0xd3e8	; 0xd3e8 <__fp_zero>
    d6e0:	b1 e0       	ldi	r27, 0x01	; 1
    d6e2:	08 95       	ret
    d6e4:	0c 94 f4 69 	jmp	0xd3e8	; 0xd3e8 <__fp_zero>
    d6e8:	67 2f       	mov	r22, r23
    d6ea:	78 2f       	mov	r23, r24
    d6ec:	88 27       	eor	r24, r24
    d6ee:	b8 5f       	subi	r27, 0xF8	; 248
    d6f0:	39 f0       	breq	.+14     	; 0xd700 <__fixunssfsi+0x4c>
    d6f2:	b9 3f       	cpi	r27, 0xF9	; 249
    d6f4:	cc f3       	brlt	.-14     	; 0xd6e8 <__fixunssfsi+0x34>
    d6f6:	86 95       	lsr	r24
    d6f8:	77 95       	ror	r23
    d6fa:	67 95       	ror	r22
    d6fc:	b3 95       	inc	r27
    d6fe:	d9 f7       	brne	.-10     	; 0xd6f6 <__fixunssfsi+0x42>
    d700:	3e f4       	brtc	.+14     	; 0xd710 <__fixunssfsi+0x5c>
    d702:	90 95       	com	r25
    d704:	80 95       	com	r24
    d706:	70 95       	com	r23
    d708:	61 95       	neg	r22
    d70a:	7f 4f       	sbci	r23, 0xFF	; 255
    d70c:	8f 4f       	sbci	r24, 0xFF	; 255
    d70e:	9f 4f       	sbci	r25, 0xFF	; 255
    d710:	08 95       	ret

0000d712 <__floatdisf>:
__floatdisf():
    d712:	97 fb       	bst	r25, 7
    d714:	16 f4       	brtc	.+4      	; 0xd71a <__floatdisf+0x8>
    d716:	0e 94 cd 6b 	call	0xd79a	; 0xd79a <__fp_negdi>
    d71a:	0c 94 90 6b 	jmp	0xd720	; 0xd720 <__fp_di2sf>

0000d71e <__floatundisf>:
__floatundisf():
    d71e:	e8 94       	clt

0000d720 <__fp_di2sf>:
    d720:	f9 2f       	mov	r31, r25
    d722:	96 eb       	ldi	r25, 0xB6	; 182
    d724:	ff 23       	and	r31, r31
    d726:	81 f0       	breq	.+32     	; 0xd748 <__fp_di2sf+0x28>
    d728:	12 16       	cp	r1, r18
    d72a:	13 06       	cpc	r1, r19
    d72c:	14 06       	cpc	r1, r20
    d72e:	44 0b       	sbc	r20, r20
    d730:	93 95       	inc	r25
    d732:	f6 95       	lsr	r31
    d734:	87 95       	ror	r24
    d736:	77 95       	ror	r23
    d738:	67 95       	ror	r22
    d73a:	57 95       	ror	r21
    d73c:	40 40       	sbci	r20, 0x00	; 0
    d73e:	ff 23       	and	r31, r31
    d740:	b9 f7       	brne	.-18     	; 0xd730 <__fp_di2sf+0x10>
    d742:	1b c0       	rjmp	.+54     	; 0xd77a <__fp_di2sf+0x5a>
    d744:	99 27       	eor	r25, r25
    d746:	08 95       	ret
    d748:	88 23       	and	r24, r24
    d74a:	51 f4       	brne	.+20     	; 0xd760 <__fp_di2sf+0x40>
    d74c:	98 50       	subi	r25, 0x08	; 8
    d74e:	d2 f7       	brpl	.-12     	; 0xd744 <__fp_di2sf+0x24>
    d750:	87 2b       	or	r24, r23
    d752:	76 2f       	mov	r23, r22
    d754:	65 2f       	mov	r22, r21
    d756:	54 2f       	mov	r21, r20
    d758:	43 2f       	mov	r20, r19
    d75a:	32 2f       	mov	r19, r18
    d75c:	20 e0       	ldi	r18, 0x00	; 0
    d75e:	b1 f3       	breq	.-20     	; 0xd74c <__fp_di2sf+0x2c>
    d760:	12 16       	cp	r1, r18
    d762:	13 06       	cpc	r1, r19
    d764:	14 06       	cpc	r1, r20
    d766:	44 0b       	sbc	r20, r20
    d768:	88 23       	and	r24, r24
    d76a:	3a f0       	brmi	.+14     	; 0xd77a <__fp_di2sf+0x5a>
    d76c:	9a 95       	dec	r25
    d76e:	44 0f       	add	r20, r20
    d770:	55 1f       	adc	r21, r21
    d772:	66 1f       	adc	r22, r22
    d774:	77 1f       	adc	r23, r23
    d776:	88 1f       	adc	r24, r24
    d778:	ca f7       	brpl	.-14     	; 0xd76c <__fp_di2sf+0x4c>
    d77a:	55 23       	and	r21, r21
    d77c:	4a f4       	brpl	.+18     	; 0xd790 <__fp_di2sf+0x70>
    d77e:	44 0f       	add	r20, r20
    d780:	55 1f       	adc	r21, r21
    d782:	11 f4       	brne	.+4      	; 0xd788 <__fp_di2sf+0x68>
    d784:	60 ff       	sbrs	r22, 0
    d786:	04 c0       	rjmp	.+8      	; 0xd790 <__fp_di2sf+0x70>
    d788:	6f 5f       	subi	r22, 0xFF	; 255
    d78a:	7f 4f       	sbci	r23, 0xFF	; 255
    d78c:	8f 4f       	sbci	r24, 0xFF	; 255
    d78e:	9f 4f       	sbci	r25, 0xFF	; 255
    d790:	88 0f       	add	r24, r24
    d792:	96 95       	lsr	r25
    d794:	87 95       	ror	r24
    d796:	97 f9       	bld	r25, 7
    d798:	08 95       	ret

0000d79a <__fp_negdi>:
__fp_negdi():
    d79a:	90 95       	com	r25
    d79c:	80 95       	com	r24
    d79e:	70 95       	com	r23
    d7a0:	60 95       	com	r22
    d7a2:	50 95       	com	r21
    d7a4:	40 95       	com	r20
    d7a6:	30 95       	com	r19
    d7a8:	21 95       	neg	r18
    d7aa:	3f 4f       	sbci	r19, 0xFF	; 255
    d7ac:	4f 4f       	sbci	r20, 0xFF	; 255
    d7ae:	5f 4f       	sbci	r21, 0xFF	; 255
    d7b0:	6f 4f       	sbci	r22, 0xFF	; 255
    d7b2:	7f 4f       	sbci	r23, 0xFF	; 255
    d7b4:	8f 4f       	sbci	r24, 0xFF	; 255
    d7b6:	9f 4f       	sbci	r25, 0xFF	; 255
    d7b8:	08 95       	ret

0000d7ba <__gesf2>:
__gesf2():
    d7ba:	0e 94 16 69 	call	0xd22c	; 0xd22c <__fp_cmp>
    d7be:	08 f4       	brcc	.+2      	; 0xd7c2 <__gesf2+0x8>
    d7c0:	8f ef       	ldi	r24, 0xFF	; 255
    d7c2:	08 95       	ret

0000d7c4 <__unordsf2>:
__unordsf2():
    d7c4:	0e 94 16 69 	call	0xd22c	; 0xd22c <__fp_cmp>
    d7c8:	88 0b       	sbc	r24, r24
    d7ca:	99 0b       	sbc	r25, r25
    d7cc:	08 95       	ret

0000d7ce <__mulsi3>:
__mulsi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:648
    d7ce:	db 01       	movw	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:649
    d7d0:	8f 93       	push	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:650
    d7d2:	9f 93       	push	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:651
    d7d4:	0e 94 30 6a 	call	0xd460	; 0xd460 <__muluhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:652
    d7d8:	bf 91       	pop	r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:653
    d7da:	af 91       	pop	r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:655
    d7dc:	a2 9f       	mul	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:656
    d7de:	80 0d       	add	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:657
    d7e0:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:658
    d7e2:	a3 9f       	mul	r26, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:659
    d7e4:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:660
    d7e6:	b2 9f       	mul	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:661
    d7e8:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:662
    d7ea:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:663
    d7ec:	08 95       	ret

0000d7ee <__udivmodqi4>:
__udivmodqi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1346
    d7ee:	99 1b       	sub	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1347
    d7f0:	79 e0       	ldi	r23, 0x09	; 9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1348
    d7f2:	04 c0       	rjmp	.+8      	; 0xd7fc <__udivmodqi4_ep>

0000d7f4 <__udivmodqi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1350
    d7f4:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1351
    d7f6:	96 17       	cp	r25, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1352
    d7f8:	08 f0       	brcs	.+2      	; 0xd7fc <__udivmodqi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1353
    d7fa:	96 1b       	sub	r25, r22

0000d7fc <__udivmodqi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1355
    d7fc:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1356
    d7fe:	7a 95       	dec	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1357
    d800:	c9 f7       	brne	.-14     	; 0xd7f4 <__udivmodqi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1358
    d802:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1360
    d804:	08 95       	ret

0000d806 <__udivmodhi4>:
__udivmodhi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1408
    d806:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1409
    d808:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1410
    d80a:	51 e1       	ldi	r21, 0x11	; 17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1411
    d80c:	07 c0       	rjmp	.+14     	; 0xd81c <__udivmodhi4_ep>

0000d80e <__udivmodhi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1413
    d80e:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1414
    d810:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1415
    d812:	a6 17       	cp	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1416
    d814:	b7 07       	cpc	r27, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1417
    d816:	10 f0       	brcs	.+4      	; 0xd81c <__udivmodhi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1418
    d818:	a6 1b       	sub	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1419
    d81a:	b7 0b       	sbc	r27, r23

0000d81c <__udivmodhi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1421
    d81c:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1422
    d81e:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1423
    d820:	5a 95       	dec	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1424
    d822:	a9 f7       	brne	.-22     	; 0xd80e <__udivmodhi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1425
    d824:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1426
    d826:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1428
    d828:	bc 01       	movw	r22, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1430
    d82a:	cd 01       	movw	r24, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1432
    d82c:	08 95       	ret

0000d82e <__divmodhi4>:
__divmodhi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1440
    d82e:	97 fb       	bst	r25, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1441
    d830:	07 2e       	mov	r0, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1442
    d832:	16 f4       	brtc	.+4      	; 0xd838 <__divmodhi4+0xa>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1443
    d834:	00 94       	com	r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1444
    d836:	07 d0       	rcall	.+14     	; 0xd846 <__divmodhi4_neg1>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1446
    d838:	77 fd       	sbrc	r23, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1447
    d83a:	09 d0       	rcall	.+18     	; 0xd84e <__divmodhi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1448
    d83c:	0e 94 03 6c 	call	0xd806	; 0xd806 <__udivmodhi4>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1449
    d840:	07 fc       	sbrc	r0, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1450
    d842:	05 d0       	rcall	.+10     	; 0xd84e <__divmodhi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1451
    d844:	3e f4       	brtc	.+14     	; 0xd854 <__divmodhi4_exit>

0000d846 <__divmodhi4_neg1>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1454
    d846:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1455
    d848:	81 95       	neg	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1456
    d84a:	9f 4f       	sbci	r25, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1457
    d84c:	08 95       	ret

0000d84e <__divmodhi4_neg2>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1460
    d84e:	70 95       	com	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1461
    d850:	61 95       	neg	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1462
    d852:	7f 4f       	sbci	r23, 0xFF	; 255

0000d854 <__divmodhi4_exit>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1464
    d854:	08 95       	ret

0000d856 <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    d856:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    d858:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2300
    d85a:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2301
    d85c:	8b bf       	out	0x3b, r24	; 59
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2312
    d85e:	07 90       	elpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2313
    d860:	f6 91       	elpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2314
    d862:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2319
    d864:	19 94       	eijmp

0000d866 <__muldi3>:
__muldi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:894
    d866:	df 93       	push	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:895
    d868:	cf 93       	push	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:896
    d86a:	1f 93       	push	r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:897
    d86c:	0f 93       	push	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:902
    d86e:	9a 9d       	mul	r25, r10
    d870:	f0 2d       	mov	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:903
    d872:	21 9f       	mul	r18, r17
    d874:	f0 0d       	add	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:904
    d876:	8b 9d       	mul	r24, r11
    d878:	f0 0d       	add	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:905
    d87a:	8a 9d       	mul	r24, r10
    d87c:	e0 2d       	mov	r30, r0
    d87e:	f1 0d       	add	r31, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:906
    d880:	03 9f       	mul	r16, r19
    d882:	f0 0d       	add	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:907
    d884:	02 9f       	mul	r16, r18
    d886:	e0 0d       	add	r30, r0
    d888:	f1 1d       	adc	r31, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:910
    d88a:	4e 9d       	mul	r20, r14
    d88c:	e0 0d       	add	r30, r0
    d88e:	f1 1d       	adc	r31, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:911
    d890:	5e 9d       	mul	r21, r14
    d892:	f0 0d       	add	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:912
    d894:	4f 9d       	mul	r20, r15
    d896:	f0 0d       	add	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:914
    d898:	7f 93       	push	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:915
    d89a:	6f 93       	push	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:916
    d89c:	bf 92       	push	r11
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:917
    d89e:	af 92       	push	r10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:918
    d8a0:	5f 93       	push	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:919
    d8a2:	4f 93       	push	r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:922
    d8a4:	d5 01       	movw	r26, r10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:923
    d8a6:	0e 94 65 6a 	call	0xd4ca	; 0xd4ca <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:924
    d8aa:	8b 01       	movw	r16, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:925
    d8ac:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:928
    d8ae:	d7 01       	movw	r26, r14
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:929
    d8b0:	0e 94 65 6a 	call	0xd4ca	; 0xd4ca <__umulhisi3>
    d8b4:	eb 01       	movw	r28, r22
    d8b6:	e8 0f       	add	r30, r24
    d8b8:	f9 1f       	adc	r31, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:931
    d8ba:	d6 01       	movw	r26, r12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:933
    d8bc:	0e 94 82 6c 	call	0xd904	; 0xd904 <__muldi3_6>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:935
    d8c0:	2f 91       	pop	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:936
    d8c2:	3f 91       	pop	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:938
    d8c4:	d6 01       	movw	r26, r12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:939
    d8c6:	0e 94 65 6a 	call	0xd4ca	; 0xd4ca <__umulhisi3>
    d8ca:	c6 0f       	add	r28, r22
    d8cc:	d7 1f       	adc	r29, r23
    d8ce:	e8 1f       	adc	r30, r24
    d8d0:	f9 1f       	adc	r31, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:941
    d8d2:	af 91       	pop	r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:942
    d8d4:	bf 91       	pop	r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:944
    d8d6:	0e 94 82 6c 	call	0xd904	; 0xd904 <__muldi3_6>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:946
    d8da:	2f 91       	pop	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:947
    d8dc:	3f 91       	pop	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:949
    d8de:	0e 94 65 6a 	call	0xd4ca	; 0xd4ca <__umulhisi3>
    d8e2:	c6 0f       	add	r28, r22
    d8e4:	d7 1f       	adc	r29, r23
    d8e6:	e8 1f       	adc	r30, r24
    d8e8:	f9 1f       	adc	r31, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:952
    d8ea:	d6 01       	movw	r26, r12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:953
    d8ec:	0e 94 65 6a 	call	0xd4ca	; 0xd4ca <__umulhisi3>
    d8f0:	e6 0f       	add	r30, r22
    d8f2:	f7 1f       	adc	r31, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:956
    d8f4:	98 01       	movw	r18, r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:958
    d8f6:	be 01       	movw	r22, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:959
    d8f8:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:961
    d8fa:	0f 91       	pop	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:962
    d8fc:	1f 91       	pop	r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:963
    d8fe:	cf 91       	pop	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:964
    d900:	df 91       	pop	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:965
    d902:	08 95       	ret

0000d904 <__muldi3_6>:
__muldi3_6():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:973
    d904:	0e 94 65 6a 	call	0xd4ca	; 0xd4ca <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:974
    d908:	46 0f       	add	r20, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:975
    d90a:	57 1f       	adc	r21, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:976
    d90c:	c8 1f       	adc	r28, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:977
    d90e:	d9 1f       	adc	r29, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:978
    d910:	08 f4       	brcc	.+2      	; 0xd914 <__muldi3_6+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:979
    d912:	31 96       	adiw	r30, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:980
    d914:	08 95       	ret

0000d916 <__moddi3>:
__moddi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1964
    d916:	68 94       	set
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1965
    d918:	01 c0       	rjmp	.+2      	; 0xd91c <__divdi3_moddi3>

0000d91a <__divdi3>:
__divdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1972
    d91a:	e8 94       	clt

0000d91c <__divdi3_moddi3>:
__divdi3_moddi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1977
    d91c:	f9 2f       	mov	r31, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1978
    d91e:	f1 2b       	or	r31, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1979
    d920:	12 f0       	brmi	.+4      	; 0xd926 <__divdi3_moddi3+0xa>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1981
    d922:	0c 94 bf 6c 	jmp	0xd97e	; 0xd97e <__udivdi3_umoddi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1987
    d926:	a0 e0       	ldi	r26, 0x00	; 0
    d928:	b0 e0       	ldi	r27, 0x00	; 0
    d92a:	e9 e9       	ldi	r30, 0x99	; 153
    d92c:	fc e6       	ldi	r31, 0x6C	; 108
    d92e:	0c 94 31 6d 	jmp	0xda62	; 0xda62 <__prologue_saves__+0xc>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1991
    d932:	09 2e       	mov	r0, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1992
    d934:	05 94       	asr	r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1997
    d936:	22 f4       	brpl	.+8      	; 0xd940 <__divdi3_moddi3+0x24>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2002
    d938:	0e 94 1b 6d 	call	0xda36	; 0xda36 <__negdi2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2005
    d93c:	11 23       	and	r17, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2006
    d93e:	92 f4       	brpl	.+36     	; 0xd964 <__divdi3_moddi3+0x48>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2007
    d940:	f0 e8       	ldi	r31, 0x80	; 128
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2008
    d942:	0f 26       	eor	r0, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2010
    d944:	ff ef       	ldi	r31, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2011
    d946:	e0 94       	com	r14
    d948:	f0 94       	com	r15
    d94a:	00 95       	com	r16
    d94c:	10 95       	com	r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2012
    d94e:	b0 94       	com	r11
    d950:	c0 94       	com	r12
    d952:	d0 94       	com	r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2013
    d954:	a1 94       	neg	r10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2014
    d956:	bf 0a       	sbc	r11, r31
    d958:	cf 0a       	sbc	r12, r31
    d95a:	df 0a       	sbc	r13, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2015
    d95c:	ef 0a       	sbc	r14, r31
    d95e:	ff 0a       	sbc	r15, r31
    d960:	0f 0b       	sbc	r16, r31
    d962:	1f 0b       	sbc	r17, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2018
    d964:	0e 94 ca 6c 	call	0xd994	; 0xd994 <__udivmod64>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2025
    d968:	07 fc       	sbrc	r0, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2027
    d96a:	0e 94 1b 6d 	call	0xda36	; 0xda36 <__negdi2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2030
    d96e:	cd b7       	in	r28, 0x3d	; 61
    d970:	de b7       	in	r29, 0x3e	; 62
    d972:	ec e0       	ldi	r30, 0x0C	; 12
    d974:	0c 94 4d 6d 	jmp	0xda9a	; 0xda9a <__epilogue_restores__+0xc>

0000d978 <__umoddi3>:
__umoddi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1806
    d978:	68 94       	set
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1807
    d97a:	01 c0       	rjmp	.+2      	; 0xd97e <__udivdi3_umoddi3>

0000d97c <__udivdi3>:
__udivdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1814
    d97c:	e8 94       	clt

0000d97e <__udivdi3_umoddi3>:
__udivdi3_umoddi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1818
    d97e:	8f 92       	push	r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1819
    d980:	9f 92       	push	r9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1820
    d982:	cf 93       	push	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1821
    d984:	df 93       	push	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1822
    d986:	0e 94 ca 6c 	call	0xd994	; 0xd994 <__udivmod64>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1823
    d98a:	df 91       	pop	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1824
    d98c:	cf 91       	pop	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1825
    d98e:	9f 90       	pop	r9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1826
    d990:	8f 90       	pop	r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1827
    d992:	08 95       	ret

0000d994 <__udivmod64>:
__udivmod64():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1842
    d994:	88 24       	eor	r8, r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1843
    d996:	99 24       	eor	r9, r9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1844
    d998:	f4 01       	movw	r30, r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1845
    d99a:	e4 01       	movw	r28, r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1846
    d99c:	b0 e4       	ldi	r27, 0x40	; 64
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1856
    d99e:	9f 93       	push	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1857
    d9a0:	aa 27       	eor	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1861
    d9a2:	9a 15       	cp	r25, r10
    d9a4:	8b 04       	cpc	r8, r11
    d9a6:	9c 04       	cpc	r9, r12
    d9a8:	ed 05       	cpc	r30, r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1862
    d9aa:	fe 05       	cpc	r31, r14
    d9ac:	cf 05       	cpc	r28, r15
    d9ae:	d0 07       	cpc	r29, r16
    d9b0:	a1 07       	cpc	r26, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1863
    d9b2:	98 f4       	brcc	.+38     	; 0xd9da <__udivmod64+0x46>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1866
    d9b4:	ad 2f       	mov	r26, r29
    d9b6:	dc 2f       	mov	r29, r28
    d9b8:	cf 2f       	mov	r28, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1867
    d9ba:	fe 2f       	mov	r31, r30
    d9bc:	e9 2d       	mov	r30, r9
    d9be:	98 2c       	mov	r9, r8
    d9c0:	89 2e       	mov	r8, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1868
    d9c2:	98 2f       	mov	r25, r24
    d9c4:	87 2f       	mov	r24, r23
    d9c6:	76 2f       	mov	r23, r22
    d9c8:	65 2f       	mov	r22, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1869
    d9ca:	54 2f       	mov	r21, r20
    d9cc:	43 2f       	mov	r20, r19
    d9ce:	32 2f       	mov	r19, r18
    d9d0:	22 27       	eor	r18, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1872
    d9d2:	b8 50       	subi	r27, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1873
    d9d4:	31 f7       	brne	.-52     	; 0xd9a2 <__udivmod64+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1876
    d9d6:	bf 91       	pop	r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1881
    d9d8:	27 c0       	rjmp	.+78     	; 0xda28 <__udivmod64+0x94>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1884
    d9da:	1b 2e       	mov	r1, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1887
    d9dc:	bf 91       	pop	r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1888
    d9de:	bb 27       	eor	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1916
    d9e0:	22 0f       	add	r18, r18
    d9e2:	33 1f       	adc	r19, r19
    d9e4:	44 1f       	adc	r20, r20
    d9e6:	55 1f       	adc	r21, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1917
    d9e8:	66 1f       	adc	r22, r22
    d9ea:	77 1f       	adc	r23, r23
    d9ec:	88 1f       	adc	r24, r24
    d9ee:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1920
    d9f0:	88 1c       	adc	r8, r8
    d9f2:	99 1c       	adc	r9, r9
    d9f4:	ee 1f       	adc	r30, r30
    d9f6:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1921
    d9f8:	cc 1f       	adc	r28, r28
    d9fa:	dd 1f       	adc	r29, r29
    d9fc:	aa 1f       	adc	r26, r26
    d9fe:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1924
    da00:	8a 14       	cp	r8, r10
    da02:	9b 04       	cpc	r9, r11
    da04:	ec 05       	cpc	r30, r12
    da06:	fd 05       	cpc	r31, r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1925
    da08:	ce 05       	cpc	r28, r14
    da0a:	df 05       	cpc	r29, r15
    da0c:	a0 07       	cpc	r26, r16
    da0e:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1927
    da10:	48 f0       	brcs	.+18     	; 0xda24 <__udivmod64+0x90>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1930
    da12:	8a 18       	sub	r8, r10
    da14:	9b 08       	sbc	r9, r11
    da16:	ec 09       	sbc	r30, r12
    da18:	fd 09       	sbc	r31, r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1931
    da1a:	ce 09       	sbc	r28, r14
    da1c:	df 09       	sbc	r29, r15
    da1e:	a0 0b       	sbc	r26, r16
    da20:	b1 0b       	sbc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1935
    da22:	21 60       	ori	r18, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1938
    da24:	1a 94       	dec	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1939
    da26:	e1 f6       	brne	.-72     	; 0xd9e0 <__udivmod64+0x4c>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1944
    da28:	2e f4       	brtc	.+10     	; 0xda34 <__udivmod64+0xa0>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1945
    da2a:	94 01       	movw	r18, r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1946
    da2c:	af 01       	movw	r20, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1947
    da2e:	be 01       	movw	r22, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1948
    da30:	cd 01       	movw	r24, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1950
    da32:	00 0c       	add	r0, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1952
    da34:	08 95       	ret

0000da36 <__negdi2>:
__negdi2():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2117
    da36:	60 95       	com	r22
    da38:	70 95       	com	r23
    da3a:	80 95       	com	r24
    da3c:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2118
    da3e:	30 95       	com	r19
    da40:	40 95       	com	r20
    da42:	50 95       	com	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2119
    da44:	21 95       	neg	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2120
    da46:	3f 4f       	sbci	r19, 0xFF	; 255
    da48:	4f 4f       	sbci	r20, 0xFF	; 255
    da4a:	5f 4f       	sbci	r21, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2121
    da4c:	6f 4f       	sbci	r22, 0xFF	; 255
    da4e:	7f 4f       	sbci	r23, 0xFF	; 255
    da50:	8f 4f       	sbci	r24, 0xFF	; 255
    da52:	9f 4f       	sbci	r25, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2122
    da54:	08 95       	ret

0000da56 <__prologue_saves__>:
__prologue_saves__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2169
    da56:	2f 92       	push	r2
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2170
    da58:	3f 92       	push	r3
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2171
    da5a:	4f 92       	push	r4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2172
    da5c:	5f 92       	push	r5
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2173
    da5e:	6f 92       	push	r6
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2174
    da60:	7f 92       	push	r7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2175
    da62:	8f 92       	push	r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2176
    da64:	9f 92       	push	r9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2177
    da66:	af 92       	push	r10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2178
    da68:	bf 92       	push	r11
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2179
    da6a:	cf 92       	push	r12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2180
    da6c:	df 92       	push	r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2181
    da6e:	ef 92       	push	r14
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2182
    da70:	ff 92       	push	r15
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2183
    da72:	0f 93       	push	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2184
    da74:	1f 93       	push	r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2185
    da76:	cf 93       	push	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2186
    da78:	df 93       	push	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2200
    da7a:	cd b7       	in	r28, 0x3d	; 61
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2201
    da7c:	de b7       	in	r29, 0x3e	; 62
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2202
    da7e:	ca 1b       	sub	r28, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2203
    da80:	db 0b       	sbc	r29, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2204
    da82:	0f b6       	in	r0, 0x3f	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2205
    da84:	f8 94       	cli
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2206
    da86:	de bf       	out	0x3e, r29	; 62
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2207
    da88:	0f be       	out	0x3f, r0	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2208
    da8a:	cd bf       	out	0x3d, r28	; 61
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2211
    da8c:	19 94       	eijmp

0000da8e <__epilogue_restores__>:
__epilogue_restores__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2222
    da8e:	2a 88       	ldd	r2, Y+18	; 0x12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2223
    da90:	39 88       	ldd	r3, Y+17	; 0x11
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2224
    da92:	48 88       	ldd	r4, Y+16	; 0x10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2225
    da94:	5f 84       	ldd	r5, Y+15	; 0x0f
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2226
    da96:	6e 84       	ldd	r6, Y+14	; 0x0e
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2227
    da98:	7d 84       	ldd	r7, Y+13	; 0x0d
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2228
    da9a:	8c 84       	ldd	r8, Y+12	; 0x0c
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2229
    da9c:	9b 84       	ldd	r9, Y+11	; 0x0b
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2230
    da9e:	aa 84       	ldd	r10, Y+10	; 0x0a
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2231
    daa0:	b9 84       	ldd	r11, Y+9	; 0x09
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2232
    daa2:	c8 84       	ldd	r12, Y+8	; 0x08
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2233
    daa4:	df 80       	ldd	r13, Y+7	; 0x07
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2234
    daa6:	ee 80       	ldd	r14, Y+6	; 0x06
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2235
    daa8:	fd 80       	ldd	r15, Y+5	; 0x05
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2236
    daaa:	0c 81       	ldd	r16, Y+4	; 0x04
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2237
    daac:	1b 81       	ldd	r17, Y+3	; 0x03
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2238
    daae:	aa 81       	ldd	r26, Y+2	; 0x02
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2252
    dab0:	b9 81       	ldd	r27, Y+1	; 0x01
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2253
    dab2:	ce 0f       	add	r28, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2254
    dab4:	d1 1d       	adc	r29, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2255
    dab6:	0f b6       	in	r0, 0x3f	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2256
    dab8:	f8 94       	cli
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2257
    daba:	de bf       	out	0x3e, r29	; 62
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2258
    dabc:	0f be       	out	0x3f, r0	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2259
    dabe:	cd bf       	out	0x3d, r28	; 61
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2260
    dac0:	ed 01       	movw	r28, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2263
    dac2:	08 95       	ret

0000dac4 <__ashldi3>:
__ashldi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3169
    dac4:	00 2e       	mov	r0, r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3170
    dac6:	08 30       	cpi	r16, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3171
    dac8:	90 f0       	brcs	.+36     	; 0xdaee <__ashldi3+0x2a>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3172
    daca:	98 2f       	mov	r25, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3173
    dacc:	87 2f       	mov	r24, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3174
    dace:	76 2f       	mov	r23, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3175
    dad0:	65 2f       	mov	r22, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3176
    dad2:	54 2f       	mov	r21, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3177
    dad4:	43 2f       	mov	r20, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3178
    dad6:	32 2f       	mov	r19, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3179
    dad8:	22 27       	eor	r18, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3180
    dada:	08 50       	subi	r16, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3181
    dadc:	f4 cf       	rjmp	.-24     	; 0xdac6 <__ashldi3+0x2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3182
    dade:	22 0f       	add	r18, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3183
    dae0:	33 1f       	adc	r19, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3184
    dae2:	44 1f       	adc	r20, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3185
    dae4:	55 1f       	adc	r21, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3186
    dae6:	66 1f       	adc	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3187
    dae8:	77 1f       	adc	r23, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3188
    daea:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3189
    daec:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3190
    daee:	0a 95       	dec	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3191
    daf0:	b2 f7       	brpl	.-20     	; 0xdade <__ashldi3+0x1a>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3192
    daf2:	00 2d       	mov	r16, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3193
    daf4:	08 95       	ret

0000daf6 <__ashrdi3>:
__ashrdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3122
    daf6:	97 fd       	sbrc	r25, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3123
    daf8:	10 94       	com	r1

0000dafa <__lshrdi3>:
__lshrdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3131
    dafa:	00 2e       	mov	r0, r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3132
    dafc:	08 30       	cpi	r16, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3133
    dafe:	98 f0       	brcs	.+38     	; 0xdb26 <__lshrdi3+0x2c>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3134
    db00:	08 50       	subi	r16, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3135
    db02:	23 2f       	mov	r18, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3136
    db04:	34 2f       	mov	r19, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3137
    db06:	45 2f       	mov	r20, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3138
    db08:	56 2f       	mov	r21, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3139
    db0a:	67 2f       	mov	r22, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3140
    db0c:	78 2f       	mov	r23, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3141
    db0e:	89 2f       	mov	r24, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3142
    db10:	91 2d       	mov	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3143
    db12:	f4 cf       	rjmp	.-24     	; 0xdafc <__lshrdi3+0x2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3144
    db14:	15 94       	asr	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3145
    db16:	97 95       	ror	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3146
    db18:	87 95       	ror	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3147
    db1a:	77 95       	ror	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3148
    db1c:	67 95       	ror	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3149
    db1e:	57 95       	ror	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3150
    db20:	47 95       	ror	r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3151
    db22:	37 95       	ror	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3152
    db24:	27 95       	ror	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3153
    db26:	0a 95       	dec	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3154
    db28:	aa f7       	brpl	.-22     	; 0xdb14 <__lshrdi3+0x1a>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3155
    db2a:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3156
    db2c:	00 2d       	mov	r16, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3157
    db2e:	08 95       	ret

0000db30 <__adddi3>:
__adddi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2051
    db30:	2a 0d       	add	r18, r10
    db32:	3b 1d       	adc	r19, r11
    db34:	4c 1d       	adc	r20, r12
    db36:	5d 1d       	adc	r21, r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2052
    db38:	6e 1d       	adc	r22, r14
    db3a:	7f 1d       	adc	r23, r15
    db3c:	80 1f       	adc	r24, r16
    db3e:	91 1f       	adc	r25, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2053
    db40:	08 95       	ret

0000db42 <__subdi3>:
__subdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2080
    db42:	2a 19       	sub	r18, r10
    db44:	3b 09       	sbc	r19, r11
    db46:	4c 09       	sbc	r20, r12
    db48:	5d 09       	sbc	r21, r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2081
    db4a:	6e 09       	sbc	r22, r14
    db4c:	7f 09       	sbc	r23, r15
    db4e:	80 0b       	sbc	r24, r16
    db50:	91 0b       	sbc	r25, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2082
    db52:	08 95       	ret

0000db54 <__cmpdi2_s8>:
__cmpdi2_s8():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2102
    db54:	00 24       	eor	r0, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2103
    db56:	a7 fd       	sbrc	r26, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2104
    db58:	00 94       	com	r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2105
    db5a:	2a 17       	cp	r18, r26
    db5c:	30 05       	cpc	r19, r0
    db5e:	40 05       	cpc	r20, r0
    db60:	50 05       	cpc	r21, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2106
    db62:	60 05       	cpc	r22, r0
    db64:	70 05       	cpc	r23, r0
    db66:	80 05       	cpc	r24, r0
    db68:	90 05       	cpc	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2107
    db6a:	08 95       	ret

0000db6c <realloc>:
realloc():
    db6c:	4f 92       	push	r4
    db6e:	5f 92       	push	r5
    db70:	6f 92       	push	r6
    db72:	7f 92       	push	r7
    db74:	8f 92       	push	r8
    db76:	9f 92       	push	r9
    db78:	af 92       	push	r10
    db7a:	bf 92       	push	r11
    db7c:	cf 92       	push	r12
    db7e:	df 92       	push	r13
    db80:	ef 92       	push	r14
    db82:	ff 92       	push	r15
    db84:	0f 93       	push	r16
    db86:	1f 93       	push	r17
    db88:	cf 93       	push	r28
    db8a:	df 93       	push	r29
    db8c:	8c 01       	movw	r16, r24
    db8e:	00 97       	sbiw	r24, 0x00	; 0
    db90:	99 f4       	brne	.+38     	; 0xdbb8 <realloc+0x4c>
    db92:	cb 01       	movw	r24, r22
    db94:	df 91       	pop	r29
    db96:	cf 91       	pop	r28
    db98:	1f 91       	pop	r17
    db9a:	0f 91       	pop	r16
    db9c:	ff 90       	pop	r15
    db9e:	ef 90       	pop	r14
    dba0:	df 90       	pop	r13
    dba2:	cf 90       	pop	r12
    dba4:	bf 90       	pop	r11
    dba6:	af 90       	pop	r10
    dba8:	9f 90       	pop	r9
    dbaa:	8f 90       	pop	r8
    dbac:	7f 90       	pop	r7
    dbae:	6f 90       	pop	r6
    dbb0:	5f 90       	pop	r5
    dbb2:	4f 90       	pop	r4
    dbb4:	0c 94 d8 62 	jmp	0xc5b0	; 0xc5b0 <malloc>
    dbb8:	fc 01       	movw	r30, r24
    dbba:	e6 0f       	add	r30, r22
    dbbc:	f7 1f       	adc	r31, r23
    dbbe:	9c 01       	movw	r18, r24
    dbc0:	22 50       	subi	r18, 0x02	; 2
    dbc2:	31 09       	sbc	r19, r1
    dbc4:	e2 17       	cp	r30, r18
    dbc6:	f3 07       	cpc	r31, r19
    dbc8:	08 f4       	brcc	.+2      	; 0xdbcc <realloc+0x60>
    dbca:	ae c0       	rjmp	.+348    	; 0xdd28 <realloc+0x1bc>
    dbcc:	d9 01       	movw	r26, r18
    dbce:	cd 91       	ld	r28, X+
    dbd0:	dc 91       	ld	r29, X
    dbd2:	11 97       	sbiw	r26, 0x01	; 1
    dbd4:	c6 17       	cp	r28, r22
    dbd6:	d7 07       	cpc	r29, r23
    dbd8:	20 f1       	brcs	.+72     	; 0xdc22 <realloc+0xb6>
    dbda:	c5 30       	cpi	r28, 0x05	; 5
    dbdc:	d1 05       	cpc	r29, r1
    dbde:	78 f0       	brcs	.+30     	; 0xdbfe <realloc+0x92>
    dbe0:	ce 01       	movw	r24, r28
    dbe2:	04 97       	sbiw	r24, 0x04	; 4
    dbe4:	86 17       	cp	r24, r22
    dbe6:	97 07       	cpc	r25, r23
    dbe8:	50 f0       	brcs	.+20     	; 0xdbfe <realloc+0x92>
    dbea:	c6 1b       	sub	r28, r22
    dbec:	d7 0b       	sbc	r29, r23
    dbee:	22 97       	sbiw	r28, 0x02	; 2
    dbf0:	c1 93       	st	Z+, r28
    dbf2:	d1 93       	st	Z+, r29
    dbf4:	6d 93       	st	X+, r22
    dbf6:	7c 93       	st	X, r23
    dbf8:	cf 01       	movw	r24, r30
    dbfa:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
    dbfe:	c8 01       	movw	r24, r16
    dc00:	df 91       	pop	r29
    dc02:	cf 91       	pop	r28
    dc04:	1f 91       	pop	r17
    dc06:	0f 91       	pop	r16
    dc08:	ff 90       	pop	r15
    dc0a:	ef 90       	pop	r14
    dc0c:	df 90       	pop	r13
    dc0e:	cf 90       	pop	r12
    dc10:	bf 90       	pop	r11
    dc12:	af 90       	pop	r10
    dc14:	9f 90       	pop	r9
    dc16:	8f 90       	pop	r8
    dc18:	7f 90       	pop	r7
    dc1a:	6f 90       	pop	r6
    dc1c:	5f 90       	pop	r5
    dc1e:	4f 90       	pop	r4
    dc20:	08 95       	ret
    dc22:	5b 01       	movw	r10, r22
    dc24:	ac 1a       	sub	r10, r28
    dc26:	bd 0a       	sbc	r11, r29
    dc28:	4c 01       	movw	r8, r24
    dc2a:	8c 0e       	add	r8, r28
    dc2c:	9d 1e       	adc	r9, r29
    dc2e:	a0 91 6c 13 	lds	r26, 0x136C	; 0x80136c <__flp>
    dc32:	b0 91 6d 13 	lds	r27, 0x136D	; 0x80136d <__flp+0x1>
    dc36:	51 2c       	mov	r5, r1
    dc38:	41 2c       	mov	r4, r1
    dc3a:	f1 2c       	mov	r15, r1
    dc3c:	e1 2c       	mov	r14, r1
    dc3e:	10 97       	sbiw	r26, 0x00	; 0
    dc40:	31 f5       	brne	.+76     	; 0xdc8e <realloc+0x122>
    dc42:	80 91 6a 13 	lds	r24, 0x136A	; 0x80136a <__brkval>
    dc46:	90 91 6b 13 	lds	r25, 0x136B	; 0x80136b <__brkval+0x1>
    dc4a:	88 15       	cp	r24, r8
    dc4c:	99 05       	cpc	r25, r9
    dc4e:	09 f0       	breq	.+2      	; 0xdc52 <realloc+0xe6>
    dc50:	5c c0       	rjmp	.+184    	; 0xdd0a <realloc+0x19e>
    dc52:	46 16       	cp	r4, r22
    dc54:	57 06       	cpc	r5, r23
    dc56:	08 f0       	brcs	.+2      	; 0xdc5a <realloc+0xee>
    dc58:	58 c0       	rjmp	.+176    	; 0xdd0a <realloc+0x19e>
    dc5a:	80 91 a3 02 	lds	r24, 0x02A3	; 0x8002a3 <__malloc_heap_end>
    dc5e:	90 91 a4 02 	lds	r25, 0x02A4	; 0x8002a4 <__malloc_heap_end+0x1>
    dc62:	00 97       	sbiw	r24, 0x00	; 0
    dc64:	41 f4       	brne	.+16     	; 0xdc76 <realloc+0x10a>
    dc66:	8d b7       	in	r24, 0x3d	; 61
    dc68:	9e b7       	in	r25, 0x3e	; 62
    dc6a:	40 91 a7 02 	lds	r20, 0x02A7	; 0x8002a7 <__malloc_margin>
    dc6e:	50 91 a8 02 	lds	r21, 0x02A8	; 0x8002a8 <__malloc_margin+0x1>
    dc72:	84 1b       	sub	r24, r20
    dc74:	95 0b       	sbc	r25, r21
    dc76:	e8 17       	cp	r30, r24
    dc78:	f9 07       	cpc	r31, r25
    dc7a:	08 f0       	brcs	.+2      	; 0xdc7e <realloc+0x112>
    dc7c:	55 c0       	rjmp	.+170    	; 0xdd28 <realloc+0x1bc>
    dc7e:	f0 93 6b 13 	sts	0x136B, r31	; 0x80136b <__brkval+0x1>
    dc82:	e0 93 6a 13 	sts	0x136A, r30	; 0x80136a <__brkval>
    dc86:	f9 01       	movw	r30, r18
    dc88:	71 83       	std	Z+1, r23	; 0x01
    dc8a:	60 83       	st	Z, r22
    dc8c:	b8 cf       	rjmp	.-144    	; 0xdbfe <realloc+0x92>
    dc8e:	8d 91       	ld	r24, X+
    dc90:	9c 91       	ld	r25, X
    dc92:	11 97       	sbiw	r26, 0x01	; 1
    dc94:	12 96       	adiw	r26, 0x02	; 2
    dc96:	6c 90       	ld	r6, X
    dc98:	12 97       	sbiw	r26, 0x02	; 2
    dc9a:	13 96       	adiw	r26, 0x03	; 3
    dc9c:	7c 90       	ld	r7, X
    dc9e:	13 97       	sbiw	r26, 0x03	; 3
    dca0:	a8 15       	cp	r26, r8
    dca2:	b9 05       	cpc	r27, r9
    dca4:	59 f5       	brne	.+86     	; 0xdcfc <realloc+0x190>
    dca6:	6c 01       	movw	r12, r24
    dca8:	42 e0       	ldi	r20, 0x02	; 2
    dcaa:	c4 0e       	add	r12, r20
    dcac:	d1 1c       	adc	r13, r1
    dcae:	ca 14       	cp	r12, r10
    dcb0:	db 04       	cpc	r13, r11
    dcb2:	20 f1       	brcs	.+72     	; 0xdcfc <realloc+0x190>
    dcb4:	ac 01       	movw	r20, r24
    dcb6:	4a 19       	sub	r20, r10
    dcb8:	5b 09       	sbc	r21, r11
    dcba:	da 01       	movw	r26, r20
    dcbc:	12 96       	adiw	r26, 0x02	; 2
    dcbe:	15 97       	sbiw	r26, 0x05	; 5
    dcc0:	80 f0       	brcs	.+32     	; 0xdce2 <realloc+0x176>
    dcc2:	62 82       	std	Z+2, r6	; 0x02
    dcc4:	73 82       	std	Z+3, r7	; 0x03
    dcc6:	51 83       	std	Z+1, r21	; 0x01
    dcc8:	40 83       	st	Z, r20
    dcca:	d9 01       	movw	r26, r18
    dccc:	6d 93       	st	X+, r22
    dcce:	7c 93       	st	X, r23
    dcd0:	e1 14       	cp	r14, r1
    dcd2:	f1 04       	cpc	r15, r1
    dcd4:	71 f0       	breq	.+28     	; 0xdcf2 <realloc+0x186>
    dcd6:	d7 01       	movw	r26, r14
    dcd8:	13 96       	adiw	r26, 0x03	; 3
    dcda:	fc 93       	st	X, r31
    dcdc:	ee 93       	st	-X, r30
    dcde:	12 97       	sbiw	r26, 0x02	; 2
    dce0:	8e cf       	rjmp	.-228    	; 0xdbfe <realloc+0x92>
    dce2:	22 96       	adiw	r28, 0x02	; 2
    dce4:	8c 0f       	add	r24, r28
    dce6:	9d 1f       	adc	r25, r29
    dce8:	f9 01       	movw	r30, r18
    dcea:	91 83       	std	Z+1, r25	; 0x01
    dcec:	80 83       	st	Z, r24
    dcee:	f3 01       	movw	r30, r6
    dcf0:	ef cf       	rjmp	.-34     	; 0xdcd0 <realloc+0x164>
    dcf2:	f0 93 6d 13 	sts	0x136D, r31	; 0x80136d <__flp+0x1>
    dcf6:	e0 93 6c 13 	sts	0x136C, r30	; 0x80136c <__flp>
    dcfa:	81 cf       	rjmp	.-254    	; 0xdbfe <realloc+0x92>
    dcfc:	48 16       	cp	r4, r24
    dcfe:	59 06       	cpc	r5, r25
    dd00:	08 f4       	brcc	.+2      	; 0xdd04 <realloc+0x198>
    dd02:	2c 01       	movw	r4, r24
    dd04:	7d 01       	movw	r14, r26
    dd06:	d3 01       	movw	r26, r6
    dd08:	9a cf       	rjmp	.-204    	; 0xdc3e <realloc+0xd2>
    dd0a:	cb 01       	movw	r24, r22
    dd0c:	0e 94 d8 62 	call	0xc5b0	; 0xc5b0 <malloc>
    dd10:	7c 01       	movw	r14, r24
    dd12:	00 97       	sbiw	r24, 0x00	; 0
    dd14:	49 f0       	breq	.+18     	; 0xdd28 <realloc+0x1bc>
    dd16:	ae 01       	movw	r20, r28
    dd18:	b8 01       	movw	r22, r16
    dd1a:	0e 94 a4 6e 	call	0xdd48	; 0xdd48 <memcpy>
    dd1e:	c8 01       	movw	r24, r16
    dd20:	0e 94 74 63 	call	0xc6e8	; 0xc6e8 <free>
    dd24:	87 01       	movw	r16, r14
    dd26:	6b cf       	rjmp	.-298    	; 0xdbfe <realloc+0x92>
    dd28:	10 e0       	ldi	r17, 0x00	; 0
    dd2a:	00 e0       	ldi	r16, 0x00	; 0
    dd2c:	68 cf       	rjmp	.-304    	; 0xdbfe <realloc+0x92>

0000dd2e <memcmp>:
memcmp():
    dd2e:	fb 01       	movw	r30, r22
    dd30:	dc 01       	movw	r26, r24
    dd32:	04 c0       	rjmp	.+8      	; 0xdd3c <memcmp+0xe>
    dd34:	8d 91       	ld	r24, X+
    dd36:	01 90       	ld	r0, Z+
    dd38:	80 19       	sub	r24, r0
    dd3a:	21 f4       	brne	.+8      	; 0xdd44 <memcmp+0x16>
    dd3c:	41 50       	subi	r20, 0x01	; 1
    dd3e:	50 40       	sbci	r21, 0x00	; 0
    dd40:	c8 f7       	brcc	.-14     	; 0xdd34 <memcmp+0x6>
    dd42:	88 1b       	sub	r24, r24
    dd44:	99 0b       	sbc	r25, r25
    dd46:	08 95       	ret

0000dd48 <memcpy>:
memcpy():
    dd48:	fb 01       	movw	r30, r22
    dd4a:	dc 01       	movw	r26, r24
    dd4c:	02 c0       	rjmp	.+4      	; 0xdd52 <memcpy+0xa>
    dd4e:	01 90       	ld	r0, Z+
    dd50:	0d 92       	st	X+, r0
    dd52:	41 50       	subi	r20, 0x01	; 1
    dd54:	50 40       	sbci	r21, 0x00	; 0
    dd56:	d8 f7       	brcc	.-10     	; 0xdd4e <memcpy+0x6>
    dd58:	08 95       	ret

0000dd5a <memset>:
memset():
    dd5a:	dc 01       	movw	r26, r24
    dd5c:	01 c0       	rjmp	.+2      	; 0xdd60 <memset+0x6>
    dd5e:	6d 93       	st	X+, r22
    dd60:	41 50       	subi	r20, 0x01	; 1
    dd62:	50 40       	sbci	r21, 0x00	; 0
    dd64:	e0 f7       	brcc	.-8      	; 0xdd5e <memset+0x4>
    dd66:	08 95       	ret

0000dd68 <strchr>:
strchr():
    dd68:	fc 01       	movw	r30, r24
    dd6a:	81 91       	ld	r24, Z+
    dd6c:	86 17       	cp	r24, r22
    dd6e:	21 f0       	breq	.+8      	; 0xdd78 <strchr+0x10>
    dd70:	88 23       	and	r24, r24
    dd72:	d9 f7       	brne	.-10     	; 0xdd6a <strchr+0x2>
    dd74:	99 27       	eor	r25, r25
    dd76:	08 95       	ret
    dd78:	31 97       	sbiw	r30, 0x01	; 1
    dd7a:	cf 01       	movw	r24, r30
    dd7c:	08 95       	ret

0000dd7e <strcmp>:
strcmp():
    dd7e:	fb 01       	movw	r30, r22
    dd80:	dc 01       	movw	r26, r24
    dd82:	8d 91       	ld	r24, X+
    dd84:	01 90       	ld	r0, Z+
    dd86:	80 19       	sub	r24, r0
    dd88:	01 10       	cpse	r0, r1
    dd8a:	d9 f3       	breq	.-10     	; 0xdd82 <strcmp+0x4>
    dd8c:	99 0b       	sbc	r25, r25
    dd8e:	08 95       	ret

0000dd90 <strcpy>:
strcpy():
    dd90:	fb 01       	movw	r30, r22
    dd92:	dc 01       	movw	r26, r24
    dd94:	01 90       	ld	r0, Z+
    dd96:	0d 92       	st	X+, r0
    dd98:	00 20       	and	r0, r0
    dd9a:	e1 f7       	brne	.-8      	; 0xdd94 <strcpy+0x4>
    dd9c:	08 95       	ret

0000dd9e <strncpy>:
strncpy():
    dd9e:	fb 01       	movw	r30, r22
    dda0:	dc 01       	movw	r26, r24
    dda2:	41 50       	subi	r20, 0x01	; 1
    dda4:	50 40       	sbci	r21, 0x00	; 0
    dda6:	48 f0       	brcs	.+18     	; 0xddba <strncpy+0x1c>
    dda8:	01 90       	ld	r0, Z+
    ddaa:	0d 92       	st	X+, r0
    ddac:	00 20       	and	r0, r0
    ddae:	c9 f7       	brne	.-14     	; 0xdda2 <strncpy+0x4>
    ddb0:	01 c0       	rjmp	.+2      	; 0xddb4 <strncpy+0x16>
    ddb2:	1d 92       	st	X+, r1
    ddb4:	41 50       	subi	r20, 0x01	; 1
    ddb6:	50 40       	sbci	r21, 0x00	; 0
    ddb8:	e0 f7       	brcc	.-8      	; 0xddb2 <strncpy+0x14>
    ddba:	08 95       	ret

0000ddbc <sprintf>:
sprintf():
    ddbc:	0f 93       	push	r16
    ddbe:	1f 93       	push	r17
    ddc0:	cf 93       	push	r28
    ddc2:	df 93       	push	r29
    ddc4:	cd b7       	in	r28, 0x3d	; 61
    ddc6:	de b7       	in	r29, 0x3e	; 62
    ddc8:	2e 97       	sbiw	r28, 0x0e	; 14
    ddca:	0f b6       	in	r0, 0x3f	; 63
    ddcc:	f8 94       	cli
    ddce:	de bf       	out	0x3e, r29	; 62
    ddd0:	0f be       	out	0x3f, r0	; 63
    ddd2:	cd bf       	out	0x3d, r28	; 61
    ddd4:	0e 89       	ldd	r16, Y+22	; 0x16
    ddd6:	1f 89       	ldd	r17, Y+23	; 0x17
    ddd8:	86 e0       	ldi	r24, 0x06	; 6
    ddda:	8c 83       	std	Y+4, r24	; 0x04
    dddc:	1a 83       	std	Y+2, r17	; 0x02
    ddde:	09 83       	std	Y+1, r16	; 0x01
    dde0:	8f ef       	ldi	r24, 0xFF	; 255
    dde2:	9f e7       	ldi	r25, 0x7F	; 127
    dde4:	9e 83       	std	Y+6, r25	; 0x06
    dde6:	8d 83       	std	Y+5, r24	; 0x05
    dde8:	ae 01       	movw	r20, r28
    ddea:	46 5e       	subi	r20, 0xE6	; 230
    ddec:	5f 4f       	sbci	r21, 0xFF	; 255
    ddee:	68 8d       	ldd	r22, Y+24	; 0x18
    ddf0:	79 8d       	ldd	r23, Y+25	; 0x19
    ddf2:	ce 01       	movw	r24, r28
    ddf4:	01 96       	adiw	r24, 0x01	; 1
    ddf6:	0e 94 30 6f 	call	0xde60	; 0xde60 <vfprintf>
    ddfa:	2f 81       	ldd	r18, Y+7	; 0x07
    ddfc:	38 85       	ldd	r19, Y+8	; 0x08
    ddfe:	02 0f       	add	r16, r18
    de00:	13 1f       	adc	r17, r19
    de02:	f8 01       	movw	r30, r16
    de04:	10 82       	st	Z, r1
    de06:	2e 96       	adiw	r28, 0x0e	; 14
    de08:	0f b6       	in	r0, 0x3f	; 63
    de0a:	f8 94       	cli
    de0c:	de bf       	out	0x3e, r29	; 62
    de0e:	0f be       	out	0x3f, r0	; 63
    de10:	cd bf       	out	0x3d, r28	; 61
    de12:	df 91       	pop	r29
    de14:	cf 91       	pop	r28
    de16:	1f 91       	pop	r17
    de18:	0f 91       	pop	r16
    de1a:	08 95       	ret

0000de1c <sscanf>:
sscanf():
    de1c:	cf 93       	push	r28
    de1e:	df 93       	push	r29
    de20:	cd b7       	in	r28, 0x3d	; 61
    de22:	de b7       	in	r29, 0x3e	; 62
    de24:	2e 97       	sbiw	r28, 0x0e	; 14
    de26:	0f b6       	in	r0, 0x3f	; 63
    de28:	f8 94       	cli
    de2a:	de bf       	out	0x3e, r29	; 62
    de2c:	0f be       	out	0x3f, r0	; 63
    de2e:	cd bf       	out	0x3d, r28	; 61
    de30:	85 e0       	ldi	r24, 0x05	; 5
    de32:	8c 83       	std	Y+4, r24	; 0x04
    de34:	8c 89       	ldd	r24, Y+20	; 0x14
    de36:	9d 89       	ldd	r25, Y+21	; 0x15
    de38:	9a 83       	std	Y+2, r25	; 0x02
    de3a:	89 83       	std	Y+1, r24	; 0x01
    de3c:	ae 01       	movw	r20, r28
    de3e:	48 5e       	subi	r20, 0xE8	; 232
    de40:	5f 4f       	sbci	r21, 0xFF	; 255
    de42:	6e 89       	ldd	r22, Y+22	; 0x16
    de44:	7f 89       	ldd	r23, Y+23	; 0x17
    de46:	ce 01       	movw	r24, r28
    de48:	01 96       	adiw	r24, 0x01	; 1
    de4a:	0e 94 dc 72 	call	0xe5b8	; 0xe5b8 <vfscanf>
    de4e:	2e 96       	adiw	r28, 0x0e	; 14
    de50:	0f b6       	in	r0, 0x3f	; 63
    de52:	f8 94       	cli
    de54:	de bf       	out	0x3e, r29	; 62
    de56:	0f be       	out	0x3f, r0	; 63
    de58:	cd bf       	out	0x3d, r28	; 61
    de5a:	df 91       	pop	r29
    de5c:	cf 91       	pop	r28
    de5e:	08 95       	ret

0000de60 <vfprintf>:
vfprintf():
    de60:	2f 92       	push	r2
    de62:	3f 92       	push	r3
    de64:	4f 92       	push	r4
    de66:	5f 92       	push	r5
    de68:	6f 92       	push	r6
    de6a:	7f 92       	push	r7
    de6c:	8f 92       	push	r8
    de6e:	9f 92       	push	r9
    de70:	af 92       	push	r10
    de72:	bf 92       	push	r11
    de74:	cf 92       	push	r12
    de76:	df 92       	push	r13
    de78:	ef 92       	push	r14
    de7a:	ff 92       	push	r15
    de7c:	0f 93       	push	r16
    de7e:	1f 93       	push	r17
    de80:	cf 93       	push	r28
    de82:	df 93       	push	r29
    de84:	00 d0       	rcall	.+0      	; 0xde86 <vfprintf+0x26>
    de86:	00 d0       	rcall	.+0      	; 0xde88 <vfprintf+0x28>
    de88:	00 d0       	rcall	.+0      	; 0xde8a <vfprintf+0x2a>
    de8a:	1f 92       	push	r1
    de8c:	1f 92       	push	r1
    de8e:	cd b7       	in	r28, 0x3d	; 61
    de90:	de b7       	in	r29, 0x3e	; 62
    de92:	7c 01       	movw	r14, r24
    de94:	3b 01       	movw	r6, r22
    de96:	8a 01       	movw	r16, r20
    de98:	fc 01       	movw	r30, r24
    de9a:	17 82       	std	Z+7, r1	; 0x07
    de9c:	16 82       	std	Z+6, r1	; 0x06
    de9e:	83 81       	ldd	r24, Z+3	; 0x03
    dea0:	81 ff       	sbrs	r24, 1
    dea2:	dd c1       	rjmp	.+954    	; 0xe25e <vfprintf+0x3fe>
    dea4:	ce 01       	movw	r24, r28
    dea6:	01 96       	adiw	r24, 0x01	; 1
    dea8:	5c 01       	movw	r10, r24
    deaa:	f7 01       	movw	r30, r14
    deac:	93 81       	ldd	r25, Z+3	; 0x03
    deae:	f3 01       	movw	r30, r6
    deb0:	93 fd       	sbrc	r25, 3
    deb2:	85 91       	lpm	r24, Z+
    deb4:	93 ff       	sbrs	r25, 3
    deb6:	81 91       	ld	r24, Z+
    deb8:	3f 01       	movw	r6, r30
    deba:	88 23       	and	r24, r24
    debc:	09 f4       	brne	.+2      	; 0xdec0 <vfprintf+0x60>
    debe:	53 c1       	rjmp	.+678    	; 0xe166 <vfprintf+0x306>
    dec0:	85 32       	cpi	r24, 0x25	; 37
    dec2:	39 f4       	brne	.+14     	; 0xded2 <vfprintf+0x72>
    dec4:	93 fd       	sbrc	r25, 3
    dec6:	85 91       	lpm	r24, Z+
    dec8:	93 ff       	sbrs	r25, 3
    deca:	81 91       	ld	r24, Z+
    decc:	3f 01       	movw	r6, r30
    dece:	85 32       	cpi	r24, 0x25	; 37
    ded0:	29 f4       	brne	.+10     	; 0xdedc <vfprintf+0x7c>
    ded2:	b7 01       	movw	r22, r14
    ded4:	90 e0       	ldi	r25, 0x00	; 0
    ded6:	0e 94 52 74 	call	0xe8a4	; 0xe8a4 <fputc>
    deda:	e7 cf       	rjmp	.-50     	; 0xdeaa <vfprintf+0x4a>
    dedc:	91 2c       	mov	r9, r1
    dede:	21 2c       	mov	r2, r1
    dee0:	31 2c       	mov	r3, r1
    dee2:	ff e1       	ldi	r31, 0x1F	; 31
    dee4:	f3 15       	cp	r31, r3
    dee6:	38 f0       	brcs	.+14     	; 0xdef6 <vfprintf+0x96>
    dee8:	8b 32       	cpi	r24, 0x2B	; 43
    deea:	11 f1       	breq	.+68     	; 0xdf30 <vfprintf+0xd0>
    deec:	90 f4       	brcc	.+36     	; 0xdf12 <vfprintf+0xb2>
    deee:	80 32       	cpi	r24, 0x20	; 32
    def0:	09 f1       	breq	.+66     	; 0xdf34 <vfprintf+0xd4>
    def2:	83 32       	cpi	r24, 0x23	; 35
    def4:	29 f1       	breq	.+74     	; 0xdf40 <vfprintf+0xe0>
    def6:	37 fc       	sbrc	r3, 7
    def8:	3c c0       	rjmp	.+120    	; 0xdf72 <vfprintf+0x112>
    defa:	20 ed       	ldi	r18, 0xD0	; 208
    defc:	28 0f       	add	r18, r24
    defe:	2a 30       	cpi	r18, 0x0A	; 10
    df00:	50 f5       	brcc	.+84     	; 0xdf56 <vfprintf+0xf6>
    df02:	36 fe       	sbrs	r3, 6
    df04:	20 c0       	rjmp	.+64     	; 0xdf46 <vfprintf+0xe6>
    df06:	8a e0       	ldi	r24, 0x0A	; 10
    df08:	98 9e       	mul	r9, r24
    df0a:	20 0d       	add	r18, r0
    df0c:	11 24       	eor	r1, r1
    df0e:	92 2e       	mov	r9, r18
    df10:	06 c0       	rjmp	.+12     	; 0xdf1e <vfprintf+0xbe>
    df12:	8d 32       	cpi	r24, 0x2D	; 45
    df14:	91 f0       	breq	.+36     	; 0xdf3a <vfprintf+0xda>
    df16:	80 33       	cpi	r24, 0x30	; 48
    df18:	71 f7       	brne	.-36     	; 0xdef6 <vfprintf+0x96>
    df1a:	68 94       	set
    df1c:	30 f8       	bld	r3, 0
    df1e:	f3 01       	movw	r30, r6
    df20:	93 fd       	sbrc	r25, 3
    df22:	85 91       	lpm	r24, Z+
    df24:	93 ff       	sbrs	r25, 3
    df26:	81 91       	ld	r24, Z+
    df28:	3f 01       	movw	r6, r30
    df2a:	81 11       	cpse	r24, r1
    df2c:	da cf       	rjmp	.-76     	; 0xdee2 <vfprintf+0x82>
    df2e:	21 c0       	rjmp	.+66     	; 0xdf72 <vfprintf+0x112>
    df30:	68 94       	set
    df32:	31 f8       	bld	r3, 1
    df34:	68 94       	set
    df36:	32 f8       	bld	r3, 2
    df38:	f2 cf       	rjmp	.-28     	; 0xdf1e <vfprintf+0xbe>
    df3a:	68 94       	set
    df3c:	33 f8       	bld	r3, 3
    df3e:	ef cf       	rjmp	.-34     	; 0xdf1e <vfprintf+0xbe>
    df40:	68 94       	set
    df42:	34 f8       	bld	r3, 4
    df44:	ec cf       	rjmp	.-40     	; 0xdf1e <vfprintf+0xbe>
    df46:	ea e0       	ldi	r30, 0x0A	; 10
    df48:	2e 9e       	mul	r2, r30
    df4a:	20 0d       	add	r18, r0
    df4c:	11 24       	eor	r1, r1
    df4e:	22 2e       	mov	r2, r18
    df50:	68 94       	set
    df52:	35 f8       	bld	r3, 5
    df54:	e4 cf       	rjmp	.-56     	; 0xdf1e <vfprintf+0xbe>
    df56:	8e 32       	cpi	r24, 0x2E	; 46
    df58:	29 f4       	brne	.+10     	; 0xdf64 <vfprintf+0x104>
    df5a:	36 fc       	sbrc	r3, 6
    df5c:	04 c1       	rjmp	.+520    	; 0xe166 <vfprintf+0x306>
    df5e:	68 94       	set
    df60:	36 f8       	bld	r3, 6
    df62:	dd cf       	rjmp	.-70     	; 0xdf1e <vfprintf+0xbe>
    df64:	8c 36       	cpi	r24, 0x6C	; 108
    df66:	19 f4       	brne	.+6      	; 0xdf6e <vfprintf+0x10e>
    df68:	68 94       	set
    df6a:	37 f8       	bld	r3, 7
    df6c:	d8 cf       	rjmp	.-80     	; 0xdf1e <vfprintf+0xbe>
    df6e:	88 36       	cpi	r24, 0x68	; 104
    df70:	b1 f2       	breq	.-84     	; 0xdf1e <vfprintf+0xbe>
    df72:	98 2f       	mov	r25, r24
    df74:	9f 7d       	andi	r25, 0xDF	; 223
    df76:	95 54       	subi	r25, 0x45	; 69
    df78:	93 30       	cpi	r25, 0x03	; 3
    df7a:	e0 f0       	brcs	.+56     	; 0xdfb4 <vfprintf+0x154>
    df7c:	83 36       	cpi	r24, 0x63	; 99
    df7e:	a1 f1       	breq	.+104    	; 0xdfe8 <vfprintf+0x188>
    df80:	83 37       	cpi	r24, 0x73	; 115
    df82:	c1 f1       	breq	.+112    	; 0xdff4 <vfprintf+0x194>
    df84:	83 35       	cpi	r24, 0x53	; 83
    df86:	09 f0       	breq	.+2      	; 0xdf8a <vfprintf+0x12a>
    df88:	63 c0       	rjmp	.+198    	; 0xe050 <vfprintf+0x1f0>
    df8a:	28 01       	movw	r4, r16
    df8c:	f2 e0       	ldi	r31, 0x02	; 2
    df8e:	4f 0e       	add	r4, r31
    df90:	51 1c       	adc	r5, r1
    df92:	f8 01       	movw	r30, r16
    df94:	c0 80       	ld	r12, Z
    df96:	d1 80       	ldd	r13, Z+1	; 0x01
    df98:	69 2d       	mov	r22, r9
    df9a:	70 e0       	ldi	r23, 0x00	; 0
    df9c:	36 fc       	sbrc	r3, 6
    df9e:	02 c0       	rjmp	.+4      	; 0xdfa4 <vfprintf+0x144>
    dfa0:	6f ef       	ldi	r22, 0xFF	; 255
    dfa2:	7f ef       	ldi	r23, 0xFF	; 255
    dfa4:	c6 01       	movw	r24, r12
    dfa6:	0e 94 00 74 	call	0xe800	; 0xe800 <strnlen_P>
    dfaa:	4c 01       	movw	r8, r24
    dfac:	68 94       	set
    dfae:	37 f8       	bld	r3, 7
    dfb0:	82 01       	movw	r16, r4
    dfb2:	0a c0       	rjmp	.+20     	; 0xdfc8 <vfprintf+0x168>
    dfb4:	0c 5f       	subi	r16, 0xFC	; 252
    dfb6:	1f 4f       	sbci	r17, 0xFF	; 255
    dfb8:	ff e3       	ldi	r31, 0x3F	; 63
    dfba:	f9 83       	std	Y+1, r31	; 0x01
    dfbc:	88 24       	eor	r8, r8
    dfbe:	83 94       	inc	r8
    dfc0:	91 2c       	mov	r9, r1
    dfc2:	65 01       	movw	r12, r10
    dfc4:	e8 94       	clt
    dfc6:	37 f8       	bld	r3, 7
    dfc8:	33 fe       	sbrs	r3, 3
    dfca:	2d c0       	rjmp	.+90     	; 0xe026 <vfprintf+0x1c6>
    dfcc:	52 2c       	mov	r5, r2
    dfce:	81 14       	cp	r8, r1
    dfd0:	91 04       	cpc	r9, r1
    dfd2:	71 f5       	brne	.+92     	; 0xe030 <vfprintf+0x1d0>
    dfd4:	55 20       	and	r5, r5
    dfd6:	09 f4       	brne	.+2      	; 0xdfda <vfprintf+0x17a>
    dfd8:	68 cf       	rjmp	.-304    	; 0xdeaa <vfprintf+0x4a>
    dfda:	b7 01       	movw	r22, r14
    dfdc:	80 e2       	ldi	r24, 0x20	; 32
    dfde:	90 e0       	ldi	r25, 0x00	; 0
    dfe0:	0e 94 52 74 	call	0xe8a4	; 0xe8a4 <fputc>
    dfe4:	5a 94       	dec	r5
    dfe6:	f6 cf       	rjmp	.-20     	; 0xdfd4 <vfprintf+0x174>
    dfe8:	f8 01       	movw	r30, r16
    dfea:	80 81       	ld	r24, Z
    dfec:	89 83       	std	Y+1, r24	; 0x01
    dfee:	0e 5f       	subi	r16, 0xFE	; 254
    dff0:	1f 4f       	sbci	r17, 0xFF	; 255
    dff2:	e4 cf       	rjmp	.-56     	; 0xdfbc <vfprintf+0x15c>
    dff4:	28 01       	movw	r4, r16
    dff6:	f2 e0       	ldi	r31, 0x02	; 2
    dff8:	4f 0e       	add	r4, r31
    dffa:	51 1c       	adc	r5, r1
    dffc:	f8 01       	movw	r30, r16
    dffe:	c0 80       	ld	r12, Z
    e000:	d1 80       	ldd	r13, Z+1	; 0x01
    e002:	69 2d       	mov	r22, r9
    e004:	70 e0       	ldi	r23, 0x00	; 0
    e006:	36 fc       	sbrc	r3, 6
    e008:	02 c0       	rjmp	.+4      	; 0xe00e <vfprintf+0x1ae>
    e00a:	6f ef       	ldi	r22, 0xFF	; 255
    e00c:	7f ef       	ldi	r23, 0xFF	; 255
    e00e:	c6 01       	movw	r24, r12
    e010:	0e 94 0b 74 	call	0xe816	; 0xe816 <strnlen>
    e014:	4c 01       	movw	r8, r24
    e016:	82 01       	movw	r16, r4
    e018:	d5 cf       	rjmp	.-86     	; 0xdfc4 <vfprintf+0x164>
    e01a:	b7 01       	movw	r22, r14
    e01c:	80 e2       	ldi	r24, 0x20	; 32
    e01e:	90 e0       	ldi	r25, 0x00	; 0
    e020:	0e 94 52 74 	call	0xe8a4	; 0xe8a4 <fputc>
    e024:	2a 94       	dec	r2
    e026:	28 14       	cp	r2, r8
    e028:	19 04       	cpc	r1, r9
    e02a:	09 f0       	breq	.+2      	; 0xe02e <vfprintf+0x1ce>
    e02c:	b0 f7       	brcc	.-20     	; 0xe01a <vfprintf+0x1ba>
    e02e:	ce cf       	rjmp	.-100    	; 0xdfcc <vfprintf+0x16c>
    e030:	f6 01       	movw	r30, r12
    e032:	37 fc       	sbrc	r3, 7
    e034:	85 91       	lpm	r24, Z+
    e036:	37 fe       	sbrs	r3, 7
    e038:	81 91       	ld	r24, Z+
    e03a:	6f 01       	movw	r12, r30
    e03c:	b7 01       	movw	r22, r14
    e03e:	90 e0       	ldi	r25, 0x00	; 0
    e040:	0e 94 52 74 	call	0xe8a4	; 0xe8a4 <fputc>
    e044:	51 10       	cpse	r5, r1
    e046:	5a 94       	dec	r5
    e048:	f1 e0       	ldi	r31, 0x01	; 1
    e04a:	8f 1a       	sub	r8, r31
    e04c:	91 08       	sbc	r9, r1
    e04e:	bf cf       	rjmp	.-130    	; 0xdfce <vfprintf+0x16e>
    e050:	84 36       	cpi	r24, 0x64	; 100
    e052:	19 f0       	breq	.+6      	; 0xe05a <vfprintf+0x1fa>
    e054:	89 36       	cpi	r24, 0x69	; 105
    e056:	09 f0       	breq	.+2      	; 0xe05a <vfprintf+0x1fa>
    e058:	77 c0       	rjmp	.+238    	; 0xe148 <vfprintf+0x2e8>
    e05a:	f8 01       	movw	r30, r16
    e05c:	37 fe       	sbrs	r3, 7
    e05e:	6b c0       	rjmp	.+214    	; 0xe136 <vfprintf+0x2d6>
    e060:	60 81       	ld	r22, Z
    e062:	71 81       	ldd	r23, Z+1	; 0x01
    e064:	82 81       	ldd	r24, Z+2	; 0x02
    e066:	93 81       	ldd	r25, Z+3	; 0x03
    e068:	0c 5f       	subi	r16, 0xFC	; 252
    e06a:	1f 4f       	sbci	r17, 0xFF	; 255
    e06c:	f3 2d       	mov	r31, r3
    e06e:	ff 76       	andi	r31, 0x6F	; 111
    e070:	3f 2e       	mov	r3, r31
    e072:	97 ff       	sbrs	r25, 7
    e074:	09 c0       	rjmp	.+18     	; 0xe088 <vfprintf+0x228>
    e076:	90 95       	com	r25
    e078:	80 95       	com	r24
    e07a:	70 95       	com	r23
    e07c:	61 95       	neg	r22
    e07e:	7f 4f       	sbci	r23, 0xFF	; 255
    e080:	8f 4f       	sbci	r24, 0xFF	; 255
    e082:	9f 4f       	sbci	r25, 0xFF	; 255
    e084:	68 94       	set
    e086:	37 f8       	bld	r3, 7
    e088:	2a e0       	ldi	r18, 0x0A	; 10
    e08a:	30 e0       	ldi	r19, 0x00	; 0
    e08c:	a5 01       	movw	r20, r10
    e08e:	0e 94 9a 74 	call	0xe934	; 0xe934 <__ultoa_invert>
    e092:	c8 2e       	mov	r12, r24
    e094:	ca 18       	sub	r12, r10
    e096:	8c 2c       	mov	r8, r12
    e098:	43 2c       	mov	r4, r3
    e09a:	36 fe       	sbrs	r3, 6
    e09c:	0c c0       	rjmp	.+24     	; 0xe0b6 <vfprintf+0x256>
    e09e:	e8 94       	clt
    e0a0:	40 f8       	bld	r4, 0
    e0a2:	c9 14       	cp	r12, r9
    e0a4:	40 f4       	brcc	.+16     	; 0xe0b6 <vfprintf+0x256>
    e0a6:	34 fe       	sbrs	r3, 4
    e0a8:	05 c0       	rjmp	.+10     	; 0xe0b4 <vfprintf+0x254>
    e0aa:	32 fc       	sbrc	r3, 2
    e0ac:	03 c0       	rjmp	.+6      	; 0xe0b4 <vfprintf+0x254>
    e0ae:	f3 2d       	mov	r31, r3
    e0b0:	fe 7e       	andi	r31, 0xEE	; 238
    e0b2:	4f 2e       	mov	r4, r31
    e0b4:	89 2c       	mov	r8, r9
    e0b6:	44 fe       	sbrs	r4, 4
    e0b8:	aa c0       	rjmp	.+340    	; 0xe20e <vfprintf+0x3ae>
    e0ba:	fe 01       	movw	r30, r28
    e0bc:	ec 0d       	add	r30, r12
    e0be:	f1 1d       	adc	r31, r1
    e0c0:	80 81       	ld	r24, Z
    e0c2:	80 33       	cpi	r24, 0x30	; 48
    e0c4:	09 f0       	breq	.+2      	; 0xe0c8 <vfprintf+0x268>
    e0c6:	9c c0       	rjmp	.+312    	; 0xe200 <vfprintf+0x3a0>
    e0c8:	24 2d       	mov	r18, r4
    e0ca:	29 7e       	andi	r18, 0xE9	; 233
    e0cc:	42 2e       	mov	r4, r18
    e0ce:	84 2d       	mov	r24, r4
    e0d0:	88 70       	andi	r24, 0x08	; 8
    e0d2:	58 2e       	mov	r5, r24
    e0d4:	43 fc       	sbrc	r4, 3
    e0d6:	aa c0       	rjmp	.+340    	; 0xe22c <vfprintf+0x3cc>
    e0d8:	40 fe       	sbrs	r4, 0
    e0da:	a4 c0       	rjmp	.+328    	; 0xe224 <vfprintf+0x3c4>
    e0dc:	9c 2c       	mov	r9, r12
    e0de:	82 14       	cp	r8, r2
    e0e0:	18 f4       	brcc	.+6      	; 0xe0e8 <vfprintf+0x288>
    e0e2:	2c 0c       	add	r2, r12
    e0e4:	92 2c       	mov	r9, r2
    e0e6:	98 18       	sub	r9, r8
    e0e8:	44 fe       	sbrs	r4, 4
    e0ea:	a6 c0       	rjmp	.+332    	; 0xe238 <vfprintf+0x3d8>
    e0ec:	b7 01       	movw	r22, r14
    e0ee:	80 e3       	ldi	r24, 0x30	; 48
    e0f0:	90 e0       	ldi	r25, 0x00	; 0
    e0f2:	0e 94 52 74 	call	0xe8a4	; 0xe8a4 <fputc>
    e0f6:	42 fe       	sbrs	r4, 2
    e0f8:	09 c0       	rjmp	.+18     	; 0xe10c <vfprintf+0x2ac>
    e0fa:	88 e7       	ldi	r24, 0x78	; 120
    e0fc:	90 e0       	ldi	r25, 0x00	; 0
    e0fe:	41 fe       	sbrs	r4, 1
    e100:	02 c0       	rjmp	.+4      	; 0xe106 <vfprintf+0x2a6>
    e102:	88 e5       	ldi	r24, 0x58	; 88
    e104:	90 e0       	ldi	r25, 0x00	; 0
    e106:	b7 01       	movw	r22, r14
    e108:	0e 94 52 74 	call	0xe8a4	; 0xe8a4 <fputc>
    e10c:	c9 14       	cp	r12, r9
    e10e:	08 f4       	brcc	.+2      	; 0xe112 <vfprintf+0x2b2>
    e110:	9f c0       	rjmp	.+318    	; 0xe250 <vfprintf+0x3f0>
    e112:	ca 94       	dec	r12
    e114:	d1 2c       	mov	r13, r1
    e116:	9f ef       	ldi	r25, 0xFF	; 255
    e118:	c9 1a       	sub	r12, r25
    e11a:	d9 0a       	sbc	r13, r25
    e11c:	ca 0c       	add	r12, r10
    e11e:	db 1c       	adc	r13, r11
    e120:	f6 01       	movw	r30, r12
    e122:	82 91       	ld	r24, -Z
    e124:	6f 01       	movw	r12, r30
    e126:	b7 01       	movw	r22, r14
    e128:	90 e0       	ldi	r25, 0x00	; 0
    e12a:	0e 94 52 74 	call	0xe8a4	; 0xe8a4 <fputc>
    e12e:	ac 14       	cp	r10, r12
    e130:	bd 04       	cpc	r11, r13
    e132:	b1 f7       	brne	.-20     	; 0xe120 <vfprintf+0x2c0>
    e134:	4f cf       	rjmp	.-354    	; 0xdfd4 <vfprintf+0x174>
    e136:	60 81       	ld	r22, Z
    e138:	71 81       	ldd	r23, Z+1	; 0x01
    e13a:	07 2e       	mov	r0, r23
    e13c:	00 0c       	add	r0, r0
    e13e:	88 0b       	sbc	r24, r24
    e140:	99 0b       	sbc	r25, r25
    e142:	0e 5f       	subi	r16, 0xFE	; 254
    e144:	1f 4f       	sbci	r17, 0xFF	; 255
    e146:	92 cf       	rjmp	.-220    	; 0xe06c <vfprintf+0x20c>
    e148:	d3 2c       	mov	r13, r3
    e14a:	e8 94       	clt
    e14c:	d4 f8       	bld	r13, 4
    e14e:	2a e0       	ldi	r18, 0x0A	; 10
    e150:	30 e0       	ldi	r19, 0x00	; 0
    e152:	85 37       	cpi	r24, 0x75	; 117
    e154:	e1 f1       	breq	.+120    	; 0xe1ce <vfprintf+0x36e>
    e156:	23 2d       	mov	r18, r3
    e158:	29 7f       	andi	r18, 0xF9	; 249
    e15a:	d2 2e       	mov	r13, r18
    e15c:	8f 36       	cpi	r24, 0x6F	; 111
    e15e:	a9 f1       	breq	.+106    	; 0xe1ca <vfprintf+0x36a>
    e160:	f0 f4       	brcc	.+60     	; 0xe19e <vfprintf+0x33e>
    e162:	88 35       	cpi	r24, 0x58	; 88
    e164:	51 f1       	breq	.+84     	; 0xe1ba <vfprintf+0x35a>
    e166:	f7 01       	movw	r30, r14
    e168:	86 81       	ldd	r24, Z+6	; 0x06
    e16a:	97 81       	ldd	r25, Z+7	; 0x07
    e16c:	2b 96       	adiw	r28, 0x0b	; 11
    e16e:	0f b6       	in	r0, 0x3f	; 63
    e170:	f8 94       	cli
    e172:	de bf       	out	0x3e, r29	; 62
    e174:	0f be       	out	0x3f, r0	; 63
    e176:	cd bf       	out	0x3d, r28	; 61
    e178:	df 91       	pop	r29
    e17a:	cf 91       	pop	r28
    e17c:	1f 91       	pop	r17
    e17e:	0f 91       	pop	r16
    e180:	ff 90       	pop	r15
    e182:	ef 90       	pop	r14
    e184:	df 90       	pop	r13
    e186:	cf 90       	pop	r12
    e188:	bf 90       	pop	r11
    e18a:	af 90       	pop	r10
    e18c:	9f 90       	pop	r9
    e18e:	8f 90       	pop	r8
    e190:	7f 90       	pop	r7
    e192:	6f 90       	pop	r6
    e194:	5f 90       	pop	r5
    e196:	4f 90       	pop	r4
    e198:	3f 90       	pop	r3
    e19a:	2f 90       	pop	r2
    e19c:	08 95       	ret
    e19e:	80 37       	cpi	r24, 0x70	; 112
    e1a0:	49 f0       	breq	.+18     	; 0xe1b4 <vfprintf+0x354>
    e1a2:	88 37       	cpi	r24, 0x78	; 120
    e1a4:	01 f7       	brne	.-64     	; 0xe166 <vfprintf+0x306>
    e1a6:	d4 fe       	sbrs	r13, 4
    e1a8:	02 c0       	rjmp	.+4      	; 0xe1ae <vfprintf+0x34e>
    e1aa:	68 94       	set
    e1ac:	d2 f8       	bld	r13, 2
    e1ae:	20 e1       	ldi	r18, 0x10	; 16
    e1b0:	30 e0       	ldi	r19, 0x00	; 0
    e1b2:	0d c0       	rjmp	.+26     	; 0xe1ce <vfprintf+0x36e>
    e1b4:	68 94       	set
    e1b6:	d4 f8       	bld	r13, 4
    e1b8:	f6 cf       	rjmp	.-20     	; 0xe1a6 <vfprintf+0x346>
    e1ba:	34 fe       	sbrs	r3, 4
    e1bc:	03 c0       	rjmp	.+6      	; 0xe1c4 <vfprintf+0x364>
    e1be:	82 2f       	mov	r24, r18
    e1c0:	86 60       	ori	r24, 0x06	; 6
    e1c2:	d8 2e       	mov	r13, r24
    e1c4:	20 e1       	ldi	r18, 0x10	; 16
    e1c6:	32 e0       	ldi	r19, 0x02	; 2
    e1c8:	02 c0       	rjmp	.+4      	; 0xe1ce <vfprintf+0x36e>
    e1ca:	28 e0       	ldi	r18, 0x08	; 8
    e1cc:	30 e0       	ldi	r19, 0x00	; 0
    e1ce:	f8 01       	movw	r30, r16
    e1d0:	d7 fe       	sbrs	r13, 7
    e1d2:	0f c0       	rjmp	.+30     	; 0xe1f2 <vfprintf+0x392>
    e1d4:	60 81       	ld	r22, Z
    e1d6:	71 81       	ldd	r23, Z+1	; 0x01
    e1d8:	82 81       	ldd	r24, Z+2	; 0x02
    e1da:	93 81       	ldd	r25, Z+3	; 0x03
    e1dc:	0c 5f       	subi	r16, 0xFC	; 252
    e1de:	1f 4f       	sbci	r17, 0xFF	; 255
    e1e0:	a5 01       	movw	r20, r10
    e1e2:	0e 94 9a 74 	call	0xe934	; 0xe934 <__ultoa_invert>
    e1e6:	c8 2e       	mov	r12, r24
    e1e8:	ca 18       	sub	r12, r10
    e1ea:	3d 2c       	mov	r3, r13
    e1ec:	e8 94       	clt
    e1ee:	37 f8       	bld	r3, 7
    e1f0:	52 cf       	rjmp	.-348    	; 0xe096 <vfprintf+0x236>
    e1f2:	60 81       	ld	r22, Z
    e1f4:	71 81       	ldd	r23, Z+1	; 0x01
    e1f6:	90 e0       	ldi	r25, 0x00	; 0
    e1f8:	80 e0       	ldi	r24, 0x00	; 0
    e1fa:	0e 5f       	subi	r16, 0xFE	; 254
    e1fc:	1f 4f       	sbci	r17, 0xFF	; 255
    e1fe:	f0 cf       	rjmp	.-32     	; 0xe1e0 <vfprintf+0x380>
    e200:	42 fc       	sbrc	r4, 2
    e202:	02 c0       	rjmp	.+4      	; 0xe208 <vfprintf+0x3a8>
    e204:	83 94       	inc	r8
    e206:	63 cf       	rjmp	.-314    	; 0xe0ce <vfprintf+0x26e>
    e208:	83 94       	inc	r8
    e20a:	83 94       	inc	r8
    e20c:	60 cf       	rjmp	.-320    	; 0xe0ce <vfprintf+0x26e>
    e20e:	84 2d       	mov	r24, r4
    e210:	86 78       	andi	r24, 0x86	; 134
    e212:	09 f4       	brne	.+2      	; 0xe216 <vfprintf+0x3b6>
    e214:	5c cf       	rjmp	.-328    	; 0xe0ce <vfprintf+0x26e>
    e216:	f6 cf       	rjmp	.-20     	; 0xe204 <vfprintf+0x3a4>
    e218:	b7 01       	movw	r22, r14
    e21a:	80 e2       	ldi	r24, 0x20	; 32
    e21c:	90 e0       	ldi	r25, 0x00	; 0
    e21e:	0e 94 52 74 	call	0xe8a4	; 0xe8a4 <fputc>
    e222:	83 94       	inc	r8
    e224:	82 14       	cp	r8, r2
    e226:	c0 f3       	brcs	.-16     	; 0xe218 <vfprintf+0x3b8>
    e228:	51 2c       	mov	r5, r1
    e22a:	5e cf       	rjmp	.-324    	; 0xe0e8 <vfprintf+0x288>
    e22c:	52 2c       	mov	r5, r2
    e22e:	58 18       	sub	r5, r8
    e230:	82 14       	cp	r8, r2
    e232:	08 f4       	brcc	.+2      	; 0xe236 <vfprintf+0x3d6>
    e234:	59 cf       	rjmp	.-334    	; 0xe0e8 <vfprintf+0x288>
    e236:	f8 cf       	rjmp	.-16     	; 0xe228 <vfprintf+0x3c8>
    e238:	84 2d       	mov	r24, r4
    e23a:	86 78       	andi	r24, 0x86	; 134
    e23c:	09 f4       	brne	.+2      	; 0xe240 <vfprintf+0x3e0>
    e23e:	66 cf       	rjmp	.-308    	; 0xe10c <vfprintf+0x2ac>
    e240:	8b e2       	ldi	r24, 0x2B	; 43
    e242:	41 fe       	sbrs	r4, 1
    e244:	80 e2       	ldi	r24, 0x20	; 32
    e246:	47 fc       	sbrc	r4, 7
    e248:	8d e2       	ldi	r24, 0x2D	; 45
    e24a:	b7 01       	movw	r22, r14
    e24c:	90 e0       	ldi	r25, 0x00	; 0
    e24e:	5c cf       	rjmp	.-328    	; 0xe108 <vfprintf+0x2a8>
    e250:	b7 01       	movw	r22, r14
    e252:	80 e3       	ldi	r24, 0x30	; 48
    e254:	90 e0       	ldi	r25, 0x00	; 0
    e256:	0e 94 52 74 	call	0xe8a4	; 0xe8a4 <fputc>
    e25a:	9a 94       	dec	r9
    e25c:	57 cf       	rjmp	.-338    	; 0xe10c <vfprintf+0x2ac>
    e25e:	8f ef       	ldi	r24, 0xFF	; 255
    e260:	9f ef       	ldi	r25, 0xFF	; 255
    e262:	84 cf       	rjmp	.-248    	; 0xe16c <vfprintf+0x30c>

0000e264 <putval>:
putval():
    e264:	20 fd       	sbrc	r18, 0
    e266:	09 c0       	rjmp	.+18     	; 0xe27a <putval+0x16>
    e268:	fc 01       	movw	r30, r24
    e26a:	23 fd       	sbrc	r18, 3
    e26c:	05 c0       	rjmp	.+10     	; 0xe278 <putval+0x14>
    e26e:	22 ff       	sbrs	r18, 2
    e270:	02 c0       	rjmp	.+4      	; 0xe276 <putval+0x12>
    e272:	73 83       	std	Z+3, r23	; 0x03
    e274:	62 83       	std	Z+2, r22	; 0x02
    e276:	51 83       	std	Z+1, r21	; 0x01
    e278:	40 83       	st	Z, r20
    e27a:	08 95       	ret

0000e27c <mulacc>:
mulacc():
    e27c:	44 fd       	sbrc	r20, 4
    e27e:	17 c0       	rjmp	.+46     	; 0xe2ae <mulacc+0x32>
    e280:	46 fd       	sbrc	r20, 6
    e282:	1d c0       	rjmp	.+58     	; 0xe2be <mulacc+0x42>
    e284:	db 01       	movw	r26, r22
    e286:	fc 01       	movw	r30, r24
    e288:	aa 0f       	add	r26, r26
    e28a:	bb 1f       	adc	r27, r27
    e28c:	ee 1f       	adc	r30, r30
    e28e:	ff 1f       	adc	r31, r31
    e290:	10 94       	com	r1
    e292:	d1 f7       	brne	.-12     	; 0xe288 <mulacc+0xc>
    e294:	6a 0f       	add	r22, r26
    e296:	7b 1f       	adc	r23, r27
    e298:	8e 1f       	adc	r24, r30
    e29a:	9f 1f       	adc	r25, r31
    e29c:	66 0f       	add	r22, r22
    e29e:	77 1f       	adc	r23, r23
    e2a0:	88 1f       	adc	r24, r24
    e2a2:	99 1f       	adc	r25, r25
    e2a4:	62 0f       	add	r22, r18
    e2a6:	71 1d       	adc	r23, r1
    e2a8:	81 1d       	adc	r24, r1
    e2aa:	91 1d       	adc	r25, r1
    e2ac:	08 95       	ret
    e2ae:	33 e0       	ldi	r19, 0x03	; 3
    e2b0:	66 0f       	add	r22, r22
    e2b2:	77 1f       	adc	r23, r23
    e2b4:	88 1f       	adc	r24, r24
    e2b6:	99 1f       	adc	r25, r25
    e2b8:	31 50       	subi	r19, 0x01	; 1
    e2ba:	d1 f7       	brne	.-12     	; 0xe2b0 <mulacc+0x34>
    e2bc:	f3 cf       	rjmp	.-26     	; 0xe2a4 <mulacc+0x28>
    e2be:	34 e0       	ldi	r19, 0x04	; 4
    e2c0:	f7 cf       	rjmp	.-18     	; 0xe2b0 <mulacc+0x34>

0000e2c2 <skip_spaces>:
skip_spaces():
    e2c2:	0f 93       	push	r16
    e2c4:	1f 93       	push	r17
    e2c6:	cf 93       	push	r28
    e2c8:	df 93       	push	r29
    e2ca:	8c 01       	movw	r16, r24
    e2cc:	c8 01       	movw	r24, r16
    e2ce:	0e 94 16 74 	call	0xe82c	; 0xe82c <fgetc>
    e2d2:	ec 01       	movw	r28, r24
    e2d4:	97 fd       	sbrc	r25, 7
    e2d6:	08 c0       	rjmp	.+16     	; 0xe2e8 <skip_spaces+0x26>
    e2d8:	0e 94 a3 68 	call	0xd146	; 0xd146 <isspace>
    e2dc:	89 2b       	or	r24, r25
    e2de:	b1 f7       	brne	.-20     	; 0xe2cc <skip_spaces+0xa>
    e2e0:	b8 01       	movw	r22, r16
    e2e2:	ce 01       	movw	r24, r28
    e2e4:	0e 94 82 74 	call	0xe904	; 0xe904 <ungetc>
    e2e8:	ce 01       	movw	r24, r28
    e2ea:	df 91       	pop	r29
    e2ec:	cf 91       	pop	r28
    e2ee:	1f 91       	pop	r17
    e2f0:	0f 91       	pop	r16
    e2f2:	08 95       	ret

0000e2f4 <conv_int>:
conv_int():
    e2f4:	8f 92       	push	r8
    e2f6:	9f 92       	push	r9
    e2f8:	af 92       	push	r10
    e2fa:	bf 92       	push	r11
    e2fc:	ef 92       	push	r14
    e2fe:	ff 92       	push	r15
    e300:	0f 93       	push	r16
    e302:	1f 93       	push	r17
    e304:	cf 93       	push	r28
    e306:	df 93       	push	r29
    e308:	8c 01       	movw	r16, r24
    e30a:	d6 2f       	mov	r29, r22
    e30c:	7a 01       	movw	r14, r20
    e30e:	b2 2e       	mov	r11, r18
    e310:	0e 94 16 74 	call	0xe82c	; 0xe82c <fgetc>
    e314:	9c 01       	movw	r18, r24
    e316:	33 27       	eor	r19, r19
    e318:	2b 32       	cpi	r18, 0x2B	; 43
    e31a:	31 05       	cpc	r19, r1
    e31c:	29 f0       	breq	.+10     	; 0xe328 <conv_int+0x34>
    e31e:	2d 32       	cpi	r18, 0x2D	; 45
    e320:	31 05       	cpc	r19, r1
    e322:	a9 f4       	brne	.+42     	; 0xe34e <conv_int+0x5a>
    e324:	68 94       	set
    e326:	b7 f8       	bld	r11, 7
    e328:	d1 50       	subi	r29, 0x01	; 1
    e32a:	61 f4       	brne	.+24     	; 0xe344 <conv_int+0x50>
    e32c:	80 e0       	ldi	r24, 0x00	; 0
    e32e:	df 91       	pop	r29
    e330:	cf 91       	pop	r28
    e332:	1f 91       	pop	r17
    e334:	0f 91       	pop	r16
    e336:	ff 90       	pop	r15
    e338:	ef 90       	pop	r14
    e33a:	bf 90       	pop	r11
    e33c:	af 90       	pop	r10
    e33e:	9f 90       	pop	r9
    e340:	8f 90       	pop	r8
    e342:	08 95       	ret
    e344:	c8 01       	movw	r24, r16
    e346:	0e 94 16 74 	call	0xe82c	; 0xe82c <fgetc>
    e34a:	97 fd       	sbrc	r25, 7
    e34c:	ef cf       	rjmp	.-34     	; 0xe32c <conv_int+0x38>
    e34e:	cb 2d       	mov	r28, r11
    e350:	cd 7f       	andi	r28, 0xFD	; 253
    e352:	2b 2d       	mov	r18, r11
    e354:	20 73       	andi	r18, 0x30	; 48
    e356:	f9 f4       	brne	.+62     	; 0xe396 <conv_int+0xa2>
    e358:	80 33       	cpi	r24, 0x30	; 48
    e35a:	e9 f4       	brne	.+58     	; 0xe396 <conv_int+0xa2>
    e35c:	aa 24       	eor	r10, r10
    e35e:	aa 94       	dec	r10
    e360:	ad 0e       	add	r10, r29
    e362:	89 f0       	breq	.+34     	; 0xe386 <conv_int+0x92>
    e364:	c8 01       	movw	r24, r16
    e366:	0e 94 16 74 	call	0xe82c	; 0xe82c <fgetc>
    e36a:	97 fd       	sbrc	r25, 7
    e36c:	0c c0       	rjmp	.+24     	; 0xe386 <conv_int+0x92>
    e36e:	28 2f       	mov	r18, r24
    e370:	2f 7d       	andi	r18, 0xDF	; 223
    e372:	28 35       	cpi	r18, 0x58	; 88
    e374:	61 f4       	brne	.+24     	; 0xe38e <conv_int+0x9a>
    e376:	c2 64       	ori	r28, 0x42	; 66
    e378:	d2 50       	subi	r29, 0x02	; 2
    e37a:	29 f0       	breq	.+10     	; 0xe386 <conv_int+0x92>
    e37c:	c8 01       	movw	r24, r16
    e37e:	0e 94 16 74 	call	0xe82c	; 0xe82c <fgetc>
    e382:	97 ff       	sbrs	r25, 7
    e384:	08 c0       	rjmp	.+16     	; 0xe396 <conv_int+0xa2>
    e386:	81 2c       	mov	r8, r1
    e388:	91 2c       	mov	r9, r1
    e38a:	54 01       	movw	r10, r8
    e38c:	1b c0       	rjmp	.+54     	; 0xe3c4 <conv_int+0xd0>
    e38e:	b6 fe       	sbrs	r11, 6
    e390:	2b c0       	rjmp	.+86     	; 0xe3e8 <conv_int+0xf4>
    e392:	c2 60       	ori	r28, 0x02	; 2
    e394:	da 2d       	mov	r29, r10
    e396:	81 2c       	mov	r8, r1
    e398:	91 2c       	mov	r9, r1
    e39a:	54 01       	movw	r10, r8
    e39c:	20 ed       	ldi	r18, 0xD0	; 208
    e39e:	28 0f       	add	r18, r24
    e3a0:	28 30       	cpi	r18, 0x08	; 8
    e3a2:	28 f1       	brcs	.+74     	; 0xe3ee <conv_int+0xfa>
    e3a4:	c4 fd       	sbrc	r28, 4
    e3a6:	09 c0       	rjmp	.+18     	; 0xe3ba <conv_int+0xc6>
    e3a8:	2a 30       	cpi	r18, 0x0A	; 10
    e3aa:	08 f1       	brcs	.+66     	; 0xe3ee <conv_int+0xfa>
    e3ac:	c6 ff       	sbrs	r28, 6
    e3ae:	05 c0       	rjmp	.+10     	; 0xe3ba <conv_int+0xc6>
    e3b0:	2f 7d       	andi	r18, 0xDF	; 223
    e3b2:	3f ee       	ldi	r19, 0xEF	; 239
    e3b4:	32 0f       	add	r19, r18
    e3b6:	36 30       	cpi	r19, 0x06	; 6
    e3b8:	c8 f0       	brcs	.+50     	; 0xe3ec <conv_int+0xf8>
    e3ba:	b8 01       	movw	r22, r16
    e3bc:	0e 94 82 74 	call	0xe904	; 0xe904 <ungetc>
    e3c0:	c1 ff       	sbrs	r28, 1
    e3c2:	b4 cf       	rjmp	.-152    	; 0xe32c <conv_int+0x38>
    e3c4:	c7 ff       	sbrs	r28, 7
    e3c6:	08 c0       	rjmp	.+16     	; 0xe3d8 <conv_int+0xe4>
    e3c8:	b0 94       	com	r11
    e3ca:	a0 94       	com	r10
    e3cc:	90 94       	com	r9
    e3ce:	80 94       	com	r8
    e3d0:	81 1c       	adc	r8, r1
    e3d2:	91 1c       	adc	r9, r1
    e3d4:	a1 1c       	adc	r10, r1
    e3d6:	b1 1c       	adc	r11, r1
    e3d8:	2c 2f       	mov	r18, r28
    e3da:	b5 01       	movw	r22, r10
    e3dc:	a4 01       	movw	r20, r8
    e3de:	c7 01       	movw	r24, r14
    e3e0:	0e 94 32 71 	call	0xe264	; 0xe264 <putval>
    e3e4:	81 e0       	ldi	r24, 0x01	; 1
    e3e6:	a3 cf       	rjmp	.-186    	; 0xe32e <conv_int+0x3a>
    e3e8:	c2 61       	ori	r28, 0x12	; 18
    e3ea:	d4 cf       	rjmp	.-88     	; 0xe394 <conv_int+0xa0>
    e3ec:	27 50       	subi	r18, 0x07	; 7
    e3ee:	4c 2f       	mov	r20, r28
    e3f0:	c5 01       	movw	r24, r10
    e3f2:	b4 01       	movw	r22, r8
    e3f4:	0e 94 3e 71 	call	0xe27c	; 0xe27c <mulacc>
    e3f8:	4b 01       	movw	r8, r22
    e3fa:	5c 01       	movw	r10, r24
    e3fc:	c2 60       	ori	r28, 0x02	; 2
    e3fe:	d1 50       	subi	r29, 0x01	; 1
    e400:	09 f3       	breq	.-62     	; 0xe3c4 <conv_int+0xd0>
    e402:	c8 01       	movw	r24, r16
    e404:	0e 94 16 74 	call	0xe82c	; 0xe82c <fgetc>
    e408:	97 ff       	sbrs	r25, 7
    e40a:	c8 cf       	rjmp	.-112    	; 0xe39c <conv_int+0xa8>
    e40c:	d9 cf       	rjmp	.-78     	; 0xe3c0 <conv_int+0xcc>

0000e40e <conv_brk>:
conv_brk():
    e40e:	7f 92       	push	r7
    e410:	8f 92       	push	r8
    e412:	9f 92       	push	r9
    e414:	af 92       	push	r10
    e416:	bf 92       	push	r11
    e418:	cf 92       	push	r12
    e41a:	df 92       	push	r13
    e41c:	ef 92       	push	r14
    e41e:	ff 92       	push	r15
    e420:	0f 93       	push	r16
    e422:	1f 93       	push	r17
    e424:	cf 93       	push	r28
    e426:	df 93       	push	r29
    e428:	cd b7       	in	r28, 0x3d	; 61
    e42a:	de b7       	in	r29, 0x3e	; 62
    e42c:	a0 97       	sbiw	r28, 0x20	; 32
    e42e:	0f b6       	in	r0, 0x3f	; 63
    e430:	f8 94       	cli
    e432:	de bf       	out	0x3e, r29	; 62
    e434:	0f be       	out	0x3f, r0	; 63
    e436:	cd bf       	out	0x3d, r28	; 61
    e438:	5c 01       	movw	r10, r24
    e43a:	96 2e       	mov	r9, r22
    e43c:	7a 01       	movw	r14, r20
    e43e:	ce 01       	movw	r24, r28
    e440:	01 96       	adiw	r24, 0x01	; 1
    e442:	6c 01       	movw	r12, r24
    e444:	80 e2       	ldi	r24, 0x20	; 32
    e446:	f6 01       	movw	r30, r12
    e448:	11 92       	st	Z+, r1
    e44a:	8a 95       	dec	r24
    e44c:	e9 f7       	brne	.-6      	; 0xe448 <conv_brk+0x3a>
    e44e:	f5 01       	movw	r30, r10
    e450:	b3 81       	ldd	r27, Z+3	; 0x03
    e452:	89 01       	movw	r16, r18
    e454:	30 e0       	ldi	r19, 0x00	; 0
    e456:	20 e0       	ldi	r18, 0x00	; 0
    e458:	71 2c       	mov	r7, r1
    e45a:	81 2c       	mov	r8, r1
    e45c:	a0 e0       	ldi	r26, 0x00	; 0
    e45e:	41 e0       	ldi	r20, 0x01	; 1
    e460:	50 e0       	ldi	r21, 0x00	; 0
    e462:	f8 01       	movw	r30, r16
    e464:	b3 fd       	sbrc	r27, 3
    e466:	85 91       	lpm	r24, Z+
    e468:	b3 ff       	sbrs	r27, 3
    e46a:	81 91       	ld	r24, Z+
    e46c:	98 2f       	mov	r25, r24
    e46e:	8f 01       	movw	r16, r30
    e470:	81 11       	cpse	r24, r1
    e472:	17 c0       	rjmp	.+46     	; 0xe4a2 <conv_brk+0x94>
    e474:	10 e0       	ldi	r17, 0x00	; 0
    e476:	00 e0       	ldi	r16, 0x00	; 0
    e478:	c8 01       	movw	r24, r16
    e47a:	a0 96       	adiw	r28, 0x20	; 32
    e47c:	0f b6       	in	r0, 0x3f	; 63
    e47e:	f8 94       	cli
    e480:	de bf       	out	0x3e, r29	; 62
    e482:	0f be       	out	0x3f, r0	; 63
    e484:	cd bf       	out	0x3d, r28	; 61
    e486:	df 91       	pop	r29
    e488:	cf 91       	pop	r28
    e48a:	1f 91       	pop	r17
    e48c:	0f 91       	pop	r16
    e48e:	ff 90       	pop	r15
    e490:	ef 90       	pop	r14
    e492:	df 90       	pop	r13
    e494:	cf 90       	pop	r12
    e496:	bf 90       	pop	r11
    e498:	af 90       	pop	r10
    e49a:	9f 90       	pop	r9
    e49c:	8f 90       	pop	r8
    e49e:	7f 90       	pop	r7
    e4a0:	08 95       	ret
    e4a2:	8e 35       	cpi	r24, 0x5E	; 94
    e4a4:	19 f4       	brne	.+6      	; 0xe4ac <conv_brk+0x9e>
    e4a6:	21 15       	cp	r18, r1
    e4a8:	31 05       	cpc	r19, r1
    e4aa:	41 f1       	breq	.+80     	; 0xe4fc <conv_brk+0xee>
    e4ac:	a2 17       	cp	r26, r18
    e4ae:	13 06       	cpc	r1, r19
    e4b0:	4c f4       	brge	.+18     	; 0xe4c4 <conv_brk+0xb6>
    e4b2:	8d 35       	cpi	r24, 0x5D	; 93
    e4b4:	49 f1       	breq	.+82     	; 0xe508 <conv_brk+0xfa>
    e4b6:	8d 32       	cpi	r24, 0x2D	; 45
    e4b8:	29 f4       	brne	.+10     	; 0xe4c4 <conv_brk+0xb6>
    e4ba:	81 10       	cpse	r8, r1
    e4bc:	06 c0       	rjmp	.+12     	; 0xe4ca <conv_brk+0xbc>
    e4be:	88 24       	eor	r8, r8
    e4c0:	83 94       	inc	r8
    e4c2:	1d c0       	rjmp	.+58     	; 0xe4fe <conv_brk+0xf0>
    e4c4:	88 20       	and	r8, r8
    e4c6:	09 f4       	brne	.+2      	; 0xe4ca <conv_brk+0xbc>
    e4c8:	64 c0       	rjmp	.+200    	; 0xe592 <conv_brk+0x184>
    e4ca:	e9 2f       	mov	r30, r25
    e4cc:	e6 95       	lsr	r30
    e4ce:	e6 95       	lsr	r30
    e4d0:	e6 95       	lsr	r30
    e4d2:	ec 0d       	add	r30, r12
    e4d4:	fd 2d       	mov	r31, r13
    e4d6:	f1 1d       	adc	r31, r1
    e4d8:	89 2f       	mov	r24, r25
    e4da:	87 70       	andi	r24, 0x07	; 7
    e4dc:	ba 01       	movw	r22, r20
    e4de:	01 c0       	rjmp	.+2      	; 0xe4e2 <conv_brk+0xd4>
    e4e0:	66 0f       	add	r22, r22
    e4e2:	8a 95       	dec	r24
    e4e4:	ea f7       	brpl	.-6      	; 0xe4e0 <conv_brk+0xd2>
    e4e6:	80 81       	ld	r24, Z
    e4e8:	68 2b       	or	r22, r24
    e4ea:	60 83       	st	Z, r22
    e4ec:	79 16       	cp	r7, r25
    e4ee:	51 f0       	breq	.+20     	; 0xe504 <conv_brk+0xf6>
    e4f0:	97 15       	cp	r25, r7
    e4f2:	10 f4       	brcc	.+4      	; 0xe4f8 <conv_brk+0xea>
    e4f4:	9f 5f       	subi	r25, 0xFF	; 255
    e4f6:	e9 cf       	rjmp	.-46     	; 0xe4ca <conv_brk+0xbc>
    e4f8:	91 50       	subi	r25, 0x01	; 1
    e4fa:	e7 cf       	rjmp	.-50     	; 0xe4ca <conv_brk+0xbc>
    e4fc:	a1 e0       	ldi	r26, 0x01	; 1
    e4fe:	2f 5f       	subi	r18, 0xFF	; 255
    e500:	3f 4f       	sbci	r19, 0xFF	; 255
    e502:	af cf       	rjmp	.-162    	; 0xe462 <conv_brk+0x54>
    e504:	81 2c       	mov	r8, r1
    e506:	fb cf       	rjmp	.-10     	; 0xe4fe <conv_brk+0xf0>
    e508:	88 20       	and	r8, r8
    e50a:	19 f0       	breq	.+6      	; 0xe512 <conv_brk+0x104>
    e50c:	8e 81       	ldd	r24, Y+6	; 0x06
    e50e:	80 62       	ori	r24, 0x20	; 32
    e510:	8e 83       	std	Y+6, r24	; 0x06
    e512:	aa 23       	and	r26, r26
    e514:	59 f0       	breq	.+22     	; 0xe52c <conv_brk+0x11e>
    e516:	f6 01       	movw	r30, r12
    e518:	9e 01       	movw	r18, r28
    e51a:	2f 5d       	subi	r18, 0xDF	; 223
    e51c:	3f 4f       	sbci	r19, 0xFF	; 255
    e51e:	80 81       	ld	r24, Z
    e520:	80 95       	com	r24
    e522:	80 83       	st	Z, r24
    e524:	31 96       	adiw	r30, 0x01	; 1
    e526:	e2 17       	cp	r30, r18
    e528:	f3 07       	cpc	r31, r19
    e52a:	c9 f7       	brne	.-14     	; 0xe51e <conv_brk+0x110>
    e52c:	88 24       	eor	r8, r8
    e52e:	83 94       	inc	r8
    e530:	c5 01       	movw	r24, r10
    e532:	0e 94 16 74 	call	0xe82c	; 0xe82c <fgetc>
    e536:	97 fd       	sbrc	r25, 7
    e538:	16 c0       	rjmp	.+44     	; 0xe566 <conv_brk+0x158>
    e53a:	e8 2f       	mov	r30, r24
    e53c:	e6 95       	lsr	r30
    e53e:	e6 95       	lsr	r30
    e540:	e6 95       	lsr	r30
    e542:	ec 0d       	add	r30, r12
    e544:	fd 2d       	mov	r31, r13
    e546:	f1 1d       	adc	r31, r1
    e548:	20 81       	ld	r18, Z
    e54a:	30 e0       	ldi	r19, 0x00	; 0
    e54c:	ac 01       	movw	r20, r24
    e54e:	47 70       	andi	r20, 0x07	; 7
    e550:	55 27       	eor	r21, r21
    e552:	02 c0       	rjmp	.+4      	; 0xe558 <conv_brk+0x14a>
    e554:	35 95       	asr	r19
    e556:	27 95       	ror	r18
    e558:	4a 95       	dec	r20
    e55a:	e2 f7       	brpl	.-8      	; 0xe554 <conv_brk+0x146>
    e55c:	20 fd       	sbrc	r18, 0
    e55e:	06 c0       	rjmp	.+12     	; 0xe56c <conv_brk+0x15e>
    e560:	b5 01       	movw	r22, r10
    e562:	0e 94 82 74 	call	0xe904	; 0xe904 <ungetc>
    e566:	88 20       	and	r8, r8
    e568:	69 f0       	breq	.+26     	; 0xe584 <conv_brk+0x176>
    e56a:	84 cf       	rjmp	.-248    	; 0xe474 <conv_brk+0x66>
    e56c:	e1 14       	cp	r14, r1
    e56e:	f1 04       	cpc	r15, r1
    e570:	29 f0       	breq	.+10     	; 0xe57c <conv_brk+0x16e>
    e572:	f7 01       	movw	r30, r14
    e574:	80 83       	st	Z, r24
    e576:	c7 01       	movw	r24, r14
    e578:	01 96       	adiw	r24, 0x01	; 1
    e57a:	7c 01       	movw	r14, r24
    e57c:	9a 94       	dec	r9
    e57e:	81 2c       	mov	r8, r1
    e580:	91 10       	cpse	r9, r1
    e582:	d6 cf       	rjmp	.-84     	; 0xe530 <conv_brk+0x122>
    e584:	e1 14       	cp	r14, r1
    e586:	f1 04       	cpc	r15, r1
    e588:	09 f4       	brne	.+2      	; 0xe58c <conv_brk+0x17e>
    e58a:	76 cf       	rjmp	.-276    	; 0xe478 <conv_brk+0x6a>
    e58c:	f7 01       	movw	r30, r14
    e58e:	10 82       	st	Z, r1
    e590:	73 cf       	rjmp	.-282    	; 0xe478 <conv_brk+0x6a>
    e592:	e8 2f       	mov	r30, r24
    e594:	e6 95       	lsr	r30
    e596:	e6 95       	lsr	r30
    e598:	e6 95       	lsr	r30
    e59a:	ec 0d       	add	r30, r12
    e59c:	fd 2d       	mov	r31, r13
    e59e:	f1 1d       	adc	r31, r1
    e5a0:	98 2f       	mov	r25, r24
    e5a2:	97 70       	andi	r25, 0x07	; 7
    e5a4:	ba 01       	movw	r22, r20
    e5a6:	01 c0       	rjmp	.+2      	; 0xe5aa <conv_brk+0x19c>
    e5a8:	66 0f       	add	r22, r22
    e5aa:	9a 95       	dec	r25
    e5ac:	ea f7       	brpl	.-6      	; 0xe5a8 <conv_brk+0x19a>
    e5ae:	90 81       	ld	r25, Z
    e5b0:	69 2b       	or	r22, r25
    e5b2:	60 83       	st	Z, r22
    e5b4:	78 2e       	mov	r7, r24
    e5b6:	a3 cf       	rjmp	.-186    	; 0xe4fe <conv_brk+0xf0>

0000e5b8 <vfscanf>:
vfscanf():
    e5b8:	5f 92       	push	r5
    e5ba:	6f 92       	push	r6
    e5bc:	7f 92       	push	r7
    e5be:	8f 92       	push	r8
    e5c0:	9f 92       	push	r9
    e5c2:	af 92       	push	r10
    e5c4:	bf 92       	push	r11
    e5c6:	cf 92       	push	r12
    e5c8:	df 92       	push	r13
    e5ca:	ef 92       	push	r14
    e5cc:	ff 92       	push	r15
    e5ce:	0f 93       	push	r16
    e5d0:	1f 93       	push	r17
    e5d2:	cf 93       	push	r28
    e5d4:	df 93       	push	r29
    e5d6:	6c 01       	movw	r12, r24
    e5d8:	eb 01       	movw	r28, r22
    e5da:	5a 01       	movw	r10, r20
    e5dc:	fc 01       	movw	r30, r24
    e5de:	17 82       	std	Z+7, r1	; 0x07
    e5e0:	16 82       	std	Z+6, r1	; 0x06
    e5e2:	51 2c       	mov	r5, r1
    e5e4:	f6 01       	movw	r30, r12
    e5e6:	e3 80       	ldd	r14, Z+3	; 0x03
    e5e8:	fe 01       	movw	r30, r28
    e5ea:	e3 fc       	sbrc	r14, 3
    e5ec:	85 91       	lpm	r24, Z+
    e5ee:	e3 fe       	sbrs	r14, 3
    e5f0:	81 91       	ld	r24, Z+
    e5f2:	18 2f       	mov	r17, r24
    e5f4:	ef 01       	movw	r28, r30
    e5f6:	88 23       	and	r24, r24
    e5f8:	e9 f0       	breq	.+58     	; 0xe634 <vfscanf+0x7c>
    e5fa:	90 e0       	ldi	r25, 0x00	; 0
    e5fc:	0e 94 a3 68 	call	0xd146	; 0xd146 <isspace>
    e600:	89 2b       	or	r24, r25
    e602:	21 f0       	breq	.+8      	; 0xe60c <vfscanf+0x54>
    e604:	c6 01       	movw	r24, r12
    e606:	0e 94 61 71 	call	0xe2c2	; 0xe2c2 <skip_spaces>
    e60a:	ec cf       	rjmp	.-40     	; 0xe5e4 <vfscanf+0x2c>
    e60c:	15 32       	cpi	r17, 0x25	; 37
    e60e:	41 f4       	brne	.+16     	; 0xe620 <vfscanf+0x68>
    e610:	fe 01       	movw	r30, r28
    e612:	e3 fc       	sbrc	r14, 3
    e614:	15 91       	lpm	r17, Z+
    e616:	e3 fe       	sbrs	r14, 3
    e618:	11 91       	ld	r17, Z+
    e61a:	ef 01       	movw	r28, r30
    e61c:	15 32       	cpi	r17, 0x25	; 37
    e61e:	69 f4       	brne	.+26     	; 0xe63a <vfscanf+0x82>
    e620:	c6 01       	movw	r24, r12
    e622:	0e 94 16 74 	call	0xe82c	; 0xe82c <fgetc>
    e626:	97 fd       	sbrc	r25, 7
    e628:	8e c0       	rjmp	.+284    	; 0xe746 <vfscanf+0x18e>
    e62a:	18 17       	cp	r17, r24
    e62c:	d9 f2       	breq	.-74     	; 0xe5e4 <vfscanf+0x2c>
    e62e:	b6 01       	movw	r22, r12
    e630:	0e 94 82 74 	call	0xe904	; 0xe904 <ungetc>
    e634:	85 2d       	mov	r24, r5
    e636:	90 e0       	ldi	r25, 0x00	; 0
    e638:	8a c0       	rjmp	.+276    	; 0xe74e <vfscanf+0x196>
    e63a:	00 e0       	ldi	r16, 0x00	; 0
    e63c:	1a 32       	cpi	r17, 0x2A	; 42
    e63e:	31 f4       	brne	.+12     	; 0xe64c <vfscanf+0x94>
    e640:	e3 fc       	sbrc	r14, 3
    e642:	15 91       	lpm	r17, Z+
    e644:	e3 fe       	sbrs	r14, 3
    e646:	11 91       	ld	r17, Z+
    e648:	ef 01       	movw	r28, r30
    e64a:	01 e0       	ldi	r16, 0x01	; 1
    e64c:	f1 2c       	mov	r15, r1
    e64e:	20 ed       	ldi	r18, 0xD0	; 208
    e650:	21 0f       	add	r18, r17
    e652:	2a 30       	cpi	r18, 0x0A	; 10
    e654:	48 f1       	brcs	.+82     	; 0xe6a8 <vfscanf+0xf0>
    e656:	01 ff       	sbrs	r16, 1
    e658:	37 c0       	rjmp	.+110    	; 0xe6c8 <vfscanf+0x110>
    e65a:	ff 20       	and	r15, r15
    e65c:	59 f3       	breq	.-42     	; 0xe634 <vfscanf+0x7c>
    e65e:	18 36       	cpi	r17, 0x68	; 104
    e660:	b1 f1       	breq	.+108    	; 0xe6ce <vfscanf+0x116>
    e662:	1c 36       	cpi	r17, 0x6C	; 108
    e664:	09 f4       	brne	.+2      	; 0xe668 <vfscanf+0xb0>
    e666:	3d c0       	rjmp	.+122    	; 0xe6e2 <vfscanf+0x12a>
    e668:	11 23       	and	r17, r17
    e66a:	21 f3       	breq	.-56     	; 0xe634 <vfscanf+0x7c>
    e66c:	61 2f       	mov	r22, r17
    e66e:	70 e0       	ldi	r23, 0x00	; 0
    e670:	8d e9       	ldi	r24, 0x9D	; 157
    e672:	93 e0       	ldi	r25, 0x03	; 3
    e674:	0e 94 f5 73 	call	0xe7ea	; 0xe7ea <strchr_P>
    e678:	89 2b       	or	r24, r25
    e67a:	e1 f2       	breq	.-72     	; 0xe634 <vfscanf+0x7c>
    e67c:	91 2c       	mov	r9, r1
    e67e:	81 2c       	mov	r8, r1
    e680:	00 fd       	sbrc	r16, 0
    e682:	06 c0       	rjmp	.+12     	; 0xe690 <vfscanf+0xd8>
    e684:	f5 01       	movw	r30, r10
    e686:	80 80       	ld	r8, Z
    e688:	91 80       	ldd	r9, Z+1	; 0x01
    e68a:	c5 01       	movw	r24, r10
    e68c:	02 96       	adiw	r24, 0x02	; 2
    e68e:	5c 01       	movw	r10, r24
    e690:	1e 36       	cpi	r17, 0x6E	; 110
    e692:	79 f5       	brne	.+94     	; 0xe6f2 <vfscanf+0x13a>
    e694:	f6 01       	movw	r30, r12
    e696:	46 81       	ldd	r20, Z+6	; 0x06
    e698:	57 81       	ldd	r21, Z+7	; 0x07
    e69a:	70 e0       	ldi	r23, 0x00	; 0
    e69c:	60 e0       	ldi	r22, 0x00	; 0
    e69e:	20 2f       	mov	r18, r16
    e6a0:	c4 01       	movw	r24, r8
    e6a2:	0e 94 32 71 	call	0xe264	; 0xe264 <putval>
    e6a6:	9e cf       	rjmp	.-196    	; 0xe5e4 <vfscanf+0x2c>
    e6a8:	02 60       	ori	r16, 0x02	; 2
    e6aa:	6f 2d       	mov	r22, r15
    e6ac:	70 e0       	ldi	r23, 0x00	; 0
    e6ae:	90 e0       	ldi	r25, 0x00	; 0
    e6b0:	80 e0       	ldi	r24, 0x00	; 0
    e6b2:	40 e2       	ldi	r20, 0x20	; 32
    e6b4:	0e 94 3e 71 	call	0xe27c	; 0xe27c <mulacc>
    e6b8:	f6 2e       	mov	r15, r22
    e6ba:	fe 01       	movw	r30, r28
    e6bc:	e3 fc       	sbrc	r14, 3
    e6be:	15 91       	lpm	r17, Z+
    e6c0:	e3 fe       	sbrs	r14, 3
    e6c2:	11 91       	ld	r17, Z+
    e6c4:	ef 01       	movw	r28, r30
    e6c6:	c3 cf       	rjmp	.-122    	; 0xe64e <vfscanf+0x96>
    e6c8:	ff 24       	eor	r15, r15
    e6ca:	fa 94       	dec	r15
    e6cc:	c8 cf       	rjmp	.-112    	; 0xe65e <vfscanf+0xa6>
    e6ce:	fe 01       	movw	r30, r28
    e6d0:	e3 fc       	sbrc	r14, 3
    e6d2:	15 91       	lpm	r17, Z+
    e6d4:	e3 fe       	sbrs	r14, 3
    e6d6:	11 91       	ld	r17, Z+
    e6d8:	ef 01       	movw	r28, r30
    e6da:	18 36       	cpi	r17, 0x68	; 104
    e6dc:	09 f0       	breq	.+2      	; 0xe6e0 <vfscanf+0x128>
    e6de:	c4 cf       	rjmp	.-120    	; 0xe668 <vfscanf+0xb0>
    e6e0:	08 60       	ori	r16, 0x08	; 8
    e6e2:	04 60       	ori	r16, 0x04	; 4
    e6e4:	fe 01       	movw	r30, r28
    e6e6:	e3 fc       	sbrc	r14, 3
    e6e8:	15 91       	lpm	r17, Z+
    e6ea:	e3 fe       	sbrs	r14, 3
    e6ec:	11 91       	ld	r17, Z+
    e6ee:	ef 01       	movw	r28, r30
    e6f0:	bb cf       	rjmp	.-138    	; 0xe668 <vfscanf+0xb0>
    e6f2:	13 36       	cpi	r17, 0x63	; 99
    e6f4:	c1 f4       	brne	.+48     	; 0xe726 <vfscanf+0x16e>
    e6f6:	01 fd       	sbrc	r16, 1
    e6f8:	02 c0       	rjmp	.+4      	; 0xe6fe <vfscanf+0x146>
    e6fa:	ff 24       	eor	r15, r15
    e6fc:	f3 94       	inc	r15
    e6fe:	c6 01       	movw	r24, r12
    e700:	0e 94 16 74 	call	0xe82c	; 0xe82c <fgetc>
    e704:	97 fd       	sbrc	r25, 7
    e706:	1f c0       	rjmp	.+62     	; 0xe746 <vfscanf+0x18e>
    e708:	81 14       	cp	r8, r1
    e70a:	91 04       	cpc	r9, r1
    e70c:	29 f0       	breq	.+10     	; 0xe718 <vfscanf+0x160>
    e70e:	f4 01       	movw	r30, r8
    e710:	80 83       	st	Z, r24
    e712:	c4 01       	movw	r24, r8
    e714:	01 96       	adiw	r24, 0x01	; 1
    e716:	4c 01       	movw	r8, r24
    e718:	fa 94       	dec	r15
    e71a:	f1 10       	cpse	r15, r1
    e71c:	f0 cf       	rjmp	.-32     	; 0xe6fe <vfscanf+0x146>
    e71e:	00 fd       	sbrc	r16, 0
    e720:	61 cf       	rjmp	.-318    	; 0xe5e4 <vfscanf+0x2c>
    e722:	53 94       	inc	r5
    e724:	5f cf       	rjmp	.-322    	; 0xe5e4 <vfscanf+0x2c>
    e726:	1b 35       	cpi	r17, 0x5B	; 91
    e728:	11 f5       	brne	.+68     	; 0xe76e <vfscanf+0x1b6>
    e72a:	9e 01       	movw	r18, r28
    e72c:	a4 01       	movw	r20, r8
    e72e:	6f 2d       	mov	r22, r15
    e730:	c6 01       	movw	r24, r12
    e732:	0e 94 07 72 	call	0xe40e	; 0xe40e <conv_brk>
    e736:	ec 01       	movw	r28, r24
    e738:	89 2b       	or	r24, r25
    e73a:	89 f7       	brne	.-30     	; 0xe71e <vfscanf+0x166>
    e73c:	f6 01       	movw	r30, r12
    e73e:	83 81       	ldd	r24, Z+3	; 0x03
    e740:	80 73       	andi	r24, 0x30	; 48
    e742:	09 f4       	brne	.+2      	; 0xe746 <vfscanf+0x18e>
    e744:	77 cf       	rjmp	.-274    	; 0xe634 <vfscanf+0x7c>
    e746:	8f ef       	ldi	r24, 0xFF	; 255
    e748:	9f ef       	ldi	r25, 0xFF	; 255
    e74a:	51 10       	cpse	r5, r1
    e74c:	73 cf       	rjmp	.-282    	; 0xe634 <vfscanf+0x7c>
    e74e:	df 91       	pop	r29
    e750:	cf 91       	pop	r28
    e752:	1f 91       	pop	r17
    e754:	0f 91       	pop	r16
    e756:	ff 90       	pop	r15
    e758:	ef 90       	pop	r14
    e75a:	df 90       	pop	r13
    e75c:	cf 90       	pop	r12
    e75e:	bf 90       	pop	r11
    e760:	af 90       	pop	r10
    e762:	9f 90       	pop	r9
    e764:	8f 90       	pop	r8
    e766:	7f 90       	pop	r7
    e768:	6f 90       	pop	r6
    e76a:	5f 90       	pop	r5
    e76c:	08 95       	ret
    e76e:	c6 01       	movw	r24, r12
    e770:	0e 94 61 71 	call	0xe2c2	; 0xe2c2 <skip_spaces>
    e774:	97 fd       	sbrc	r25, 7
    e776:	e7 cf       	rjmp	.-50     	; 0xe746 <vfscanf+0x18e>
    e778:	1f 36       	cpi	r17, 0x6F	; 111
    e77a:	a9 f1       	breq	.+106    	; 0xe7e6 <vfscanf+0x22e>
    e77c:	30 f4       	brcc	.+12     	; 0xe78a <vfscanf+0x1d2>
    e77e:	14 36       	cpi	r17, 0x64	; 100
    e780:	41 f0       	breq	.+16     	; 0xe792 <vfscanf+0x1da>
    e782:	19 36       	cpi	r17, 0x69	; 105
    e784:	39 f0       	breq	.+14     	; 0xe794 <vfscanf+0x1dc>
    e786:	00 64       	ori	r16, 0x40	; 64
    e788:	05 c0       	rjmp	.+10     	; 0xe794 <vfscanf+0x1dc>
    e78a:	13 37       	cpi	r17, 0x73	; 115
    e78c:	b9 f0       	breq	.+46     	; 0xe7bc <vfscanf+0x204>
    e78e:	15 37       	cpi	r17, 0x75	; 117
    e790:	d1 f7       	brne	.-12     	; 0xe786 <vfscanf+0x1ce>
    e792:	00 62       	ori	r16, 0x20	; 32
    e794:	20 2f       	mov	r18, r16
    e796:	a4 01       	movw	r20, r8
    e798:	6f 2d       	mov	r22, r15
    e79a:	c6 01       	movw	r24, r12
    e79c:	0e 94 7a 71 	call	0xe2f4	; 0xe2f4 <conv_int>
    e7a0:	81 11       	cpse	r24, r1
    e7a2:	bd cf       	rjmp	.-134    	; 0xe71e <vfscanf+0x166>
    e7a4:	cb cf       	rjmp	.-106    	; 0xe73c <vfscanf+0x184>
    e7a6:	81 14       	cp	r8, r1
    e7a8:	91 04       	cpc	r9, r1
    e7aa:	29 f0       	breq	.+10     	; 0xe7b6 <vfscanf+0x1fe>
    e7ac:	f4 01       	movw	r30, r8
    e7ae:	60 82       	st	Z, r6
    e7b0:	c4 01       	movw	r24, r8
    e7b2:	01 96       	adiw	r24, 0x01	; 1
    e7b4:	4c 01       	movw	r8, r24
    e7b6:	fa 94       	dec	r15
    e7b8:	ff 20       	and	r15, r15
    e7ba:	71 f0       	breq	.+28     	; 0xe7d8 <vfscanf+0x220>
    e7bc:	c6 01       	movw	r24, r12
    e7be:	0e 94 16 74 	call	0xe82c	; 0xe82c <fgetc>
    e7c2:	3c 01       	movw	r6, r24
    e7c4:	97 fd       	sbrc	r25, 7
    e7c6:	08 c0       	rjmp	.+16     	; 0xe7d8 <vfscanf+0x220>
    e7c8:	0e 94 a3 68 	call	0xd146	; 0xd146 <isspace>
    e7cc:	89 2b       	or	r24, r25
    e7ce:	59 f3       	breq	.-42     	; 0xe7a6 <vfscanf+0x1ee>
    e7d0:	b6 01       	movw	r22, r12
    e7d2:	c3 01       	movw	r24, r6
    e7d4:	0e 94 82 74 	call	0xe904	; 0xe904 <ungetc>
    e7d8:	81 14       	cp	r8, r1
    e7da:	91 04       	cpc	r9, r1
    e7dc:	09 f4       	brne	.+2      	; 0xe7e0 <vfscanf+0x228>
    e7de:	9f cf       	rjmp	.-194    	; 0xe71e <vfscanf+0x166>
    e7e0:	f4 01       	movw	r30, r8
    e7e2:	10 82       	st	Z, r1
    e7e4:	9c cf       	rjmp	.-200    	; 0xe71e <vfscanf+0x166>
    e7e6:	00 61       	ori	r16, 0x10	; 16
    e7e8:	d5 cf       	rjmp	.-86     	; 0xe794 <vfscanf+0x1dc>

0000e7ea <strchr_P>:
strchr_P():
    e7ea:	fc 01       	movw	r30, r24
    e7ec:	05 90       	lpm	r0, Z+
    e7ee:	06 16       	cp	r0, r22
    e7f0:	21 f0       	breq	.+8      	; 0xe7fa <strchr_P+0x10>
    e7f2:	00 20       	and	r0, r0
    e7f4:	d9 f7       	brne	.-10     	; 0xe7ec <strchr_P+0x2>
    e7f6:	c0 01       	movw	r24, r0
    e7f8:	08 95       	ret
    e7fa:	31 97       	sbiw	r30, 0x01	; 1
    e7fc:	cf 01       	movw	r24, r30
    e7fe:	08 95       	ret

0000e800 <strnlen_P>:
strnlen_P():
    e800:	fc 01       	movw	r30, r24
    e802:	05 90       	lpm	r0, Z+
    e804:	61 50       	subi	r22, 0x01	; 1
    e806:	70 40       	sbci	r23, 0x00	; 0
    e808:	01 10       	cpse	r0, r1
    e80a:	d8 f7       	brcc	.-10     	; 0xe802 <strnlen_P+0x2>
    e80c:	80 95       	com	r24
    e80e:	90 95       	com	r25
    e810:	8e 0f       	add	r24, r30
    e812:	9f 1f       	adc	r25, r31
    e814:	08 95       	ret

0000e816 <strnlen>:
strnlen():
    e816:	fc 01       	movw	r30, r24
    e818:	61 50       	subi	r22, 0x01	; 1
    e81a:	70 40       	sbci	r23, 0x00	; 0
    e81c:	01 90       	ld	r0, Z+
    e81e:	01 10       	cpse	r0, r1
    e820:	d8 f7       	brcc	.-10     	; 0xe818 <strnlen+0x2>
    e822:	80 95       	com	r24
    e824:	90 95       	com	r25
    e826:	8e 0f       	add	r24, r30
    e828:	9f 1f       	adc	r25, r31
    e82a:	08 95       	ret

0000e82c <fgetc>:
fgetc():
    e82c:	cf 93       	push	r28
    e82e:	df 93       	push	r29
    e830:	ec 01       	movw	r28, r24
    e832:	2b 81       	ldd	r18, Y+3	; 0x03
    e834:	20 ff       	sbrs	r18, 0
    e836:	1a c0       	rjmp	.+52     	; 0xe86c <fgetc+0x40>
    e838:	26 ff       	sbrs	r18, 6
    e83a:	0c c0       	rjmp	.+24     	; 0xe854 <fgetc+0x28>
    e83c:	2f 7b       	andi	r18, 0xBF	; 191
    e83e:	2b 83       	std	Y+3, r18	; 0x03
    e840:	8e 81       	ldd	r24, Y+6	; 0x06
    e842:	9f 81       	ldd	r25, Y+7	; 0x07
    e844:	01 96       	adiw	r24, 0x01	; 1
    e846:	9f 83       	std	Y+7, r25	; 0x07
    e848:	8e 83       	std	Y+6, r24	; 0x06
    e84a:	8a 81       	ldd	r24, Y+2	; 0x02
    e84c:	90 e0       	ldi	r25, 0x00	; 0
    e84e:	df 91       	pop	r29
    e850:	cf 91       	pop	r28
    e852:	08 95       	ret
    e854:	22 ff       	sbrs	r18, 2
    e856:	18 c0       	rjmp	.+48     	; 0xe888 <fgetc+0x5c>
    e858:	e8 81       	ld	r30, Y
    e85a:	f9 81       	ldd	r31, Y+1	; 0x01
    e85c:	80 81       	ld	r24, Z
    e85e:	08 2e       	mov	r0, r24
    e860:	00 0c       	add	r0, r0
    e862:	99 0b       	sbc	r25, r25
    e864:	00 97       	sbiw	r24, 0x00	; 0
    e866:	29 f4       	brne	.+10     	; 0xe872 <fgetc+0x46>
    e868:	20 62       	ori	r18, 0x20	; 32
    e86a:	2b 83       	std	Y+3, r18	; 0x03
    e86c:	8f ef       	ldi	r24, 0xFF	; 255
    e86e:	9f ef       	ldi	r25, 0xFF	; 255
    e870:	ee cf       	rjmp	.-36     	; 0xe84e <fgetc+0x22>
    e872:	31 96       	adiw	r30, 0x01	; 1
    e874:	f9 83       	std	Y+1, r31	; 0x01
    e876:	e8 83       	st	Y, r30
    e878:	2e 81       	ldd	r18, Y+6	; 0x06
    e87a:	3f 81       	ldd	r19, Y+7	; 0x07
    e87c:	2f 5f       	subi	r18, 0xFF	; 255
    e87e:	3f 4f       	sbci	r19, 0xFF	; 255
    e880:	3f 83       	std	Y+7, r19	; 0x07
    e882:	2e 83       	std	Y+6, r18	; 0x06
    e884:	99 27       	eor	r25, r25
    e886:	e3 cf       	rjmp	.-58     	; 0xe84e <fgetc+0x22>
    e888:	ea 85       	ldd	r30, Y+10	; 0x0a
    e88a:	fb 85       	ldd	r31, Y+11	; 0x0b
    e88c:	19 95       	eicall
    e88e:	97 ff       	sbrs	r25, 7
    e890:	f3 cf       	rjmp	.-26     	; 0xe878 <fgetc+0x4c>
    e892:	2b 81       	ldd	r18, Y+3	; 0x03
    e894:	01 96       	adiw	r24, 0x01	; 1
    e896:	21 f0       	breq	.+8      	; 0xe8a0 <fgetc+0x74>
    e898:	80 e2       	ldi	r24, 0x20	; 32
    e89a:	82 2b       	or	r24, r18
    e89c:	8b 83       	std	Y+3, r24	; 0x03
    e89e:	e6 cf       	rjmp	.-52     	; 0xe86c <fgetc+0x40>
    e8a0:	80 e1       	ldi	r24, 0x10	; 16
    e8a2:	fb cf       	rjmp	.-10     	; 0xe89a <fgetc+0x6e>

0000e8a4 <fputc>:
fputc():
    e8a4:	0f 93       	push	r16
    e8a6:	1f 93       	push	r17
    e8a8:	cf 93       	push	r28
    e8aa:	df 93       	push	r29
    e8ac:	18 2f       	mov	r17, r24
    e8ae:	09 2f       	mov	r16, r25
    e8b0:	eb 01       	movw	r28, r22
    e8b2:	8b 81       	ldd	r24, Y+3	; 0x03
    e8b4:	81 fd       	sbrc	r24, 1
    e8b6:	09 c0       	rjmp	.+18     	; 0xe8ca <fputc+0x26>
    e8b8:	1f ef       	ldi	r17, 0xFF	; 255
    e8ba:	0f ef       	ldi	r16, 0xFF	; 255
    e8bc:	81 2f       	mov	r24, r17
    e8be:	90 2f       	mov	r25, r16
    e8c0:	df 91       	pop	r29
    e8c2:	cf 91       	pop	r28
    e8c4:	1f 91       	pop	r17
    e8c6:	0f 91       	pop	r16
    e8c8:	08 95       	ret
    e8ca:	82 ff       	sbrs	r24, 2
    e8cc:	14 c0       	rjmp	.+40     	; 0xe8f6 <fputc+0x52>
    e8ce:	2e 81       	ldd	r18, Y+6	; 0x06
    e8d0:	3f 81       	ldd	r19, Y+7	; 0x07
    e8d2:	8c 81       	ldd	r24, Y+4	; 0x04
    e8d4:	9d 81       	ldd	r25, Y+5	; 0x05
    e8d6:	28 17       	cp	r18, r24
    e8d8:	39 07       	cpc	r19, r25
    e8da:	3c f4       	brge	.+14     	; 0xe8ea <fputc+0x46>
    e8dc:	e8 81       	ld	r30, Y
    e8de:	f9 81       	ldd	r31, Y+1	; 0x01
    e8e0:	cf 01       	movw	r24, r30
    e8e2:	01 96       	adiw	r24, 0x01	; 1
    e8e4:	99 83       	std	Y+1, r25	; 0x01
    e8e6:	88 83       	st	Y, r24
    e8e8:	10 83       	st	Z, r17
    e8ea:	8e 81       	ldd	r24, Y+6	; 0x06
    e8ec:	9f 81       	ldd	r25, Y+7	; 0x07
    e8ee:	01 96       	adiw	r24, 0x01	; 1
    e8f0:	9f 83       	std	Y+7, r25	; 0x07
    e8f2:	8e 83       	std	Y+6, r24	; 0x06
    e8f4:	e3 cf       	rjmp	.-58     	; 0xe8bc <fputc+0x18>
    e8f6:	e8 85       	ldd	r30, Y+8	; 0x08
    e8f8:	f9 85       	ldd	r31, Y+9	; 0x09
    e8fa:	81 2f       	mov	r24, r17
    e8fc:	19 95       	eicall
    e8fe:	89 2b       	or	r24, r25
    e900:	a1 f3       	breq	.-24     	; 0xe8ea <fputc+0x46>
    e902:	da cf       	rjmp	.-76     	; 0xe8b8 <fputc+0x14>

0000e904 <ungetc>:
ungetc():
    e904:	fb 01       	movw	r30, r22
    e906:	23 81       	ldd	r18, Z+3	; 0x03
    e908:	20 ff       	sbrs	r18, 0
    e90a:	11 c0       	rjmp	.+34     	; 0xe92e <ungetc+0x2a>
    e90c:	26 fd       	sbrc	r18, 6
    e90e:	0f c0       	rjmp	.+30     	; 0xe92e <ungetc+0x2a>
    e910:	8f 3f       	cpi	r24, 0xFF	; 255
    e912:	98 07       	cpc	r25, r24
    e914:	71 f0       	breq	.+28     	; 0xe932 <ungetc+0x2e>
    e916:	82 83       	std	Z+2, r24	; 0x02
    e918:	2f 7d       	andi	r18, 0xDF	; 223
    e91a:	20 64       	ori	r18, 0x40	; 64
    e91c:	23 83       	std	Z+3, r18	; 0x03
    e91e:	26 81       	ldd	r18, Z+6	; 0x06
    e920:	37 81       	ldd	r19, Z+7	; 0x07
    e922:	21 50       	subi	r18, 0x01	; 1
    e924:	31 09       	sbc	r19, r1
    e926:	37 83       	std	Z+7, r19	; 0x07
    e928:	26 83       	std	Z+6, r18	; 0x06
    e92a:	99 27       	eor	r25, r25
    e92c:	08 95       	ret
    e92e:	8f ef       	ldi	r24, 0xFF	; 255
    e930:	9f ef       	ldi	r25, 0xFF	; 255
    e932:	08 95       	ret

0000e934 <__ultoa_invert>:
__ultoa_invert():
    e934:	fa 01       	movw	r30, r20
    e936:	aa 27       	eor	r26, r26
    e938:	28 30       	cpi	r18, 0x08	; 8
    e93a:	51 f1       	breq	.+84     	; 0xe990 <__ultoa_invert+0x5c>
    e93c:	20 31       	cpi	r18, 0x10	; 16
    e93e:	81 f1       	breq	.+96     	; 0xe9a0 <__ultoa_invert+0x6c>
    e940:	e8 94       	clt
    e942:	6f 93       	push	r22
    e944:	6e 7f       	andi	r22, 0xFE	; 254
    e946:	6e 5f       	subi	r22, 0xFE	; 254
    e948:	7f 4f       	sbci	r23, 0xFF	; 255
    e94a:	8f 4f       	sbci	r24, 0xFF	; 255
    e94c:	9f 4f       	sbci	r25, 0xFF	; 255
    e94e:	af 4f       	sbci	r26, 0xFF	; 255
    e950:	b1 e0       	ldi	r27, 0x01	; 1
    e952:	3e d0       	rcall	.+124    	; 0xe9d0 <__ultoa_invert+0x9c>
    e954:	b4 e0       	ldi	r27, 0x04	; 4
    e956:	3c d0       	rcall	.+120    	; 0xe9d0 <__ultoa_invert+0x9c>
    e958:	67 0f       	add	r22, r23
    e95a:	78 1f       	adc	r23, r24
    e95c:	89 1f       	adc	r24, r25
    e95e:	9a 1f       	adc	r25, r26
    e960:	a1 1d       	adc	r26, r1
    e962:	68 0f       	add	r22, r24
    e964:	79 1f       	adc	r23, r25
    e966:	8a 1f       	adc	r24, r26
    e968:	91 1d       	adc	r25, r1
    e96a:	a1 1d       	adc	r26, r1
    e96c:	6a 0f       	add	r22, r26
    e96e:	71 1d       	adc	r23, r1
    e970:	81 1d       	adc	r24, r1
    e972:	91 1d       	adc	r25, r1
    e974:	a1 1d       	adc	r26, r1
    e976:	20 d0       	rcall	.+64     	; 0xe9b8 <__ultoa_invert+0x84>
    e978:	09 f4       	brne	.+2      	; 0xe97c <__ultoa_invert+0x48>
    e97a:	68 94       	set
    e97c:	3f 91       	pop	r19
    e97e:	2a e0       	ldi	r18, 0x0A	; 10
    e980:	26 9f       	mul	r18, r22
    e982:	11 24       	eor	r1, r1
    e984:	30 19       	sub	r19, r0
    e986:	30 5d       	subi	r19, 0xD0	; 208
    e988:	31 93       	st	Z+, r19
    e98a:	de f6       	brtc	.-74     	; 0xe942 <__ultoa_invert+0xe>
    e98c:	cf 01       	movw	r24, r30
    e98e:	08 95       	ret
    e990:	46 2f       	mov	r20, r22
    e992:	47 70       	andi	r20, 0x07	; 7
    e994:	40 5d       	subi	r20, 0xD0	; 208
    e996:	41 93       	st	Z+, r20
    e998:	b3 e0       	ldi	r27, 0x03	; 3
    e99a:	0f d0       	rcall	.+30     	; 0xe9ba <__ultoa_invert+0x86>
    e99c:	c9 f7       	brne	.-14     	; 0xe990 <__ultoa_invert+0x5c>
    e99e:	f6 cf       	rjmp	.-20     	; 0xe98c <__ultoa_invert+0x58>
    e9a0:	46 2f       	mov	r20, r22
    e9a2:	4f 70       	andi	r20, 0x0F	; 15
    e9a4:	40 5d       	subi	r20, 0xD0	; 208
    e9a6:	4a 33       	cpi	r20, 0x3A	; 58
    e9a8:	18 f0       	brcs	.+6      	; 0xe9b0 <__ultoa_invert+0x7c>
    e9aa:	49 5d       	subi	r20, 0xD9	; 217
    e9ac:	31 fd       	sbrc	r19, 1
    e9ae:	40 52       	subi	r20, 0x20	; 32
    e9b0:	41 93       	st	Z+, r20
    e9b2:	02 d0       	rcall	.+4      	; 0xe9b8 <__ultoa_invert+0x84>
    e9b4:	a9 f7       	brne	.-22     	; 0xe9a0 <__ultoa_invert+0x6c>
    e9b6:	ea cf       	rjmp	.-44     	; 0xe98c <__ultoa_invert+0x58>
    e9b8:	b4 e0       	ldi	r27, 0x04	; 4
    e9ba:	a6 95       	lsr	r26
    e9bc:	97 95       	ror	r25
    e9be:	87 95       	ror	r24
    e9c0:	77 95       	ror	r23
    e9c2:	67 95       	ror	r22
    e9c4:	ba 95       	dec	r27
    e9c6:	c9 f7       	brne	.-14     	; 0xe9ba <__ultoa_invert+0x86>
    e9c8:	00 97       	sbiw	r24, 0x00	; 0
    e9ca:	61 05       	cpc	r22, r1
    e9cc:	71 05       	cpc	r23, r1
    e9ce:	08 95       	ret
    e9d0:	9b 01       	movw	r18, r22
    e9d2:	ac 01       	movw	r20, r24
    e9d4:	0a 2e       	mov	r0, r26
    e9d6:	06 94       	lsr	r0
    e9d8:	57 95       	ror	r21
    e9da:	47 95       	ror	r20
    e9dc:	37 95       	ror	r19
    e9de:	27 95       	ror	r18
    e9e0:	ba 95       	dec	r27
    e9e2:	c9 f7       	brne	.-14     	; 0xe9d6 <__ultoa_invert+0xa2>
    e9e4:	62 0f       	add	r22, r18
    e9e6:	73 1f       	adc	r23, r19
    e9e8:	84 1f       	adc	r24, r20
    e9ea:	95 1f       	adc	r25, r21
    e9ec:	a0 1d       	adc	r26, r0
    e9ee:	08 95       	ret

0000e9f0 <__do_global_dtors>:
__do_global_dtors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2496
    e9f0:	13 e0       	ldi	r17, 0x03	; 3
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2497
    e9f2:	c1 e4       	ldi	r28, 0x41	; 65
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2498
    e9f4:	d3 e0       	ldi	r29, 0x03	; 3
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2500
    e9f6:	00 e0       	ldi	r16, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2502
    e9f8:	06 c0       	rjmp	.+12     	; 0xea06 <__do_global_dtors+0x16>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2505
    e9fa:	80 2f       	mov	r24, r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2508
    e9fc:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2509
    e9fe:	0e 94 2b 6c 	call	0xd856	; 0xd856 <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2510
    ea02:	21 96       	adiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2512
    ea04:	01 1d       	adc	r16, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2515
    ea06:	c2 34       	cpi	r28, 0x42	; 66
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2516
    ea08:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2518
    ea0a:	80 e0       	ldi	r24, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2519
    ea0c:	08 07       	cpc	r16, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2521
    ea0e:	a9 f7       	brne	.-22     	; 0xe9fa <__do_global_dtors+0xa>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    ea10:	f8 94       	cli

0000ea12 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr6/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    ea12:	ff cf       	rjmp	.-2      	; 0xea12 <__stop_program>
